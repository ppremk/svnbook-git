<!-- -*- sgml -*- -->

<chapter id="svn.serverconfig">
      <!--
  <title>Server Configuration</title>
      -->
  <title>服务器配置</title>

      <!--
  <para>A Subversion repository can be accessed simultaneously by
    clients running on the same machine on which the repository
    resides using URLs carrying the <literal>file://</literal> scheme.
    But the typical Subversion setup involves a single server machine
    being accessed from clients on computers all over the
    office&mdash;or, perhaps, all over the world.</para>
      -->
  <para>一个 Subversion 仓库可以被多个客户端同时访问, 这些客户端和仓库都在同
    一台主机上, 通过 <literal>file://</literal> 形式的 URL 进行访问. 不过在
    典型的情况下, Subversion 仓库是存放在一台单独的服务器上, 办公室&mdash;
    甚至全世界&mdash;的任意一台主机都能访问到这台服务器.</para>

      <!--
  <para>This chapter describes how to get your Subversion repository
    exposed outside its host machine for use by remote clients.  We
    will cover Subversion's currently available server mechanisms,
    discussing the configuration and use of each.  After reading this
    chapter, you should be able to decide which networking setup is
    right for your needs, as well as understand how to enable such a
    setup on your host computer.</para>
      -->
  <para>本章介绍如何把 Subversion 仓库暴露给远程的客户端使用. 我们将会介绍
    Subversion 目前支持的服务器机制和各个配置, 读完本章后, 读者将有能力判断
    什么样的网络配置才是正确的, 以及如何在自己的主机上进行配置.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">

      <!--
    <title>Overview</title>
      -->
    <title>概览</title>

    <para>
      <indexterm>
        <primary>API</primary>
        <secondary>layers</secondary>
        <tertiary>Repository Access (RA) Layer</tertiary>
      </indexterm>Subversion 具有一个抽象的仓库访问层, 这就意味着仓库可以
      被任意类型的服务器进程以程序化地方式进行访问, 并且客户端 <quote>仓库访问
        API</quote> 允许程序员编写协议相关的插件. 从理论上讲, Subversion 支持
      任意类型的网络实现, 但在实际使用中, 只有两种 Subversion 服务器用得比较
      广泛.</para>
      <!--
      Subversion was designed with an abstract repository
      access layer.  This means that a repository can be
      programmatically accessed by any sort of server process, and the
      client <quote>repository access</quote> API allows programmers
      to write plug-ins that speak relevant network protocols.  In
      theory, Subversion can use an infinite number of network
      implementations.  In practice, there are only two Subversion
      servers in widespread use today.</para>
      -->

    <para>
      <indexterm>
        <primary>httpd</primary>
      </indexterm>
      <indexterm>
        <primary>Apache HTTP Server</primary>
        <see>httpd</see>
      </indexterm>Apache HTTP 服务器 (也被称作 <command>httpd</command>) 是一
      个非常流行的网页服务器; 利用 <command>mod_dav_svn</command> 模块,
      Apache 就能访问仓库, 并通过 WebDAV/DeltaV 协议支持客户端访问,
      WebDAV/DeltaV 协议是 HTTP 的扩展. 因为 Apache 的可扩展性非常强, 它提供
      了大量可 <quote>免费</quote> 使用的特性, 例如加密的 SSL 通信, 日志记录,
      可集成第三方认证系统, 受限的仓库网页访问界面.</para>
      <!--
      Apache HTTP Server (also known
      as <command>httpd</command>) is an extremely popular web server;
      using the <command>mod_dav_svn</command> module, Apache can
      access a repository and make it available to clients via the
      WebDAV/DeltaV protocol, which is an extension of HTTP.  Because
      Apache is an extremely extensible server, it provides a number
      of features <quote>for free,</quote> such as encrypted SSL
      communication, logging, integration with a number of third-party
      authentication systems, and limited built-in web browsing of
      repositories.</para>
      -->

    <para>
      <indexterm>
        <primary>svnserve</primary>
      </indexterm>另一种就是 <command>svnserve</command>: 一种小型的轻量级服务
      器程序, 使用定制的协议与客户端通信. 因为它所使用的协议是专为 Subversion
      而设计的有状态协议 (相对于无状态的 HTTP 协议), 它提供了更快速的网络操作
      &mdash;但同时也要付出一些代价. 虽然 <command>svnserve</command> 可以利用
      SASL 提供各种各样的认证和加密选项, 但它不支持日志记录和网页浏览. 然而,
      搭建 <command>svnserve</command> 服务器非常方便, 非常适合刚开始接触
      Subversion 的小型团队.</para>
      <!--
      In the other corner is <command>svnserve</command>:
      a small, lightweight server program that speaks a custom
      protocol with clients.  Because its protocol is explicitly
      designed for Subversion and is stateful (unlike HTTP), it
      provides significantly faster network operations&mdash;but at
      the cost of some features as well.  While it can use SASL to
      provide a variety of authentication and encryption options, it
      has no logging or built-in web browsing.  It is, however,
      extremely easy to set up and is often the best option for small
      teams just starting out with Subversion.</para>
      -->

      <!--
    <para>The network protocol which <command>svnserve</command>
      speaks may also be tunneled over an SSH connection.  This
      deployment option for <command>svnserve</command> differs quite
      a bit in features from a traditional <command>svnserve</command>
      deployment.  SSH is used to encrypt all communication.  SSH is
      also used exclusively to authenticate, so real system accounts
      are required on the server host (unlike
      vanilla <command>svnserve</command>, which has its own private
      user accounts).  Finally, because this setup requires that each
      user spawn a private, temporary <command>svnserve</command>
      process, it's equivalent (from a permissions point of view) to
      allowing a group of local users to all access the repository
      via <literal>file://</literal> URLs.  Path-based access control
      has no meaning, since each user is accessing the repository
      database files directly.</para>
      -->
    <para><command>svnserve</command> 所使用的协议还能被 SSH 包裹, 这种部署
      形式和以传统方式部署的 <command>svnserve</command> 相比, 在特性上有很
      大的不同. 此时 SSH 将用于加密所有的连接, 只使用 SSH 进行认证, 这就要求
      用户在服务器主机上必须拥有真实的系统账户 (而普通的
      <command>svnserve</command> 拥有一套自己的用户账户). 最后, 这种部署
      配置要求每个用户都要派生一个私有的临时 <command>svnserve</command> 进程,
      (从系统权限的角度来看) 这就相当于允许一组本地用户使用
      <literal>file://</literal> URL 访问仓库, 基于路径的访问控制将失去意义,
      因为用户是在直接访问仓库的数据库文件.</para>

      <!--
    <para><xref linkend="svn.serverconfig.overview.tbl-1"/> provides a
      quick summary of the three typical server deployments.</para>
      -->
    <para><xref linkend="svn.serverconfig.overview.tbl-1"/> 总结了三种典型
      的服务器部署方式.</para>

    <table id="svn.serverconfig.overview.tbl-1">
      <!--
      <title>Comparison of Subversion server options</title>
      -->
      <title>各种 Subversion 服务器选项的比较</title>
      <tgroup cols="4">
        <thead>
          <row>
      <!--
            <entry>Feature</entry>
      -->
            <entry>特性</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
      <!--
            <entry>svnserve over SSH</entry>
      -->
            <entry>svnserve + SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
      <!--
            <entry>Authentication options</entry>
            <entry>HTTP Basic or Digest auth, X.509 certificates, LDAP,
              NTLM, or any other mechanism available to Apache httpd</entry>
            <entry>CRAM-MD5 by default;  LDAP, NTLM, or any other mechanism
              available to SASL</entry>
      -->
            <entry>认证选项</entry>
            <entry>HTTP Basic or Digest 认证, X.509 证书, LDAP,
              NTLM, 或 Apache httpd 支持的其他认证机制</entry>
            <entry>默认是 CRAM-MD5; LDAP, NTLM, 或 SASL
              支持的其他认证机制</entry>
            <entry>SSH</entry>
          </row>
          <row>
      <!--
            <entry>User account options</entry>
            <entry>Private <quote>users</quote> file, or other mechanisms
            available to Apache httpd (LDAP, SQL, etc.)</entry>
            <entry>Private <quote>users</quote> file, or other
              mechanisms available to SASL (LDAP, SQL, etc.)</entry>
            <entry>System accounts</entry>
      -->
            <entry>用户帐户选项</entry>
            <entry>私有的 <quote>用户</quote> 文件, 或 Apache httpd 支持的
              其他机制 (LDAP, SQL 等)</entry>
            <entry>私有的 <quote>用户</quote> 文件, 或 SASL 支持的其他机制
              (LDAP, SQL 等)</entry>
            <entry>系统账户</entry>
          </row>
          <row>
      <!--
            <entry>Authorization options</entry>
            <entry>Read/write access can be granted over the whole
              repository, or specified per path</entry>
            <entry>Read/write access can be granted over the whole
              repository, or specified per path</entry>
            <entry>Read/write access only grantable over the whole
              repository</entry>
      -->
            <entry>授权选项</entry>
            <entry>可以在整个仓库或特定的路径上授予读/写权限</entry>
            <entry>可以在整个仓库或特定的路径上授予读/写权限</entry>
            <entry>只能在整个仓库上授予读/写权限</entry>
          </row>
          <row>
      <!--
            <entry>Encryption</entry>
            <entry>Available via optional SSL (https)</entry>
            <entry>Available via optional SASL features</entry>
            <entry>Inherent in SSH connection</entry>
      -->
            <entry>加密</entry>
            <entry>通过可选的 SSL (https) 实现</entry>
            <entry>通过可选的 SASL 特性实现</entry>
            <entry>由 SSH 连接实现</entry>
          </row>
          <row>
            <!--
            <entry>Logging</entry>
            <entry>High-level operational logging of Subversion
              operations plus detailed logging at the
              per-HTTP-request level</entry>
            <entry>High-level operational logging only</entry>
            <entry>High-level operational logging only</entry>
            -->
            <entry>日志记录</entry>
            <entry>支持在较高的层次上记录 Subversion 操作, 也支持为每一个 HTTP
              请求记录日志</entry>
            <entry>只支持从较高的层次上记录 Subversion 操作</entry>
            <entry>只支持从较高的层次上记录 Subversion 操作</entry>
          </row>
          <row>
      <!--
            <entry>Interoperability</entry>
            <entry>Accessible by other WebDAV clients</entry>
            <entry>Talks only to svn clients</entry>
            <entry>Talks only to svn clients</entry>
      -->
            <entry>互操作性</entry>
            <entry>其他 WebDAV 客户端可访问</entry>
            <entry>只能被 svn 客户端访问</entry>
            <entry>只能被 svn 客户端访问</entry>
          </row>
          <row>
      <!--
            <entry>Web viewing</entry>
            <entry>Limited built-in support, or via third-party tools
              such as ViewVC</entry>
            <entry>Only via third-party tools such as ViewVC</entry>
            <entry>Only via third-party tools such as ViewVC</entry>
      -->
            <entry>网页浏览</entry>
            <entry>有限的内建支持, 或者通过第三方工具实现, 例如 ViewVC</entry>
            <entry>只能通过第三方工具实现, 例如 ViewVC</entry>
            <entry>只能通过第三方工具实现, 例如 ViewVC</entry>
          </row>
          <row>
      <!--
            <entry>Master-slave server replication</entry>
            <entry>Transparent write-proxying available from slave to
              master</entry>
            <entry>Can only create read-only slave servers</entry>
            <entry>Can only create read-only slave servers</entry>
      -->
            <entry>主从服务器复制</entry>
            <entry>从服务器到主服务器可以使用透明的写代理</entry>
            <entry>只能创建只读的从服务器</entry>
            <entry>只能创建只读的从服务器</entry>
          </row>
          <row>
      <!--
            <entry>Speed</entry>
            <entry>Somewhat slower</entry>
            <entry>Somewhat faster</entry>
            <entry>Somewhat faster</entry>
      -->
            <entry>访问速度</entry>
            <entry>较慢</entry>
            <entry>较快</entry>
            <entry>较快</entry>
          </row>
          <row>
      <!--
            <entry>Initial setup</entry>
            <entry>Somewhat complex</entry>
            <entry>Extremely simple</entry>
            <entry>Moderately simple</entry>
      -->
            <entry>初始设置</entry>
            <entry>较复杂</entry>
            <entry>非常简单</entry>
            <entry>中等</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

  <sect1 id="svn.serverconfig.choosing">

      <!--
    <title>Choosing a Server Configuration</title>
      -->
    <title>选择一种服务器配置</title>

      <!--
    <para>So, which server should you use?  Which is best?</para>
      -->
    <para>那么, 我应该使用哪种服务器配置, 哪一种是最好的?</para>

      <!--
    <para>Obviously, there's no right answer to that question.  Every
      team has different needs, and the different servers all
      represent different sets of trade-offs.  The Subversion project
      itself doesn't endorse one server or another, or consider either
      server more <quote>official</quote> than another.</para>
      -->
    <para>显然, 这个问题不存在正确的答案. 每一个开发团队都有不同的需求,
      每一种服务器配置都代表了不同的权衡. Subversion 不会偏爱任何一种,
      也不会认为某种服务器配置更加 <quote>官方</quote>.</para>

      <!--
    <para>Here are some reasons why you might choose one deployment
      over another, as well as reasons you
      might <emphasis>not</emphasis> choose one.</para>
      -->
    <para>下面列出几点在选择服务器部署配置时应该考虑的因素.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.svnserve">

      <!--
      <title>The svnserve Server</title>
      -->
      <title>svnserve 服务器</title>

      <variablelist>
        <varlistentry>
      <!--
          <term>Why you might want to use it:</term>
      -->
          <term>应该用它的理由:</term>
          <listitem>
            <itemizedlist>
              <listitem>
      <!--
                <para>Quick and easy to set up.</para>
      -->
                <para>设置方便.</para>
              </listitem>
              <listitem>
      <!--
                <para>Network protocol is stateful and noticeably
                  faster than WebDAV.</para>
      -->
                <para>网络协议是有状态的, 并且比 WebDAV 快很多.</para>
              </listitem>
              <listitem>
      <!--
                <para>No need to create system accounts on
                  server.</para>
      -->
                <para>不需要在服务器上创建系统帐户.</para>
              </listitem>
              <listitem>
      <!--
                <para>Password is not passed over the network.</para>
      -->
                <para>密码不会在网络上传输.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
      <!--
          <term>Why you might want to avoid it:</term>
      -->
          <term>不应该用它的理由:</term>
          <listitem>
            <itemizedlist>
              <listitem>
      <!--
                <para>By default, only one authentication method is
                  available, the network protocol is not encrypted,
                  and the server stores clear text passwords.  (All
                  these things can be changed by configuring SASL, but
                  it's a bit more work to do.)</para>
      -->
                <para>默认情况下, 只有一种认证方式可用, 网络协议是未加密的,
                  而且服务器以明文的形式存放密码. (这些都能通过配置 SASL 加
                  以修改, 但也带来了更多的工作量.)</para>
              </listitem>
              <listitem>
      <!--
                <para>No advanced logging facilities.</para>
      -->
                <para>缺乏高级的日志设施.</para>
              </listitem>
              <listitem>
      <!--
                <para>No built-in web browsing.  (You'd have to
                  install a separate web server and repository
                  browsing software to add this.)</para>
      -->
                <para>缺乏内建的网页浏览界面. (为了实现网页浏览, 管理员必须
                  安装额外的网页服务器和仓库浏览软件.)</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.svn-ssh">

      <!--
      <title>svnserve over SSH</title>
      -->
      <title>svnserve + SSH</title>

      <variablelist>
        <varlistentry>
      <!--
          <term>Why you might want to use it:</term>
      -->
          <term>应该用它的理由:</term>
          <listitem>
            <itemizedlist>
              <listitem>
      <!--
                <para>The network protocol is stateful and noticeably
                  faster than WebDAV.</para>
      -->
                <para>网络协议是有状态的, 并且比 WebDAV 快很多.</para>
              </listitem>
              <listitem>
      <!--
                <para>You can take advantage of existing SSH accounts
                  and user infrastructure.</para>
      -->
                <para>管理员可以利用已有的 SSH 帐户和用户基础设施.</para>
              </listitem>
              <listitem>
      <!--
                <para>All network traffic is encrypted.</para>
      -->
                <para>所有的网络流量都是加密的.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
      <!--
          <term>Why you might want to avoid it:</term>
      -->
          <term>不应该用它的理由:</term>
          <listitem>
            <itemizedlist>
              <listitem>
      <!--
                <para>Only one choice of authentication method is
                  available.</para>
      -->
                <para>只有一种认证方式可用.</para>
              </listitem>
              <listitem>
      <!--
                <para>No advanced logging facilities.</para>
      -->
                <para>缺乏高级的日志设施.</para>
              </listitem>
              <listitem>
      <!--
                <para>It requires users to be in the same system
                  group, or use a shared SSH key.</para>
      -->
                <para>要求用户属于相同的系统用户组, 或者使用共享的 SSH
                  密钥.</para>
              </listitem>
              <listitem>
      <!--
                <para>If used improperly, it can lead to file
                  permission problems.</para>
      -->
                <para>如果使用得不恰当, 将产生与文件权限有关的问题.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.apache">

      <!--
      <title>The Apache HTTP Server</title>
      -->
      <title>Apache HTTP 服务器</title>

      <variablelist>
        <varlistentry>
      <!--
          <term>Why you might want to use it:</term>
      -->
          <term>应该用它的理由:</term>
          <listitem>
            <itemizedlist>
              <listitem>
      <!--
                <para>It allows Subversion to use any of the
                  numerous authentication systems already integrated
                  with Apache.</para>
      -->
                <para>允许 Subversion 去使用已经集成到 Apache 中的多种认证
                  机制.</para>
              </listitem>
              <listitem>
      <!--
                <para>There is no need to create system accounts on
                  the server.</para>
      -->
                <para>无需在服务器上创建系统帐户.</para>
              </listitem>
              <listitem>
      <!--
                <para>Full Apache logging is available.</para>
      -->
                <para>有完备的 Apache 日志可供使用.</para>
              </listitem>
              <listitem>
      <!--
                <para>Network traffic can be encrypted via SSL.</para>
      -->
                <para>网络流量经由 SSL 加密.</para>
              </listitem>
              <listitem>
      <!--
                <para>HTTP(S) can usually go through corporate
                firewalls.</para>
      -->
                <para>一般来说, HTTP(S) 可以通过企业防火墙.</para>
              </listitem>
              <listitem>
      <!--
                <para>Built-in repository browsing is available via
                  web browser.</para>
      -->
                <para>内建的仓库浏览特性可被网页浏览器使用.</para>
              </listitem>
              <listitem>
      <!--
           ### TODO
                <para>The repository can be mounted as a network
                  drive for transparent version control (see <xref
                  linkend="svn.webdav.autoversioning"/>).</para>
      -->
              <para>仓库可以被当作网络驱动器进行挂载 (见 <xref
                  linkend="svn.webdav.autoversioning"/>).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
      <!--
          <term>Why you might want to avoid it:</term>
      -->
          <term>不应该用它的理由:</term>
          <listitem>
            <itemizedlist>
              <listitem>
      <!--
                <para>Noticeably slower than <command>svnserve</command>,
                  because HTTP is a stateless protocol and requires
                  more network turnarounds.</para>
      -->
                <para>比 <command>svnserve</command> 慢得多, 因为 HTTP 是一
                  种无状态的协议, 需要更多的网络转换.</para>
              </listitem>
              <listitem>
      <!--
                <para>Initial setup can be complex.</para>
      -->
                <para>初始设置比较复杂.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.recommendations">

      <!--
      <title>Recommendations</title>
      -->
      <title>建议</title>

      <!--
      <para>In general, the authors of this book recommend a vanilla
        <command>svnserve</command> installation for small teams just
        trying to get started with a Subversion server; it's the
        simplest to set up and has the fewest maintenance issues.
        You can always switch to a more complex server
        deployment as your needs change.</para>
      -->
      <para>一般情况下, 对于想要快速搭建 Subversion 服务器的小团队而言, 本书
        作者推荐最普通的 <command>svnserve</command>, 它的设置最简单, 维护
        成本也很低. 如果有新的需求产生, 管理员总是可以切换到更复杂的部署方式.
      </para>

      <!--
      <para>Here are some general recommendations and tips, based on
        years of supporting users:</para>
      -->
      <para>根据多年的用户支持经验, 下面列出几点一般性的建议和技巧:</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>If you're trying to set up the simplest possible server
            for your group, a vanilla <command>svnserve</command>
            installation is the easiest, fastest route.  Note,
            however, that your repository data will be transmitted in
            the clear over the network.  If your deployment is
            entirely within your company's LAN or VPN, this isn't an
            issue.  If the repository is exposed to the wide-open
            Internet, you might want to make sure that either the
            repository's contents aren't sensitive (e.g., it contains
            only open source code), or that you go the extra mile in
            configuring SASL to encrypt network communications.</para>
      -->
          <para>如果管理员想为团队搭建尽可能简单的 Subversion 服务器, 那么
            最简单的选择就是 <command>svnserve</command>. 然而, 需要注意的是
            仓库的数据将在网络上以明文形式传输, 如果服务器完全部署在公司的
            LAN 或 VPN 内部, 那就不会带来什么问题. 相反, 如果仓库可被因特网
            访问到, 管理员要么确保仓库存放的不是敏感数据 (例如只包含了开源
            的代码), 要么使用 SASL 对网络传输进行加密.</para>
        </listitem>

        <listitem>
      <!--
          <para>If you need to integrate with existing legacy identity
            systems (LDAP, Active Directory, NTLM, X.509, etc.),
            you must use either the Apache-based server
            or <command>svnserve</command> configured with SASL.</para>
      -->
          <para>如果管理员想把已有的身份系统 (LDAP, Active Directory, NTLM,
            X.509 等) 集成到 Subversion 服务器中, 那就必须选择 Apache
            服务器, 或配有 SASL 的 <command>svnserve</command>.</para>
        </listitem>

        <listitem>
      <!--
          <para>If you've decided to use either Apache or stock
            <command>svnserve</command>, create a single
            <command>svn</command> user on your system and run the
            server process as that user.  Be sure to make the
            repository directory wholly owned by the
            <command>svn</command> user as well.  From a security
            point of view, this keeps the repository data nicely
            siloed and protected by operating system filesystem
            permissions, changeable by only the Subversion server
            process itself.</para> </listitem>
      -->
          <para>如果管理员想使用 Apache 或 <command>svnserve</command>, 要在
            服务器系统中创建一个新用户 <command>svn</command>, 然后以该用户的
            身份运行服务器进程. 确保用户 <command>svn</command> 完全拥有仓库
            目录, 从安全的角度来看, 这种做法使得仓库的数据能够保持孤立, 还能
            利用操作系统的文件系统权限, 保证只有 Subversion 服务器进程才能修改
            仓库目录.</para>
        </listitem>

        <listitem>
      <!--
          <para>If you have an existing infrastructure that is heavily based
            on SSH accounts, and if your users already have system
            accounts on your server machine, it makes sense to
            deploy an <command>svnserve</command>-over-SSH solution.
            Otherwise, we don't widely recommend this option to the
            public.  It's generally considered safer to have your
            users access the repository via (imaginary) accounts
            managed by <command>svnserve</command> or Apache, rather
            than by full-blown system accounts.  If your deep desire
            for encrypted communication still draws you to this
            option, we recommend using Apache with SSL or
            <command>svnserve</command> with SASL encryption
            instead.</para>
      -->
          <para>如果已有的基础设施严重依赖 SSH 账户, 并且团队成员在服务器上
            都有自己的系统账户, 此时比较好的部署方式是
            <command>svnserve</command> + SSH. 但如果是对外公开的仓库, 则我
            们不建议这样做, 一般而言, 相比于真正的系统账户, 通过
            <command>svnserve</command> 或 Apache 管理的 (虚假) 账户来访问
            仓库是一种更安全的做法. 如果管理员对加密通信仍然具有强烈的渴望,
            我们建议选择配有 SSL 的 Apache, 或配有 SASL 的
            <command>svnserve</command>.</para>
        </listitem>

        <listitem>
      <!--
          <para>Do <emphasis>not</emphasis> be seduced by the simple
            idea of having all of your users access a repository
            directly via <literal>file://</literal> URLs.  Even if the
            repository is readily available to everyone via a network
            share, this is a bad idea.  It removes any layers of
            protection between the users and the repository: users can
            accidentally (or intentionally) corrupt the repository
            database, it becomes hard to take the repository offline
            for inspection or upgrade, and it can lead to a mess of
            file permission problems (see <xref
            linkend="svn.serverconfig.multimethod"/>).  Note that this
            is also one of the reasons we warn against accessing
            repositories via <literal>svn+ssh://</literal>
            URLs&mdash;from a security standpoint, it's effectively
            the same as local users accessing via
            <literal>file://</literal>, and it can entail all the same
            problems if the administrator isn't careful.</para>
      -->
          <para><emphasis>不要</emphasis> 被这种简单的想法引诱: 让所有的用户
            使用 <literal>file://</literal> URL 直接访问仓库. 即使仓库已经
            准备好通过网络共享被所有人访问, 但这仍然不是个好主意. 这种做法
            移除了用户与仓库之间的所有保护层: 用户可以有意 (或无意) 地破坏
            仓库数据库, 为了检查或升级而对仓库进行下线操作, 也会变得非常困难,
            而且会产生一系列与文件权限有关的问题 (见 <xref
              linkend="svn.serverconfig.multimethod"/>). 注意, 这同时也是使用
            <literal>svn+ssh://</literal> URL 访问仓库时需要注意的地方&mdash;
            从安全的角度来看, 它和本地用户使用 <literal>file://</literal> 的
            情况是等效的, 如果管理员不够认真, 将会导致同样的问题.</para>
            </listitem> </itemizedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">

      <!--
    <title>svnserve, a Custom Server</title>
      -->
    <title>svnserve, 一个定制化的服务器</title>

    <para>
      <indexterm>
        <primary>svnserve</primary>
      </indexterm>
      <command>svnserve</command> 是一个轻量级的服务器程序, 基于 TCP/IP, 使用
      一种定制化的, 有状态的协议与客户端通信, 客户端使用
      <literal>svn://</literal> 或 <literal>svn+ssh://</literal> 形式的 URL
      访问 <command>svnserve</command> 服务器. 本节介绍运行
      <command>svnserve</command> 的多种方式, 服务器如何认证客户端, 以及如何为
      仓库配置合适的访问权限.</para>
      <!--
      The <command>svnserve</command> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <command>svnserve</command> server by using URLs that begin with
      the <literal>svn://</literal> or <literal>svn+ssh://</literal>
      scheme.  This section will explain the different ways of running
      <command>svnserve</command>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</para>
      -->

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">
      <!--
      <title>Invoking the Server</title>
      -->
      <title>调用服务器</title>

      <para>
        <indexterm>
          <primary>svnserve</primary>
          <secondary>running</secondary>
        </indexterm>
        运行程序 <command>svnserve</command> 有以下几种方式:</para>
      <!--
        There are a few different ways to run the
        <command>svnserve</command> program:</para>
      -->

      <itemizedlist>
        <listitem>
      <!--
          <para>Run <command>svnserve</command> as a standalone
            daemon, listening for requests.</para>
      -->
          <para>作为一个独立的守护进程运行 <command>svnserve</command>, 运行
            过程中监听请求.</para>
        </listitem>
        <listitem>
      <!--
          <para>Have the Unix <command>inetd</command> daemon
            temporarily spawn <command>svnserve</command> whenever a
            request comes in on a certain port.</para>
      -->
          <para>如果在特定的端口接收到了一个新请求, 就让 Unix 守护进程
            <command>inetd</command> 临时派生 <command>svnserve</command>.
          </para>
        </listitem>
        <listitem>
      <!--
          <para>Have SSH invoke a temporary <command>svnserve</command>
            over an encrypted tunnel.</para>
      -->
          <para>使用 SSH, 在加密的通道上调用一个临时的
            <command>svnserve</command>.</para>
        </listitem>
        <listitem>
      <!--
          <para>Run <command>svnserve</command> as a Microsoft Windows
            service.</para>
      -->
          <para>作为 Microsoft Windows 服务, 运行 <command>svnserve</command>.
          </para>
        </listitem>
        <listitem>
      <!--
          <para>Run <command>svnserve</command> as a launchd job.</para>
      -->
          <para>作为一个 launchd 作业, 运行 <command>svnserve</command>.</para>
        </listitem>
      </itemizedlist>

      <!--
      <para>The following sections will cover in detail these various
        deployment options for <command>svnserve</command>.</para>
      -->
      <para>下面的几个小节详细介绍这些不同的 <command>svnserve</command>
        部署方式.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.daemon">
      <!--
        <title>svnserve as daemon</title>
      -->
        <title>svnserve 作为守护进程</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>daemon mode</tertiary>
          </indexterm>
          最简单的方式, 就是把 <command>svnserve</command> 作为一个守护进程
          运行, 执行时需要添加选项 <option>-d</option>:</para>
      <!--
          The easiest option is to run <command>svnserve</command>
          as a standalone <quote>daemon</quote> process.  Use the
          <option>-d</option> option for this:</para>
      -->

        <informalexample>
          <screen>
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</screen>
        </informalexample>

      <!--
        <para>When running <command>svnserve</command> in daemon mode,
          you can use the <option>- -listen-port</option> and
          <option>- -listen-host</option> options to customize the
          exact port and hostname to <quote>bind</quote> to.</para>
      -->
        <para>以守护进程模式运行 <command>svnserve</command> 时, 可以使用
          选项 <option>--listen-port</option> 和 <option>--listen-host</option>
          修改进程所 <quote>绑定</quote> 的端口号和主机名.</para>

      <!--
        <para>Once we successfully start <command>svnserve</command>
          as explained previously, it makes every repository on your
          system available to the network.  A client needs to specify
          an <emphasis>absolute</emphasis> path in the repository URL.
          For example, if a repository is located at
          <filename>/var/svn/project1</filename>, a client would reach
          it via <uri>svn://host.example.com/var/svn/project1</uri>.
          To increase security, you can pass the <option>-r</option>
          option to <command>svnserve</command>, which restricts it to
          exporting only repositories below that path.  For
          example:</para>
      -->
        <para><command>svnserve</command> 一旦成功启动, 服务器上的所有仓库
          都能通过网络进行访问. 如果客户端需要访问仓库, 必须在仓库的 URL
          参数中指定一个 <emphasis>绝对</emphasis> 路径. 比如说某个仓库在
          服务器上的位置是 <filename>/var/svn/project1</filename>, 那么客户
          端访问仓库的 URL 参数就可以写成
          <uri>svn://host.example.com/var/svn/project1</uri>. 为了增加安全
          性, 可以为 <command>svnserve</command> 添加选项 <option>-r</option>,
          使得只有指定路径下的仓库才会被导出, 例如:</para>

        <informalexample>
          <screen>
$ svnserve -d -r /var/svn
&hellip;
</screen>
        </informalexample>

      <!--
        <para>Using the <option>-r</option> option effectively
          modifies the location that the program treats as the root of
          the remote filesystem space.  Clients then use URLs that
          have that path portion removed from them, leaving much
          shorter (and much less revealing) URLs:</para>
      -->
        <para>使用选项 <option>-r</option> 等价于修改了
          <command>svnserve</command> 的根目录, 客户端访问仓库的所使用的 URL
          也能写得更加简短:</para>

        <informalexample>
          <screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.inetd">
      <!--
        <title>svnserve via inetd</title>
      -->
        <title>由 inetd 调用 svnserve</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>via inetd</tertiary>
          </indexterm>
          <indexterm>
            <primary>inetd</primary>
          </indexterm>
          如果管理员希望由 <command>inetd</command> 启动进程, 就给
          <command>svnserve</command> 添加选项 <option>-i</option>
          (<option>--inetd</option>). 在下面的例子里, 我们展示了在命令行上
          执行 <literal>svnserve -i</literal> 的输出, 但要注意的是命令实际
          上并没有启动进程; 例子后面的内容介绍了如何配置
          <command>inetd</command>, 使得它能够启动 <command>svnserve</command>.
        </para>
      <!--
          If you want <command>inetd</command> to launch the
          process, you need to pass the <option>-i</option>
          (<option>- -inetd</option>) option.  In the following
          example, we've shown the output from running
          <literal>svnserve -i</literal> at the command line, but note
          that this isn't how you actually start the daemon; see the
          paragraphs following the example for how to configure
          <command>inetd</command> to start
          <command>svnserve</command>.</para>
      -->

        <informalexample>
          <screen>
$ svnserve -i
( success ( 2 2 ( ) ( edit-pipeline svndiff1 absent-entries commit-revprops d\
epth log-revprops atomic-revprops partial-replay ) ) )
</screen>
        </informalexample>

      <!--
        <para>When invoked with the <option>- -inetd</option> option,
          <command>svnserve</command> attempts to speak with a
          Subversion client via <filename>stdin</filename> and
          <filename>stdout</filename> using a custom protocol.  This
          is the standard behavior for a program being run via
          <command>inetd</command>.  The IANA has reserved port 3690
          for the Subversion protocol, so on a Unix-like system you
          can add lines to <filename>/etc/services</filename> such as
          these (if they don't already exist):</para>
      -->
        <para>如果使用选项 <option>--inetd</option> 调用
          <command>svnserve</command>, 它会尝试使用定制化的协议, 通过
          <filename>stdin</filename> 和 <filename>stdout</filename> 与
          Subversion 通信, 这是由 <command>inetd</command> 所启动的程序的标准
          行为. IANA 将端口 3690 保留给 Subversion 使用, 所以说在一个类 Unix
          系统上, 管理员可以安全地在 <filename>/etc/services</filename> 中添
          加以下内容 (如果原来没有的话):</para>

        <informalexample>
          <programlisting>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</programlisting>
        </informalexample>

      <!--
        <para>If your system is using a classic Unix-like
          <command>inetd</command> daemon, you can add this line to
          <filename>/etc/inetd.conf</filename>:</para>
      -->
        <para>如果服务器使用的是经典的类 Unix <command>inetd</command> 守护
          进程, 就在 <filename>/etc/inetd.conf</filename> 添加下面这一行:
        </para>

        <informalexample>
          <programlisting>
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</programlisting>
        </informalexample>

      <!--
        <para>Make sure <quote>svnowner</quote> is a user that has
          appropriate permissions to access your repositories.  Now,
          when a client connection comes into your server on port
          3690, <command>inetd</command> will spawn an
          <command>svnserve</command> process to service it.  Of
          course, you may also want to add <option>-r</option> to the
          configuration line as well, to restrict which repositories
          are exported.</para>
      -->
        <para>确保用户 <quote>svnowner</quote> 对仓库具有适当的访问权限.
          现在, 当客户在端口 3690 上连接服务服务器时, <command>inetd</command>
          就会派生出一个 <command>svnserve</command>, 负责处理客户端发来的
          请求. 当然, 管理员也可以在配置文件里为 <command>svnserve</command>
          添加选项 <option>-r</option>, 从而限制被导出的仓库.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.xinetd">
      <!--
        <title>svnserve via xinetd</title>
      -->
        <title>由 xinetd 调用 svnserve</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>via xinetd</tertiary>
          </indexterm>
          <indexterm>
            <primary>xinetd</primary>
          </indexterm>
          某些系统提供了 <command>xinetd</command> 作为 <command>inetd</command>
          的替代品, 幸运的是, 管理员也可以配置 <command>svnserve</command>
          由 <command>xinetd</command> 启动. 为了实现这点, 管理员创建一个配置
          文件 <command>/etc/xinetd.d/svn</command>, 文件的内容是:</para>
      <!--
          Some operating systems provide the <command>xinetd</command>
          daemon as an alternative to <command>inetd</command>.
          Fortunately, you can configure <command>svnserve</command> for
          use with <command>xinetd</command>, too.  To do so, you'll need to
          create a configuration file <filename>/etc/xinetd.d/svn</filename>
          with the following contents:</para>
      -->

        <informalexample>
          <programlisting>
# default: on
# description: Subversion server for the svn protocol
service svn
{
  disabled        = no
  port            = 3690
  socket_type     = stream
  protocol        = tcp
  wait            = no
  user            = subversion
  server          = /usr/local/bin/svnserve
  server_args     = -i -r <replaceable>/path/to/repositories</replaceable>
}
</programlisting>
        </informalexample>

      <!--
        <para>Be sure that your <filename>/etc/services</filename>
          configuration file contains the definition of the port used
          for the <literal>svn</literal> protocol (as described in
          <xref linkend="svn.serverconfig.svnserve.invoking.inetd"
          />), otherwise the daemon will not start correctly.</para>
      -->
      <para>要确保 <filename>/etc/services</filename> 包含了
        <literal>svn</literal> 协议所使用的端口 (见 <xref
          linkend="svn.serverconfig.svnserve.invoking.inetd"/>), 否则的话,
        守护进程将无法正常启动.</para>

      <!--
        <para>In Redhat-based distributions, you then need to activate
          the new service using <command>chkconfig - -add
          svn</command>.  After doing so, you will be able to enable
          and disable the server using the graphical configuration
          tools.</para>
      -->
        <para>如果是基于 Redhat 的 Linux 发行版, 管理员需要使用
          <command>chkconfig --add svn</command> 激活新的服务, 后面就可以用图
          形化配置工具禁止或允许服务器程序.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.tunnel">
      <!--
        <title>svnserve over a tunnel</title>
      -->
        <title>基于隧道的 svnserve</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>tunnel mode</tertiary>
          </indexterm>
          另一种启动方式是通过添加选项 <option>-t</option>, 以隧道模式启动
          <command>svnserve</command>. 隧道模式假设有一个远程服务程序 (例如
          <command>rsh</command> 或 <command>ssh</command> 已经成功地授权了
          一个用户, 并且以该 <emphasis>用户的身份</emphasis> 启动了一个私有
          的 <command>svnserve</command> 进程. (用户几乎没有必要在命令行
          启动带有选项 <option>-t</option> 的 <command>svnserve</command>,
          相反, SSH 守护进程会替用户执行这个操作) 程序
          <command>svnserve</command> 像往常一样运行 (通过
          <filename>stdin</filename> 和 <filename>stdout</filename> 与其它
          进程通信),
          它还假设网络数据可以通过某种隧道, 被自动重定向回客户端. 当隧道代理
          以这种方式启动 <command>svnserve</command> 时, 要确保被授权的用户
          对仓库数据库文件具有读写权限, 在本质上它和本地用户通过
          <literal>file://</literal> URL 访问仓库的情况是一样的.</para>
      <!--
          Another way to invoke <command>svnserve</command> is in
          tunnel mode, using the <option>-t</option> option.  This
          mode assumes that a remote-service program such as
          <command>rsh</command> or <command>ssh</command> has
          successfully authenticated a user and is now invoking a
          private <command>svnserve</command> process <emphasis>as
          that user</emphasis>.  (Note that you, the user, will
          rarely, if ever, have reason to invoke
          <command>svnserve</command> with the <option>-t</option> at
          the command line; instead, the SSH daemon
          does so for you.)  The <command>svnserve</command> program
          behaves normally (communicating via
          <filename>stdin</filename> and <filename>stdout</filename>)
          and assumes that the traffic is being automatically
          redirected over some sort of tunnel back to the client.
          When <command>svnserve</command> is invoked by a tunnel
          agent like this, be sure that the authenticated user has
          full read and write access to the repository database files.
          It's essentially the same as a local user accessing the
          repository via <literal>file://</literal> URLs.</para>
      -->

      <!--
        <para>This option is described in much more detail later in
          this chapter in <xref
          linkend="svn.serverconfig.svnserve.sshauth"/>.</para>
      -->
      <para>更多的细节见 <xref
          linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.winservice">
      <!--
        <title>svnserve as a Windows service</title>
      -->
        <title>svnserve 作为 Windows 服务</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>as Windows service</tertiary>
          </indexterm>
          如果服务器所用的 Windows 系统是 Windows NT 的后代 (Windows 2000 或
          更新的版本), 管理员就能把 <command>svnserve</command> 作为一个标准
          的 Windows 服务启动, 和独立的守护进程启动方式 (添加选项
          <option>--daemon</option> (<option>-d</option>)) 相比, 这通常能带
          来更好的体验. 为了以守护进程的方式启动 <command>svnserve</command>,
          我们需要打开一个控制台, 输入命令, 然后任由控制台永远地运行下去. 然而,
          在后台运行的 Windows 服务可以在系统引导时自动启动, 可以使用和其他
          Windows 服务一样的管理接口来启动或停止服务.</para>
      <!--
          If your Windows system is a descendant of Windows NT
          (Windows 2000 or newer), you can
          run <command>svnserve</command> as a standard Windows
          service.  This is typically a much nicer experience than
          running it as a standalone daemon with
          the <option>- -daemon</option> (<option>-d</option>) option.
          Using daemon mode requires launching a console, typing a
          command, and then leaving the console window running
          indefinitely.  A Windows service, however, runs in the
          background, can start at boot time automatically, and can be
          started and stopped using the same consistent administration
          interface as other Windows services.</para>
      -->

      <!--
        <para>You'll need to define the new service using the
          command-line tool <command>SC.EXE</command>.  Much like
          the <command>inetd</command> configuration line, you must
          specify an exact invocation of <command>svnserve</command>
          for Windows to run at startup time:</para>
      -->
        <para>为了定义一个新的 Windows 服务, 需要用到命令行工具
          <command>SC.EXE</command>. 类似于 <command>inetd</command> 的配置
          文件, 管理员必须准确地指定 <command>svnserve</command> 的启动方式,
          以便 Windows 在开机时启动相应的服务:</para>

        <informalexample>
          <screen>
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</screen>
        </informalexample>

      <!--
        <para>This defines a new Windows service named
          <literal>svn</literal> which executes a particular
          <command>svnserve.exe</command> command when started (in
          this case, rooted at <filename>C:\repos</filename>).  There
          are a number of caveats in the prior example,
          however.</para>
      -->
        <para>上面的命令行定义了一个新的, 名为 <literal>svn</literal> 的
          Windows 服务, 当服务启动时, 它将执行程序
          <command>svnserve.exe</command>. 在这个例子里有很多需要注意的地方.
        </para>

      <!--
        <para>First, notice that the <command>svnserve.exe</command>
          program must always be invoked with the
          <option>- -service</option> option.  Any other options to
          <command>svnserve</command> must then be specified on the
          same line, but you cannot add conflicting options such as
          <option>- -daemon</option>
          (<option>-d</option>), <option>- -tunnel</option>,
          or <option>- -inetd</option> (<option>-i</option>).  Options
          such as <option>-r</option>
          or <option>- -listen-port</option> are fine, though.  Second,
          be careful about spaces when invoking
          the <command>SC.EXE</command> command: the <literal>key=
          value</literal> patterns must have no spaces between
          <literal>key=</literal> and must have exactly one space
          before the <literal>value</literal>.  Lastly, be careful
          about spaces in your command line to be invoked.  If a
          directory name contains spaces (or other characters that
          need escaping), place the entire inner value of
          <literal>binpath</literal> in double quotes, by escaping
          them:</para>
      -->
        <para>首先, 启动 <command>svnserve.exe</command> 时必须带上参数
          <option>--service</option>, 其他选项必须出现在同一行, 不能再添加
          会引起冲突的选项, 例如 <option>--daemon</option>
          (<option>-d</option>), <option>--tunnel</option> 或
          <option>--inetd</option> (<option>-i</option>), 但可以添加选项
          <option>-r</option> 或 <option>--listen-port</option>. 第二,
          注意命令行里的空格: 模式 <literal>key= value</literal> 中,
          <literal>key</literal> 和 <literal>=</literal> 之间不能有空格, 而
          <literal>key=</literal> 和 <literal>value</literal> 之间有且仅有
          一个空格. 最后, 要注意被调用的命令行里的空格. 如果目录名含有空格
          (或其他需要转义的字符), 就把 <literal>binpath</literal> 内的路径
          包裹在一对双引号中, 但要对双引号进行转义:</para>

        <informalexample>
          <screen>
C:\&gt; sc create svn
        binpath= "\"C:\program files\svn\bin\svnserve.exe\" --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</screen>
        </informalexample>

      <!--
        <para>Also note that the word <literal>binpath</literal> is
          misleading&mdash;its value is a <emphasis>command
          line</emphasis>, not the path to an executable.  That's why
          you need to surround it with quotes if it contains
          embedded spaces.</para>
      -->
        <para>还要注意 <literal>binpath</literal> 容易让人产生误解&mdash;
          它的值是一个 <emphasis>命令行</emphasis>, 而不是可执行文件的路径.
          因此, 如果它的值含有内嵌的空格, 就要用双引号包围起来.</para>

      <!--
        <para>Once the service is defined, it can be stopped, started,
          or queried using standard GUI tools (the Services
          administrative control panel), or at the command
          line:</para>
      -->
        <para>服务定义完成后, 可以使用标准的 GUI 工具 (服务管理控制面板) 来
          停止, 启动或查询服务, 也要以使用命令行工具:</para>

        <informalexample>
          <screen>
C:\&gt; net stop svn
C:\&gt; net start svn
</screen>
        </informalexample>

      <!--
        <para>The service can also be uninstalled (i.e., undefined) by
          deleting its definition:  <userinput>sc delete svn</userinput>.
          Just be sure to stop the service first!
          The <command>SC.EXE</command> program has many other
          subcommands and options; run <userinput>sc /?</userinput> to
          learn more about it.</para>
      -->
        <para>服务还能被卸载, 方法是删除它的定义: <userinput>sc delete
            svn</userinput>, 但在这之前记得先停止服务! 程序
          <command>SC.EXE</command> 还有很多子命令和选项, 执行
          <userinput>sc /?</userinput> 查看完整的命令帮助信息.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.launchd">
      <!--
        <title>svnserve as a launchd job</title>
      -->
        <title>svnserve 作为 launchd 作业</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>via launchd</tertiary>
          </indexterm>
          <indexterm>
            <primary>launchd</primary>
          </indexterm>
          Mac OS X (10.4 及更新的版本) 使用 <command>launchd</command>, 在
          系统范围和用户范围内管理进程 (包括守护进程). 一个
          <command>launchd</command> 由 XML 文件内的参数指定, 命令
          <command>launchctl</command> 用于管理作业的生命周期.</para>
      <!--
          Mac OS X (10.4 and higher) uses <command>launchd</command>
          to manage processes (including daemons) both system-wide and
          per-user.  A <command>launchd</command> job is specified by
          parameters in an XML property list file, and
          the <command>launchctl</command> command is used to manage
          the lifecycle of those jobs.</para>
      -->

      <!--
        <para>When configured to run as a <command>launchd</command>
          job, <command>svnserve</command> is automatically launched
          on demand whenever incoming Subversion
          <literal>svn://</literal> network traffic needs to be
          handled.  This is far more convenient than a configuration
          which requires you to manually invoke
          <command>svnserve</command> as a long-running
          background process.</para>
      -->
        <para>如果 <command>svnserve</command> 被配置成作为一个
          <command>launchd</command> 作业, 那么当有 <literal>svn://</literal>
          网络流量需要处理时, 将自动启动 <command>svnserve</command>. 这要比
          手动地启动 <command>svnserve</command> 并把它作为长时间运行的后台
          进程要方便得多.</para>

      <!--
        <para>To configure <command>svnserve</command> as
          a <command>launchd</command> job, first create a job
          definition file named
          <filename>/Library/LaunchDaemons/org.apache.subversion.svnserve.plist</filename>.
          <xref linkend="svn.serverconfig.svnserve.invoking.launchd.ex-1"/>
          provides an example of such a file.</para>
      -->
        <para>为了把 <command>svnserve</command> 配置成一个
          <command>launchd</command> 作业, 首先创建一个名为
          <filename>/Library/LaunchDaemons/org.apache.subversion.svnserve.plist</filename>
          的作业定义文件, <xref
            linkend="svn.serverconfig.svnserve.invoking.launchd.ex-1"/> 展示
          了该文件的一个例子.</para>

        <example id="svn.serverconfig.svnserve.invoking.launchd.ex-1">
      <!--
          <title>A sample svnserve launchd job definition</title>
      -->
          <title>svnserve 的 launchd 作业定义的一个示例</title>
          <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;Label&lt;/key&gt;
        &lt;string&gt;org.apache.subversion.svnserve&lt;/string&gt;
        &lt;key&gt;ServiceDescription&lt;/key&gt;
        &lt;string&gt;Host Subversion repositories using svn:// scheme&lt;/string&gt;
        &lt;key&gt;ProgramArguments&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;/usr/bin/svnserve&lt;/string&gt;
            &lt;string&gt;--inetd&lt;/string&gt;
            &lt;string&gt;--root=/var/svn&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;UserName&lt;/key&gt;
        &lt;string&gt;svn&lt;/string&gt;
        &lt;key&gt;GroupName&lt;/key&gt;
        &lt;string&gt;svn&lt;/string&gt;
        &lt;key&gt;inetdCompatibility&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Wait&lt;/key&gt;
            &lt;false/&gt;
        &lt;/dict&gt;
        &lt;key&gt;Sockets&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Listeners&lt;/key&gt;
            &lt;array&gt;
                &lt;dict&gt;
                    &lt;key&gt;SockServiceName&lt;/key&gt;
                    &lt;string&gt;svn&lt;/string&gt;
                    &lt;key&gt;Bonjour&lt;/key&gt;
                    &lt;true/&gt;
                &lt;/dict&gt;
            &lt;/array&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</programlisting>
        </example>

        <warning>
      <!--
          <para>The <command>launchd</command> system can be somewhat
            challenging to learn.  Fortunately, documentation exists
            for the commands described in this section. For example,
            run <userinput>man launchd</userinput> from the command
            line to see the manual page for <command>launchd</command>
            itself, <userinput>man launchd.plist</userinput> to read
            about the job definition format, etc.</para>
      -->
          <para><command>launchd</command> 系统学习起来有一定的困难, 幸运的是
            本节所介绍的 <command>launchd</command> 命令都有相关的文档可供
            参考, 例如执行 <userinput>man launchd</userinput> 查看
            <command>launchd</command> 的手册页, 执行
            <userinput>man launchd.plist</userinput> 查看作业定义文件的格式.
          </para>
        </warning>

      <!--
        <para>Once your job definition file is created, you can
          activate the job using <command>launchctl load</command>:</para>
      -->
        <para>作业定义文件创建完毕后, 就可以用 <command>launchctl
            load</command> 激活作业:</para>

        <informalexample>
          <screen>
$ sudo launchctl load \
       -w /Library/LaunchDaemons/org.apache.subversion.svnserve.plist
</screen>
        </informalexample>

      <!--
        <para>To be clear, this action doesn't actually launch
          <command>svnserve</command> yet.  It simply tells
          <command>launchd</command> how to fire up
          <command>svnserve</command> when incoming networking traffic
          arrives on the <literal>svn</literal> network port; it will
          be terminated it after the traffic has been handled.</para>
      -->
        <para>需要澄清的是, 上面的命令并没有启动 <command>svnserve</command>,
          它只是告诉 <command>launchd</command> 当网络端口
          <literal>svn</literal> 有网络数据到达时如何启动
          <command>svnserve</command>, 当网络数据处理完毕后,
          <command>svnserve</command> 进程就会终止.</para>

        <note>
      <!--
          <para>Because we want <command>svnserve</command> to be a
            system-wide daemon process, we need to
            use <command>sudo</command> to manage this job as an
            administrator.  Note also that the
            <literal>UserName</literal>
            and <literal>GroupName</literal> keys in the definition
            file are optional&mdash;if omitted, the job will run as
            the user who loaded the job.</para>
      -->
          <para>因为我们希望 <command>svnserve</command> 成为整个系统范围内
            的守护进程, 所以要用 <command>sudo</command> 命令, 作为系统管理员
            去管理作业. 定义文件内的 <literal>UserName</literal> 和
            <literal>GroupName</literal> 是可选的&mdash;如果忽略它们, 作业的
            所有者将是加载该作业的用户.</para>
        </note>

      <!--
        <para>Deactivating the job is just as easy to do&mdash;use
          <command>launchctl unload</command>:</para>
      -->
        <para>禁用作业的方法也很简单&mdash;使用 <command>launchctl
            unload</command>:</para>

        <informalexample>
          <screen>
$ sudo launchctl unload \
       -w /Library/LaunchDaemons/org.apache.subversion.svnserve.plist
</screen>
        </informalexample>

      <!--
        <para><command>launchctl</command> also provides a way for you
          to query the status of jobs.  If the job is loaded, there
          will be line which matches the <literal>Label</literal>
          specified in the job definition file:</para>
      -->
        <para><command>launchctl</command> 也提供了查询作业状态的命令, 如果
          作业已加载, 那么作业定义文件中, <literal>Label</literal> 所指定的
          内容将会出现在命令的输出中:</para>

        <informalexample>
          <screen>
$ sudo launchctl list | grep org.apache.subversion.svnserve
-       0       org.apache.subversion.svnserve
$
</screen>
        </informalexample>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">
      <!--
      <title>Built-in Authentication and Authorization</title>
      -->
      <title>内建的认证与授权</title>

      <para>
        <indexterm>
          <primary>svnserve</primary>
          <secondary>authentication</secondary>
        </indexterm>
        <indexterm>
          <primary>svnserve</primary>
          <secondary>authorization</secondary>
        </indexterm>
        当客户端连接到 <command>svnserve</command> 进程时, 将会发生以下事件:
      </para>
      <!--
        When a client connects to an <command>svnserve</command>
        process, the following things happen:</para>
      -->

      <itemizedlist>
        <listitem>
      <!--
          <para>The client selects a specific repository.</para>
      -->
          <para>客户端选择一个特定的仓库.</para>
        </listitem>
        <listitem>
      <!--
          <para>The server processes the repository's
            <filename>conf/svnserve.conf</filename> file and begins to
            enforce any authentication and authorization policies it
            describes.</para>
      -->
          <para>服务器读取仓库的 <filename>conf/svnserve.conf</filename>,
            施加文件所描述的认证与授权策略.</para>
        </listitem>
        <listitem>
      <!--
          <para>Depending on the defined policies, one of the
            following may occur:</para>
      -->
          <para>取决于具体的策略, 可能会发生下面几件事中的一件:</para>
          <itemizedlist>
            <listitem>
      <!--
              <para>The client may be allowed to make requests
                anonymously, without ever receiving an authentication
                challenge.</para>
      -->
              <para>允许客户端以匿名的方式提出请求, 不会收到任何认证要求.</para>
            </listitem>
            <listitem>
      <!--
              <para>The client may be challenged for authentication at
                any time.</para>
      -->
              <para>客户端可能在任意时刻收到认证要求.</para>
            </listitem>
            <listitem>
      <!--
              <para>If operating in tunnel mode, the client will
                declare itself to be already externally authenticated
                (typically by SSH).</para>
      -->
              <para>如果操作是在隧道模式下进行, 客户端将声明它已经在外部认证
                过了 (通常是 SSH).</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <!--
      <para>The <command>svnserve</command> server, by default, knows
        only how to send a CRAM-MD5<footnote><para>See RFC
        2195.</para></footnote> authentication challenge.  In essence,
        the server sends a small amount of data to the client.  The
        client uses the MD5 hash algorithm to create a fingerprint of
        the data and password combined, and then sends the fingerprint
        as a response.  The server performs the same computation with
        the stored password to verify that the result is identical.
        <emphasis>At no point does the actual password travel over the
        network.</emphasis></para>
      -->
    <para>默认情况下, <command>svnserve</command> 只知道如何发送一个
      CRAM-MD5<footnote><para>见 RFC 2195.</para></footnote> 授权请求,
      在本质上, 就是服务器向客户端发送了一小段数据. 客户端使用 MD5 散列算法
      为数据和密码的混合物创建指纹, 然后发送该指纹, 作为认证请求的响应. 服
      务器对存放在本地的密码进行同样的计算, 以验证它们是否相同. <emphasis>在
        任何情况下都不会在网络上传输明文密码</emphasis>.</para>

      <!--
      <para>If your <command>svnserve</command> server was built with
        SASL support, it not only knows how to send CRAM-MD5 challenges,
        but also likely knows a whole host of other authentication
        mechanisms.  See <xref
        linkend="svn.serverconfig.svnserve.sasl"/> later in this
        chapter to learn how to configure SASL authentication and
        encryption.</para>
      -->
      <para>如果 <command>svnserve</command> 支持 SASL, 除了知道如何发送
        CRAM-MD5 请求外, <command>svnserve</command> 还能使用其他几种认证
        机制, 本章后面的 <xref linkend="svn.serverconfig.svnserve.sasl"/>
        将会介绍如何配置 SASL 认证和加密.</para>

      <!--
      <para>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <command>ssh</command>.  In that case, the server simply
        examines the user it's running as, and uses this name as the
        authenticated username.  For more on this, see the later
        section, <xref
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>
      -->
    <para>当然, 客户端也可以通过一个隧道代理 (例如 <command>ssh</command>),
      实现外部认证. 在这种情况下, 服务器只是简单地检查自己的用户身份, 然后
      使用该用户名作为已认证的用户. 更多的相关内容, 见
      <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <!--
      <para>As you've already guessed, a repository's
        <filename>svnserve.conf</filename> file is the central
        mechanism for controlling access to the repository.  When used
        in conjunction with other supplemental files described in this
        section, this configuration file offers an administrator a
        complete solution for governing user authentication and
        authorization policies.  Each of the files we'll discuss uses
        the format common to other configuration files (see
        <xref linkend="svn.advanced.confarea"/>): section names are
        marked by square brackets (<literal>[</literal>
        and <literal>]</literal>), comments begin with hashes
        (<literal>#</literal>), and each section contains specific
        variables that can be set (<literal>variable =
        value</literal>).  Let's walk through these files now and
        learn how to use them.</para>
      -->
      <para>读者可能已经猜到了, 仓库里的 <filename>svnserve.conf</filename>
        正是控制认证和授权策略的关键. 当它和本节所描述的其他附加文件配合工作
        时, <filename>svnserve.conf</filename> 向管理员提供了用于控制用户认证
        和授权策略的完整方案. 我们将要讨论的每个文件所使用的格式, 与其他配置
        文件的格式相同 (见
        <xref linkend="svn.advanced.confarea"/>): 节名用一对方括号标记
        (<literal>[</literal> 和 <literal>]</literal>), 注释由井号
        (<literal>#</literal>) 开始, 每一节都包含了可被赋值的特定变量
        (<literal>variable = value</literal>). 下面介绍各个文件并学习如何
        使用它们.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.users">
      <!--
        <title>Create a users file and realm</title>
      -->
        <title>创建一个用户文件和认证域</title>

      <!--
        <para>For now, the <literal>[general]</literal> section of
          <filename>svnserve.conf</filename> has all the variables you
          need.  Begin by changing the values of those variables:
          choose a name for a file that will contain your usernames
          and passwords and choose an authentication realm:</para>
      -->
        <para>现在, 你所需要的所有变量都在 <filename>svnserve.conf</filename>
          的 <literal>[general]</literal> 部分. 先从修改这些变量的值开始:
          为存放用户名和密码的文件选择一个名字, 以及选择一个认证域:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm
</programlisting>
        </informalexample>

      <!--
        <para>The <literal>realm</literal> is a name that you define.
          It tells clients which sort of <quote>authentication
          namespace</quote> they're connecting to; the Subversion
          client displays it in the authentication prompt and uses it
          as a key (along with the server's hostname and port) for
          caching credentials on disk (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  The
          <literal>password-db</literal> variable points to a separate
          file that contains a list of usernames and passwords, using
          the same familiar format.  For example:</para>
      -->
        <para><literal>realm</literal> 的值是你自己定义的一个名字, 它告诉
          客户端它们正在连接的是哪一个 <quote>认证空间</quote>; Subversion
          客户端在认证的提示信息里显示 <literal>realm</literal> 的值, 并
          用它 (再加上服务器的主机名和端口号) 作为缓存在磁盘上的证书的键
          (见 <xref linkend="svn.serverconfig.netmodel.credcache"/>).
          变量 <literal>password-db</literal> 指向一个单独的文件, 它包含了
          一连串的用户名和密码, 文件的格式和
          <filename>svnserve.conf</filename> 是相同的, 例如:</para>

        <informalexample>
          <programlisting>
[users]
harry = foopassword
sally = barpassword
</programlisting>
        </informalexample>

      <!--
        <para>The value of <literal>password-db</literal> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <filename>conf/</filename> area of the repository, alongside
          <filename>svnserve.conf</filename>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Wherever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <command>svnserve</command> will run
          as, restrict read access to the users file as necessary.</para>
      -->
        <para>变量 <literal>password-db</literal> 的值可以是指向用户文件
          的绝对路径或相对路径, 管理员很容易就能把用户文件设置到仓库的
          <filename>conf/</filename> 目录内, 和
          <filename>svnserve.conf</filename> 放在一起. 另外, 多个仓库还能
          共享同一个用户文件, 在这种情况下, 文件应该放在更加开放的位置.
          共享同一用户文件的仓库还要配置相同的认证域, 因为用户名列表在本质上
          就已经定义了一个认证域. 无论用户文件放在何处, 都要设置好它的
          读写权限. 如果管理员知道 <command>svnserve</command> 将以哪些用户
          身份运行, 在必要时可限制用户文件的读取权限.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.general">
      <!--
        <title>Set access controls</title>
      -->
        <title>设置访问控制</title>

      <!--
        <para>There are two more variables to set in the
          <filename>svnserve.conf</filename> file: they determine what
          unauthenticated (anonymous) and authenticated users are
          allowed to do.  The variables <literal>anon-access</literal>
          and <literal>auth-access</literal> can be set to the value
          <literal>none</literal>, <literal>read</literal>, or
          <literal>write</literal>.  Setting the value to
          <literal>none</literal> prohibits both reading and writing;
          <literal>read</literal> allows read-only access to the
          repository, and <literal>write</literal> allows complete
          read/write access to the repository.  For example:</para>
      -->
        <para>还有两个变量可以在 <filename>svnserve.conf</filename> 里设置:
          它们决定了未验证 (匿名) 的用户和已验证的用户可以做哪些事情. 变量
          <literal>anon-access</literal> 和 <literal>auth-access</literal>
          可被设置的值有 <literal>none</literal>, <literal>read</literal>
          和 <literal>write</literal>. 设置为 <literal>none</literal> 将
          禁止读和写; <literal>read</literal> 允许以只读方式访问仓库;
          <literal>write</literal> 允许对仓库进行完全的读写访问. 例如:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</programlisting>
        </informalexample>

      <!--
        <para>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</para>
      -->
        <para>例子所展示的其实就是变量的默认值, 以免管理员忘记设置它们. 如
          果管理员需要更加保守的设置, 可以完全禁止匿名访问:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</programlisting>
        </informalexample>

      <!--
        <para>The server process understands not only
          these <quote>blanket</quote> access controls to the
          repository, but also finer-grained access restrictions
          placed on specific files and directories within the
          repository.  To make use of this feature, you need to define
          a file containing more detailed rules, and then set
          the <literal>authz-db</literal> variable to point to
          it:</para>
      -->
        <para>服务器进程不仅可以理解施加到仓库上的全局的访问控制, 还能理解
          施加到文件或目录上的更细粒度的访问控制. 为了利用后者, 管理员创建一
          个文件, 文件包含了更细致的规则, 然后让变量
          <literal>authz-db</literal> 指向该文件:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm

# Specific access rules for specific locations
authz-db = authzfile
</programlisting>
        </informalexample>

      <!--
        <para>We discuss the syntax of the <filename>authzfile</filename> file
          in detail later in this chapter, in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.  Note
          that the <literal>authz-db</literal> variable isn't mutually
          exclusive with the <literal>anon-access</literal>
          and <literal>auth-access</literal> variables;  if all the
          variables are defined at once, <emphasis>all</emphasis>
          of the rules must be satisfied before access is allowed.</para>
      -->
        <para>我们在 <xref linkend="svn.serverconfig.pathbasedauthz"/> 详细
          介绍 <filename>authzfile</filename> 的语法. 注意, 变量
          <literal>authz-db</literal> 与 <literal>anon-access</literal>,
          <literal>auth-access</literal> 并非互不相容, 如果同时定义了这三个
          变量, 则只有在 <emphasis>所有</emphasis> 规则都被满足的情况下,
          才能允许访问.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sasl">
      <!--
      <title>Using svnserve with SASL</title>
      -->
      <title>svnserve 使用 SASL</title>

      <!--
      <para>For many teams, the built-in CRAM-MD5 authentication is
        all they need from <command>svnserve</command>.  However, if
        your server (and your Subversion clients) were built with the
        Cyrus Simple Authentication and Security Layer (SASL) library,
        you have a number of authentication and encryption
        options available to you.</para>
      -->
      <para>对于许多团队而言, 使用 <command>svnserve</command> 内建的 CRAM-MD5
        认证就已足够. 然而, 如果服务器和 Subversion 客户端支持 SASL (Cyrus
        Simple Authentication and Security Layer) 函数库, 那么管理员就有了
        大量的认证和加密选项可供选择.</para>

      <sidebar>
      <!--
        <title>What Is SASL?</title>
      -->
        <title>什么是 SASL?</title>

      <!--
        <para>The Cyrus Simple Authentication and Security Layer is
          open source software written by Carnegie Mellon University.
          It adds generic authentication and encryption capabilities
          to any network protocol, and as of Subversion 1.5 and later,
          both the <command>svnserve</command> server
          and <command>svn</command> client know how to make use of
          this library.  It may or may not be available to you: if
          you're building Subversion yourself, you'll need to have at
          least version 2.1 of SASL installed on your system, and
          you'll need to make sure that it's detected during
          Subversion's build process.  The Subversion command-line
          client will report the availability of Cyrus SASL when you
          run <userinput>svn - -version</userinput>; if you're using
          some other Subversion client, you might need to check with
          the package maintainer as to whether SASL support was
          compiled in.</para>
      -->
        <para>Cyrus Simple Authenticated and Security Layer (简称 SASL)
          是卡耐基梅隆
          大学开发的一款开源软件, 可以给任意一种网络协议添加通用的认证和
          授权功能, 从 Subversion 1.5 开始, <command>svnserve</command>
          服务器和 <command>svn</command> 客户端开始支持 SASL. 不过 SASL
          并非总是可用, 如果 Subversion 是你自己编译安装的, 为了利用 SASL,
          系统中至少要安装 SASL 2.1 版, 并且在 Subversion 构建过程中能够检测
          到 SASL 的存在. 执行 <userinput>svn --version</userinput> 时,
          Subversion 客户端命令行工具将报告 Cyrus SASL 是否可用. 如果你安装
          的是已经编译好了的二进制包, 那你就要检查 SASL 是否被编译到了安装
          包里.</para>

      <!--
        <para>SASL comes with a number of pluggable modules that
          represent different authentication systems: Kerberos
          (GSSAPI), NTLM, One-Time-Passwords (OTP), DIGEST-MD5, LDAP,
          Secure-Remote-Password (SRP), and others.  Certain
          mechanisms may or may not be available to you; be sure to
          check which modules are provided.</para>
      -->
        <para>SASL 包含大量可插拔的模块, 这些模块代表了不同的认证机制:
          Kerberos (GSSAPI), NTLM, One-Time-Passwords (OTP), DIGEST-MD5,
          LDAP, Secure-Remote-Password (SRP) 等. 某些机制在你的系统中可能
          无法使用, 使用前检查系统中的 SASL 提供了哪些模块.</para>

      <!--
        <para>You can download Cyrus SASL (both code and
          documentation) from
          <ulink url="http://asg.web.cmu.edu/sasl/sasl-library.html"
          />.</para>
      -->
      <para>Cyrus SASL 源代码及其文档的下载地址是 <ulink
          url="http://asg.web.cmu.edu/sasl/sasl-library.html" />.</para>

      </sidebar>

      <!--
      <para>Normally, when a subversion client connects to
        <command>svnserve</command>, the server sends a greeting that
        advertises a list of the capabilities it supports, and the
        client responds with a similar list of capabilities.  If the
        server is configured to require authentication, it then sends
        a challenge that lists the authentication mechanisms
        available; the client responds by choosing one of the
        mechanisms, and then authentication is carried out in some
        number of round-trip messages.  Even when SASL capabilities
        aren't present, the client and server inherently know how to
        use the CRAM-MD5 and ANONYMOUS mechanisms (see
        <xref linkend="svn.serverconfig.svnserve.auth"/>).  If server
        and client were linked against SASL, a number of other
        authentication mechanisms may also be available.  However,
        you'll need to explicitly configure SASL on the server side to
        advertise them.</para>
      -->
      <para>正常情况下, 当 Subversion 客户端连接到 <command>svnserve</command>
        时, 服务器以宣告它所支持的功能作为响应. 如果服务器的配置要求认证,
        服务器将向客户端发起认证请求, 并列出它所支持的认证机制, 客户端从中选择
        一种认证机制, 通过几个往返消息携带认证信息. 即使 SASL 不可用, 客户端
        和服务器也能使用内建的 CRAM-MD5 和 ANONYMOUS 认证机制 (见 <xref
          linkend="svn.serverconfig.svnserve.auth"/>). 如果服务器和客户端
        支持 SASL, 那么可供选择的认证机制就比较多, 但是管理员必须在服务器
        端显式地配置 SASL, 服务端才能向客户端宣告这些认证机制是可用的.
      </para>

      <sect3 id="svn.serverconfig.svnserve.sasl.authn">
      <!--
        <title>Authenticating with SASL</title>
      -->
        <title>使用 SASL 进行认证</title>

      <!--
        <para>To activate specific SASL mechanisms on the server,
          you'll need to do two things.  First, create
          a <literal>[sasl]</literal> section in your
          repository's <filename>svnserve.conf</filename> file with an
          initial key-value pair:</para>
      -->
        <para>为了在服务器上激活 SASL, 管理员要做两件事. 首先, 在仓库的
          <filename>svnserve.conf</filename> 里创建 <literal>[sasl]</literal>
          节, 并为变量 <literal>use-sasl</literal> 赋值:</para>

        <informalexample>
          <programlisting>
[sasl]
use-sasl = true
</programlisting>
        </informalexample>

      <!--
        <para>Second, create a main SASL configuration file
          called <filename>svn.conf</filename> in a place where the
          SASL library can find it&mdash;typically in the directory
          where SASL plug-ins are located.  You'll have to locate the
          plug-in directory on your particular system, such
          as <filename>/usr/lib/sasl2/</filename>
          or <filename>/etc/sasl2/</filename>.  (Note that this
          is <emphasis>not</emphasis>
          the <filename>svnserve.conf</filename> file that lives
          within a repository!)</para>
      -->
        <para>然后, 在 SASL 库函数能够找到的位置创建一个名为
          <filename>svn.conf</filename> 的配置文件&mdash;最典型的位置就是
          SASL 插件所处的位置, 因此管理员需要定位 SASL 插件在系统中的位置,
          例如 <filename>/usr/lib/sasl2/</filename> 或
          <filename>/etc/sasl2/</filename>. (注意, 本段所说的配置文件是
          <filename>svn.conf</filename>, 不是仓库中的
          <filename>svnserve.conf</filename>!).</para>

      <!--
        <para>On a Windows server, you'll also have to edit the system
          registry (using a tool such as <command>regedit</command>)
          to tell SASL where to find things.  Create a registry key
          named <literal>[HKEY_LOCAL_MACHINE\SOFTWARE\Carnegie
          Mellon\Project Cyrus\SASL Library]</literal>, and place two
          keys inside it: a key called <literal>SearchPath</literal>
          (whose value is a path to the directory containing the SASL
          <filename>sasl*.dll</filename> plug-in libraries), and a key
          called
          <literal>ConfFile</literal> (whose value is a path to the
          parent directory containing
          the <filename>svn.conf</filename> file you created).</para>
      -->
        <para>如果服务器的系统是 Windows, 你需要编辑系统注册表 (使用工具
          <command>regedit</command>), 以便告诉 SASL 去哪里搜索所需要的
          文件. 在系统注册表中添加一个新的注册表项, 表项的名字是
          <literal>[HKEY_LOCAL_MACHINE\SOFTWARE\CarnegieMellon\Project Cyrus\SASL Library]</literal>,
          并在其中新增两项: 一项是 <literal>SearchPath</literal> (它的值是一个
          指向目录的路径, 目录包含了 SASL 动态链接库), 另一项是
          <literal>ConfFile</literal> (它的值是一个指向目录的路径, 目录内含有
          管理员创建的 <filename>svn.conf</filename> 文件).</para>

      <!--
        <para>Because SASL provides so many different kinds of
          authentication mechanisms, it would be foolish (and far
          beyond the scope of this book) to try to describe every
          possible server-side configuration.  Instead, we recommend
          that you read the documentation supplied in the
          <filename>doc/</filename> subdirectory of the SASL source
          code.  It goes into great detail about every mechanism and
          how to configure the server appropriately for each.  For the
          purposes of this discussion, we'll just demonstrate a simple
          example of configuring the DIGEST-MD5 mechanism.  For
          example, if your <filename>svn.conf</filename> file contains the
          following:</para>
      -->
        <para>因为 SASL 提供了多种不同的认证机制, 描述每一种可能的服务器端
          配置是不切实际的 (而且也超出了本书的范围), 所以我们建议读者自己去
          阅读 SASL 源代码目录内, <filename>doc</filename> 子目录内的文档,
          文档详细介绍了每一种认证机制, 以及如何正确地配置服务器, 以便使用
          这些认证机制. 为了方便讨论, 我们将介绍一个配置 DIGEST-MD5 的简单
          示例. 如果你的 <filename>svn.conf</filename> 含有以下内容:</para>

        <informalexample>
          <programlisting>
pwcheck_method: auxprop
auxprop_plugin: sasldb
sasldb_path: /etc/my_sasldb
mech_list: DIGEST-MD5
</programlisting>
        </informalexample>

      <!--
        <para>you've told SASL to advertise the DIGEST-MD5
          mechanism to clients and to check user passwords against a
          private password database located
          at <filename>/etc/my_sasldb</filename>.  A system
          administrator can then use
          the <command>saslpasswd2</command> program to add or modify
          usernames and passwords in the database:</para>
      -->
        <para>上面的配置向客户端宣告了 DIGEST-MD5 认证机制, 使用存放在
          <filename>/etc/my_sasldb</filename> 里的私有密码数据库检查用户
          输入的密码的正确性. 管理员可以使用 <command>saslpasswd2</command>
          向密码数据库添加或修改用户名和密码:</para>

        <informalexample>
          <screen>
$ saslpasswd2 -c -f /etc/my_sasldb -u realm username
</screen>
        </informalexample>

      <!--
        <para>A few words of warning: first, make sure the
          <quote>realm</quote> argument
          to <command>saslpasswd2</command> matches the same realm
          you've defined in your
          repository's <filename>svnserve.conf</filename> file; if
          they don't match, authentication will fail.  Also, due to a
          shortcoming in SASL, the common realm must be a string with
          no space characters.  Finally, if you decide to go with the
          standard SASL password database, make sure
          the <command>svnserve</command> program has read access to
          the file (and possibly write access as well, if you're using
          a mechanism such as OTP).</para>
      -->
        <para>有些地方需要注意: 首先要确保 <command>saslpasswd2</command> 的
          <quote>认证域</quote> 参数和定义在 <filename>svnserve.conf</filename>
          里的认证域是一致的, 如果它们不一致, 认证将会失败. 另外, 受限于 SASL,
          认证域必须是不带空格的字符串. 最后, 如果你决定使用标准的 SASL 密码数据
          库, 需要确保进程 <command>svnserve</command> 对数据库文件具有读
          权限 (某些认证机制&mdash;例如 OTP&mdash;还会要求写权限).</para>

      <!--
        <para>This is just one simple way of configuring SASL.  Many
          other authentication mechanisms are available, and passwords
          can be stored in other places such as in LDAP or a SQL
          database.  Consult the full SASL documentation for
          details.</para>
      -->
        <para>这只是一种配置 SASL 的简单方式. 还有其他多种认证机制可供选择,
          密码也能以其他格式存在, 例如 LDAP 或 SQL 数据库, 具体的细节请参考
          SASL 文档.</para>

      <!--
        <para>Remember that if you configure your server to only allow
          certain SASL authentication mechanisms, this forces all
          connecting clients to have SASL support as well.  Any
          Subversion client built without SASL support (which includes
          all pre-1.5 clients) will be unable to authenticate.  On the
          one hand, this sort of restriction may be exactly what you
          want (<quote>My clients must all use Kerberos!</quote>).
          However, if you still want non-SASL clients to be able to
          authenticate, be sure to advertise the CRAM-MD5 mechanism as
          an option.  All clients are able to use CRAM-MD5, whether
          they have SASL capabilities or not.</para>
      -->
        <para>注意, 如果管理员将服务器配置成仅允许使用 SASL 认证机制, 这同时
          也在要求所有连接到服务器的客户端必须支持 SASL, 不支持 SASL 的客户
          端 (包括 1.5 版之前的所有客户端) 将无法完成认证, 但是另一个方面,
          这种配置也正是你所想要的效果 (<quote>所有的客户端都必须使用
            Kerberos!</quote>). 然而, 如果仍然存在不支持 SASL 的客户端需要
          连接服务器, 就要确保 CRAM-MD5 认证机制是可用的, 因为所有的客户端
          都支持 CRAM-MD5.</para>

      </sect3>

      <sect3 id="svn.serverconfig.svnserve.sasl.encryption">
      <!--
        <title>SASL encryption</title>
      -->
        <title>SASL 加密</title>

      <!--
        <para>SASL is also able to perform data encryption if a
          particular mechanism supports it.  The built-in CRAM-MD5
          mechanism doesn't support encryption, but DIGEST-MD5 does,
          and mechanisms such as SRP actually require use of the
          OpenSSL library.  To enable or disable different levels of
          encryption, you can set two values in your repository's
          <filename>svnserve.conf</filename> file:</para>
      -->
        <para>如果特定的认证机制支持, 那么 SASL 也能实现数据加密. 内建的
          CRAM-MD5 不支持加密, 但 DIGEST-MD5 支持, SRP 实际上会用到 OpenSSL
          函数库. 为了开启或禁止加密的不同级别, 你需要在仓库的
          <filename>svnserve.conf</filename> 里定义两个值:</para>

        <informalexample>
          <programlisting>
[sasl]
use-sasl = true
min-encryption = 128
max-encryption = 256
</programlisting>
        </informalexample>

      <!--
        <para>The <literal>min-encryption</literal> and
          <literal>max-encryption</literal> variables control the
          level of encryption demanded by the server.  To disable
          encryption completely, set both values to 0.  To enable
          simple checksumming of data (i.e., prevent tampering and
          guarantee data integrity without encryption), set both
          values to 1.  If you wish to allow&mdash;but not
          require&mdash;encryption, set the minimum value to 0, and
          the maximum value to some bit length.  To require encryption
          unconditionally, set both values to numbers greater than 1.
          In our previous example, we require clients to do at least
          128-bit encryption, but no more than 256-bit
          encryption.</para>
      -->
        <para>变量 <literal>min-encryption</literal> 和
          <literal>max-encryption</literal> 决定加密的级别. 为了完全禁止加密,
          就把两个变量都设为 0. 为了开启简单的数据检验 (即防止数据被篡改,
          保证数据的完整性, 但没有对数据进行加密), 把两个变量都设为 1. 如果
          管理员希望允许&mdash;但并非强制&mdash;加密, 就把
          <literal>min-encryption</literal> 设为 0, 把
          <literal>max-encryption</literal> 设为稍微大点的值. 为了强制要求
          对数据进行加密, 把两个变量都设为大于 1 的数. 在上面的例子里, 我们
          要求客户端的加密至少为 128 位, 但不多于 256 位.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">
      <!--
      <title>Tunneling over SSH</title>
      -->
      <title>SSH 隧道</title>

      <!--
      <para><command>svnserve</command>'s built-in authentication (and
        SASL support) can be very handy, because it avoids the need to
        create real system accounts.  On the other hand, some
        administrators already have well-established SSH
        authentication frameworks in place.  In these situations, all
        of the project's users already have system accounts and the
        ability to <quote>SSH into</quote> the server machine.</para>
      -->
      <para><command>svnserve</command> 内建的认证机制 (和 SASL) 使用起来
        非常方便, 因为它避免了创建真正的系统账户. 但另一方面, 管理员可能
        已经建立了一套完善的 SSH 认证框架, 项目所有的开发人员都拥有自己的
        系统账户, 而且能够通过 SSH 登录到服务器.</para>

      <!--
      <para>It's easy to use SSH in conjunction with
        <command>svnserve</command>.  The client simply uses the
        <literal>svn+ssh://</literal> URL scheme to connect:</para>
      -->
      <para>结合使用 SSH 和 <command>svnserve</command> 比较简单, 客户端只要
        用 <literal>svn+ssh://</literal> 形式的 URL 连接服务器即可:</para>

      <informalexample>
        <screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harryssh@host.example.com's password:  *****

foo
bar
baz
&hellip;
</screen>
      </informalexample>

      <!--
      <para>In this example, the Subversion client is invoking a local
        <command>ssh</command> process, connecting to
        <literal>host.example.com</literal>, authenticating as the
        user <literal>harryssh</literal> (according to SSH user
        configuration), then spawning a private
        <command>svnserve</command> process on the remote machine
        running as the user <literal>harryssh</literal>.  The
        <command>svnserve</command> command is being invoked in tunnel
        mode (<option>-t</option>), and its network protocol is being
        <quote>tunneled</quote> over the encrypted connection by
        <command>ssh</command>, the tunnel agent.
        If the client performs a commit, the authenticated username
        <literal>harryssh</literal> will be used as the author
        of the new revision.</para>
      -->
      <para>在上面的例子里, Subversion 客户端唤起一个本地的
        <command>ssh</command> 进程, 连接到 <literal>host.example.com</literal>,
        作为用户 <literal>harryssh</literal> (根据 SSH 用户配置) 进行认证,
        然后在远程的服务器中, 以用户 <literal>harryssh</literal> 的身份派生
        一个私有的 <command>svnserve</command> 进程. 命令
        <command>svnserve</command> 在隧道模式 (<option>-t</option>) 下执行,
        它的网络协议行走在由 <command>ssh</command>&mdash;隧道代理&mdash;提供
        的加密通道中. 如果客户端执行一个提交操作, 认证过的用户名
        <literal>harryssh</literal> 将作为新版本号的作者.</para>

      <!--
      <para>The important thing to understand here is that the
        Subversion client is <emphasis>not</emphasis> connecting to a
        running <command>svnserve</command> daemon.  This method of
        access doesn't require a daemon, nor does it notice one if
        present.  It relies wholly on the ability of
        <command>ssh</command> to spawn a temporary
        <command>svnserve</command> process, which then terminates
        when the network connection is closed.</para>
      -->
      <para>这里需要强调的一点是 Subversion 客户端 <emphasis>并没有</emphasis>
        连接到运行着的 <command>svnserve</command> 守护进程, 这种访问方式不
        要求 <command>svnserve</command> 守护进程存在, 即使存在也不会被注意
        到. 它完全依赖 <command>ssh</command> 临时派生的
        <command>svnserve</command> 进程, 当网络连接关闭时,
        <command>svnserve</command> 进程就会终止.</para>

      <!--
      <para>When using <literal>svn+ssh://</literal> URLs to access a
        repository, remember that it's the <command>ssh</command>
        program prompting for authentication, and
        <emphasis>not</emphasis> the <command>svn</command> client
        program.  That means there's no automatic password-caching
        going on (see <xref linkend="svn.serverconfig.netmodel.credcache"/>).
        The Subversion client often makes multiple connections to the
        repository, though users don't normally notice this due to the
        password caching feature.  When using
        <literal>svn+ssh://</literal> URLs, however, users may be
        annoyed by <command>ssh</command> repeatedly asking for a
        password for every outbound connection.  The solution is to
        use a separate SSH password-caching tool such as
        <command>ssh-agent</command> on a Unix-like system, or
        <command>pageant</command> on Windows.</para>
      -->
      <para>当使用 <literal>svn+ssh://</literal> URL 访问仓库时, 要记住提出
        认证要求的程序是 <command>ssh</command>, 而 <emphasis>不是</emphasis>
        客户端程序 <command>svn</command>, 这就意味着不会出现密码缓存 (见
        <xref linkend="svn.serverconfig.netmodel.credcache"/>). Subversion
        客户端经常向仓库发起多个连接, 由于密码缓存, 用户通常不会注意到这点,
        然而, 当用户使用 <literal>svn+ssh://</literal> 连接仓库时, 客户端每发起
        一次连接, <command>ssh</command> 都会要求用户输入密码, 用户可能会对
        此感到恼怒. 解决问题的办法是使用一个单独的 SSH 密码缓存工具, 例如
        类 Unix 系统中的 <command>ssh-agent</command>, 或 Windows 系统中的
        <command>pageant</command>.</para>

      <!--
      <para>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <literal>file://</literal> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks (be sure to read <xref
        linkend="svn.serverconfig.multimethod"/> later in this
        chapter).  But even in the case of tunneling, you can still use the
        <filename>svnserve.conf</filename> file to block access, by
        simply setting <literal>auth-access = read</literal>
        or <literal>auth-access = none</literal>.<footnote><para>Note
        that using any sort of <command>svnserve</command>-enforced
        access control at all only makes sense if the users cannot 
        bypass it and access the repository directory directly using
        other tools (such as <command>cd</command> and
        <command>vi</command>); implementing
        such restrictions is described in
        <xref linkend="svn.serverconfig.svnserve.sshtricks.fixedcmd"
        />.</para></footnote></para>
      -->
      <para>在隧道模式下操作时, 授权主要由仓库数据文件的操作系统权限控制,
        这和 Harry 使用 <literal>file://</literal> 直接访问仓库的情形基本
        一致. 如果有多个系统用户会直接访问仓库, 管理员可能想把他们都放到
        一个用户组里, 同时还要注意文件模式创建屏蔽字 (记得阅读本章后面的
        <xref linkend="svn.serverconfig.multimethod"/>). 即使在隧道模式下,
        你也可以使用 <command>svnserve.conf</command> 屏蔽特定的访问方式,
        只需要设置 <literal>auth-access = read</literal> 或
        <literal>auth-access = none</literal>.<footnote><para>注意,
            <command>svnserve</command> 施加的访问限制只有在以下情况中才是
            有效的: 用户无法旁路掉 <command>svnserve</command> 限制的条件,
            并且没有使用其他工具 (例如 <command>cd</command> 和
            <command>vi</command>) 直接访问仓库. 关于如何实现这些访问限制,
            见 <xref
              linkend="svn.serverconfig.svnserve.sshtricks.fixedcmd"/>.
      </para></footnote></para>

      <!--
      <para>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your runtime <filename>config</filename>
        file (see <xref linkend="svn.advanced.confarea"/>).  For
        example, suppose you want to use RSH instead of
        SSH.<footnote><para>We don't actually recommend this, since
        RSH is notably less secure than SSH.</para></footnote>  In
        the <literal>[tunnels]</literal> section of your
        <filename>config</filename> file, simply define it like
        this:</para>
      -->
      <para>读者可能以为关于 SSH 隧道的内容就此结束, 然而并没有. Subversion
        允许用户在运行时配置文件 <filename>config</filename> (见 <xref
          linkend="svn.advanced.confarea"/>) 里创建定制化的隧道行为. 例如使用
        RSH, 而不是 SSH, <footnote><para>实际上我们不推荐使用 RSH, 因为它的安
            全性远不如 SSH.</para></footnote> 具体的配置方式是在
        <filename>config</filename> 的 <literal>[tunnels]</literal> 节添加如
        下内容:</para>

      <informalexample>
        <programlisting>
[tunnels]
rsh = rsh --
</programlisting>
      </informalexample>

      <!--
      <para>And now, you can use this new tunnel definition by using a
        URL scheme that matches the name of your new variable:
        <literal>svn+rsh://host/path</literal>.  When using the new
        URL scheme, the Subversion client will actually be running the
        command <userinput>rsh - - host svnserve -t</userinput> behind the
        scenes.  If you include a username in the URL (e.g.,
        <literal>svn+rsh://username@host/path</literal>), the client
        will also include that in its command (<userinput>rsh - -
        username@host svnserve -t</userinput>).</para>
      -->
    <para>现在, 为了使用新的隧道配置, 把访问仓库的 URL 模式更改为
      <literal>svn+rsh://</literal>, 例如
      <literal>svn+rsh://host/path</literal>, 此时 Subversion 客户端相当于
      在执行 <userinput>rsh -- host svnserve -t</userinput>. 如果用户在
      URL 中包含了用户名 (例如 <literal>svn+rsh://username@host/path</literal>,
      则客户端也会在待执行的命令中包含用户名 (<userinput>rsh --
        username@host svnserve -t</userinput>).</para>

      <warning>
      <!--
        <para>Notice that when defining an RSH-based tunnel, we've
          added the <literal>- -</literal> end-of-options argument to
          the tunnel command line.  This is to prevent a malformed
          hostname from being treated as another option to the tunnel
          command.  You should do the same for other tunnel programs
          (for example, SSH).</para>
      -->
        <para>注意, 在定义基于 RSH 的隧道时, 我们在隧道命令行添加了选项结束
          参数 <literal>--</literal>, 这是为了避免把一个错误的主机名当成隧道
          命令的另一个选项, 使用其他隧道程序时也要考虑这个问题 (例如 SSH).
        </para>
      </warning>

      <!--
      <para>But you can define new tunneling schemes to be much more
        clever than that:</para>
      -->
      <para>不过, 你也可以定义更加灵活的隧道方案:</para>

      <informalexample>
        <programlisting>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934 --
</programlisting>
      </informalexample>

      <!--
      <para>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <filename>/opt/alternate/ssh</filename>) with specific
        options.  In this case, accessing an
        <literal>svn+joessh://</literal> URL would invoke the
        particular SSH binary with <option>-p 29934</option> as
        arguments&mdash;useful if you want the tunnel program to
        connect to a nonstandard port.</para>
      -->
      <para>这个例子有两点需要说明, 首先它展示了 Subversion 客户端如何启动
        一个特定的隧道程序 (例子里是 <filename>/opt/alternate/ssh</filename>),
        并带有特定的选项. 此时, 访问 URL <literal>svn+joessh</literal> 将启动
        一个特定的 SSH 程序, 并带有参数 <option>-p 29934</option>&mdash;如果
        你希望隧道程序连接到一个非标准的端口, 那么这种方法就比较方便.</para>

      <!--
      <para>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <literal>SVN_SSH</literal> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options to SSH, you can use the
        mechanism demonstrated in this example.  Now if we were to set
        the <literal>JOESSH</literal> environment variable, its value
        would override the entire value of the tunnel
        variable&mdash;<command>$JOESSH</command> would be executed
        instead of <userinput>/opt/alternate/ssh -p
        29934</userinput>.</para>
      -->
    <para>第二, 例子展示了如何使用环境变量去覆盖隧道程序的名字. 通过设置
      环境变量 <literal>SVN_SSH</literal> 来覆盖默认的 SSH 隧道代理是一种
      方便的做法, 但是如果你希望不同的服务器使用不同的变量覆盖, 甚至在连接
      每个服务器时, 其端口和选项也不尽相同, 这时候就要用到本例所介绍的方法.
      如果用户设置了环境变量 <literal>JOESSH</literal>, 它的值将会覆盖掉
      变量 <literal>joessh</literal> 原来的值&mdash;Subversion 客户端将会
      执行 <command>$JOESSH</command>, 而不是 <userinput>/opt/alternate/ssh
        -p 29934</userinput>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">
      <!--
      <title>SSH Configuration Tricks</title>
      -->
      <title>SSH 配置技巧</title>

      <!--
      <para>It's possible to control not only the way in which the
        client invokes <command>ssh</command>, but also to control
        the behavior of <command>sshd</command> on your server
        machine.  In this section, we'll show how to control the
        exact <command>svnserve</command> command executed
        by <command>sshd</command>, as well as how to have multiple
        users share a single system account.</para>
      -->
      <para>除了可以控制客户端执行 <command>ssh</command> 的方式外, 还能
        控制服务器上的 <command>sshd</command> 的行为. 本节我们将介绍如何
        控制由 <command>sshd</command> 启动的 <command>svnserve</command>,
        以及多个用户如何共享一个系统账号.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">
      <!--
        <title>Initial setup</title>
      -->
        <title>初始化设置</title>

      <!--
        <para>To begin, locate the home directory of the account
          you'll be using to launch <command>svnserve</command>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <filename>authorized_keys</filename> file.</para>
      -->
        <para>首先, 先确定你将用来启动 <command>svnserve</command> 的账户
          的家目录. 确保账户已经安装了 SSH 公钥与私钥, 并且用户可通过公钥
          认证进行登录. 密码认证将无法工作, 因此下面将要介绍的 SSH 技巧
          全都是在围绕 SSH <filename>authorized_keys</filename> 文件.</para>

      <!--
        <para>If it doesn't already exist, create the
          <filename>authorized_keys</filename> file (on Unix,
          typically <filename>~/.ssh/authorized_keys</filename>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</para>
      -->
        <para>如果 <filename>authorized_keys</filename> 事先不存在, 直接创建
          即可 (在 Unix 系统中, 它的典型位置是 <filename>~/.ssh/authorized_keys
          </filename>). 文件的每一行都描述了一个允许连接的公钥, 行的典型样式为:
        </para>

        <informalexample>
          <programlisting>
  ssh-dsa AAAABtce9euch&hellip; user@example.com
</programlisting>
        </informalexample>

      <!--
        <para>The first field describes the type of key, the second
          field is the base64-encoded key itself, and the third field
          is a comment.  However, it's a lesser known fact that the
          entire line can be preceded by a <literal>command</literal>
          field:</para>
      -->
        <para>第一列描述密钥的类型, 第二列是 base64 编码的密钥, 第三列是注释.
          除了这三列, 其实还可以添加一个 <literal>command</literal>
          字段:</para>

        <informalexample>
          <programlisting>
  command="program" ssh-dsa AAAABtce9euch&hellip; user@example.com
</programlisting>
        </informalexample>

      <!--
        <para>When the <literal>command</literal> field is set, the
          SSH daemon will run the named program instead of the
          typical tunnel-mode <command>svnserve</command> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</para>
      -->
        <para>如果含有 <literal>command</literal> 字段, SSH 守护进程将会执行
          该字段所指定的程序, 而不是 Subversion 客户端所请求的以隧道模式
          启动的 <command>svnserve</command>. 这种行为允许我们实现多种服务器
          端技巧, 在下面的例子里, 我们把 <filename>authorized_keys</filename>
          的每一行简写为:</para>

        <informalexample>
          <programlisting>
  command="program" TYPE KEY COMMENT
</programlisting>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
      <!--
        <title>Controlling the invoked command</title>
      -->
        <title>控制被调用的命令</title>

      <!--
        <para>Because we can specify the executed server-side command,
          it's easy to name a specific <command>svnserve</command>
          binary to run and to pass it extra arguments:</para>
      -->
        <para>因为我们可以指定在服务器端被执行的命令, 所以很容易就能指定
          一个特殊的 <command>svnserve</command> 程序, 并给它传递额外的参数:
        </para>

        <informalexample>
          <programlisting>
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</programlisting>
        </informalexample>

      <!--
        <para>In this example, <filename>/path/to/svnserve</filename>
          might be a custom wrapper script
          around <command>svnserve</command> which sets the umask (see
          <xref linkend="svn.serverconfig.multimethod"/>).  It also
          shows how to anchor <command>svnserve</command> in a virtual
          root directory, just as one often does when
          running <command>svnserve</command> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <literal>svn+ssh://</literal>
          URL.</para>
      -->
        <para>在上面的例子里, <filename>/path/to/svnserve</filename> 可能是
          一个定制化的 <command>svnserve</command> 包装脚本, 脚本将会重新
          设置文件权限掩码 (见 <xref linkend="svn.serverconfig.multimethod"/>).
          例子还展示了如何修改 <command>svnserve</command> 的文件系统根目录,
          当以守护进程方式运行 <command>svnserve</command> 时, 修改进程的根
          目录是很常见的操作, 这么做可以是为了限制用户对系统目录空间的访问,
          也可以是为了在输入 <literal>svn+ssh://</literal> URL 的路径参数时,
          减少用户打字的工作量.</para>

      <!--
        <para>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private key pair for each
          person.  Then place each public key into
          the <filename>authorized_keys</filename> file, one per
          line, and use the <option>- -tunnel-user</option>
          option:</para>
      -->
        <para>多个用户共享同一个账户也是有可能的, 方法是为每一个用户生成一对
          公钥与私钥, 然后把每个公钥的内容都写入文件
          <filename>authorized_keys</filename> 内, 每行一个, 并使用选项
          <option>--tunnel-user</option>:</para>

        <informalexample>
          <programlisting>
  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</programlisting>
        </informalexample>

      <!--
        <para>This example allows both Harry and Sally to connect to
          the same account via public key authentication.  Each of
          them has a custom command that will be executed;
          the <option>- -tunnel-user</option> option
          tells <command>svnserve</command> to assume that the named
          argument is the authenticated user.  Without
          <option>- -tunnel-user</option>, it would appear as though
          all commits were coming from the one shared system
          account.</para>
      -->
        <para>上面的例子允许 Harry 和 Sally 使用相同的账户, 通过各自的公钥
          认证来连接服务器. 每一行都指定了一条待执行的命令, 选项
          <option>--tunnel-user</option> 告诉 <command>svnserve</command>
          它的参数是已认证的用户, 如果没有加上 <option>--tunnel-user</option>,
          那么 <command>svnserve</command> 会认为所有的提交都来自被共享的
          账户.</para>

      <!--
        <para>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <literal>command</literal> value
          in <filename>authorized_keys</filename>.  For example, the
          user may still get shell access through SSH or be able to
          perform X11 or general port forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <literal>command</literal>:</para>
      -->
        <para>最后一点需要提醒的是: 如果一个用户可通过共享账户的公钥访问
          服务器, 即使在 <filename>authorized_keys</filename> 里设置了
          <literal>command</literal>, 也可能仍然允许其他形式的 SSH 访问. 例如
          用户仍然能够通过 SSH 获取 shell 访问权限, 或者 X11 窗口, 或者一般
          性的端口转发. 为了使用户的权限尽可能得小, 在
          <literal>command</literal> 后面添加一些限制选项:</para>

        <informalexample>
          <programlisting>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,no-agent-forw
arding,no-X11-forwarding,no-pty TYPE1 KEY1 harry@example.com
</programlisting>
        </informalexample>

      <!--
        <para>Note that this all must be on one line&mdash;truly on
          one line&mdash;since SSH <filename>authorized_keys</filename>
          files do not even allow the conventional backslash character
          (<literal>\</literal>) for line continuation.  The only
          reason we've shown it with a line break is to fit it on
          the physical page of a book.</para>
      -->
        <para>注意上面的内容必须写在同一行内, 因为
          <filename>authorized_keys</filename> 不支持通过反斜杠来实现行的
          延续, 例子里的换行只是为了方便排版.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.ref">
      <!--
      <title>svnserve Configuration Reference</title>
      -->
      <title>svnserve 配置参考</title>

      <!--
      <para>In the previous sections, we've mentioned numerous
        configuration options that administrators can use in their
        <filename>svnserve.conf</filename> files to configure the
        behavior of Subversion as accessed via Subversion's
        <command>svnserve</command> server option.  In this section,
        we'll quickly summarize <emphasis>all</emphasis> the
        configuration options supported by this server.</para>
      -->
      <para>上一节提到了 <filename>svnserve.conf</filename> 支持的众多选项,
        利用这些选项, 当用户通过 <command>svnserve</command> 服务器访问
        Subversion 时, 管理员就能够实现对 Subversion 行为的控制. 本节将对
        <command>svnserve</command> 支持的 <emphasis>所有</emphasis> 选项
        进行一个总结.</para>

      <!--
      <para>The <filename>svnserve.conf</filename> configuration file
        uses a typical INI-style format, with name/value pairs of
        options grouped into named sections.  (This is conveniently
        the same format used by Subversion's runtime configuration
        area on the client side of the network.)  We'll describe
        herein each of those named sections and the options available
        for use within them.</para>
      -->
      <para>配置文件 <filename>svnserve.conf</filename> 的格式是典型的
        INI 风格, 选项是一对 名字/值, 通过带名字的节进行分组. (这种格式和
        Subversion 客户端的运行时配置所使用的格式相同.) 这里将会介绍配置
        文件里的每一节, 及其支持的各个选项.</para>

      <!--
      <para>By default, <command>svnserve</command> will consult
        per-repository configuration files located
        at <filename>conf/svnserve.conf</filename> within the physical
        directory structure of the repository.  To instead use a
        single configuration file whose values apply to all
        repositories served via an instance
        of <command>svnserve</command>, use
        the <option>- -config-file</option> option when starting your
        server.</para>
      -->
      <para>默认情况下, <command>svnserve</command> 会查阅每个仓库的
        <filename>conf/svnserve.conf</filename>, 为了让一个
        <command>svnserve</command> 的运行实例访问到的所有仓库都使用同一个
        配置文件, 就给它添加选项 <option>--config-file</option>.</para>

      <note>
      <!--
        <para>In the following sections, we will refer to
          the <command>svnserve</command> configuration file by its
          canonical name, <filename>svnserve.conf</filename>.  The
          filename of actual configuration file used by
          your <command>svnserve</command> instance might be something
          else, though.  We trust this won't be too confusing.</para>
      -->
        <para>在下面的几节里, 我们将使用正式名称
          <filename>svnserve.conf</filename> 指代 <command>svnserve</command>
          配置文件, 实际上配置文件还可以取其他名字, 但我们相信读者不会感到
          迷惑.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.ref.general">
      <!--
        <title>General configuration</title>
      -->
        <title>通用配置</title>

      <!--
        <para>The <literal>[general]</literal> section contains the
          most commonly used and broadly
          focused <command>svnserve</command> configuration
          options.</para>
      -->
        <para><literal>[general]</literal> 节包含了最常用到的
          <command>svnserve</command> 配置选项.</para>

        <variablelist>
    
          <varlistentry>
            <term><literal>anon-access</literal></term>
            <listitem>

      <!--
              <para>Controls the access level granted to
                unauthenticated (anonymous) users.  Valid values
                are <literal>write</literal>, <literal>read</literal>,
                and <literal>none</literal>, with <literal>read</literal>
                being the default value.</para>
      -->
              <para>控制未认证的 (匿名的) 用户的访问权限, 有效值包括
                <literal>write</literal>, <literal>read</literal>, 和
                <literal>none</literal>, 其中 <literal>read</literal> 是
                默认值.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>auth-access</literal></term>
            <listitem>

      <!--
              <para>Controls the access level granted to authenticaed
                users.  Valid values are <literal>write</literal>,
                <literal>read</literal>, and <literal>none</literal>,
                with <literal>write</literal> being the default
                value.</para>
      -->
              <para>控制已认证的用户的访问权限, 有效值包括
                <literal>write</literal>, <literal>read</literal> 和
                <literal>none</literal>, 其中 <literal>write</literal> 是
                默认值.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>authz-db</literal></term>
            <listitem>

      <!--
              <para>Specifies the location of the repository access
                file as described in
                <xref linkend="svn.serverconfig.pathbasedauthz.getting-started"
                />.  If a regular local path is used, then unless that
                path begins with a forward-slash character
                (<literal>/</literal>), it is interpreted as a path
                relative to the directory containing
                the <filename>svnserve.conf</filename> configuration
                file.  If no path is specified, path-based access
                control will be disabled.</para>
      -->
              <para>指定仓库访问权限配置文件的路径 (见 <xref
                  linkend="svn.serverconfig.pathbasedauthz.getting-started"/>).
                如果是一个普通的本地路径, 除非路径以正斜杠
                (<literal>/</literal>) 开始, 否则的话路径就看成是相对于包含
                了 <filename>svnserve.conf</filename> 的目录的相对路径. 如果没
                有指定路径, 将禁止基于路径的访问权限控制.</para>

      <!--
              <para>As a special consideration, you may also specify
                the location of an access file which is versioned
                inside a Subversion repository.  Use a local URL (one
                which begins with <literal>file://</literal>) to refer
                to an absolute Subversion-versioned access file.
                Alternatively, use a repository relative URL (one
                which begins with <literal>^/</literal>) to cause
                <command>svnserve</command> to consult for each
                repository the access file stored at the specified
                relative URL within that repository.</para>
      -->
              <para>作为一种特殊的情况, 可以把 Subversion 仓库内的文件指定为
                访问权限配置文件, 使用本地 URL (以 <literal>file://</literal>
                开始) 指定文件的位置. 另外, 还可以用相对的仓库 URL (以
                <literal>^/</literal> 开始), 使得 <command>svnserve</command>
                根据相对 URL 访问仓库内的访问权限配置文件.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>force-username-case</literal></term>
            <listitem>

      <!--
              <para>Specifies the case normalization applied to
                usernames before comparing them against the rules
                found in the access file (specified by
                the <literal>authz-db</literal> option).  Valid values
                are <literal>upper</literal> (to uppercase the
                usernames), <literal>lower</literal> (to lowercase the
                usernames), and <literal>none</literal> (to perform no
                normalization at all).  By
                default, <command>svnserve</command> will not perform
                any case normalization on usernames.</para>
      -->
              <para>在和访问权限配置文件 (由选项 <option>authz-db</option> 指定)
                里的规则比较之前, 指定用户名的大小写形式, 有效值包括
                <literal>upper</literal> (用户名的大小写形式),
                <option>lower</option> (用户名的小写形式) 和
                <option>none</option> (不改变用户名的大小写形式). 默认情况下,
                <command>svnserve</command> 不改变用户名的大小写形式.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>groups-db</literal></term>
            <listitem>

      <!--
              <para>Specifies the path of the groups file.  If a
                regular local path is used, then unless that path
                begins with a forward-slash character
                (<literal>/</literal>), it is interpreted as a path
                relative to the directory containing
                the <filename>svnserve.conf</filename> configuration
                file.</para>
      -->
              <para>指定组文件的路径. 如果是一个普通的本地路径, 除非路径以正
                斜杠 (<literal>/</literal>) 开始, 否则的话路径就看成是相对于
                包含了 <filename>svnserve.conf</filename> 的目录的相对路径.
              </para>

      <!--
              <para>You may also specify the location of a groups file
                which is versioned inside a Subversion repository.
                Use a local URL (one which begins
                with <literal>file://</literal>) to refer to an
                absolute Subversion-versioned file.  Alternatively,
                use a repository relative URL (one which begins
                with <literal>^/</literal>) to cause
                <command>svnserve</command> to consult for each
                repository the group file stored at the specified
                relative URL within that repository.</para>
      -->
              <para>还可以把 Subversion 仓库内的文件指定为组文件. 使用本地
                URL (以 <literal>file://</literal> 开始) 指定文件的位置.
                另外, 还可以用相对的仓库 URL (以
                <literal>^/</literal> 开始), 使得 <command>svnserve</command>
                根据相对 URL 访问仓库内的组文件.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>hooks-env</literal></term>
            <listitem>

      <!--
              <para>Specifies the path to the hook script environment
                configuration file.  This option overrides the
                per-repository default location for this file, and can
                be used to configure the hook script environment for
                multiple repositories in a single file if an absolute
                path is specified.  Unless you specify an absolute
                path, the file's location is interpreted as relative
                to the directory containing
                the <filename>svnserve.conf</filename> configuration
                file.</para>
      -->
              <para>指定钩子脚本环境配置文件的路径. 该选项覆盖了文件在每个
                仓库内的默认位置, 如果写成绝对路径, 就可以用同一个文件为多个
                仓库的钩子脚本环境进行配置. 除非写成绝对路径, 否则的话就看成
                是相对于包含了 <filename>svnserve.conf</filename> 的目录的
                相对路径.</para>

      <!--
              <para>See
                <xref linkend="svn.reposadmin.hooks.configuration" />
                for detailed information regarding the hook script
                environment configuration file.</para>
      -->
              <para>关于钩子环境配置文件的更多信息, 见
                <xref linkend="svn.reposadmin.hooks.configuration" />.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>password-db</literal></term>
            <listitem>

      <!--
              <para>Specifies the path of the password database file.
                Unless the path specified begins with a forward-slash
                character (<literal>/</literal>), it is interpreted as
                a path relative to the directory containing the
                <filename>svnserve.conf</filename> configuration file.
                Note that if the SASL feature is used, this option
                will be ignored.</para>
      -->
              <para>指定密码文件的路径. 除非路径以正 斜杠
                (<literal>/</literal>) 开始, 否则的话路径就看成是相对于
                包含了 <filename>svnserve.conf</filename> 的目录的相对路径.
                注意, 如果使用了 SASL 特性, 则该选项将被忽略.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>realm</literal></term>
            <listitem>

      <!--
              <para>Specifies the authentication realm of the
                repository.  This is primarily used by the client to
                associate cached authentication credentials with a
                specific repository or set of repositories.  As such,
                it is best that the specified realm be unique across
                your repositories unless those repositories share the
                same password database.  By default, the repository's
                UUID is used as its authentication realm.</para>
      -->
              <para>指定仓库的认证域. 该选项主要被客户端使用, 用来关联缓存的
                认证证书和特定的某个或某些仓库, 正因为如此, 除非多个仓库使用
                了相同的密码数据库, 否则的话, 最好把每个仓库的认证域都设置
                成独一无二的值. 仓库认证域的默认值是它的 UUID.</para>

            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.ref.sasl">
      <!--
        <title>Cyrus SASL configuration</title>
      -->
        <title>Cyrus SASL 配置</title>

      <!--
        <para>The <literal>[sasl]</literal> section contains
          configuration which is specific to the optional Cyrus Simple
          Authentication and Security Layer (SASL) integration feature
          of <command>svnserve</command>.  See
          <xref linkend="svn.serverconfig.svnserve.sasl"/> for a more
          thorough description of this feature and the benefits it
          provides.</para>
      -->
        <para><literal>[sasl]</literal> 节包含了专门针对
          <command>svnserve</command> 可选特性 SASL (Cyrus Simple
          Authentication and Security Layer) 的配置, 关于 SASL 更详细的信息
          以及它的益处, 见 <xref linkend="svn.serverconfig.svnserve.sasl"/>.
        </para>

        <variablelist>
    
          <varlistentry>
            <term><literal>max-encryption</literal></term>
            <listitem>

      <!--
              <para>Specifies&mdash;as an integer bit-width&mdash;the
                maximum desired strength of the security layer's
                encryption algorithm.  The special
                value <literal>0</literal> means "no encryption", and
                the special value <literal>1</literal> means
                "integrity checking only".  The default value for this
                option is <literal>256</literal> (256-bit
                encryption).</para>
      -->
              <para>指定安全层加密算法最大的期望长度&mdash;整数的二进制位数.
                <literal>0</literal> 表示 <quote>不加密</quote>,
                <literal>1</literal> 表示 <quote>只检查完整性</quote>,
                默认值是 <literal>256</literal> (256 位加密).</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>min-encryption</literal></term>
            <listitem>

      <!--
              <para>Specifies&mdash;as an integer bit-width&mdash;the
                minimum desired strength of the security layer's
                encryption algorithm.  The special
                value <literal>0</literal> means "no encryption", and
                the special value <literal>1</literal> means
                "integrity checking only".  The default value for this
                option is <literal>0</literal> (no encryption).</para>
      -->
              <para>指定安全层加密算法最小的期望长度&mdash;整数的二进制位数.
                特殊值 <literal>0</literal> 表示 <quote>不加密</quote>,
                <literal>1</literal> 表示 <quote>只检查完整性</quote>,
                默认值是 <literal>0</literal> (不加密).</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>use-sasl</literal></term>
            <listitem>

      <!--
              <para>Specifies (as a <literal>true</literal>
                or <literal>false</literal> value) whether to enable
                the Cyrus SASL feature.  Note that this feature is
                only available if <command>svnserve</command> was
                built with support for the feature.  This feature is
                disabled by default.</para>
      -->
              <para>指定是否开启 Cyrus SASL 特性 (<literal>true</literal> 或
                <literal>false</literal>). 注意, 只有在编译
                <command>svnserve</command> 时添加了对 SASL 的支持, 才能开启
                该特性. 默认值是 <literal>false</literal>.</para>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>
    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">

      <!--
    <title>httpd, the Apache HTTP Server</title>
      -->
    <title>httpd, Apache HTTP 服务器</title>

      <!--
    <para>The Apache HTTP Server is a <quote>heavy-duty</quote>
      network server that Subversion can leverage.  Via a custom
      module, <command>httpd</command> makes Subversion repositories
      available to clients via the WebDAV/DeltaV<footnote><para>See
      <ulink url="http://www.webdav.org/"/>.</para></footnote>
      protocol, which is an extension to HTTP 1.1.  This protocol
      takes the ubiquitous HTTP protocol that is the core of the World
      Wide Web, and adds writing&mdash;specifically, versioned
      writing&mdash;capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, supported by numerous operating systems and
      third-party products, and doesn't require network administrators
      to open up yet another custom port.<footnote><para>They really
      hate doing that.</para></footnote> While an Apache-Subversion
      server has more features than <command>svnserve</command>, it's
      also a bit more difficult to set up.  With flexibility often
      comes more complexity.</para>
      -->
    <para>Apache HTTP 服务器是 Subversion 可使用的 <quote>重型</quote> 网络
      服务器. 借助一个定制的模块, <command>httpd</command> 允许客户端通过
      WebDAV/Delta 协议 <footnote><para>见 <ulink
            url="http://www.webdav.org/"/>.</para></footnote> 访问 Subversion
      仓库, WebDAV/Delta 协议是 HTTP 1.1 的扩展. WebDAV/Delta 在万维网核心
      协议 HTTP 的基础上, 增加了写功能&mdash;确切地说, 是版本化的写. 这样做的
      结果是得到了一个标准化的, 健壮的软件系统, 可以方便地作为 Apache 2.0
      软件的一部分进行打包, 受到多种操作系统和第三方软件的支持, 也不要求网络
      管理员开通额外的端口.<footnote><para>他们真得很讨厌这样做.</para>
      </footnote> 因为 Apache-Subversion 服务器比 <command>svnserve</command>
      拥有更多的特性, 因此设置起来会更加困难&mdash;灵活性往往伴随着复杂性.
    </para>

      <!--
    <para>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their web site at
      <ulink url="http://httpd.apache.org"/>.  For example, a general
      reference for the configuration directives is located at
      <ulink url="http://httpd.apache.org/docs/current/mod/directives.html"
      />.</para>
      -->
  <para>下面将要介绍的很多内容都包含了关于 Apache 配置指令的引用, 虽然某些
    例子用到了 Apache 的配置指令, 但完整地介绍它们已经超出了本章的范畴.
    Apache 团队维护了非常优秀的文档供用户参考, 可以到它的官网 <ulink
      url="http://httpd.apache.org"/> 获取, 例如, 关于 Apache 配置指令的
    文档在 <ulink
      url="http://httpd.apache.org/docs/current/mod/directives.html"/>.</para>

      <!--
    <para>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <filename>httpd.conf</filename>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <literal>CustomLog</literal> and <literal>ErrorLog</literal>
      directives, respectively).
      Subversion's <command>mod_dav_svn</command> uses Apache's error
      logging interface as well.  You can always browse the contents
      of those files for information that might reveal the source of a
      problem that is not clearly noticeable otherwise.</para>
      -->
    <para>另外, 在管理员修改 Apache 设置的过程中, 有可能会有错误发生, 如果你
      还不太熟悉 Apache 的日志子系统, 现在应该着手熟悉它. 文件
      <filename>httpd.conf</filename> 可以指定 Apache 所生成的访问与错误
      日志的存放位置 (配置指令分别是 <literal>CustomLog</literal> 和
      <literal>ErrorLog</literal>). Subversion 的
      <command>mod_dav_svn</command> 也用到了 Apache 的错误日志接口. 管理员
      可以通过查看这些日志文件定位问题发生的原因.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">
      <!--
      <title>Prerequisites</title>
      -->
      <title>先决条件</title>

      <!--
      <para>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <command>httpd</command> 2.0 or newer, the
        <command>mod_dav</command> DAV module that comes with it,
        Subversion, and the <command>mod_dav_svn</command>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</para>
      -->
      <para>为了能让用户使用 HTTP 协议访问仓库, 你需要 4 项组件, 包含在 2 个
        软件包里. 你需要 Apache <command>httpd</command> 2.0 或更新的版本,
        (它包含了 <command>mod_dav</command> DAV 模块), Subversion, 以
        及随 Subversion 软件包一起发布的 <command>mod_dav_svn</command>
        模块. 这些组件一旦准备完毕, 为仓库添加 HTTP 网络访问能力的步骤就简单
        了:</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>Getting httpd up and running with
            the <command>mod_dav</command> module</para>
      -->
          <para>为 httpd 加载 <command>mod_dav</command>, 并启动 httpd</para>
        </listitem>
        <listitem>
      <!--
          <para>Installing the <command>mod_dav_svn</command> backend
            to <command>mod_dav</command>, which uses Subversion's
            libraries to access the repository</para>
      -->
          <para>安装 <command>mod_dav_svn</command>, 它将使用 Subversion 的
            库函数来访问仓库</para>
        </listitem>
        <listitem>
      <!--
          <para>Configuring your <filename>httpd.conf</filename>
            file to export (or expose) the repository</para>
      -->
          <para>修改 <filename>httpd.conf</filename>, 以便导出 Subversion
            仓库</para>
        </listitem>
      </itemizedlist>

      <!--
      <para>You can accomplish the first two items either by
        compiling <command>httpd</command> and Subversion from
        source code or by installing prebuilt binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <filename>INSTALL</filename> file in
        the top level of the Subversion source code tree.</para>
      -->
      <para>前面两步你可以从源代码编译安装 <command>httpd</command> 和
        Subversion, 或者安装它们的二进制包来完成. 关于如何编译 Subversion,
        以便支持 Apache HTTP Server, 以及如何配置 Apache, 见 Subversion
        源代码顶层目录下的 <filename>INSTALL</filename> 文件.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">
      <!--
      <title>Basic Apache Configuration</title>
      -->
      <title>Apache 基本配置</title>

      <!--
      <para>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <filename>httpd.conf</filename> file.  Instruct Apache
        to load the <command>mod_dav_svn</command> module using the
        <literal>LoadModule</literal> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <command>mod_dav_svn</command> module should have been
        installed in the <filename>modules</filename> subdirectory of
        the Apache install location (often
        <filename>/usr/local/apache2</filename>).  The
        <literal>LoadModule</literal> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</para>
      -->
      <para>所有组件安装完毕后, 剩下的工作就是通过
        <filename>httpd.conf</filename> 配置 Apache. 为了让 Apache 加载
        <command>mod_dav_svn</command>, 要用到配置指令
        <literal>LoadModule</literal>, 这条配置指令必须出现在任何与 Subversion
        有关的配置项之前. 如果你是按照默认方式安装 Apache, 则
        <command>mod_dav_svn</command> 是被安装在 Apache 安装位置 (通常是
        <filename>/usr/local/apache2</filename>) 的
        <filename>modules</filename> 子目录内. 配置指令
        <literal>LoadModule</literal> 的语法非常简单, 包含模块名及其共享库
        文件的路径:</para>

      <informalexample>
        <programlisting>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</programlisting>
      </informalexample>

      <!--
      <para>Apache interprets the <literal>LoadModule</literal>
        configuration item's library path as relative to its own
        server root.  If configured as previously shown, Apache will
        look for the Subversion DAV module shared library in its
        own <filename>modules/</filename> subdirectory.  Depending on
        how Subversion was installed on your system, you might need to
        specify a different path for this library altogether, perhaps
        even an absolute path such as in the following example:</para>
      -->
      <para>Apache 将 <literal>LoadModule</literal> 共享库文件的路径解释成
        相对于服务器进程根目录的路径. 对于上面的例子而言, Apache 将会在它的
        <filename>moduels/</filename> 子目录内搜索 Subversion DAV 模块的
        共享库文件. 取决于 Subversion 在系统中的安装方式, 你可能需要指定
        不同的路径, 甚至像下面这样的绝对路径:</para>

      <informalexample>
        <programlisting>
LoadModule dav_svn_module     C:/Subversion/lib/mod_dav_svn.so
</programlisting>
      </informalexample>

      <!--
      <para>Note that if <command>mod_dav</command> was compiled as a
        shared object (instead of statically linked directly to the
        <command>httpd</command> binary), you'll need a similar
        <literal>LoadModule</literal> statement for it, too.  Be sure
        that it comes before the <command>mod_dav_svn</command> line:</para>
      -->
      <para>如果 <command>mod_dav</command> 被编译成一个共享库文件 (而不是
        被直接编译进 <command>httpd</command> 二进制文件里), 那么它也需要
        一个类似的 <literal>LoadModule</literal> 指令, 注意, 它要出现在
        <command>mod_dav_svn</command> 加载指令的前面:</para>

      <informalexample>
        <programlisting>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</programlisting>
      </informalexample>

      <!--
      <para>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <literal>Location</literal> directive
        has an XML-like notation, starting with an opening tag and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <literal>Location</literal> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <filename>/repos/</filename> to a DAV provider whose
        repository is located at
        <filename>/var/svn/repository</filename> using the
        following <filename>httpd.conf</filename> syntax:</para>
      -->
      <para>在配置文件的后面, 你需要把 Subversion 仓库的位置告诉给 Apache.
        指令 <literal>Location</literal> 具有与 XML 类似的格式, 它以开标签
        开始, 以闭标签结束, 在开标签和闭标签之间可以包含多个配置指令.
        <literal>Location</literal> 的目的是在处理指定的 URL 及其子路径上
        的请求时, 做一些特殊的操作. 对于 Subversion 而言, 就是希望 Apache
        将指向 Subversion 仓库的请求交由 DAV 层进行处理. 下面的例子告诉
        Apache, 如果 URL 的路径部分 (URL 中, 跟在服务器名和端口号后面的部分)
        以 <filename>/repos/</filename> 开始, 就把请求交由 DAV 处理:</para>

      <informalexample>
        <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
&lt;/Location&gt;
</programlisting>
      </informalexample>

      <!--
      <para>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative
        directive&mdash;<literal>SVNParentPath</literal>&mdash;to
        indicate that common parent directory.  For example, if you
        know you will be creating multiple Subversion repositories in
        a directory <filename>/var/svn</filename> that would be
        accessed via URLs such as
        <uri>http://my.server.com/svn/repos1</uri>,
        <uri>http://my.server.com/svn/repos2</uri>, and so on, you
        could use the <filename>httpd.conf</filename> configuration
        syntax in the following example:</para>
      -->
      <para>如果你计划支持多个位于同一父目录下的 Subversion 仓库, 可以
        使用指令 <literal>SVNParentPath</literal> 指明公共的父目录. 例如,
        如果你将会在 <filename>/var/svn</filename> 目录下创建多个 Subversion
        仓库, 访问这些仓库的 URL 是 <uri>http://my.server.com/svn/repos1</uri>,
        <uri>http://my.server.com/svn/repos2</uri> 等, 那你就可以在
        <filename>httpd.conf</filename> 里这样写:</para>

      <informalexample>
        <programlisting>
&lt;Location /svn&gt;
  DAV svn

  # Automatically map any "/svn/foo" URL to repository /var/svn/foo
  SVNParentPath /var/svn
&lt;/Location&gt;
</programlisting>
      </informalexample>

      <!--
      <para>Using this syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <filename>/svn/</filename> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <literal>SVNParentPath</literal> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <literal>SVNPath</literal> directive, you don't have to
        restart Apache to add or remove hosted repositories.</para>
      -->
      <para>利用这种语法, Apache 将会把路径部分以 <filename>/svn/</filename>
        开始的 URL 的处理代理给 Subversion DAV, 它将假设由
        <literal>SVNParentPath</literal> 所指定的目录内的所有子目录都是
        Subversion 仓库. 相对于 <literal>SVNPath</literal>,
        使用 <literal>SVNParentPath</literal> 更加方便, 因为在添加或删除仓库
        时不用重启 Apache.</para>

      <!--
      <para>Be sure that when you define your new
        <literal>Location</literal>, it doesn't overlap with other
        exported locations.  For example, if your main
        <literal>DocumentRoot</literal> is exported to
        <filename>/www</filename>, do not export a Subversion
        repository in <literal>&lt;Location /www/repos&gt;</literal>.
        If a request comes in for the URI
        <filename>/www/repos/foo.c</filename>, Apache won't know
        whether to look for a file <filename>repos/foo.c</filename> in
        the <literal>DocumentRoot</literal>, or whether to delegate
        <command>mod_dav_svn</command> to return
        <filename>foo.c</filename> from the Subversion repository.
        The result is often an error from the server of the form
        <literal>301 Moved Permanently</literal>.</para>
      -->
      <para>需要注意的是在定义新的 <literal>Location</literal> 时, 不要和
        其他已有的 <literal>Location</literal> 重叠. 比如说
        <literal>DocumentRoot</literal> 被导出到 <filename>/www</filename>,
        那就不要再导出 <literal>&lt;Location /www/repos&gt;</literal> 内的
        Subversion 仓库, 因为如果 Apache 接到一个访问
        <filename>/www/repos/foo.c</filename> 的请求, 它就没办法确认这是
        <literal>DocumentRoot</literal> 内的
        <filename>repos/foo.c</filename>, 还是代理给
        <command>mod_dav_svn</command>, 并由它返回 Subversion 仓库内的
        <filename>foo.c</filename>, 这种错误通常的结果是返回一个
        <literal>301 Moved Permanently</literal> 响应.</para>

      <sidebar>
      <!--
        <title>Server Names and the COPY Request</title>
      -->
        <title>服务器名和 COPY 请求</title>

      <!--
        <para>Subversion makes use of the <literal>COPY</literal>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to
          tell <command>mod_dav</command> the name you use as the
          hostname of your server.  Generally, you can use
          the <literal>ServerName</literal> directive in
          <filename>httpd.conf</filename> to accomplish this.</para>
      -->
        <para>Subversion 使用请求类型 <literal>COPY</literal> 来完成服务器
          端的文件和目录的复制. 作为 Apache 模块完整性检查的一部分, 复制的
          源和目标必须在同一台主机上, 为了满足这个要求, 你需要把服务器的主
          机名告诉给 <command>mod_dav</command>. 在
          <filename>httpd.conf</filename> 里, 可以用指令
          <literal>ServerName</literal> 完成:</para>

        <informalexample>
          <programlisting>
ServerName svn.example.com
</programlisting>
        </informalexample>

      <!--
        <para>If you are using Apache's virtual hosting support via
          the <literal>NameVirtualHost</literal> directive, you may
          need to use the <literal>ServerAlias</literal> directive to
          specify additional names by which your server is known.
          Again, refer to the Apache documentation for full
          details.</para>
      -->
        <para>如果你通过指令 <literal>NameVirtualHost</literal> 使用了
          Apache 的虚拟托管支持, 那你可能需要使用指令
          <literal>ServerAlias</literal> 指定服务器已经知晓的其他名字. 再次
          强调, 详细的信息请参阅 Apache 文档.</para>
      </sidebar>

      <!--
      <para>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content&mdash;web pages, scripts, and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</para>
      -->
      <para>现在, 你必须认真考虑与权限有关的问题. 如果 Apache 已经作为你的
        网页服务器运行了一段时间, 服务器上可能积累了一定量的内容&mdash;网页,
        脚本等, 这些文件的权限配置允许 Apache 对它们进行访问. 当 Apache 作为
        Subversion 服务器时, 也要求 Subversion 仓库的读写权限配置正确.</para>

      <!--
      <para>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <literal>User</literal> and <literal>Group</literal>
        directives in <filename>httpd.conf</filename> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</para>
      -->
      <para>你需要确定一种权限设置, 以便满足 Subversion 的需求, 而不影响已
        有的网页或脚本. 这可能意味着修改 Subversion 仓库的权限, 以便与 Apache
        提供的其他服务一致, 或者是使用 <filename>httpd.conf</filename> 的
        <literal>User</literal> 与 <literal>Group</literal> 指令, 去指定
        Apache 运行时的用户名与用户组, 这些用户名与用户组正是 Subversion
        仓库的所有者. 正确设置权限的方法不是唯一的, 每一个管理员都可以选择一
        种适合自己的方式, 只是需要注意的是, Subversion 搭配 Apache 的最常见
        问题就是与权限有关的问题.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">
      <!--
      <title>Authentication Options</title>
      -->
      <title>认证选项</title>

      <!--
      <para>At this point, if you configured
        <filename>httpd.conf</filename> to contain something such as the
        following:</para>
      -->
      <para>到这里为止, 如果你的 <filename>httpd.conf</filename> 包含了类似
        下面的内容:</para>

      <informalexample>
        <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
&lt;/Location&gt;
</programlisting>
      </informalexample>

      <!--
      <para>your repository is <quote>anonymously</quote>
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories that you make available via the
        <literal>Location</literal> directive will be generally
        accessible to everyone.  In other words:</para>
      -->
      <para>那么你的仓库对于外界而言是 <quote>匿名</quote> 访问的. 除非你为
        Subversion 仓库配置了认证与授权策略, 否则的话, 那些通过指令
        <literal>Location</literal> 指定的仓库将对所有人开放. 换句话说就是:
      </para>

      <itemizedlist>
        <listitem>
      <!--
          <para>Anyone can use a Subversion client to check out a
            working copy of a repository URL (or any of its
            subdirectories).</para>
      -->
          <para>任何人都可以用 Subversion 客户端, 根据仓库 (或者它的子目录)
            的 URL 检出工作副本.</para>
        </listitem>
        <listitem>
      <!--
          <para>Anyone can interactively browse the repository's
            latest revision simply by pointing a web browser to
            the repository URL.</para>
      -->
          <para>任何人都可以用网页浏览器浏览仓库的最新内容.</para>
        </listitem>
        <listitem>
      <!--
          <para>Anyone can commit to the repository.</para>
      -->
          <para>任何人都可以向仓库提交修改.</para>
        </listitem>
      </itemizedlist>

      <!--
      <para>Of course, you might have already set up
        a pre-commit hook script to prevent
        commits (see <xref linkend="svn.reposadmin.hooks" />).
        But as you read on, you'll see that it's also possible to use
        Apache's built-in methods to restrict access in specific
        ways.</para>
      -->
      <para>当然, 你可能已经设置好了一个 pre-commit 钩子, 以便阻止那些不符合
        要求的提交 (见 <xref linkend="svn.reposadmin.hooks" />). 但是如果你接
        着读下去, 就会发现其实我们还可以使用 Apache 的内建机制, 以一种特定
        的方式来限制访问.</para>

      <tip>
      <!--
        <para>Requiring authentication defends against invalid users
          directly accessing the repository, but does not guard the
          privacy of valid users' network activity.  See
          <xref linkend="svn.serverconfig.httpd.ssl"/> for how to
          configure your server to support SSL encryption, which can
          provide that extra layer of protection.</para>
      -->
        <para>认证可以阻止无效的用户直接访问仓库, 但是它无法保护有效用户
          的网络流量的隐私. 为服务器配置 SSL 加密, 可以为用户添加额外的一层
          保护, 关于如何配置 SSL 加密, 见 <xref
            linkend="svn.serverconfig.httpd.ssl"/>.
        </para>
      </tip>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.basic">
      <!--
        <title>Basic authentication</title>
      -->
        <title>Basic 认证</title>

      <!--
        <para>The easiest way to authenticate a client is via the HTTP
          Basic authentication mechanism, which simply uses a username
          and password to verify a user's identity.  Apache provides
          the <command>htpasswd</command> utility<footnote><para>See
          <ulink url="http://httpd.apache.org/docs/current/programs/htpasswd.html"
          />.</para></footnote> for managing files containing
          usernames and passwords.</para>
      -->
        <para>对客户端进行认证的最简单的方式是使用 HTTP Basic 认证机制, 它
          仅仅是使用用户名与密码验证用户的身份. Apache 提供了命令行工具
          <command>htpasswd</command><footnote><para>见
              <ulink url="http://httpd.apache.org/docs/current/programs/htpasswd.html"
                />.</para></footnote> 来管理包含用户名与密码的文件.</para>

        <warning>
      <!--
          <para>Basic authentication is <emphasis>extremely</emphasis>
            insecure, because it sends passwords over the network
            in very nearly plain text.  See
            <xref linkend="svn.serverconfig.httpd.authn.digest"/> for
            details on using the much safer Digest mechanism.</para>
      -->
          <para>Basic 认证 <emphasis>非常</emphasis> 不安全, 因为它以几乎明
            文的方式在网络上传输密码, 建议使用更加安全的 Digest 认证机制,
            具体的细节见 <xref linkend="svn.serverconfig.httpd.authn.digest"/>.
          </para>
        </warning>

      <!--
        <para>First, create a password file and grant access to
          users Harry and Sally:</para>
      -->
        <para>首先创建一个密码文件, 并为用户 Harry 和 Sally 授予访问权限.
        </para>

        <informalexample>
          <screen>
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -c -m /etc/svn-auth.htpasswd harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth.htpasswd sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>
        </informalexample>
        
      <!--
        <para>Next, ensure that Apache has access to the modules which
          provide the Basic authentication and related
          functionality:  <command>mod_auth_basic</command>,
          <command>mod_authn_file</command>, and
          <command>mod_authz_user</command>.  In many cases, these
          modules are compiled into <command>httpd</command> itself,
          but if not, you might need to explicitly load one or more of
          them using the <literal>LoadModule</literal> directive:</para>
      -->
        <para>然后, 确保 Apache 可以访问到提供 Basic 认证和相关功能的模块:
          <command>mod_auth_basic</command>, <command>mod_authn_file</command>
          和 <command>mod_authz_user</command>. 在大部分情况下, 这些模块本来
          就已经被编译进 <filename>httpd</filename>, 如果没有, 你可能需要显
          式地使用配置指令 <literal>LoadModule</literal> 加载它们:</para>

        <informalexample>
          <programlisting>
LoadModule auth_basic_module   modules/mod_auth_basic.so
LoadModule authn_file_module   modules/mod_authn_file.so
LoadModule authz_user_module   moduels/mod_authz_user.so
</programlisting>
        </informalexample>

      <!--
        <para>After ensuring the Apache has access to the required
          functionality, you'll need to add some more directives
          inside the <literal>&lt;Location&gt;</literal> block to tell
          Apache what type of authentication you wish to use, and just
          how to do so:</para>
      -->
        <para>确定 Apache 具备必需的功能后, 接下来你就可以在
          <literal>&lt;Location&gt;</literal> 块内添加必要的配置指令, 告诉
          Apache 你想用哪一种认证类型, 例如:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Basic
  AuthName "Subversion repository"
  AuthType Basic
  AuthBasicProvider file
  AuthUserFile /etc/svn-auth.htpasswd
&lt;/Location&gt;
</programlisting>
        </informalexample>

      <!--
        <para>These directives work as follows:</para>
      -->
        <para>这些配置指令的意义是:</para>

        <itemizedlist>
          <listitem>
      <!--
            <para><literal>AuthName</literal> is an arbitrary name
              that you choose for the authentication domain.  Most
              browsers display this name in the dialog box when
              prompting for username and password.</para>
      -->
            <para><literal>AuthName</literal> 是你为认证域所选定的一个任意的
              名字, 大多数浏览器会在提示用户输入用户名与密码的对话框上显示
              这个名字.</para>
          </listitem>
          <listitem>
      <!--
            <para><literal>AuthType</literal> specifies the type of
              authentication to use.</para>
      -->
            <para><literal>AuthType</literal> 指定认证的类型.</para>
          </listitem>
          <listitem>
      <!--
            <para><literal>AuthBasicProvider</literal> specifies the
              Basic authentication provider to use for the location.
              In our example, we wish to consult a local password
              file.</para>
      -->
            <para><literal>AuthBasicProvider</literal> 指定由谁来提供 Basic
              认证, 我们的例子里写得是一个本地密码文件.</para>
          </listitem>
          <listitem>
      <!--
            <para><literal>AuthUserFile</literal> specifies the
              location of the password file to use.</para>
      -->
            <para><literal>AuthUserFile</literal> 指定密码文件的路径.</para>
          </listitem>
        </itemizedlist>

      <!--
        <para>However, this <literal>&lt;Location&gt;</literal> block
          doesn't yet do anything useful.  It merely tells Apache that
          <emphasis>if</emphasis> authorization were required, it
          should challenge the Subversion client for a username and
          password.  (When authorization is required, Apache requires
          authentication as well.)  What's missing here, however, are
          directives that tell Apache <emphasis>which sorts</emphasis>
          of client requests require authorization; currently, none do.
          The simplest thing is to specify that <emphasis>all</emphasis>
          requests require authorization by adding
          <literal>Require valid-user</literal> to the block:</para>
      -->
        <para>然而, 这个 <literal>&lt;Location&gt;</literal> 并没有做任何有
          用的工作, 它仅仅是告诉 Apache <emphasis>如果</emphasis> 授权是必须的,
          它应该要求 Subversion 客户端提供用户名与密码. (如果有需要, Apache
          自己也会要求认证.) 然而这里还有不完善的地方, 那就是告诉 Apache
          哪些客户请求才需要授权, 当前的配置是所有的请求都不需要认证, 此时最
          简单的配置就是通过添加 <literal>Require valid-user</literal> 要求
          <emphasis>所有的</emphasis> 客户端请求都需要认证:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Basic
  AuthName "Subversion repository"
  AuthType Basic
  AuthBasicProvider file
  AuthUserFile /etc/svn-auth.htpasswd

  # Authorization: Authenticated users only
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </informalexample>

      <!--
        <para>Refer to <xref linkend="svn.serverconfig.httpd.authz"/>
          for more detail on the <literal>Require</literal> directive
          and other ways to set authorization policies.</para>
      -->
        <para>关于配置指令 <literal>Require</literal> 的更多细节, 以及设置
          授权策略的其他方式, 请参考 <xref
            linkend="svn.serverconfig.httpd.authz"/>.</para>

        <note>
      <!--
          <para>The default value of the
            <literal>AuthBasicProvider</literal> option is
            <literal>file</literal>, so we won't bother including
            it in future examples.  Just know that if in a broader
            context you've set this value to something else, you'll
            need to explicitly reset it to <literal>file</literal>
            within your Subversion <literal>&lt;Location&gt;</literal>
            block in order to get that behavior.</para>
      -->
          <para><literal>AuthBasicProvider</literal> 的默认值是
            <literal>file</literal>, 所以我们不会在后面的例子里显式地写出
            来. 但有一点需要注意, 如果在更广的上下文内你已经把
            <literal>AuthBasicProvider</literal> 设置成了其他值, 那就需要在
            Subversion 的 <literal>&lt;Location&gt;</literal> 内再显式地把
            <literal>AuthBasicProvider</literal> 设置成
            <literal>file</literal>.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.digest">
      <!--
        <title>Digest authentication</title>
      -->
        <title>Digest 认证</title>

      <!--
        <para>Digest authentication is an improvement on Basic
          authentication which allows the server to verify a client's
          identity without sending the password over the network
          unprotected.  Both client and server create a non-reversible
          MD5 hash of the username, password, requested URI, and a
          <firstterm>nonce</firstterm> (number used once) provided by
          the server and changed each time authentication is required.
          The client sends its hash to the server, and the server then
          verifies that the hashes match.</para>
      -->
        <para>Digest 认证比 Basic 认证更加完善, 它允许服务器验证客户客户端
          的身份, 而不会在网络上以明文的形式传输密码. 服务器和客户端会使用
          不可逆的 MD5 算法计算敏感信息的散列值, 敏感信息包括用户名, 密码,
          所请求的 URI, 由服务器生成的 <firstterm>nonce</firstterm>
          (一次性数字, 每次认证时都会变化). 客户端把散列值发给服务器, 服务器
          验证散列值是否正确.</para>

      <!--
        <para>Configuring Apache to use Digest authentication is
          straightforward.  You'll need to ensure that
          the <command>mod_auth_digest</command> module is available
          (instead of <command>mod_auth_basic</command>), and then
          make a few small variations on our prior example:</para>
      -->
        <para>为 Apache 配置 Digest 认证非常简单, 首先你要确保模块
          <command>mod_auth_digest</command> (而不是
          <command>mod_auth_basic</command>) 是可用的, 然后再在上面例子的基础
          上做一些小改动:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthDigestProvider file
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Authenticated users only
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </informalexample>

      <!--
        <para>Notice that <literal>AuthType</literal> is now set to
          <literal>Digest</literal>, and we specify a different path
          for <literal>AuthUserFile</literal>.  Digest authentication
          uses a different file format than Basic authentication, 
          created and managed using Apache's <command>htdigest</command>
          utility<footnote><para>See
          <ulink url="http://httpd.apache.org/docs/current/programs/htdigest.html"
          />.</para></footnote> rather than <command>htpasswd</command>.
          Digest authentication also has the additional concept of a
          <quote>realm</quote>, which must match the value of the
          <literal>AuthName</literal> directive.</para>
      -->
        <para>注意到 <literal>AuthType</literal> 现在被设置成了
          <literal>Digest</literal>, 而且为 <literal>AuthUserFile</literal>
          指定了一个不同的路径. Digest 认证所使用的文件格式与 Basic 认证的
          不同, 这种格式的文件使用 Apache 的命令行工具
          <command>htdigest</command> <footnote><para>见
          <ulink url="http://httpd.apache.org/docs/current/programs/htdigest.html"
            />.</para></footnote> 创建与管理, 而不是
          <command>htpasswd</command>. Digest 认证也有 <quote>认证域</quote>
          的概念, 它由配置指令 <literal>AuthName</literal> 指定.</para>

        <note>
      <!--
          <para>For Digest authentication, the authentication provider
            is selected using the <literal>AuthDigestProvider</literal>
            as shown in the previous example.  As was the case with
            the <literal>AuthBasicProvider</literal> directive,
            <literal>file</literal> is the default value of the
            <literal>AuthDigestProvider</literal> option, so this
            line is not strictly required unless you need to override
            a different value thereof inherited from a broader
            configuration context.</para>
      -->
          <para>Digest 认证指定认证信息来源的配置指令是
            <literal>AuthDigestProvider</literal>,
            <literal>AuthDigestProvider</literal> 的默认值是
            <literal>file</literal>, 所以例子里的
            <userinput>AuthDigestProvider file</userinput> 并不是必需的,
            除非你要覆盖从更广的配置上下文继承而来的, 与 <literal>file</literal>
            不同的值.</para>
        </note>

      <!--
        <para>The password file can be created as follows:</para>
      -->
        <para>可以像下面这样创建密码文件:</para>

        <informalexample>
          <screen>
$ ### First time: use -c to create the file
$ htdigest -c /etc/svn-auth.htdigest "Subversion repository" harry
Adding password for harry in realm Subversion repository.
New password: *****
Re-type new password: *****
$ htdigest /etc/svn-auth.htdigest "Subversion repository" sally
Adding user sally in realm Subversion repository
New password: *******
Re-type new password: *******
$
</screen>
        </informalexample>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">
      <!--
      <title>Authorization Options</title>
      -->
      <title>授权选项</title>

      <!--
      <para>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</para>
      -->
      <para>到这里为止, 你已经知道了如何配置认证, 但还没有提到授权. Apache 可
        以要求客户端认证他们的身份, 但 Apache 还不知道如何允许或限制客户端
        的访问权限, 本节将介绍两种控制客户端对仓库的访问权限的策略.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.blanket">
      <!--
        <title>Blanket access control</title>
      -->
        <title>完全访问控制</title>

      <!--
        <para>The simplest form of access control is to authorize
          certain users for either read-only access to a repository or
          read/write access to a repository.</para>
      -->
        <para>访问控制最简单的形式是只授权特定的用户可以对仓库进行读取或读写.
        </para>

      <!--
        <para>You can restrict access on all repository operations by
          adding <literal>Require valid-user</literal> directly inside
          the <literal>&lt;Location&gt;</literal> block.  The example
          from <xref linkend="svn.serverconfig.httpd.authn.digest"/>
          allows only clients that successfully authenticate to do
          anything with the Subversion repository:</para>
      -->
        <para>你可以通过在 <literal>&lt;Location&gt;</literal> 添加
          <literal>Require valid-user</literal>, 从而允许用户对仓库执行所有
          可能的操作. 下面的例子只允许成功认证的客户端对 Subversion
          仓库执行任意的操作:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Authenticated users only
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </informalexample>

      <!--
        <para>Sometimes you don't need to run such a tight ship.  For
          example, the server hosting Subversion's own source code at
          <ulink url="https://svn.apache.org/repos/asf/subversion/"/> allows
          anyone in the world to perform read-only repository tasks (such as
          checking out working copies and browsing the repository),
          but restricts write operations to authenticated users.  The
          <literal>Limit</literal> and <literal>LimitExcept</literal>
          directives allow for this type of selective restriction.
          Like the <literal>Location</literal> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <literal>&lt;Location&gt;</literal>
          block.</para>
      -->
        <para>有时候, 你并不需要这么严格的设置. 比如说托管 Subversion 源代码
          的服务器 (<ulink
            url="https://svn.apache.org/repos/asf/subversion/"/>) 允许所有人
          对仓库执行只读操作 (例如检出工作副本, 浏览仓库等), 但只允许认证
          用户执行写操作. 配置指令 <literal>Limit</literal> 和
          <literal>LimitExcept</literal> 可以实现这种有选择的访问限制, 和
          配置指令 <literal>Location</literal> 一样, 前面两个配置指令也有开
          标签和闭标签, 管理员需要把它们放在 <literal>&lt;Location&gt;</literal>
          内部.</para>

      <!--
        <para>The parameters present on the <literal>Limit</literal>
          and <literal>LimitExcept</literal> directives are HTTP
          request types that are affected by that block.  For example,
          to allow anonymous read-only operations, you would use the
          <literal>LimitExcept</literal> directive (passing the
          <literal>GET</literal>, <literal>PROPFIND</literal>,
          <literal>OPTIONS</literal>, and <literal>REPORT</literal>
          request type parameters) and place the previously mentioned
          <literal>Require valid-user</literal> directive inside the
          <literal>&lt;LimitExcept&gt;</literal> block instead of just
          inside the <literal>&lt;Location&gt;</literal> block.</para>
      -->
        <para><literal>Limit</literal> 和 <literal>LimitExcept</literal>
          内的参数是 HTTP 请求类型, 这些请求类型将会受到这两个配置指令的
          影响. 比如说为了允许匿名的只读访问, 管理员需要使用配置指令
          <literal>LimitExcept</literal> (为指令添加请求类型参数
          <literal>GET</literal>, <literal>PROPFIND</literal>,
          <literal>OPTIONS</literal> 和 <literal>REPORT</literal>), 还要把
          前面提到的配置指令 <literal>Require valid-user</literal> 写到
          <literal>&lt;LimitExcept&gt;</literal> 内.</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Authenticated users only for non-read-only
  #                (write) operations; allow anonymous reads
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</programlisting>
        </informalexample>

      <!--
        <para>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <literal>Require</literal> directive, take a look at the
          <literal>Security</literal> section of the Apache
          documentation's tutorials collection at <ulink
          url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>
      -->
      <para>前面展示的只是一些很简单的例子, 如果想知道关于 Apache 访问控制和
        配置指令 <literal>Require</literal> 的更多细节, 可以参考 Apache
        文档的教程集合 (<ulink
          url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>) 中的
        <literal>Security</literal> 部分.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.perdir">
      <!--
        <title>Per-directory access control</title>
      -->
        <title>每个目录的访问控制</title>

      <!--
        <para>It's possible to set up finer-grained permissions using
          <command>mod_authz_svn</command>.  This Apache module grabs
          the various opaque URLs passing from client to server, asks
          <command>mod_dav_svn</command> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</para>
      -->
        <para>还可以使用 Apache 模块 <command>mod_authz_svn</command> 进行
          更细致的权限设置, 该模块截取从客户端发往服务器的 URL, 然后请求
          模块 <command>mod_dav_svn</command> 对 URL 进行解码, 根据定义在
          配置文件里的访问策略, 可能会禁止客户端的请求.</para>

      <!--
        <para>If you've built Subversion from source code,
          <command>mod_authz_svn</command> is automatically built
          and installed alongside <command>mod_dav_svn</command>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <command>mod_dav_svn</command>'s
          <literal>LoadModule</literal> directive in
          <filename>httpd.conf</filename>:</para>
      -->
        <para>如果你是自己从源代码编译安装的 Subversion, 那么默认情况下, 模块
          <command>mod_authz_svn</command> 将和 <command>mod_dav_svn</command>
          一起被编译安装, 许多二进制包也会自动安装这两个模块. 为了确认模块已
          被正确地安装, 在 <filename>httpd.conf</filename> 里将
          <command>mod_authz_svn</command> 的加载放到
          <command>mod_dav_svn</command> 之后:</para>

        <informalexample>
          <programlisting>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</programlisting>
        </informalexample>

      <!--
        <para>To activate this module, you need to configure your
          <literal>&lt;Location&gt;</literal> block to use the
          <literal>AuthzSVNAccessFile</literal> directive which specifies
          a single file containing the permissions policy for paths within
          your repositories.  Beginning with Subversion 1.7, you can
          also use <literal>AuthzSVNReposRelativeAccessFile</literal>
          directive to specify a per repository access file.
          (In a moment, we'll discuss the format of that file.)</para>
      -->
        <para>为了激活 <command>mod_authz_svn</command>, 你需要在
          <literal>&lt;Location&gt;</literal> 里, 用配置指令
          <literal>AuthzSVNAccessFile</literal> 指定一个文件, 这个文件包含
          了仓库内各个文件路径的权限策略. 从 Subversion 1.7 开始, 还可以用
          配置指令 <literal>AuthzSVNReposRelativeAccessFile</literal> 指定
          每个仓库各自的访问权限配置文件. (过一会儿, 我们就会讨论该文件的
          格式.)</para>

      <!--
        <para>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          following examples are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</para>
      -->
        <para>Apache 非常灵活, 所以你可以从 3 种通用模式中选择一种进行配置.
          首先, 先选择一种基本配置模式. (下面介绍的例子非常简单, 关于 Apache
          认证与授权选择的更多细节, 请参考 Apache 的文档.)</para>

      <!--
        <para>The most open approach is to allow access to everyone.
          This means Apache never sends authentication challenges, and
          all users are treated as <quote>anonymous</quote>.  (See
          <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-1"
          />.)</para>
      -->
      <para>最开放的做法是允许所有人访问, 这意味着 Apache 从不会要求客户
        端进行认证, 把所有的用户都当成 <quote>匿名用户</quote>. (见
        <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-1" />.)</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
      <!--
          <title>A sample configuration for anonymous access</title>
      -->
          <title>匿名访问的配置示例</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: None

  # Authorization: Path-based access control
  AuthzSVNAccessFile /path/to/access/file
&lt;/Location&gt;
</programlisting>
        </example>

      <!--
        <para>On the opposite end of the paranoia scale, you can
          configure Apache to authenticate all clients.
          This block unconditionally requires authentication via the
          <literal>Require valid-user</literal> directive, and defines
          a means to authenticate valid users.  (See
          <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-2"/>.)</para>
      -->
        <para>相反, 你可以要求 Apache 对所有的客户端进行认证, 下面的配置
          使用配置指令 <literal>Require valid-user</literal> 无条件地要求
          认证, 而且还指定了用户的认证方式. (见 <xref
            linkend="svn.serverconfig.httpd.authz.perdir.ex-2"/>.)</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">
      <!--
          <title>A sample configuration for authenticated access</title>
      -->
          <title>认证访问的配置示例</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Path-based access control; authenticated users only
  AuthzSVNAccessFile /path/to/access/file
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </example>

      <!--
        <para>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but restrict access to more
          sensitive areas to authenticated users.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, use both the <literal>Satisfy Any</literal>
          and <literal>Require valid-user</literal> directives.  (See
          <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-3"
          />.)</para>
      -->
      <para>第三种常见的配置模式是同时允许认证与匿名访问. 比如说很多管理
        员通常会允许匿名用户读取特定的仓库目录, 但较为敏感的区域仅允许
        被认证用户访问. 在这种配置下, 所有用户首先以匿名身份访问仓库, 在
        任意时刻, 如果你的访问控制策略要求使用真正的用户名, Apache 将向
        客户端发起认证要求. 为了实现这种配置, 使用配置指令
        <literal>Satisfy Any</literal> 和
        <literal>Require valid-user</literal>. (见 <xref
          linkend="svn.serverconfig.httpd.authz.perdir.ex-3" />.)</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">
      <!--
          <title>A sample configuration for mixed
            authenticated/anonymous access</title>
      -->
          <title>匿名/认证混合访问的配置示例</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Path-based access control; try anonymous access
  #                first, but authenticate if necessary
  AuthzSVNAccessFile /path/to/access/file
  Satisfy Any
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </example>

      <!--
        <para>The next step is to create the authorization file
          containing access rules for particular paths within the
          repository.  We describe how later in this chapter, in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>
      -->
        <para>下一步就是创建授权文件, 文件内包含了访问仓库中特定路径的规则,
          我们将在 <xref linkend="svn.serverconfig.pathbasedauthz"/> 介绍
          如何编写授权文件.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">
      <!--
        <title>Disabling path-based checks</title>
      -->
        <title>禁止基于路径的检查</title>

      <!--
        <para>The <command>mod_dav_svn</command> module goes through a
          lot of work to make sure that data you've marked
          <quote>unreadable</quote> doesn't get accidentally leaked.
          This means it needs to closely monitor all of the paths
          and file-contents returned by commands such as <command>svn
          checkout</command> and <command>svn update</command>.
          If these commands encounter a path that isn't
          readable according to some authorization policy, the
          path is typically omitted altogether.  In the case of
          history or rename tracing&mdash;for example, running a command such
          as <userinput>svn cat -r OLD foo.c</userinput> on a file that
          was renamed long ago&mdash;the rename tracking will simply
          halt if one of the object's former names is determined to be
          read-restricted.</para>
      -->
        <para>模块 <command>mod_dav_svn</command> 会做大量的工作, 以便确保
          被管理员标记为 <quote>不可读</quote> 的数据不会被意外地泄漏,
          这意味着它需要仔细地监控由客户端命令 (例如
          <command>svn checkout</command> 和 <command>svn update</command>)
          返回的路径和文件内容. 如果客户端命令遇到了一个它不可读的路径, 该
          路径就会被忽略. 对于历史或重命名追溯&mdash;例如对一个早就被重命名
          过的文件执行 <userinput>svn cat -r OLD foo.c</userinput>&mdash;
          如果其中一个对象以前的名字被禁止读取, 那么重命名追溯就会被终止.
        </para>

      <!--
        <para>All of this path checking can sometimes be quite
          expensive, especially in the case of <command>svn
          log</command>.  When retrieving a list of revisions, the
          server looks at every changed path in each revision and
          checks it for readability.  If an unreadable path is
          discovered, it's omitted from the list of the revision's
          changed paths (normally seen with
          the <option>- -verbose</option> (<option>-v</option>) option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module such as
          <command>mod_authz_svn</command> at all, the
          <command>mod_dav_svn</command> module is still asking Apache
          <command>httpd</command> to run authorization checks on
          every path.  The <command>mod_dav_svn</command> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</para>
      -->
        <para>有时候这些路径检查的代价将会非常高昂, 特别是对 <command>svn
            log</command> 而言. 当检索一个版本号列表时, 服务器查看每个版本号
          内被修改的路径, 检查路径的可读性, 如果碰到一个不可读的路径, 它将不
          会出现在版本号的修改路径列表里 (选项 <option>--verbose</option>
          (<option>-v</option>) 能够显示被版本号修改的路径), 整个日志消息也不
          会显示出来. 不管怎么说, 如果被版本号影响的文件数量非常大, 那么这种
          检查将会非常耗时. 这就是安全的代价: 即使你根本就没有配置像
          <command>mod_authz_svn</command> 这样的模块, 模块
          <command>mod_dav_svn</command> 仍然会要求 Apache
          <command>httpd</command> 对每一个路径执行授权检查. 模块
          <command>mod_dav_svn</command> 无法知晓系统中已经安装了哪些授权模块,
          所以它就要求 Apache 调用可能存在的任意模块.</para>

      <!--
        <para>On the other hand, there's also an escape hatch of
          sorts, which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e., not using
          <command>mod_authz_svn</command> or similar module),
          you can disable all of this path checking.  In your
          <filename>httpd.conf</filename> file, use the
          <literal>SVNPathAuthz</literal> directive as shown in
          <xref linkend="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"/>.</para>
      -->
        <para>另一方面, 管理员还可以牺牲部分安全, 以换取速度. 如果你没有实施
          任意类型的每目录授权 (即没有使用 <command>mod_authz_svn</command>
          或类似的模块), 就可以禁止这些路径检查, 禁止方式是在
          <filename>httpd.conf</filename> 里使用配置指令
          <literal>SVNPathAuthz</literal>, 见
          <xref linkend="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"/>
          所示.</para>

        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">
      <!--
          <title>Disabling path checks altogether</title>
      -->
          <title>完全禁止路径检查</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  SVNPathAuthz off
&lt;/Location&gt;
</programlisting>
        </example>

      <!--
        <para>The <literal>SVNPathAuthz</literal> directive
          is <quote>on</quote> by default.  When
          set to <quote>off,</quote> all path-based authorization
          checking is disabled;
          <command>mod_dav_svn</command> stops invoking authorization
          checks on every path it discovers.</para>
      -->
        <para>配置指令 <literal>SVNPathAuthz</literal> 的默认值是
          <literal>on</literal>, 当把它设置成 <literal>off</literal> 后,
          所有基于路径的授权检查都会被禁止, <command>mod_dav_svn</command>
          也不会再在每个发现的路径上唤起授权检查.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.inrepo-authz">
      <!--
        <title>Versioned in repository access files</title>
      -->
        <title>存放在仓库内的访问权限配置文件</title>

      <!--
        <para>Beginning with Subversion 1.8, access files can be
          stored inside a Subversion repository.  It is possible to
          store the access file in the same repository to which the
          access rules are being applied, or you can store it in an
          entirely different repository.  This approach enables
          versioning features of Subversion for the path-based
          authorization configuration.</para>
      -->
        <para>从 Subversion 1.8 开始, 访问权限配置文件可以存放在仓库内, 这个
          仓库可以是应用了本文件的同一仓库, 或者是另一个完全不同的仓库. 这个
          功能为 Subversion 基于路径的授权配置添加了版本控制的特性.</para>

      <!--
        <para>Both <literal>AuthzSVNAccessFile</literal> and
          <literal>AuthzSVNReposRelativeAccessFile</literal> configuration
          directives allow to specify in-repository access file's location.
          The directives accept absolute <literal>file://</literal> URLs
          and repository relative URLs (one which begins with
          <literal>^/</literal>).</para>
      -->
        <para>配置指令 <literal>AuthzSVNAccessFile</literal> 和
          <literal>AuthzSVNReposRelativeAccessFile</literal> 都可以用来指定
          仓库内的访问权限配置文件的位置. 配置指令的参数既可以是表示绝对路径
          的 <literal>file://</literal>, 也可以是表示相对路径的 URL (以
          <literal>^/</literal> 开始).</para>

      <!--
        <para>For example, it is possible to specify an absolute URL to
          in-repository access file as shown in
          <xref linkend="svn.serverconfig.httpd.authz.inrepo-authz.ex-1"/>.</para>
      -->
        <para>比如说, 可以像 <xref
            linkend="svn.serverconfig.httpd.authz.inrepo-authz.ex-1"/> 那样,
          为仓库内的访问权限配置文件指定一个绝对路径.</para>

        <example id="svn.serverconfig.httpd.authz.inrepo-authz.ex-1">
      <!--
          <title>Using single versioned in repo access file</title>
      -->
          <title>为多个仓库指定同一个位于仓库内的访问配置文件</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthzSVNAccessFile file:///var/svn/authzrepo/authz
&lt;/Location&gt;
</programlisting>
        </example>

      <!--
        <para>You can also specify a relative URL to an in repository access
          file as demonstrated in
          <xref linkend="svn.serverconfig.httpd.authz.inrepo-authz.ex-2"/>.</para>
      -->
        <para>还可以像 <xref
            linkend="svn.serverconfig.httpd.authz.inrepo-authz.ex-2"/> 那样
          为仓库内的访问权限配置文件指定一个相对路径.</para>

        <example id="svn.serverconfig.httpd.authz.inrepo-authz.ex-2">
      <!--
          <title>Using per repository in repo access files</title>
      -->
          <title>为每个仓库都指定一个仓库内的访问配置文件</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthzSVNReposRelativeAccessFile ^/authz
&lt;/Location&gt;
</programlisting>
        </example>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.ssl">
      <!--
      <title>Protecting network traffic with SSL</title>
      -->
      <title>使用 SSL 保护网络流量</title>

      <!--
      <para>Connecting to a repository via <literal>http://</literal>
        means that all Subversion activity is sent across the network
        in the clear.  This means that actions such as checkouts,
        commits, and updates could potentially be intercepted by an
        unauthorized party <quote>sniffing</quote> network traffic.
        Encrypting traffic using SSL is a good way to protect
        potentially sensitive information over the network.</para>
      -->
      <para>通过 <literal>http://</literal> 连接仓库意味着 Subversion 所
        有的活动都会在网络上暴露无遗, 也就是说像检出, 提交和更新这些操作
        都有可能被未授权的网络嗅探工具所拦截. 使用 SSL 加密网络流量是保护
        敏感数据不在网络上泄露的常用方法.</para>

      <!--
      <para>If a Subversion client is compiled to use OpenSSL,
        it gains the ability to speak to an Apache server via
        <literal>https://</literal> URLs, so all traffic is encrypted
        with a per-connection session key.  The WebDAV library used by
        the Subversion client is not only able to verify server
        certificates, but can also supply client certificates when
        challenged by the server.</para>
      -->
      <para>如果 Subversion 客户端工具在编译时开启了 OpenSSL, 它就可以使用
        <literal>https://</literal> 形式的 URL 连接 Apache 服务器, 于是所有
        的网络流量都会使用每连接会话密钥进行加密. Subversion 客户端所使用的
        WebDAV 函数库不仅可以验证服务器的证书, 当服务器提出要求时, 它也可
        以为客户端提供证书.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ssl.server">
      <!--
        <title>Subversion server SSL certificate configuration</title>
      -->
        <title>Subversion 服务器 SSL 证书配置</title>

      <!--
        <para>It's beyond the scope of this book to describe how to
          generate client and server SSL certificates and how to
          configure Apache to use them.  Many other references,
          including Apache's own documentation (<ulink 
          url="http://httpd.apache.org/docs/current/ssl/"/>),
          describe the process.</para>
      -->
        <para>如何为客户端和服务器生成 SSL 证书, 以及如何配置 Apache 以便
          使用这些证书, 已经超出了本书的范畴, 读者可参考 Apache 的文档
          (<ulink url="http://httpd.apache.org/docs/current/ssl/"/>).</para>

        <tip>
      <!--
          <para>SSL certificates from well-known entities generally
            cost money, but at a bare minimum, you can configure
            Apache to use a self-signed certificate generated with a
            tool such as OpenSSL (<ulink url="http://openssl.org"
            />).<footnote><para>While self-signed certificates are
            still vulnerable to a <quote>man-in-the-middle</quote>
            attack (before a client sees the certificate for the first
            time), such an attack is much more difficult for a casual
            observer to pull off, compared to sniffing unprotected
            passwords.</para></footnote></para>
      -->
      <para>来自知名组织的 SSL 证书通常需要花钱购买, 但如果只需要满足最低
        限度的要求, 你可以让 Apache 使用自签署的证书, 这种证书由 OpenSSL
        生成.<footnote><para>但是, 自签署的证书仍然无法抵御 <quote>中间人
              攻击</quote> (在客户端首次见到证书之前), 和嗅探敏感数据相比,
            这种攻击更难防范.</para></footnote></para>
        </tip>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ssl.client">
      <!--
        <title>Subversion client SSL certificate management</title>
      -->
        <title>Subversion 客户端 SSL 证书管理</title>

      <!--
        <para>When connecting to Apache via <literal>https://</literal>,
          a Subversion client can receive two different types of
          responses:</para>
      -->
        <para>当使用 <literal>https://</literal> 形式的 URL 连接 Apache 时,
          Subversion 客户端将会收到两个类型的响应:</para>

        <itemizedlist>
          <listitem>
      <!--
            <para>A server certificate</para>
      -->
            <para>一个服务器证书</para>
          </listitem>
          <listitem>
      <!--
            <para>A challenge for a client certificate</para>
      -->
            <para>一个针对客户端证书的请求</para>
          </listitem>
        </itemizedlist>

        <sect4 id="svn.serverconfig.httpd.ssl.client.servercert">
      <!--
          <title>Server certificate</title>
      -->
          <title>服务器证书</title>

      <!--
          <para>When the client receives a server certificate, it needs
            to verify that the server is who it claims to be. OpenSSL
            does this by examining the signer of the server certificate,
            or <firstterm>certificate authority</firstterm> (CA).  If
            OpenSSL is unable to automatically trust the CA, or if some
            other problem occurs (such as an expired certificate or
            hostname mismatch), the Subversion command-line client will
            ask you whether you want to trust the server certificate
            anyway:</para>
      -->
          <para>当客户端收到服务器证书时, 它需要验证服务器身份的真实性,
            OpenSSL 完成验证的方法是检查服务器证书的签发人, 也就是
            <firstterm>证书颁发机构</firstterm> (<firstterm>certificate
              authority</firstterm>, 简称 CA). 如果 OpenSSL 无法自动信任
            CA, 或者是发生的错误 (例如认证超时或主机名不匹配), 那么 Subversion
            客户端工具将询问用户是否要信任服务器的证书:</para>

          <informalexample>
            <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority.  Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>
          </informalexample>

      <!--
          <para>This dialogue is essentially the same question you may
            have seen coming from your web browser (which is just
            another HTTP client like Subversion).  If you choose the
            <literal>(p)</literal>ermanent option, Subversion will
            cache the server certificate in your private runtime
            <filename>auth/</filename> area, just as your username and
            password are cached (see <xref
            linkend="svn.serverconfig.netmodel.credcache"/>), and will
            automatically trust the certificate in the future.</para>
      -->
          <para>用户可能会在网页浏览器看到相同的对话框 (浏览器只是一个
            HTTP 客户端), 如果选择 <literal>p</literal>, Subversion 将把
            服务器证书缓存在本地的 <filename>auth/</filename> 目录内,
            你的用户名和密码也缓存在这里 (见 <xref
              linkend="svn.serverconfig.netmodel.credcache"/>), 今后再次
            连接服务器时, 将会自动信任证书.</para>

      <!--
          <para>Your runtime <filename>servers</filename> file also gives
            you the ability to make your Subversion client automatically
            trust specific CAs, either globally or on a per-host basis.
            Simply set the <literal>ssl-authority-files</literal>
            variable to a semicolon-separated list of PEM-encoded CA
            certificates:</para>
      -->
          <para>运行时配置文件 <filename>servers</filename> 允许 Subversion
            客户端自动信任特定的 CA, 信任既可以是全局的, 也可以是基于每个主
            机的, 方法是用变量 <literal>ssl-authority-files</literal> 指定
            PEM 编码的 CA 证书, 证书之间用分号分开:</para>

          <informalexample>
            <programlisting>
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</programlisting>
          </informalexample>

      <!--
          <para>Many OpenSSL installations also have a predefined set
            of <quote>default</quote> CAs that are nearly universally
            trusted.  To make the Subversion client automatically trust
            these standard authorities, set the
            <literal>ssl-trust-default-ca</literal> variable to
            <literal>true</literal>.</para>
      -->
          <para>很多 OpenSSL 安装包预定义了一套 <quote>默认的</quote>
            CA, 这些 CA 得到了非常普遍的信任. 为了让 Subversion 客户端自动
            信任 OpenSSL 的证书, 把变量 <literal>ssl-trust-default-ca</literal>
            设置成 <literal>true</literal>.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.ssl.client.clientcert">
      <!--
          <title>Client certificate challenge</title>
      -->
          <title>客户端证书盘问</title>

      <!--
          <para>If the client receives a challenge for a certificate,
            the server is asking the client to prove its identity.
            The client must send back a certificate signed by a CA
            that the server trusts, along with a <firstterm>challenge
            response</firstterm> which proves that the client owns the
            private key associated with the certificate.  The private
            key and certificate are usually stored in an encrypted
            format on disk, protected by a passphrase.  When Subversion
            receives this challenge, it will ask you for the path to the
            encrypted file and the passphrase that protects it:</para>
      -->
          <para>如果客户端收到一个证书请求, 那便是服务器要求客户端提供它的
            身份, 客户端必须提供由 CA 签名过的证书, 而该 CA 是服务器所信任
            的, 除了证书, 还要发送一个 <firstterm>回应</firstterm>
            (<firstterm>challenge response</firstterm>), 这个回应证明了客户
            端拥有与证书关联的私钥. 私钥和证书通常被加密后存放在本地磁盘上,
            被一个密码保护. 当 Subversion 客户端收到证书的盘问时, 它将询问
            用户密钥与证书的存放路径, 以及对应的密码:</para>

          <informalexample>
            <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
</screen>
          </informalexample>

      <!--
          <para>Notice that the client credentials are stored in a
            <literal>.p12</literal> file.  To use a client certificate
            with Subversion, it must be in PKCS#12 format, which is a
            portable standard.  Most web browsers are able to import
            and export certificates in that format.  Another option
            is to use the OpenSSL command-line tools to convert
            existing certificates into PKCS#12.</para>
      -->
          <para>在上面的例子里, 客户端证书存放在一个 <literal>.p12</literal>
            文件里. 为了让 Subversion 使用证书, 证书的格式必须是 PKCS#12,
            这是一种可移植的标准格式, 大多数网页浏览器支持导入或导出这种
            格式的证书, 除了浏览器, 还可以用 OpenSSL 命令行工具把已有的
            证书转换成 PKCS#12 格式.</para>

      <!--
          <para>The runtime <filename>servers</filename> file also
            allows you to automate this challenge on a per-host basis.
            If you set the <literal>ssl-client-cert-file</literal>
            and <literal>ssl-client-cert-password</literal> variables,
            Subversion can automatically respond to a client
            certificate challenge without prompting you:</para>
      -->
          <para>运行时配置文件 <filename>servers</filename> 允许用户基于
            每个主机, 自动完成证书请求的响应. 如果用户设置了变量
            <literal>ssl-client-cert-file</literal> 和
            <literal>ssl-client-cert-password</literal>, Subversion 将自动
            响应证书请求, 而不会提示用户:</para>

          <informalexample>
            <programlisting>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</programlisting>
          </informalexample>

      <!--
          <para>More security-conscious folk might want to exclude
            <literal>ssl-client-cert-password</literal> to avoid
            storing the passphrase in the clear on disk.</para>
      -->
          <para>更注重安全的用户可能并不想设置变量
            <literal>ssl-client-cert-password</literal>.</para>

        </sect4>
      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.perf">
      <!--
      <title>Tuning for Performance</title>
      -->
      <title>优化性能</title>

      <!--
      <para>The Apache HTTP Server is built for performance, but you
        can improve upon its default configuration to get even better
        results out of your Subversion service offering.  In this
        section, we'll recommend some specific configuration changes
        to consider.  Understand, however, that some of
        the <filename>httpd.conf</filename> configuration options
        we'll be discussing herein affect the general behavior of your
        server, not merely the Subversion service.  As such, you need
        to consider the full breadth of your HTTP service offering to
        discern how modifications to these settings for Subversion's
        sake may affect your other services.</para>
      -->
      <para>Apache HTTP 服务器非常注重性能, 不过你仍然可以通过修改配置为
        Subversion 服务争取更高的性能. 本节将介绍几种比较重要的配置修改,
        但是需要注意的某些 <filename>httpd.conf</filename> 配置选项将会影响
        Apache 服务器的整体表现, 而不仅仅是 Subversion 服务, 因此管理员在
        修改配置时, 需要考虑对其他服务的影响.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.perf.keepalive">
        <title>KeepAlive</title>

      <!--
        <para>By default, the Apache HTTP Server is configured to
          enable the re-use of a single server connection for multiple
          requests.  That's very beneficial for Subversion, because
          unlike many HTTP-based applications, Subversion can very
          quickly generate hundreds or thousands of requests against
          the server for a single operation, and the cost of opening a
          new connection to the server is non-trivial.  Subversion
          wants to squeeze as many requests as possible out of a
          single connection before that connection is terminated by
          the server.  The <literal>KeepAlive</literal> directive is the
          boolean flag which enables or disables this connection
          re-use facility, and as we indicated previously, by default
          its value is <literal>On</literal>.</para>
      -->
        <para>默认情况下, Apache HTTP 服务器允许为多个请求复用同一个连接,
          这对于 Subversion 而言非常有好处, 因为 Subversion 在一个单独的
          操作中, 很可能会快速产生成百上千个请求, 而重新打开一个服务器的
          连接是一件颇费周张的事. 在连接被服务器关闭之前, Subversion 会在同
          一个连接内发送尽可能多的请求. 配置指令 <literal>KeepAlive</literal>
          用于开启或禁止连接重用功能, 它的默认值是 <literal>On</literal>.
        </para>

      <!--
        <para>But there's another directive which limits the number of
          requests a client is allowed to submit on a single
          connection:  the <literal>MaxKeepAliveRequests</literal>
          directive.  The default value for that option
          is <literal>100</literal>.  This was probably sufficient for
          older versions of Subversion, but Subversion 1.8 employs a
          different HTTP communications library (called Serf) which
          prefers to pipeline several smaller requests for specific bits
          of information rather than asking the server to transmit
          huge chunks of data in a single response.  We recommend that
          you increase the value of the
          <literal>MaxKeepAliveRequests</literal> option
          to at least <literal>1000</literal>.</para>
      -->
        <para>但是还有另一个配置指令用于限制客户端在一个单独的连接内, 可以提交
          的请求数量: <literal>MaxKeepAliveRequests</literal>, 它的默认值是
          <literal>100</literal>. 对于版本较旧的 Subversion 而言, 它的默认值
          已经足够了, 但是 Subversion 1.8 使用了不同的 HTTP 通信函数库 (称为
          Serf), 为了获取特定的零碎信息, Serf 更倾向于发送若干个小请求, 而不是
          请求服务器在一个单独的响应中, 传回一大块数据. 因此, 我们建议把
          至少把 <literal>MaxKeepAliveRequests</literal> 设置为
          <literal>1000</literal>.</para>

        <informalexample>
          <programlisting>
#
# KeepAlive: Whether or not to allow persistent connections (more than
# one request per connection). Set to "Off" to deactivate.
#
KeepAlive On

#
# MaxKeepAliveRequests: The maximum number of requests to allow
# during a persistent connection. Set to 0 to allow an unlimited amount.
# We recommend you leave this number high, for maximum performance.
#
MaxKeepAliveRequests 1000
</programlisting>
        </informalexample>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.perf.bulk-updates">
      <!--
        <title>Bulk updates</title>
      -->
        <title>批量更新</title>

      <!--
        <para>The biggest difference between the way that Subversion
          1.8 clients and pre-1.8 clients behave is in how update-style
          operations (<command>svn checkout</command>, <command>svn
          update</command>, <command>svn switch</command>, etc.) are
          handled.  Older clients which used the Neon HTTP library for
          communications preferred to ask the server for the entire
          payload of information required from the server in a single
          request.  Admins will have noticed that in their server
          logs, there would be some initial handshaking operations,
          and then a <literal>REPORT</literal> request with a massive
          response.  That response was the entire checkout/update
          dataset!</para>
      -->
        <para>Subversion 1.8 客户端和它旧版之间最大的不同点在于更新操作
          (<command>svn checkout</command>, <command>svn update</command>,
          <command>svn switch</command> 等) 的处理过程. 老版客户端使用
          Neon HTTP 函数库实现通信, Neon 函数库更喜欢在一个单独的请求中, 向
          服务器索要全部的信息. 管理员可能在他们的服务器日志里见到过这种日志:
          先是一些握手操作, 然后是一个带有大量数据的 <literal>REPORT</literal>
          请求, 这些数据就是整个的检出/更新数据集!</para>

      <!--
        <para>Subversion clients which use the Serf HTTP
          library&mdash;which includes all clients built atop the
          Subversion 1.8&mdash;still send the <literal>REPORT</literal>
          request, but with slightly different flags set inside that
          request.  These flags ask the server not to send all the
          data for the operation, but to instead send only a checklist
          of other more specific things that the client needs to
          subsequently fetch from the server in order to complete that
          operation.  In the server's <filename>access_log</filename>,
          that <literal>REPORT</literal> is followed by many smaller
          requests (<literal>GET</literal>s and, in older versions of
          Subversion, <literal>PROPFIND</literal>s).</para>
      -->
        <para>使用 Serf 函数库的 Subversion 客户端&mdash;版本大于或等于
          Subversion 1.8&mdash;仍然会发送 <literal>REPORT</literal> 请求,
          但在请求内会设置一些稍微不同的标志, 这些标志告诉服务器不用发送全
          部的数据, 而是发送一个清单, 客户端随后根据清单向服务器请求更明确
          的数据, 从而完成整个操作. 在服务器的 <filename>access_log</filename>
          日志里, 这种 <literal>REPORT</literal> 请求后面会出现很多小块的
          <literal>GETS</literal> 请求 (如果是旧版 Subversion, 则是
          <literal>PROPFIND</literal> 请求).</para>

      <!--
        <para>There are pros and cons to each approach.  As we've
          mentioned, the so-called bulk updates generate considerably
          less information in the server logs, but a given Apache HTTP
          Server child process is completely consumed for the duration
          of what could be a lengthy operation.  Non-bulk updates
          offer opportunities for setting up content caches (which
          themselves can improve performance), but generate server log
          traffic which is whole orders of magnitude larger than the
          bulk update approach.  So, for one reason or another,
          administrators may desire to exert a little more control
          over which approach the clients use.  Subversion 1.6
          introduced the <literal>SVNAllowBulkUpdates</literal>
          <command>mod_dav_svn</command> directive&mdash;a simple
          boolean flag&mdash;to allow admins to specify whether the
          server was allowed to honor bulk update requests.  In
          Subversion 1.8, this directive has expanded to include
          a <literal>Prefer</literal> value in addition to the
          <literal>On</literal> and <literal>Off</literal> values it
          already supported. When <literal>SVNAllowBulkUpdates</literal>
          is set to <literal>Prefer</literal>, supporting clients (1.8
          or newer) will try to use the bulk update approach unless
          otherwise configured.</para>
      -->
        <para>上面的做法有好有坏. 批量更新的做法虽然在服务器上产生的日志更少,
          但在操作运行的过程中, 被占用的 Apache HTTP 服务器子进程将无暇顾及
          其他工作, 而当前操作可能还需要很长时间才能完成. 非批量更新提供了
          设置内容缓存的机会 (缓存可用于提高性能), 但生成的服务器日志比批量
          更新多得多. 无论是由于哪种原因, 管理员可能想对客户端施加更多的限制.
          Subversion 1.6 为 <command>mod_dav_svn</command> 添加了一个新的二
          元配置指令 <literal>SVNAllowBulkUpdates</literal>, 用于配置服务器
          是否允许批量更新. 在 Subversion 1.8,
          <literal>SVNAllowBulkUpdates</literal> 的值除了 <literal>On</literal>
          和 <literal>Off</literal> 外, 还新增了 <literal>Prefer</literal>,
          如果 <literal>SVNAllowBulkUpdates</literal> 被设置为
          <literal>Prefer</literal>, 受支持的客户端 (1.8 或更新的版本) 将尝试
          使用批量更新, 除非另有指定.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">
      <!--
      <title>Extra Goodies</title>
      -->
      <title>其他好处</title>

      <!--
      <para>We've covered most of the authentication and authorization
        options for Apache and <command>mod_dav_svn</command>.  But
        there are a few other nice features that Apache
        provides.</para>
      -->
      <para>关于 Apache 和 <command>mod_dav_svn</command> 的认证与授权, 我
        们已经介绍了大部分, 不过 Apache 还提供了一些非常有效的特性.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.browsing">
      <!--
        <title>Repository browsing</title>
      -->
        <title>仓库浏览</title>

      <!--
        <para>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that your
          versioned files and directories are immediately available
          for viewing via a regular web browser.  Since Subversion
          uses URLs to identify versioned resources, those URLs used
          for HTTP-based repository access can be typed directly into
          a web browser.  Your browser will issue an
          HTTP <literal>GET</literal> request for that URL; based on
          whether that URL represents a versioned directory or
          file, <command>mod_dav_svn</command> will respond with a
          directory listing or with file contents.</para>
      -->
        <para>Apache/WebDAV 最实用的功能之一是允许用户直接在网页浏览器上浏览
          仓库内的文件与目录. 因为 Subversion 使用 URL 标识仓库内的文件,
          基于 HTTP 的 URL 可以直接输入到网页浏览器的地址栏上, 然后浏览器
          向服务器发送 HTTP <literal>GET</literal> 请求, 根据 URL 所指向的
          资源是文件还是目录, <command>mod_dav_svn</command> 将返回目录内的
          文件列表, 或文件的内容.</para>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.syntax">
      <!--
          <title>URL syntax</title>
      -->
          <title>URL 语法</title>

      <!--
          <para>If the URLs do not contain any information about which
            version of the resource you wish to
            see, <command>mod_dav_svn</command> will answer with the
            youngest version.  This functionality has the wonderful
            side effect that you can pass around Subversion URLs to
            your peers as references to documents, and those URLs will
            always point at the latest manifestation of that document.
            Of course, you can even use the URLs as hyperlinks from
            other web sites, too.</para>
      -->
          <para>如果 URL 没有指定所请求的资源的版本,
            <command>mod_dav_svn</command> 将返回最新的版本, 这种做法最大的
            好处是你可以把 Subversion URL (例如某篇文档的 URL) 发给其他同事,
            而这些 URL 将始终指向文档的最新版. 当然, 你也可以把这些 URL 作
            为超链接放到网站上.</para>

      <!--
          <para>As of Subversion 1.6, <command>mod_dav_svn</command>
            supports a public URI syntax for examining older revisions
            of both files and directories.  The syntax uses the query
            string portion of the URL to specify either or both of a
            peg revision and operative revision, which Subversion will
            then use to determine which version of the file or
            directory to display to your web browser.  Add the query
            string name/value pair
            <literal>p=<replaceable>PEGREV</replaceable></literal>,
            where <replaceable>PEGREV</replaceable> is a revision
            number, to specify the peg revision you wish to apply to the
            request.  Use
            <literal>r=<replaceable>REV</replaceable></literal>,
            where <replaceable>REV</replaceable> is a revision number, to
            specify an operative revision.</para>
      -->
          <para>从 Subversion 1.6 开始, <command>mod_dav_svn</command> 支持
            一种用于查看旧版本文件与目录的 URL 语法. 这种语法使用 URL 的查询
            字符串部分指定限定版本号和 (或) 实施版本号, Subversion 将会把这些
            版本号对应的文件与目录显示到网页浏览器上. 为了指定限定版本号, 在
            URL 的查询字符串部分添加
            <literal>p=<replaceable>PEGREV</replaceable></literal> 形式的
            名字/值 对 (其中, <replaceable>PEGREV</replaceable> 是一个版本号);
            为了指定实施版本号, 在 URL 的查询字符串部分添加
            <literal>r=<replaceable>REV</replaceable></literal> 形式的
            名字/值 对 (其中, <replaceable>REV</replaceable> 是一个版本号).
          </para>

      <!--
          <para>For example, if you wish to see the latest version of a
            <filename>README.txt</filename> file located in your
            project's <filename>/trunk</filename>, point your web
            browser to that file's repository URL, which might look
            something like the following:</para>
      -->
          <para>比如说, 你想查看 <filename>/trunk</filename> 里的最新版的
            <filename>README.txt</filename>, 就在网页浏览器的地址栏里输入类似
            于下面的 URL:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/README.txt
</programlisting>
          </informalexample>

      <!--
          <para>If you now wish to see some older version of that
            file, add an operative revision to the URL's query
            string:</para>
      -->
          <para>如果你想查看该文件的旧版, 在 URL 的查询字符部分添加实施版本号:
          </para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/README.txt?r=1234
</programlisting>
          </informalexample>

      <!--
          <para>What if the thing you're trying to view no longer exists
            in the youngest revision of the repository?  That's where a
            peg revision is handy:</para>
      -->
          <para>如果你想查看的文件在最新版中已经被删除了, 那又该怎么办? 这
            时候就要用到限定版本号:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/deleted-thing.txt?p=321
</programlisting>
          </informalexample>

      <!--
          <para>And of course, you can combine peg revision and
            operative revision specifiers to fine-tune the exact item
            you wish to view:</para>
      -->
          <para>当然, 你还可以结合使用限定版本号和实施版本号, 更精细地指定待
            查看的项目:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/renamed-thing.txt?p=123&amp;r=21
</programlisting>
          </informalexample>

      <!--
          <para>The previous URL would display revision 21 of the
            object which, in revision 123, was located
            at <filename>/trunk/renamed-thing.txt</filename> in the
            repository.  See <xref linkend="svn.advanced.pegrevs" /> for a
            detailed explanation of these <quote>peg revision</quote>
            and <quote>operative revision</quote> concepts.  They can
            be a bit tricky to wrap your head around.</para>
      -->
          <para>上面的 URL 将显示对象在版本号 21 时的内容, 这个对象在版本
            号为 123 时, 位于 <filename>/trunk/renamed-thing.txt</filename>.
            关于 <quote>限定版本号</quote> 和 <quote>实施版本号</quote> 的详细
            介绍, 见 <xref linkend="svn.advanced.pegrevs" />, 理解它们可能会
            让你感到有点头晕.</para>

      <!--
          <para>Beginning with Subversion 1.8, <command>mod_dav_svn</command>
            has the ability to substitute keywords.  When 
            <command>mod_dav_svn</command>
            finds the query argument <literal>kw=1</literal> added to
            the URL of a file, it will expand keywords when delivering
            the file's content.  Omitting the <literal>kw</literal>
            parameter or using any value besides <literal>1</literal>
            for that parameter will cause Subversion to use its
            default behavior, which is to deliver the file's content
            without any keywords expanded.</para>
      -->
          <para>从 Subversion 1.8 开始, <command>mod_dav_svn</command> 具有了
            替换关键字的能力. 如果 <command>mod_dav_svn</command> 在文件的
            URL 里发现了查询参数 <literal>kw=1</literal>, 它将在递送文件内容
            时, 替换掉其中的关键字. 如果省略参数 <literal>kw</literal>, 或是
            赋予了除 <literal>1</literal> 之外的其他值, 则 Subversion 将保持
            默认行为, 即在递送文件内容时, 不替换其中的关键字.</para>

      <!--
          <para>Because keyword substitution is typically performed by the
            Subversion client as part of its working copy administration
            and management, this is a handy way to get the server to deliver
            a keyword-expanded form of your versioned file without the use
            of a working copy.</para>
      -->
          <para>通常情况下, 关键字替换是作为工作副本管理工作的一部分, 在客户
            端执行, 所以说在不使用工作副本的情况下, 让服务器递送一份关键字被
            替换后的文件是一件非常方便的事情.</para>

      <!--
          <para>For example, if you wish to see the latest version of a
            <filename>README.txt</filename> file located in your
            project's <filename>/trunk</filename> with keywords
            expanded, add the query argument <literal>kw=1</literal> to the
            URL:</para>
      -->
          <para>比如说, 你想查看位于项目目录 <filename>/trunk</filename> 内,
            最新版本的 <filename>README.txt</filename>, 而且还要求替换文件
            内的关键字, 则在 URL 的后面添加查询参数 <literal>kw=1</literal>:
          </para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/README.txt?kw=1
</programlisting>
          </informalexample>

      <!--
          <para>As with client-side keyword expansion, only those keywords
            which are explicitly designated for expansion via the
            <literal>svn:keywords</literal> property set on the file itself
            will be expanded.  See
            <xref linkend="svn.advanced.props.special.keywords" /> for a
            detailed description of the keyword substitution feature.</para>
      -->
          <para>和客户端的关键字展开一样, 只有在文件上设置属性
            <literal>svn:keywords</literal> 后, 被指定的关键字才会被替换,
            关于关键字替换的更多内容, 见 <xref
              linkend="svn.advanced.props.special.keywords" />.</para>

      <!--
          <para>As a reminder, <command>mod_dav_svn</command> offers only a
            limited repository browsing experience.  You can see directory
            listings and file contents, but no revision properties
            (such as commit log messages) or file/directory
            properties.  For folks who require more extensive browsing
            of repositories and their history, there are several
            third-party software packages which offer this.  Some
            examples include ViewVC (<ulink url="http://viewvc.org" />),
            Trac (<ulink url="http://trac.edgewall.org" />) and WebSVN
            (<ulink url="http://websvnphp.github.io" />).  These third-party
            tools don't affect <command>mod_dav_svn</command>'s
            built-in <quote>browseability</quote>, and generally offer
            a much wider set of features, including the display of the
            aforementioned property sets, display of content
            differences between file revisions, and so on.</para>
      -->
          <para>作为提醒, <command>mod_dav_svn</command> 所能提供的仓库浏览
            体验比较有限, 你只能看到目录列表和文件内容, 但无法看到版本号属性
            (例如日志消息) 或文件/目录属性. 如果用户需要更强大的仓库浏览功能,
            可以借助第三方软件, 例如 ViewVC (<ulink
              url="http://viewvc.org"/>), Trac (<ulink
              url="http://trac.edgewall.org" />) 和 WebSVN (<ulink
              url="http://websvnphp.github.io" />). 这些第三方软件不会影响
            <command>mod_dav_svn</command> 的内建 <quote>可浏览性</quote>,
            而且还提供了更强大的功能, 包括显示前面提到的属性, 显示文件的两个
            版本号之间的差异等.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.mimetype">
      <!--
          <title>Proper MIME type</title>
      -->
          <title>合适的 MIME 类型</title>

      <!--
          <para>When browsing a Subversion repository, the web browser
            gets a clue about how to render a file's contents by
            looking at the <literal>Content-Type:</literal> header
            returned in Apache's response to the
            HTTP <literal>GET</literal> request.  The value of this
            header is some sort of MIME type.  By default, Apache will
            tell the web browsers that all repository files are of
            the <quote>default</quote> MIME type,
            typically <literal>text/plain</literal>.  This can be
            frustrating, however, if a user wishes repository files to
            render as something more meaningful&mdash;for example,
            it might be nice to have a <filename>foo.html</filename> file
            in the repository actually render as HTML when
            browsing.</para>
      -->
          <para>浏览一个 Subversion 仓库时, 网页浏览器通过查看
            <literal>Content-Type</literal> 来判断如何提供文件的内容.
            <literal>Content-Type</literal> 是 Apache 答复 HTTP
            <literal>GET</literal> 请求的消息中的一段头部信息, 这段头部信息存
            放 MIME 类型. 默认情况下, Apache 告诉浏览器所有的仓库文件的 MIME
            类型都是默认值, 通常是 <literal>text/plain</literal>. 然而, 用户
            有时候可能对这种处理不太满意, 因为他希望仓库里的文件能够以更有意义
            的方式呈现&mdash;比如说把 <filename>foo.html</filename> 按照 HTML
            的格式进行显示.</para>

      <!--
          <para>To make this happen, you need only to make sure that
            your files have the proper <literal>svn:mime-type</literal>
            set.  We discuss this in more detail in
            <xref linkend="svn.advanced.props.special.mime-type"/>,
            and you can even configure your client to automatically
            attach proper <literal>svn:mime-type</literal> properties
            to files entering the repository for the first time; see
            <xref linkend="svn.advanced.props.auto"/>.</para>
      -->
          <para>为了让文件在浏览器内以更加合适的方式呈现, 需要为文件设置
            <literal>svn:mime-type</literal> 属性, 详细的内容在
            <xref linkend="svn.advanced.props.special.mime-type"/>, 另外,
            还可以配置客户端, 使得在第一次把文件存放到仓库是时, 自动地为文件
            设置合适的 <literal>svn:mime-type</literal> 属性, 见
            <xref linkend="svn.advanced.props.auto"/>.</para>

      <!--
          <para>Continuing our example, if one were to set
            the <literal>svn:mime-type</literal> property
            to <literal>text/html</literal> on
            file <filename>foo.html</filename>, Apache would properly
            tell your web browser to render the file as HTML.  One
            could also attach proper <literal>image/*</literal>
            MIME-type properties to image files and ultimately get an
            entire web site to be viewable directly from a repository!
            There's generally no problem with this, as long as the web
            site doesn't contain any dynamically generated
            content.</para>
      -->
          <para>继续我们的例子, 如果 <filename>foo.html</filename> 的
            <literal>svn:mime-type</literal> 属性已经被设置为
            <literal>text/html</literal>, Apache 将告诉浏览器按照 HTML 格式
            来显示 <filename>foo.html</filename>. 用户还可以为图片文件的
            <literal>svn:mime-type</literal> 属性设置合适的
            <literal>image/*</literal>, 最终得到一个可以直接从仓库中浏览的
            网站! 只要网站不包含任何动态生成的内容, 这是完全可以做到的.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.xslt">
      <!--
          <title>Customizing the look</title>
      -->
          <title>定制外观</title>

      <!--
          <para>You generally will get more use out of URLs to
            versioned files&mdash;after all, that's where the
            interesting content tends to lie.  But you might have
            occasion to browse a Subversion directory listing, where
            you'll quickly note that the generated HTML used to
            display that listing is very basic, and certainly not
            intended to be aesthetically pleasing (or even
            interesting).  To enable customization of these directory
            displays, Subversion provides an XML index feature.  A
            single <literal>SVNIndexXSLT</literal> directive in your
            repository's <literal>Location</literal> block of
            <filename>httpd.conf</filename> will
            instruct <command>mod_dav_svn</command> to generate XML
            output when displaying a directory listing, and to
            reference the XSLT stylesheet of your choice:</para>
      -->
          <para>通常来说, 用户更经常使用普通文件的 URL&mdash;毕竟文件的内容
            才是人们感兴趣的东西. 不过, 在少数情况下用户仍然需要浏览 Subversion
            的目录列表, 此时用户可能会觉得目录列表的外观过于简单, 缺乏美感
            (或者说无法引起人们的兴趣). 为了允许对目录列表的外观进行修改,
            Subversion 提供了一个 XML 索引特性. 在仓库的
            <filename>httpd.conf</filename> <literal>Location</literal>
            配置块里, 如果增加一个配置指令 <literal>SVNIndexXSLT</literal>,
            <command>mod_dav_svn</command> 在显示目录列表时, 将生成一个 XML
            输出, 并引用到用户所选择的 XSLT 样式表:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</programlisting>
          </informalexample>

      <!--
          <para>Using the <literal>SVNIndexXSLT</literal> directive
            and a creative XSLT stylesheet, you can make your
            directory listings match the color schemes and imagery
            used in other parts of your web site.  Or, if you'd
            prefer, you can use the sample stylesheets provided in the
            Subversion source distribution's
            <filename>tools/xslt/</filename> directory.
            Keep in mind that the path provided to the
            <literal>SVNIndexXSLT</literal> directive is actually a
            URL path&mdash;browsers need to be able to read your
            stylesheets to make use of them!</para>
      -->
          <para>利用配置指令 <literal>SVNIndexXSLT</literal> 和一个优秀的
            XSLT 样式表, 就可以让目录列表的显示风格与网站上的其他部分保持
            一致. 如果用户愿意, 还可以使用 Subversion 提供的样式表示例,
            样式表示例放在源码包的 <filename>tools/xslt/</filename> 目录内.
            需要注意的是提供给配置指令 <literal>SVNIndexXSLT</literal> 的路径
            实际上是一个 URL 路径&mdash;浏览器必须能够读取到样式表, 这样才能
            使用它们!</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.reposlisting">
      <!--
          <title>Listing repositories</title>
      -->
          <title>罗列仓库</title>

      <!--
          <para>If you're serving a collection of repositories from a
            single URL via the <literal>SVNParentPath</literal>
            directive, then it's also possible to have Apache display
            all available repositories to a web browser.  Just
            activate the <literal>SVNListParentPath</literal>
            directive:</para>
      -->
          <para>如果你通过配置指令 <literal>SVNParentPath</literal>, 在一个
            单独的 URL 上服务多个仓库, 那么 Apache 就有可能在浏览器上列出所有
            的仓库, 你所需要做的就是激活配置指令
            <literal>SVNListParentPath</literal>:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNListParentPath on
  &hellip;
&lt;/Location&gt;
</programlisting>
          </informalexample>

      <!--
          <para>If a user now points her web browser to the
            URL <literal>http://host.example.com/svn/</literal>,
            she'll see a list of all Subversion repositories sitting
            in <filename>/var/svn</filename>.  Obviously, this can be
            a security problem, so this feature is turned off by
            default.</para>
      -->
          <para>如果某个用户在浏览器上打开了 URL
            <literal>http://host.example.com/svn/</literal>, 他将会看所有的
            位于 <filename>/var/svn</filename> 目录内的 Subversion 仓库. 这样
            做显然不太安全, 所以 <literal>SVNListParentPath</literal> 的默认
            值是 <literal>off</literal>.</para>

        </sect4>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.logging">
      <!--
        <title>Apache logging</title>
      -->
        <title>Apache 日志</title>

      <!--
        <para>Because Apache is an HTTP server at heart, it contains
          fantastically flexible logging features.  It's beyond the
          scope of this book to discuss all of the ways logging can be
          configured, but we should point out that even the most
          generic <filename>httpd.conf</filename> file will cause
          Apache to produce two logs:
          <filename>error_log</filename>
          and <filename>access_log</filename>.  These logs may appear
          in different places, but are typically created in the
          logging area of your Apache installation.  (On Unix, they
          often live
          in <filename>/usr/local/apache2/logs/</filename>.)</para>
      -->
        <para>Apache 本质上是一个 HTTP 服务器, 它支持异常灵活的日志特性. 讨论
          日志的所有配置方式已经超出了本书的范畴, 但我们必须指出的是即使是最
          普通的 <filename>httpd.conf</filename> 也会让 Apache 生成两种日志:
          <filename>error_log</filename> 和 <filename>access_log</filename>.
          这些日志可能会出现在不同的地方, 但通常都在 Apache 安装路径的日志
          目录内. (如果是 Unix 系统, 它们通常在
          <filename>/usr/local/apache2/logs/</filename>.)</para>

      <!--
        <para>The <filename>error_log</filename> describes any internal
          errors that Apache runs into as it works.
          The <filename>access_log</filename> file records every
          incoming HTTP request received by Apache.  This makes it
          easy to see, for example, which IP addresses Subversion
          clients are coming from, how often particular clients use
          the server, which users are authenticating properly, and
          which requests succeed or fail.</para>
      -->
        <para>文件 <filename>error_log</filename> 记录了 Apache 遇到的所有
          内部错误, 文件 <filename>access_log</filename> 则记录了 Apache 收
          到的每一个 HTTP 请求. 利用这些日志, 管理员就能很方便地看出 Subversion
          客户端来自哪个 IP, 特定客户端访问服务器的频率高低, 哪些用户认证成功,
          以及哪些请求成功或失败.</para>

      <!--
        <para>Unfortunately, because HTTP is a stateless protocol,
          even the simplest Subversion client operation generates
          multiple network requests.  It's very difficult to look at
          the <filename>access_log</filename> and deduce what the
          client was doing&mdash;most operations look like a series
          of cryptic <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal>, and <literal>REPORT</literal>
          requests.  To make things worse, many client operations send
          nearly identical series of requests, so it's even harder to
          tell them apart.</para>
      -->
        <para>不幸的是, 由于 HTTP 是一种无状态的协议, 即使是最简单的 Subversion
          客户端操作也会产生多个网络请求. 要想从
          <filename>access_log</filename> 推论出客户端在做什么操作是一件非常困
          难的工作&mdash;大多数操作看起来就像是一系列神秘的
          <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal> 和 <literal>REPORT</literal> 请求. 更为严重
          的是, 很多客户端操作发送的是几乎相同的请求序列, 这就使得分辨这些
          请求变得更加困难.</para>

      <!--
        <para><command>mod_dav_svn</command>, however, can come to
          your aid.  By activating an <quote>operational
          logging</quote> feature, you can
          ask <command>mod_dav_svn</command> to create a separate log
          file describing what sort of high-level operations your
          clients are performing.</para>
      -->
        <para>还好, <command>mod_dav_svn</command> 可以帮到你. 为了激活特性
          <quote>操作日志</quote> (operational logging), 管理员可以要求
          <command>mod_dav_svn</command> 创建一个单独的日志文件, 文件从较
          高的层次描述了客户端所执行的操作.</para>

      <!--
        <para>To do this, you need to make use of
          Apache's <literal>CustomLog</literal> directive (which is
          explained in more detail in Apache's own documentation).
          Be sure to invoke this
          directive <emphasis>outside</emphasis> your
          Subversion <literal>Location</literal> block:</para>
      -->
        <para>为了让 <command>mod_dav_svn</command> 从较高的层次描述客户端所
          执行的操作, 管理员需要使用 Apache 的配置指令
          <literal>CustomLog</literal> (关于该配置指令的详细信息可以参考
          Apache 的文档). 注意, 该配置指令必须出现在 Subversion 配置块
          <literal>Location</literal> 的 <emphasis>外面 </emphasis>:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  &hellip;
&lt;/Location&gt;

CustomLog logs/svn_logfile "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</programlisting>
        </informalexample>

      <!--
        <para>In this example, we're asking Apache to create a special
          logfile, <filename>svn_logfile</filename>, in the standard
          Apache <filename>logs</filename> directory.
          The <literal>%t</literal> and <literal>%u</literal>
          variables are replaced by the time and username of the
          request, respectively.  The really important parts are the
          two instances of <literal>SVN-ACTION</literal>.
          When Apache sees that variable, it substitutes the value of
          the <literal>SVN-ACTION</literal> environment variable,
          which is automatically set by <command>mod_dav_svn</command>
          whenever it detects a high-level client action.</para>
      -->
        <para>在上面的例子里, 我们请求 Apache 在标准的 <filename>log</filename>
          目录下创建一个特殊的日志文件: <filename>svn_logfile</filename>. 变
          量 <literal>%t</literal> 和 <literal>%u</literal> 分别被替换为请求
          接到的时间和用户名, 但其中最需要关注的是出现两次的
          <literal>SVN-ACTION</literal>.当 Apache 看见
          <literal>SVN-ACTION</literal> 时, 它把该字符串替换为环境变量
          <literal>SVN-ACTION</literal> 的值, 每当
          <command>mod_dav_svn</command> 检测到一个客户端操作时, 它就自动设置
          环境变量 <literal>SVN-ACTION</literal> 的值.</para>

      <!--
        <para>So, instead of having to interpret a
          traditional <filename>access_log</filename> like
          this:</para>
      -->
        <para>所以说, 我们不用面对像下面这样复杂的
          <filename>access_log</filename>:</para>

        <informalexample>
          <programlisting>
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
&hellip;
</programlisting>
        </informalexample>

      <!--
        <para>you can peruse a much more
          intelligible <filename>svn_logfile</filename> like
          this:</para>
      -->
        <para>你完全可以追求更容易理解的 <filename>svn_logfile</filename>:
        </para>

        <informalexample>
          <programlisting>
[26/Jan/2007:22:24:20 -0600] - get-dir /tags r1729 props
[26/Jan/2007:22:24:27 -0600] - update /trunk r1729 depth=infinity
[26/Jan/2007:22:25:29 -0600] - status /trunk/foo r1729 depth=infinity
[26/Jan/2007:22:25:31 -0600] sally commit r1730
</programlisting>
        </informalexample>

      <!--
        <para>In addition to the <literal>SVN-ACTION</literal>
          environment variable, <command>mod_dav_svn</command> also
          populates the <literal>SVN-REPOS</literal>
          and <literal>SVN-REPOS-NAME</literal> variables, which carry
          the filesystem path to the repository and the basename
          thereof, respectively.  You might wish to include references
          to one or both of these variables in
          your <literal>CustomLog</literal> format string, too,
          especially if you are combining usage information from
          multiple repositories into a single log file.  For an
          exhaustive list of all actions logged, see
          <xref linkend="svn.serverconfig.operational-logging"/>.</para>
      -->
        <para>除了环境变量 <literal>SVN-ACTION</literal>,
          <command>mod_dav_svn</command> 还会设置 <literal>SVN-REPOS</literal>
          和 <literal>SVN-REPOS-NAME</literal>, 这两个环境变量分别存放仓库的
          文件系统路径和路径的最后一个分量. 如果你想把多个仓库的日志写到同一
          个日志文件里, 那么你可能需要把这两个环境变量包含到
          <literal>CustomLog</literal> 格式字符串里. 可被日志记录的操作的详尽
          列表, 见 <xref linkend="svn.serverconfig.operational-logging"/>.
        </para>

      <!--
        <para>Obviously, the more information that Apache logs about
          your Subversion activities, the more disk space on your
          server those logs consume.  It is non uncommon for
          high-traffic Subversion servers to generate many gigabytes
          of log information daily.  Obviously, logs are only valuable
          if they can be meaningfully processed, and huge log files
          can quickly become unwieldy.  There are various standard
          approaches to Apache HTTP Server log management which are
          outside the scope of this book.  Administrators are
          encouraged to use the log rotation and archival approach
          which works best for them.</para>
      -->
        <para>显示, Apache 为 Subversion 所记录的日志越多, 服务器上的磁盘消耗
          也就越多, 对于非常活跃的 Subversion 服务器而言, 每天产生数兆大小的
          日志并不少见. 只有当日志能被有效地处理时, 它才是有价值的, 而庞大的
          日志文件很快就会让分析难以为继. 关于如何管理 Apache HTTP 服务器日志,
          有很多标准的做法可供参考, 介绍它们已经超出了本书的范畴, 管理员应该
          选择一种最适合他们的日志轮换与归档方式.</para>

      <!--
        <para>But what if Subversion is simply generating too much log
          information to be useful?  For example, in
          <xref linkend="svn.serverconfig.httpd.perf.bulk-updates" />,
          we mentioned that certain approaches that Subversion clients
          may take to checkouts and other update-style operations can
          cause rapid growth of your server logs as requests for
          individual pieces of the update data set are individually
          logged (whereas in previous version of Subversion, they
          might not have been).  In this case, you might consider
          using some Apache configuration magic to selectively silence
          some of that log activity.</para>
      -->
        <para>如果 Subversion 只是产生了太多没什么用的日志, 那又该怎么办?
          比如说在
          <xref linkend="svn.serverconfig.httpd.perf.bulk-updates" /> 我们
          说过 Subversion 客户端在执行检出和其他更新操作时, 所采取的特定
          方式将会导致服务器快速产生大量日志, 因为请求每一段数据的日志都是
          单独记录 (Subversion 以前的版本可能不会这样做). 在这种情况下, 管理
          员可能需要配置 Apache, 以便静默某些日志.</para>

      <!--
        <para>Apache HTTP Server's
          <command>mod_setenvif</command> module offers
          a <literal>SetEnvIf</literal> directive which is handy for
          conditionally setting environment variables.  And as it
          turns out, the <literal>CustomLog</literal> directive can be
          told to conditionally log requests based on the state of
          environment variables.  The following is a sample
          configuration which instructs the server
          to <emphasis>not</emphasis> log <literal>GET</literal>
          and <literal>PROPFIND</literal> requests aimed at private
          Subversion URLs.</para>
      -->
        <para>Apache HTTP 模块 <command>mod_setenvif</command> 提供了配置
          指令 <literal>SetEnvIf</literal>, 可根据条件设置环境变量. 利用
          <literal>SetEnvIf</literal>, 就可以让 <literal>CustomLog</literal>
          根据环境变量的状态, 有条件地为请求记录日志. 下面的配置示例告诉
          服务器不要为指向私有 Subversion URL 的 <literal>GET</literal> 和
          <literal>PROPFIND</literal> 请求记录日志.</para>

        <informalexample>
          <programlisting>
# Matches everything, just to initialize the "in_repos" variable.
SetEnvIf Request_URI "^" in_repos=0

# Set "in_repos" if this is a request for a private Subversion URL.
SetEnvIf Request_URI "/!svn/" in_repos=1

# Set "do_not_log" for non-public request types we don't care to log.
SetEnvIf Request_Method "GET" do_not_log
SetEnvIf Request_Method "PROPFIND" do_not_log

# Unset "do_not_log" for URLs that aren't private Subversion URLs.
SetEnvIf in_repos 0 !do_not_log

# Log requests, but only if "do_not_log" isn't set.
CustomLog logs/access_log env=!do_not_log
</programlisting>
        </informalexample>

      <!--
        <para>Using this configuration, <command>httpd</command> would
          still log <literal>GET</literal> requests aimed at public
          Subversion URLs.  These are the sorts of requests generated
          by a web browser as someone navigates the repository
          directly.  But <literal>GET</literal>
          and <literal>PROPFIND</literal> requests aimed at so-called
	  <quote>private</quote> Subversion URLs&mdash;which are the very sorts of
          requests used to fetch each and every individual file during
          a checkout operation&mdash;won't get logged.</para>
      -->
        <para>利用上面的配置, <command>httpd</command> 仍然会为指向公开的
          Subversion URL 的 <literal>GET</literal> 请求记录日志, 这些请求
          有可能是用户在网页上浏览仓库时产生的. 对于指向私有
          的 Subversion URL 的 <literal>GET</literal> 和
          <literal>PROPFIND</literal> 请求&mdash;这些请求可能是检出操作所
          产生的&mdash;将不会记录日志.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.writethruproxy">
      <!--
        <title>Write-through proxying</title>
      -->
        <title>直写代理</title>

        <para>
          <indexterm>
            <primary>WebDAV</primary>
            <secondary>proxies</secondary>
            <see>httpd, write-through proxies</see>
          </indexterm>
          <indexterm>
            <primary>httpd</primary>
            <secondary>write-through proxies</secondary>
            <tertiary>master</tertiary>
          </indexterm>
          <indexterm>
            <primary>httpd</primary>
            <secondary>write-through proxies</secondary>
            <tertiary>slave</tertiary>
          </indexterm>
          使用 Apache 作为 Subversion 服务器的一大好处是它可以用来实现简单的
          副本备份. 比如说, 你的团队分布在全球的四个办公室内, 而 Subversion
          仓库只能放在其中一个办公室中, 这就意味着其他三个办公室将享受不到好
          的访问体验&mdash;当他们更新和提交代码时, 看到的很可能是缓慢的响应
          时间. 对于这种问题, 最有效的解决方案是搭建一套系统, 该系统由一个
          Apache <firstterm>主</firstterm> (<firstterm>master</firstterm>)
          服务器与若干个 <firstterm>从</firstterm>
          (<firstterm>slave</firstterm>) 服务器组成. 如果在每一个办公室都放置
          一个从服务器, 当用户检出工作副本时, 将从最近的服务器上检出&mdash;所
          有的读操作都在本地的从服务器上完成, 写操作将被自动路由到主服务器.
          当提交完成时, 主服务器自动地使用备份工具 <command>svnsync</command>,
          把新版本号 <quote>推送</quote> 给其他所有的从服务器.</para>
      <!--
          One of the nice advantages of using Apache as a
          Subversion server is that it can be set up for simple
          replication.  For example, suppose that your team is
          distributed across four offices around the globe.  The
          Subversion repository can exist only in one of those
          offices, which means the other three offices will not enjoy
          accessing it&mdash;they're likely to experience
          significantly slower traffic and response times when
          updating and committing code.  A powerful solution is to set
          up a system consisting of one <firstterm>master</firstterm>
          Apache server and several <firstterm>slave</firstterm>
          Apache servers.  If you place a slave server in each office,
          users can check out a working copy from whichever slave
          is closest to them.  All read requests go to their local
          slave.  Write requests get automatically routed to the
          single master server.  When the commit completes, the master
          then automatically <quote>pushes</quote> the new revision to
          each slave server using the <command>svnsync</command>
          replication tool.</para>
      -->

      <!--
        <para>This configuration creates a huge perceptual speed
          increase for your users, because Subversion client traffic
          is typically 80&ndash;90% read requests.  And if those
          requests are coming from a <emphasis>local</emphasis>
          server, it's a huge win.</para>
      -->
        <para>上面的方案可以极大地提高用户的访问速度, 因为 Subversion 客户端
          所产生的网络流量中, 有 80&ndash;90% 都是读请求, 如果这些请求都由
          <emphasis>本地的</emphasis> 服务器进行处理, 将是一个很大的性能提升.
        </para>

      <!--
        <para>In this section, we'll walk you through a standard setup
          of this single-master/multiple-slave system.  However, keep
          in mind that your servers must be running at least Apache
          2.2.0 (with <command>mod_proxy</command> loaded) and
          Subversion 1.5 (<command>mod_dav_svn</command>).</para>
      -->
        <para>本节, 我们将介绍如何搭建一个标准的一主多从服务器系统, 注意,
          Apache 的版本至少是 2.2.0 (加载了模块 <command>mod_proxy</command>),
          Subversion (<command>mod_dav_svn</command>) 至少是 1.5.</para>

        <note>
      <!--
          <para>Ours is just one example of how you might setup a
            Subversion write-through proxy configuration.  There are
            other approaches.  For example, rather than having the
            master server push changes out to every slave server, the
            slaves could periodically pull those changes from the
            master.  Or perhaps the master could push changes to a
            single slave, which then pushes the same change to the
            next slave, and so on down the line.  Administrators are
            encouraged to use this section for basic understanding
            of what happens in a Subversion WebDAV proxy deployment
            scenario, and then implement the specific approach that
            works best for their organization.</para>
      -->
          <para>我们这里所介绍的方案, 只是配置 Subversion 直写代理的众多方案
            中的一种, 还有其他方案可供选择, 例如从服务器可以定期地从主服务器
            上拉取修改, 而不是主服务器主动向从服务器推送修改. 又或者是主服务
            器先将修改推送到某个从服务器, 这个从服务器再将相同的修改推送给下
            一个从服务器, 依次类推. 管理员可以先通过本节理解当部署 Subversion
            WebDAV 代理时, 发生了哪些事情, 然后再实现一种最适合自己的方案.
          </para>
        </note>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.configure">
      <!--
          <title>Configure the servers</title>
      -->
          <title>配置服务器</title>

      <!--
          <para>First, configure your master server's
            <filename>httpd.conf</filename> file in the usual way.
            Make the repository available at a certain URI location,
            and configure authentication and authorization however
            you'd like.  After that's done, configure each of your
            <quote>slave</quote> servers in the exact same way, but
            add the special <literal>SVNMasterURI</literal> directive
            to the block:</para>
      -->
          <para>首先, 按照通常的方式修改主服务器的
            <filename>httpd.conf</filename>, 使得仓库能在特定的 URI 位置被
            访问到, 按照你自己的需求, 配置认证与授权. 主服务器配置完成后,
            按照相同的步骤配置从服务器, 不过从服务器要额外配置一个
            <literal>SVNMasterURI</literal> 配置指令:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNPath /var/svn/repos
  SVNMasterURI http://master.example.com/svn
  &hellip;
&lt;/Location&gt;
</programlisting>
          </informalexample>

      <!--
          <para>This new directive tells a slave server to redirect
            all write requests to the master.  (This is done
            automatically via Apache's <command>mod_proxy</command>
            module.)  Ordinary read requests, however, are still
            serviced by the slaves.  Be sure that your master and
            slave servers all have matching authentication and
            authorization configurations;  if they fall out of sync,
            it can lead to big headaches.</para>
      -->
          <para>配置指令 <literal>SVNMasterURI</literal> 告诉从服务器把所有
            的写请求都重定向到主服务器 (写请求重定向由 Apache 模块
            <command>mod_proxy</command> 自动完成). 然而, 普通的读请求仍然由
            从服务器处理. 一定要确保主服务器和从服务器都配置了相同的认证与
            授权, 否则的话会非常让人头疼.</para>

      <!--
          <para>Next, we need to deal with the problem of infinite
            recursion.  With the current configuration, imagine what
            will happen when a Subversion client performs a commit to
            the master server.  After the commit completes, the server
            uses <command>svnsync</command> to replicate the new
            revision to each slave.  But because
            <command>svnsync</command> appears to be just another
            Subversion client performing a commit, the slave will
            immediately attempt to proxy the incoming write request
            back to the master!  Hilarity ensues.</para>
      -->
          <para>接下来, 我们需要解决无限递归的问题. 根据目前的配置, 想像一下
            当客户端向主服务器提交一个修改时, 将会发生什么现象. 当提交完成后,
            主服务器使用 <command>svnsync</command> 将新的版本号复制给每一个
            从服务器, 但是在从服务器看来, <command>svnsync</command> 只不过是
            提交修改的另一个客户端而已, 于是从服务器会马上把这个写请求重定向
            给主服务器, 这就导致了无限递归.</para>

      <!--
          <para>The solution to this problem is to have the master
            push revisions to a different
            <literal>&lt;Location&gt;</literal> on the slaves.  This
            location is configured to <emphasis>not</emphasis> proxy
            write requests at all, but to accept normal commits from
            (and only from) the master's IP address:</para>
      -->
          <para>解决办法是让主服务器把版本号复制到从服务器上与主服务器不同的
            <literal>&lt;Location&gt;</literal>, 这个位置
            <emphasis>不</emphasis> 设置写请求代理, 但接受且只接受从主服务器
            IP 地址发过来的提交:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn-proxy-sync&gt;
  DAV svn
  SVNPath /var/svn/repos
  Order deny,allow
  Deny from all
  # Only let the server's IP address access this Location:
  Allow from 10.20.30.40
  &hellip;
&lt;/Location&gt;
</programlisting>
          </informalexample>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.replicate">
      <!--
          <title>Set up replication</title>
      -->
          <title>设置备份</title>

      <!--
          <para>Now that you've configured
            your <literal>Location</literal> blocks on master and
            slaves, you need to configure the master to replicate to
            the slaves.  Our walkthough uses <command>svnsync</command>,
            which is covered in more detail in
            <xref linkend="svn.reposadmin.maint.replication.svnsync"
            />.</para>
      -->
        <para>主服务器和从服务器上的 <literal>Location</literal> 配置完毕后,
          接下来需要配置主服务器将修改复制给所有的从服务器, 其中需要用到
          <command>svnsync</command>, 关于该命令的详细介绍在
          <xref linkend="svn.reposadmin.maint.replication.svnsync"/>.</para>

      <!--
          <para>First, make sure that each slave repository has a
            pre-revprop-change hook script which
            allows remote revision property changes.  (This is
            standard procedure for being on the receiving end of
            <command>svnsync</command>.) Then log into the master
            server and configure each of the slave repository URIs to
            receive data from the master repository on the local
            disk:</para>
      -->
          <para>首先要确保的是从服务器上的每一个仓库都含有钩子脚本
            pre-revprop-change, 该脚本用于开启版本号属性修改 (修改版本号属性
            是接收端接收到 <command>svnsync</command> 结束时的标准步骤). 然后
            登录到主服务器, 将每一个从服务器的仓库配置为从主服务器本地磁盘上
            的仓库接收数据:</para>

          <informalexample>
            <screen>
$ svnsync init http://slave1.example.com/svn-proxy-sync \
               file:///var/svn/repos
Copied properties for revision 0.
$ svnsync init http://slave2.example.com/svn-proxy-sync \
               file:///var/svn/repos
Copied properties for revision 0.
$ svnsync init http://slave3.example.com/svn-proxy-sync \
               file:///var/svn/repos
Copied properties for revision 0.

# Perform the initial replication

$ svnsync sync http://slave1.example.com/svn-proxy-sync \
               file:///var/svn/repos
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
&hellip;

$ svnsync sync http://slave2.example.com/svn-proxy-sync \
               file:///var/svn/repos
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
&hellip;

$ svnsync sync http://slave3.example.com/svn-proxy-sync \
               file:///var/svn/repos
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
&hellip;
</screen>
          </informalexample>

      <!--
          <para>After this is done, we configure the master server's
            post-commit hook script to invoke
            <command>svnsync</command> on each slave server:</para>
      -->
          <para>上面的命令执行完后, 修改主服务器的钩子脚本 post-commit,
            使得在提交完成后, 调用 <command>svnsync</command> 将版本号复制
            给每一个从服务器:</para>

          <informalexample>
            <programlisting>
#!/bin/sh
# Post-commit script to replicate newly committed revision to slaves

svnsync sync http://slave1.example.com/svn-proxy-sync \
             file:///var/svn/repos &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync sync http://slave2.example.com/svn-proxy-sync \
             file:///var/svn/repos &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync sync http://slave3.example.com/svn-proxy-sync \
             file:///var/svn/repos &gt; /dev/null 2&gt;&amp;1 &amp;
</programlisting>
          </informalexample>

      <!--
          <para>The extra bits on the end of each line aren't
            necessary, but they're a sneaky way to allow the sync
            commands to run in the background so that the Subversion
            client isn't left waiting forever for the commit to
            finish.  In addition to this
            post-commit hook, you'll need a
            post-revprop-change hook as well so
            that when a user, say, modifies a log message, the slave
            servers get that change also:</para>
      -->
          <para>每一行末尾的 <literal>&amp;</literal> 并非绝对必需, 添加它的
            目的是为了让命令在后台执行, 于是 Subversion 客户端就不必等待
            post-commit 脚本里的命令全部执行完毕. 除了 post-commit 钩子脚本,
            管理员还要编写 post-revprop-change 钩子脚本, 以便在用户修改了版本
            号属性 (例如日志消息) 后, 从服务器也能接收到这个修改:</para>

          <informalexample>
            <programlisting>
#!/bin/sh
# Post-revprop-change script to replicate revprop-changes to slaves

REV=${2}
svnsync copy-revprops http://slave1.example.com/svn-proxy-sync \
                      file:///var/svn/repos \
                      -r ${REV} &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync copy-revprops http://slave2.example.com/svn-proxy-sync \
                      file:///var/svn/repos \
                      -r ${REV} &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync copy-revprops http://slave3.example.com/svn-proxy-sync \
                      file:///var/svn/repos \
                      -r ${REV} &gt; /dev/null 2&gt;&amp;1 &amp;
</programlisting>
          </informalexample>

      <!--
          <para>The only thing we've left out here is what to do about
            user-level locks (of the <command>svn lock</command>
            variety).  Locks are enforced by the master server during
            commit operations; but all the information about locks is
            distributed during read operations such as <command>svn
            update</command> and <command>svn status</command> by the
            slave server.  As such, a fully functioning proxy setup
            needs to perfectly replicate lock information from the
            master server to the slave servers.  Unfortunately, most
            of the mechanisms that one might employ to accomplish this
            replication fall short in one way or
            another<footnote><para><ulink
            url="http://subversion.tigris.org/issues/show_bug.cgi?id=3457"
            /> tracks these problems.</para></footnote>.  Many teams
            don't use Subversion's locking features at all, so this
            may be a nonissue for you.  Sadly, for those teams which
            do use locks, we have no recommendations on how to
            gracefully work around this shortcoming.</para>
      -->
          <para>现在还未处理的就是用户级别的锁 (也就是与
            <command>svn lock</command> 相关的锁), 在提交操作执行期间, 由主
            服务器完成锁的施加, 但是关于锁的全部信息在读取操作 (例如由从服务器
            负责处理的 <command>svn update</command> 和
            <command>svn status</command>) 执行期间, 需要进行分发. 因此,
            一个功能完善的代理设置需要把主服务器中与锁有关的信息复制到
            从服务器上. 不幸的是, 该问题的大多数解决方案无论如何都达不到要求
            <footnote><para><ulink
              url="http://subversion.tigris.org/issues/show_bug.cgi?id=3457" />
            记录了各种方案存在的问题.</para></footnote>. 很多团队根本就不使用
            Subversion 的锁, 所以这些解决方案存在的问题并不会给你带来麻烦.
            不过对于那些确实要用到锁的团队而言, 我们目前也无法提供有用的建议.
          </para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.caveats">
      <!--
          <title>Caveats</title>
      -->
          <title>警告</title>

      <!--
          <para>Your master/slave replication system should now be
            ready to use.  A couple of words of warning are in order,
            however.  Remember that this replication isn't entirely
            robust in the face of computer or network crashes.  For
            example, if one of the automated
            <command>svnsync</command> commands fails to complete for
            some reason, the slaves will begin to fall behind.  For
            example, your remote users will see that they've committed
            revision 100, but then when they run <command>svn
            update</command>, their local server will tell them that
            revision 100 doesn't yet exist!  Of course, the problem
            will be automatically fixed the next time another commit
            happens and the subsequent <command>svnsync</command> is
            successful&mdash;the sync will replicate all waiting
            revisions.  But still, you may want to set up some sort of
            out-of-band monitoring to notice synchronization failures
            and force <command>svnsync</command> to run when things go
            wrong.</para>
      -->
          <para>主从副本系统现在就可以正式工作了, 不过有些事情需要提前注意.
            这里介绍的副本策略不能抵抗服务器或网络崩溃的情况. 举例来说, 如果
            其中一个 <command>svnsync</command> 由于某种原因失败了, 那么从
            服务器就会悄无声息的失败, 即使有用户声称他们已经提交了版本号 100,
            但是后面执行 <command>svn update</command> 时, 本地从服务器将告诉
            他们版本号 100 并不存在! 当然, 如果又有新的提交发生, 并且随后的
            <command>svnsync</command> 都执行成功了, 那么问题就会被自动的修复
            &mdash;<command>svnsync</command> 会复制所以未复制的版本号. 不过
            管理员仍然想设置某种带外的监控, 以便能够侦测到失败的同步, 并强制
            运行 <command>svnsync</command>, 修正错误.</para>

      <!--
          <para>Another limitation of the write-through proxy
            deployment model involves version mismatches&mdash;of the
            version of Subversion which is installed, that
            is&mdash;between the master and slave servers.  Each new
            release of Subversion may (and often does) add new
            features to the network protocol used between the clients
            and servers.  Since feature negotiation happens against
            the slave, it is the slave's protocol version and feature
            set which is used.  But write operations are passed
            through to the master server quite literally.  Therefore,
            there is a risk that the slave server will answer a
            feature negotiation request from the client in way that is
            true for the slave, but untrue for the master if the
            master is running an older version of Subversion.  This
            could result in the client trying to use a new feature
            that the master doesn't understand, and failing.</para>
      -->
          <para>直写代理的另一个限制涉及到主服务器与从服务器的 Subversion
            版本不匹配. 新发布的 Subversion 很可能为服务器与客户端之间所使用
            的网络协议添加了新特性, 由于客户端只和从服务器进行特性协商, 因此
            最终使用的协议版本和特性集合由从服务器的 Subversion 版本决定.
            不过, 写操作是被逐字逐句地传递给主服务器, 因此, 如果主服务器的
            Subversion
            版本较旧, 从服务器在与客户端进行特性协商时, 可能会返回从服务器
            支持, 而主服务器不支持的特性, 结果是客户端使用了主服务器不理解的
            特性, 最终导致操作失败.</para>

      <!--
          <para>Subversion 1.8 helps to mitigate this problem via the
            introduction of a new Apache configuration
            directive, <literal>SVNMasterVersion</literal>.  By
            configuring each of your slave servers
            with <literal>SVNMasterVersion</literal> set to the
            release version of the Subversion instance which is
            running on your master server, the slave servers can more
            accurately negotiate feature support with the
            client.</para>
      -->
          <para>为了缓和上面的问题, Subversion 1.8 引入了一个新的 Apache 配置
            指令&mdash;<literal>SVNMasterVersion</literal>. 在每个从服务器上,
            把 <literal>SVNMasterVersion</literal> 都设置成主服务器的
            Subversion 版本号, 这样从服务器在与客户端协商特性时, 就会考虑到主
            服务器的 Subversion 版本.</para>

      <!--
          <para>Unfortunately, Subversion 1.7 doesn't offer
            the <literal>SVNMasterVersion</literal> configuration
            ### TODO
            directive and is known to have some specific problems
            along these lines.  If you are deploying a Subversion 1.7
            slave server in front of a pre-1.7 master, you'll want to
            configure your slave server's
            Subversion <literal>&lt;Location&gt;</literal> block with
            the <literal>SVNAdvertiseV2Protocol Off</literal>
            directive.</para>
      -->
          <para>不幸的是, Subversion 1.7 不支持配置指令
            <literal>SVNMasterVersion</literal>, 如果从服务器的版本是
            Subversion 1.7, 而主服务器的版本比 Subversion 1.7 旧, 那么管理员
            就需要在从服务器的 <literal>&lt;Location&gt;</literal> 配置块里
            加上配置指令 <literal>SVNAdvertiseV2Protocol Off</literal>.</para>

          <tip>
      <!--
            <para>For the best results possible, try to run the same
              version of Subversion on your master and slave
              servers.</para>
      -->
            <para>为了尽量减少可能的麻烦, 最好在主服务器和从服务器上运行相
              同版本的 Subversion.</para>
          </tip>

          <sidebar>
      <!--
            <title>Can We Set Up Replication with svnserve?</title>
      -->
            <title>是否可以用 svnserve 设置副本?</title>

      <!--
            <para>If you're using <command>svnserve</command> instead
              of Apache as your server, you can certainly configure
              your repository's hook scripts to invoke
              <command>svnsync</command> as we've shown here, thereby
              causing automatic replication from master to slaves.
              Unfortunately, at the time of this writing there is no way to
              make slave <command>svnserve</command> servers
              automatically proxy write requests back to the master
              server.  This means your users would only be able to
              check out read-only working copies from the slave
              servers.  You'd have to configure your slave servers to
              disallow write access completely.  This might be useful
              for creating read-only <quote>mirrors</quote> of popular
              open source projects, but it's not a transparent
              proxying system.</para>
      -->
            <para>如果管理员使用 <command>svnserve</command>&mdash;而不是
              Apache&mdash;作为服务器软件,那么仍然可以使用钩子脚本执行
              <command>svnsync</command>, 完成主服务器到从服务器的版本号复制.
              但不幸的是, 在撰写本书时, 还没有办法让 <command>svnserve</command>
              自动地把写请求重定向至主服务器, 这就意味着用户只能从从服务器上
              检出只读的工作副本, 管理员必须把从服务器配置成禁止写访问. 如果
              想创建某个开源项目的只读 <quote>镜像</quote>, 这倒是一种不错的
              办法, 但这就不是一个透明的代理系统了.</para>
          </sidebar>

        </sect4>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.other">
      <!--
        <title>Other Apache features</title>
      -->
        <title>Apache 的其他特性</title>

      <!--
        <para>Several of the features already provided by Apache in
          its role as a robust web server can be leveraged for
          increased functionality or security in Subversion as well.
          The Subversion client is able to use SSL (the Secure Sockets
          Layer, discussed earlier).  If your Subversion client is
          built to support SSL, it can access your Apache server
          using <literal>https://</literal> and enjoy a high-quality
          encrypted network session.</para>
      -->
        <para>作为一个优秀的网页服务器, Apache 提供的诸多特性同样也可以用于
          提高 Subversion 的功能性与安全性. 如果 Subversion 客户端在编译时
          打开了对 SSL (Secure Socket Layer, 安全套接字层, 前面我们已经介绍
          过了) 的支持, 客户端就可以使用 <literal>https://</literal> 形式
          的 URL 访问 Apache 服务器, 享受高质量的加密网络服务.</para>

      <!--
        <para>Equally useful are other features of the Apache and
          Subversion relationship, such as the ability to specify a
          custom port (instead of the default HTTP port 80) or a
          virtual domain name by which the Subversion repository
          should be accessed, or the ability to access the repository
          through an HTTP proxy.</para>
      -->
        <para>同样有用的特性还包括支持端口指定 (而不是使用默认的 HTTP 80 端口),
          或者是为 Subversion 仓库指定一个虚拟域名, 或者是支持通过 HTTP 代理
          访问仓库.</para>

      <!--
        <para>Finally, because <command>mod_dav_svn</command> is
          speaking a subset of the WebDAV/DeltaV protocol, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network <quote>shared folder.</quote> This is a
          complicated topic, but also wondrous when implemented.  For
          details, read <xref linkend="svn.webdav"/>.</para>
      -->
        <para>最后, 由于 <command>mod_dav_svn</command> 使用的是 WebDAV/DeltaV
          协议的一个子集, 所以说我们还可以通过第三方的 DAV 客户访问仓库. 大多
          数现代操作系统 (Win32, OS X 和 Linux) 都支持把 DAV 服务器作为一个
          标准的网络 <quote>共享目录</quote> 挂载到本地. 这是一个比较复杂
          的主题, 但是一旦实现就会觉得非常奇妙, 更多的细节见
          <xref linkend="svn.webdav"/>.</para>

      <!--
        <para>Note that there are a number of other small tweaks one
          can make to <command>mod_dav_svn</command> that perhaps do
          not merit extensive coverage.  For those interested,
          however, we provide a complete list of
          all <filename>httpd.conf</filename> directives
          to which <command>mod_dav_svn</command> responds in
          <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn"
          />.</para>
      -->
      <para>注意, 除了我们这里介绍的之外, <command>mod_dav_svn</command> 还
        有很多不常用的配置, 对于感兴趣的读者, 我们在
        <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" /> 列出了可用
        在 <filename>httpd.conf</filename> 中的所有
        <command>mod_dav_svn</command> 配置指令.</para>
      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.ref">
      <!--
      <title>Subversion Apache HTTP Server Configuration Reference</title>
      -->
      <title>Subversion Apache HTTP 服务器配置参考</title>

      <!--
      <para>In the previous sections, we've mentioned numerous
        directives that administrators can use in their
        <filename>httpd.conf</filename> files to enable and configure
        their Subversion server offering, introducing each directive
        as we also introduce the functionality it toggles.  In this
        section, we'll quickly summarize <emphasis>all</emphasis> the
        configuration directives supported by both of the Apache HTTP
        Server modules which are provided as part of the standard
        Subversion distribution.</para>
      -->
      <para>在上面一节, 我们介绍了很多配置指令, 通过在
        <filename>httpd.conf</filename> 中使用这些配置指令, 管理员就可以
        配置 Subversion 服务器的具体行为, 以及服务器所能提供的功能. 本节将
        快速总结 Subversion 提供的
        Apache HTTP 服务器模块的 <emphasis>所有</emphasis> 配置指令.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ref.mod_dav_svn">
      <!--
        <title>mod_dav_svn configuration directives</title>
      -->
        <title>mod_dav_svn 配置指令</title>

      <!--
        <para>The following configuration directives are recognized
          and supported by Subversion's Apache HTTP Server module,
          <command>mod_dav_svn</command>.</para>
      -->
        <para>下面是 Subversion 提供的 Apache HTTP 服务器模块
          <command>mod_dav_svn</command> 支持的所有配置指令.</para>

        <variablelist>
    
          <varlistentry>
            <term><literal>DAV svn</literal></term>
            <listitem>

      <!--
              <para>Must be included in any
                <literal>Directory</literal> or <literal>Location</literal>
                block for a Subversion repository.  It
                tells <command>httpd</command> to use the Subversion
                backend for <command>mod_dav</command> to handle all
                requests.</para>
      -->
              <para>必须被包含在 Subversion 仓库的 <literal>Directory</literal>
                或 <literal>Location</literal> 配置块内.
                <literal>DAV svn</literal> 告诉 <command>httpd</command>
                使用 Subversion 提供的 <command>mod_dav</command> 后端驱动
                处理所有的请求.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNActivitiesDB
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the location in the filesystem where the
                activities database should be stored.  By default,
                <command>mod_dav_svn</command> creates and uses a
                directory in the repository
                called <filename>dav/activities.d</filename>.  The
                path specified with this option must be an absolute
                path.</para>
      -->
              <para>指定活动数据库的存放目录. 默认情况下,
                <command>mod_dav_svn</command> 使用仓库中的
                <filename>dav/activities.d</filename> 作为活动数据库的存放
                目录 (若没有则创建该目录). 该选项所指定的目录路径必须是绝对
                路径.</para>

      <!--
              <para>If specified for
                an <literal>SVNParentPath</literal>
                area, <command>mod_dav_svn</command> appends the
                basename of the repository to the path specified here.
                For example:</para>
      -->
              <para>如果定义了 <literal>SVNParentPath</literal>,
                <command>mod_dav_svn</command> 就会把仓库路径的最后一个分量
                附加到 <literal>SVNActivitiesDB</literal> 所指定的路径上,
                例如:</para>

              <informalexample>
          <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository in 
  # /net/svn.nfs/repositories/foo
  SVNParentPath         "/net/svn.nfs/repositories"

  # any "/svn/foo" URL will map to an activities db in
  #  /var/db/svn/activities/foo
  SVNActivitiesDB       "/var/db/svn/activities"
&lt;/Location&gt;
</screen>
        </informalexample>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNAdvertiseV2Protocol On|Off</literal></term>
            <listitem>

      <!--
              <para>New to Subversion 1.7, this toggles
                whether <command>mod_dav_svn</command> advertises its
                support for the new version of its HTTP protocol also
                introduced in that version.  Most admins will not wish
                to use this directive (which is <literal>On</literal>
                by default), choosing instead to enjoy the performance
                benefits that the new protocol offers.  However, when
                configuring a server as a write-through proxy to
                another server which does not support the new
                protocol, set this directive's value
                to <literal>Off</literal>.</para>
      -->
              <para>在 Subversion 1.7 引入, 该配置指令决定
                <command>mod_dav_svn</command> 是否应该支持 1.7 引入的新版
                HTTP 协议. 大多数管理员都会选择禁止
                <literal>SVNAdvertiseV2Protocol</literal> (而默认值是
                <literal>On</literal>). 如果选择打开
                <literal>SVNAdvertiseV2Protocol</literal>, 就能享受到新版
                协议带来的性能提升. 然而, 如果服务器被设置为另一个服务器的
                直写代理, 而另一个服务器并不支持新版协议, 那就要设置成
                <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNAllowBulkUpdates On|Off|Prefer</literal></term>
            <listitem>

      <!--
              <para>Toggles support for all-inclusive responses to
                update-style requests.  Subversion clients use
                <literal>REPORT</literal> requests to get information
                about directory tree checkouts and updates from
                <command>mod_dav_svn</command>.  They can ask the
                server to send that information in one of two ways:
                with the entirety of the tree's information in one
                massive (bulk) response, or with a
                <firstterm>skelta</firstterm> (a skeletal
                representation of a tree delta) which contains just
                enough information for the client to know what
                <emphasis>additional</emphasis> data to fetch from the
                server using subsequent requests.  When this directive
                is included with a value of <literal>Off</literal>,
                <command>mod_dav_svn</command> will only ever respond
                to these <literal>REPORT</literal> requests with
                skelta responses, regardless of the type of responses
                requested by the client.</para>
      -->
              <para>该配置指令决定, 对于更新类型的请求, 是否支持全包含
                (all-inclusive) 的响应. Subversion 客户端通过发送请求
                <literal>REPORT</literal> 向服务器索取关于目录检出和更新
                的信息, 客户端可以请求服务器以两种方式之一返回信息: 在一个
                单独的响应中携带全部的信息, 或者是只返回一段概略性的信息,
                然后 Subversion 客户端再根据这段信息, 向服务器请求
                <emphasis>额外的</emphasis> 数据. 如果
                <literal>SVNAllowBulkUpdates</literal> 被设置成
                <literal>Off</literal>, <command>mod_dav_svn</command> 将
                按照第二种方式响应 <literal>REPORT</literal> 请求, 无论客户
                端所请求的是哪一种响应类型.</para>

      <!--
              <para>The default value of this directive is
                <literal>On</literal>, which permits the server to
                reply to update requests using the style of response
                (bulk or skelta) requested by the client.  Beginning
                in Subversion 1.8, this directive also accepts a value
                of <literal>Prefer</literal>, which is similar
                to <literal>On</literal> but additionally causes the
                server to announce to clients that it
                <emphasis>prefers</emphasis> to handle bulk update
                requests.</para>
      -->
              <para><literal>SVNAllowBulkUpdates</literal> 的默认值是
                <literal>On</literal>, 也就是说服务器会根据客户端所请求的
                响应类型来回复请求. 从 Subversion 1.8 开始,
                <literal>SVNAllowBulkUpdates</literal> 也可以被设置成
                <literal>Prefer</literal>, 它和 <literal>On</literal> 类似,
                但是服务器将向客户端宣告它 <emphasis>更喜欢</emphasis> 按
                照第一种方式处理更新请求.</para>

      <!--
              <para>Most folks won't need to use this directive at
                all.  It primarily exists for administrators who
                wish&mdash;for security or auditing reasons&mdash;to
                force Subversion clients to fetch individually all the
                files and directories needed for updates and
                checkouts, thus leaving an audit trail of
                <literal>GET</literal> and <literal>PROPFIND</literal>
                requests in Apache's logs.</para>
      -->
              <para>大多数人根本就不会用到这个配置指令, 它的存在主要是为了满足
                管理员的这种需要&mdash;为了安全或审计需要, 强迫 Subversion
                客户端在更新或检出时, 单独地抓取文件与目录, 从而在 Apache 的
                日志里留下请求 <literal>GET</literal> 和
                <literal>PROPFIND</literal> 的审计记录.</para>

            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>SVNAutoversioning On|Off</literal></term>
            <listitem>

      <!--
              <para>When its value is
                <literal>On</literal>, allows write requests from
                WebDAV clients to result in automatic commits.  A
                generic log message is auto-generated and attached to
                each revision.  If you enable autoversioning, you'll
                likely want to set <literal>ModMimeUsePathInfo
                On</literal> so that <command>mod_mime</command> can
                set <literal>svn:mime-type</literal> to the correct
                MIME type automatically (as best as
                <command>mod_mime</command> is able to, of course).
                For more information, see <xref
                linkend="svn.webdav"/>.  The default value of this
                directive is <literal>Off</literal>.</para>
      -->
              <para>如果配置指令的值是 <literal>On</literal>, 来自 WebDAV
                的写请求将自动生成提交, 版本号的日志消息也是一条自动生成的
                消息. 如果 <literal>SVNAutoversioning</literal> 的值是
                <literal>On</literal>, 你可能还需要设置上
                <literal>ModMimeUsePathInfo On</literal>, 于是
                <command>mod_mime</command> 就能自动地为文件设置正确的
                <literal>svn:mime-type</literal> 属性 (当然,
                <command>mod_mime</command> 也只能尽最大努力做到正确). 更多的
                细节见 <xref linkend="svn.webdav"/>.
                <literal>SVNAutoversioning</literal> 的默认值是
                <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNCacheFullTexts On|Off</literal></term>
            <listitem>

      <!--
              <para>When set to <literal>On</literal>, this tells
                Subversion to cache content fulltexts if sufficient
                in-memory cache is available, which could offer a
                significant performance benefit to the server.  (See
                also the <literal>SVNInMemoryCacheSize</literal>
                directive.)  The default value of this directive
                is <literal>Off</literal>.</para>
      -->
              <para>如果被设置成 <literal>On</literal>, 并且内存缓存足够,
                Subversion 将全文缓存文件的内容, 这可以极大地提升服务器的性能.
                (另请参阅 <literal>SVNInMemoryCacheSize</literal>) 默认值是
                <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>SVNCacheTextDeltas On|Off</literal></term>
            <listitem>

      <!--
              <para>When set to <literal>On</literal>, this tells
                Subversion to cache content deltas if sufficient
                in-memory cache is available, which could offer a
                significant performance benefit to the server.  (See
                also the <literal>SVNInMemoryCacheSize</literal>
                directive.)  The default value of this directive
                is <literal>Off</literal>.</para>
      -->
              <para>如果被设置成 <literal>On</literal> 并且内存缓存足够,
                Subversion 将缓存文件内容的差异部分, 这可以极大地提升服务器
                的性能. (另请参阅 <literal>SVNInMemoryCacheSize</literal>)
                默认值是 <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNCompressionLevel
              <replaceable>level</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the compression level used when sending
                file content over the network.  A value
                of <literal>0</literal> disables compression
                altogether, and <literal>9</literal> is the maximum
                value.  <literal>5</literal> is the default
                value.</para>
      -->
              <para>指定在网络上传输文件内容时所用的压缩级别. 把
                <literal>SVNCompressionLevel</literal> 设置成
                <literal>0</literal> 将禁止压缩, 最大值是 <literal>9</literal>,
                默认值是 <literal>5</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNHooksEnv
              <replaceable>file-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the location of the Subversion
                repository hook script environment configuration file.
                This file is used to describe the initial environment
                in which repository hook scripts are executed.  For
                more on this feature, see
                <xref linkend="svn.reposadmin.hooks.configuration"
                />.</para>
      -->
            <para>指定 Subversion 仓库钩子脚本环境配置文件的路径, 这个配置文件
              描述了钩子脚本运行时的初始环境, 更多的细节见
              <xref linkend="svn.reposadmin.hooks.configuration" />.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNIndexXSLT
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the URI of an XSL transformation for
                directory indexes.  This directive is optional.</para>
      -->
              <para>为目录索引指定一个 XML 变换规则的 URI, 该配置指令是可选的.
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNInMemoryCacheSize
              <replaceable>size</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the maximum size (in kbytes) per process
                of Subversion's in-memory object cache.  The default
                value is <literal>16384</literal>; use a value
                of <literal>0</literal> to deactivate this cache
                altogether.</para>
      -->
              <para>指定 Subversion 每个进程的内存对象缓存的最大大小 (单位
                KB). 默认值是 <literal>16384</literal>, 把
                <literal>SVNInMemoryCacheSize</literal> 设置为
                <literal>0</literal> 表示禁止缓存.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNListParentPath On|Off</literal></term>
            <listitem>

      <!--
              <para>When set to <literal>On</literal>, allows
                a <literal>GET</literal>
                of <literal>SVNParentPath</literal>, which results in
                a listing of all repositories under that path.  The
                default setting is
                <literal>Off</literal>.</para>
      -->
              <para>如果设置为 <literal>On</literal>, 将允许客户端向
                <literal>SVNParentPath</literal> 发送 <literal>GET</literal>
                请求, 请求的结果是返回目录 <literal>SVNParentPath</literal>
                下的所有仓库组成的列表. 默认值是 <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNMasterURI
              <replaceable>url</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies a URI to the master Subversion
                repository (used for a write-through proxy).</para>
      -->
              <para>指定 Subversion 主仓库的 URI (用于设置直写代理).</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNMasterVersion
              <replaceable>X.Y</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the release version number of the
                Subversion instance which is serving the master
                repository (used for a write-through proxy).</para>
      -->
              <para>指定主仓库的 Subversion 服务器的版本 (用于设置直写代理).
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNParentPath
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the location in the filesystem of a
                parent directory whose child directories are
                Subversion repositories.  In a configuration block for
                a Subversion repository, either this directive or
                <literal>SVNPath</literal> must be present, but not
                both.</para>
      -->
              <para>指定一个目录路径, 而该目录的子目录都是 Subversion 仓库.
                在一个 Subversion 仓库的配置块内, 要么出现
                <literal>SVNParentPath</literal>, 要么出现
                <literal>SVNPath</literal>, 但这两个配置指令不能同时出现或都
                不出现.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNPath
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the location in the
                filesystem for a Subversion repository's files.  In a
                configuration block for a Subversion repository,
                either this directive or
                <literal>SVNParentPath</literal> must be present, but
                not both.</para>
      -->
              <para>指定一个 Subversion 仓库的路径. 在一个 Subversion 仓库的
                配置块内, 要么出现 <literal>SVNPath</literal>, 要么出现
                <literal>SVNParentPath</literal>, 但这两个配置指令不能同时出
                现或都不出现.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNPathAuthz On|Off|short_circuit</literal></term>
            <listitem>

      <!--
              <para>Controls path-based authorization by enabling
                subrequests (<literal>On</literal>), disabling
                subrequests (<literal>Off</literal>; see <xref
                linkend="svn.serverconfig.httpd.authz.pathauthzoff"/>),
                or querying <command>mod_authz_svn</command> directly
                (<literal>short_circuit</literal>).  The default
                value of this directive is <literal>On</literal>.</para>
      -->
              <para>控制基于路径的授权检查, 控制方式包括允许子请求 (
                <literal>On</literal>), 禁止子请求 (<literal>Off</literal>, 见
                <xref linkend="svn.serverconfig.httpd.authz.pathauthzoff"/>),
                或者直接访问 <command>mod_authz_svn</command> (
                <literal>short_circuit</literal>). 默认值是
                <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNReposName
              <replaceable>name</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the name of a Subversion repository for
                use in <literal>HTTP GET</literal> responses.  This
                ### TODO
                value will be prepended to the title of all directory
                listings (which are served when you navigate to a
                Subversion repository with a web browser).  This
                directive is optional.</para>
      -->
              <para>指定 Subversion 仓库在 <literal>HTTP GET</literal> 响应
                中所使用的名字. 这个值将作为所有目录列表的标题 (使用网页浏览
                器浏览 Subversion 仓库时将会看到该标题). 该配置指令是可选的.
              </para>

               <note>
      <!--
                 <para>Subversion will not use the repository name as
                   configured via this directive when trying to match
                   rules in access control files.  The repository names
                   used in that file's syntax are always derived from
                   the repository URL.  See
                   <xref linkend="svn.serverconfig.pathbasedauthz.getting-started"
                   /> for details.</para>
      -->
               <para>当 Subversion 尝试匹配访问控制文件里的规则时, 不会用到
                 <literal>SVNReposName</literal> 所指定的名字. 用于匹配访问
                 控制文件的仓库名总是来自仓库的 URL, 更多的细节见
                 <xref
                   linkend="svn.serverconfig.pathbasedauthz.getting-started"/>.
               </para>
               </note>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNSpecialURI
              <replaceable>component</replaceable></literal></term>
            <listitem>

      <!--
              <para>Specifies the URI component (namespace) for
                special Subversion resources.  The default is
                <literal>!svn</literal>, and most
                administrators will never use this directive.  Set
                this only if there is a pressing need to have a file
                named <filename>!svn</filename> in your repository.
                If you change this on a server already in use, it will
                break all of the outstanding working copies, and your
                users will hunt you down with pitchforks and flaming
                torches.</para>
      -->
              <para>为特殊的 Subversion 资源指定 URI 分量 (名字空间). 默认
                值是 <literal>!svn</literal>, 绝大多数管理员从来不会用到这个
                配置指令, 除非仓库中有存在名为 <filename>!svn</filename> 的
                文件. 如果你在服务器投入使用后再修改此值, 那么所有已存在的
                工作副本都将无法正确工作, 用户也会把怒火发泄到你身上.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNUseUTF8 On|Off</literal></term>
            <listitem>

      <!--
              <para>When set to <literal>On</literal>,
                <command>mod_dav_svn</command> will communicate with
                hook scripts using repository root paths encoded in
                UTF-8, and will expect those scripts to likewise
                generate output (such as error messages) encoded in
                UTF-8.  The default value of this option
                is <literal>Off</literal>, which means
                that <command>mod_dav_svn</command> assumes a 7-bit
                ASCII encoding for its hook script interactions.  This
                option is available as of Subversion 1.8.</para>
      -->
              <para>如果设置为 <literal>On</literal>,
                <command>mod_dav_svn</command> 将使用 UTF-8 编码的仓库根目录
                路径与钩子脚本通信, 并且期望脚本的输出 (例如错误消息) 也是使
                用 UTF-8 编码. 默认值是 <literal>Off</literal>, 这意味着
                <command>mod_dav_svn</command> 将使用 ASCII 编码的仓库根目录
                路径与钩子脚本交互. 该配置指令在 Subversion 1.8 引进.</para>

              <note>
      <!--
                <para>Administrators should ensure that the character
                  set and encoding expectations of hook scripts match
                  all the ways they might be invoked.  For example, if
                  one repository is served by both <command>httpd</command>
                  and <command>svnserve</command>, <command>svnserve</command>
                  should also be configured to use UTF-8 (by setting
                  an appropriate locale in its environment) if this
                  option is enabled for <command>mod_dav_svn</command>.
                  Also, local filesystem paths containing non-ASCII
                  characters which will be accessed by those scripts
                  (such as repository root paths) must be properly
                  encoded in the filesystem to match the scripts'
                  expectations.</para>
      -->
                <para>管理员应该确保钩子脚本的字符集和编码方案与所有可能的调用
                  方式相匹配. 比如说, 某个仓库同时使用 <command>httpd</command>
                  和 <command>svnserve</command> 暴露给用户, 如果该配置指令
                  被设置为 <literal>On</literal>, 那么
                  <command>svnserve</command> 也要配置成使用 UTF-8 编码 (通过
                  在它的环境变量中设置合适的地区选项). 而且, 如果钩子脚本所
                  访问到的文件系统路径 (例如仓库根目录的路径) 包含了非 ASCII
                  码字符, 那么这些路径的编码也必须和脚本的编码方案相匹配.</para>
              </note>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ref.mod_authz_svn">
      <!--
        <title>mod_authz_svn configuration directives</title>
      -->
        <title>mod_authz_svn 配置指令</title>

      <!--
        <para>The following configuration directives are provided
          by <command>mod_authz_svn</command>, Subversion's path-based
          authorization Apache HTTP Server module.  For an in-depth
          description of using path-based authorization in Subversion,
          see <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>
      -->
        <para>以下的配置指令由 <command>mod_authz_svn</command> 提供, 它是
          Subversion 基于路径授权的 Apache HTTP 服务器模块. 关于如何在
          Subversion 中使用基于路径的授权, 见 <xref
            linkend="svn.serverconfig.pathbasedauthz"/>.</para>

        <variablelist>
   
          <varlistentry>
            <term><literal>AuthzForceUsernameCase Upper|Lower</literal></term>
            <listitem>

      <!--
              <para>Set to <literal>Upper</literal>
                or <literal>Lower</literal> to perform case conversion
                of the specified sort on the authenticated username
                before checking it for authorization.  While usernames
                are compared in a case-sensitive fashion against those
                referenced in the authorization rules file, this
                directive can at least normalize variably-cased
                usernames into something consistent.</para>
      -->
              <para>在检查授权之前, 把已认证的用户名转换成大写或小写形式. 当
                用户名与授权规则文件中记录的用户名相比较时, 是区分大小写的,
                这个配置指令可以把大小写混合的用户名转换成大小写一致的形式.
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNAccessFile
              <replaceable>file-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Consult <replaceable>file-path</replaceable> for
                access rules describing the permissions for paths in
                Subversion repository.  In a configuration
                block for a Subversion repository or a colletion of repositories,
                either this directive or
                <literal>AuthzSVNReposRelativeAccessFile</literal> can be
                present, but not both.</para>
      -->
              <para>在路径为 <filename>file-path</filename> 的文件中查找访问
                规则, 访问规则描述了 Subversion 仓库中的路径的权限. 在
                Subversion 仓库的配置块内, 可以出现这个配置指令或
                <literal>AuthzSVNReposRelativeAccessFile</literal>, 但不能同
                时出现.</para>

      <!--
              <para>Beginning with Subversion 1.8,
                <literal>AuthzSVNAccessFile</literal> accepts a URL to a file
                stored inside a Subversion repository&mdash;either the
                same repository to which the access rules are
                being applied, or an entirely different repository.</para>
      -->
              <para>从 Subversion 1.8 开始,
                <literal>AuthzSVNAccessFile</literal> 接受一个 URL 作为参数,
                这个 URL 指向了 Subversion 仓库内的一个文件, 这个仓库可以是
                应用规则文件的同一仓库或不同仓库.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNAnonymous On|Off</literal></term>
            <listitem>

      <!--
              <para>Set to <literal>Off</literal> to disable two
                special-case behaviours of this module: interaction
                with the <literal>Satisfy Any</literal> directive and
                enforcement of the authorization policy even when no
                <literal>Require</literal> directives are present.
                The default value of this directive is
                <literal>On</literal>.</para>
      -->
              <para>设置成 <literal>Off</literal>, 将禁止模块
                <command>mod_authz_svn</command> 的两个特例行为: 与配置指令
                <literal>Satisfy Any</literal> 的相互影响, 和强制实施授权策略
                (即使没有出现配置指令 <literal>Require</literal>). 该配置指令的
                默认值是 <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNAuthoritative On|Off</literal></term>
            <listitem>

      <!--
              <para>Set to <literal>Off</literal> to allow access
                control to be passed along to lower modules.  The
                default value of this directive is
                <literal>On</literal>.</para>
      -->
              <para>设置成 <literal>Off</literal> 将允许把访问控制传递到下层
                模块. 默认值是 <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNNoAuthWhenAnonymousAllowed On|Off</literal></term>
            <listitem>

      <!--
              <para>Set to <literal>On</literal> to suppress
                authentication and authorization for requests which
                anonymous users are allowed to perform.  The default
                value of this directive is
                <literal>On</literal>.</para>
      -->
              <para>设置成 <literal>On</literal> 将禁止匿名用户发来的请求的
                认证与授权检查, 默认值是 <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNReposRelativeAccessFile
              <replaceable>file-path</replaceable></literal></term>
            <listitem>

      <!--
              <para>Consult <replaceable>file-path</replaceable> for
                access rules describing the permissions for paths in
                Subversion repository.  Unlike
                <literal>AuthzSVNAccessFile</literal>, the path specified
                for <literal>AuthzSVNReposRelativeAccessFile</literal> is
                relative to the <filename>conf/</filename> directory in
                the repository on
                filesystem.  In other words, the <replaceable>file-path</replaceable>
                specifies a per repository file that must be accessible by
                the relative path for all repositories in a configuration block.
                In a configuration block for a Subversion repository or a collection
                of repositories either this directive or
                <literal>AuthzSVNAccessFile</literal> can be present, but not both.
                This option is available as of Subversion 1.7.</para>
      -->
              <para>在路径为 <filename>file-path</filename> 的文件中查找访问
                规则, 访问规则描述了 Subversion 仓库中的路径的权限. 和
                <literal>AuthzSVNAccessFile</literal> 不同的是,
                <literal>AuthzSVNReposRelativeAccessFile</literal> 定义的是相
                对于仓库中的 <filename>conf/</filename> 目录的路径. 换句话说,
                由 <filename>file-path</filename> 所指定的文件, 必须能让仓库
                通过相对路径访问到. 在仓库的配置块内, 可以出现配置指令
                <literal>AuthzSVNReposRelativeAccessFile</literal> 或
                <literal>AuthzSVNAccessFile</literal>, 但两者不能同时出现.
                该配置指令在 Subversion 1.7 引进.</para>

      <!--
              <para>Beginning with Subversion 1.8,
                <literal>AuthzSVNReposRelativeAccessFile</literal> accepts a
                URL to a file
                stored inside a Subversion repository&mdash;either the
                same repository to which the access rules are
                being applied, or an entirely different repository.</para>
      -->
              <para>从 Subversion 1.8 开始,
                <literal>AuthzSVNReposRelativeAccessFile</literal> 接受一个
                URL 作为参数, 这个 URL 指向了 Subversion 仓库内的一个文件,
                这个仓库可以是应用规则文件的同一仓库或不同仓库.</para>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.pathbasedauthz">

      <!--
    <title>Path-Based Authorization</title>
      -->
    <title>基于路径的授权</title>

      <!--
    <para>Both Apache and <command>svnserve</command> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).</para>
      -->
    <para>Apache 和 <command>svnserve</command> 都可以向用户授予或剥夺权限.
      权限通常是针对整个仓库: 允许 (或禁止) 用户读取仓库, 以及允许 (或禁止)
      用户写仓库.</para>

      <!--
    <para>It's also possible, however, to define finer-grained access
      rules.  One set of users may have permission to write to a
      certain directory in the repository, but not others; another
      directory might not even be readable by all but a few special
      people.  It's even possible to restrict access on a per file
      basis.</para>
      -->
    <para>实际上, 管理员还可以设置更加精细的访问规则. 例如允许一部分的用户 写
      仓库中的某个特定目录, 但禁止其他用户; 或者是禁止大部分用户读取某个特定的
      目录, 但允许少数用户读取. 访问规则的精细程度甚至可以细致到单个文件.
    </para>

      <!--
    <para>Both Subversion servers use a common file format to describe
      these path-based access rules.  In this section, we will
      explain that file format, as well how to configure your
      Subversion server to use it for managing path-based
      authorization.</para>
      -->
    <para>Apache 和 <command>svnserve</command> 使用相同的文件格式描述基于
      路径的访问规则. 本节我们将介绍文件的格式, 以及如何配置 Subversion 服务
      器, 以便利用规则文件管理基于路径的授权.</para>

    <sidebar>
      <!--
      <title>Do You Really Need Path-Based Access Control?</title>
      -->
      <title>你是否真得需要基于路径的访问控制?</title>

      <!--
      <para>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</para>
      -->
      <para>很多管理员在第一次配置 Subversion 时, 就急不可待地开始设置基于
        路径的授权. 管理员通常知道团队成员与项目的对应关系, 所以很容易就能
        决定应该把特定目录的权限授予给哪些人, 不授予给哪些人. 乍看起来非常
        自然, 还可以缓解管理员过度控制仓库的欲望.</para>

      <!--
      <para>Note, though, that there are often invisible (and
        visible!) costs associated with this feature.  In the visible
        category, the server needs to do a lot more work to ensure
        that the user has the right to read or write each specific
        path; in certain situations, there's very noticeable
        performance loss.  In the invisible category, consider the
        culture you're creating.  Most of the time, while certain
        users <emphasis>shouldn't</emphasis> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to
        maintain.</para>
      -->
      <para>但是, 这样做通常会产生一些可见 (和不可见) 的代价. 可见的代价是
        服务器需要做大量的配置工作, 以便确保用户对每个特定的目录都有正确的
        读写权限, 在某些情况下, 这会产生很明显的性能损失. 对于不可见的代价,
        考虑一下你所创建的文化. 在大多数情况下, 特定的用户
        <emphasis>不应该</emphasis> 向特定的仓库目录提交修改, 这种约定没必要
        通过技术手段加以约束. 团队成员有时候会不由自主地与他们协作, 例如通过
        向不属于他们的仓库目录提供修改, 帮助别人完成工作. 如果在服务器配置上
        禁止了这种形式的合作, 无形中就树起了一道协作屏障. 随着项目的发展与
        新成员的加入, 管理员需要不停地创建新规则, 这会带来大量额外的维护工作.
      </para>

      <!--
        <para>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something she
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, it's a
        social problem anyway, and that the problem needs to be dealt
        with outside Subversion.</para>
      -->
      <para>记住, 这是一个版本控制系统! 即使有人不小心向错误的目录提交了修改,
        这些修改也可以轻易地撤消. 如果用户故意向错误地目录提交修改, 这只能算
        作人际问题, 要在 Subversion 外部解决.</para>

      <!--
      <para>So, before you begin restricting users' access rights, ask
        yourself whether there's a real, honest need for this, or
        whether it's just something that <quote>sounds good</quote> to
        an administrator.  Decide whether it's worth sacrificing some
        server speed, and remember that there's very little risk
        involved; it's bad to become dependent on technology as a
        crutch for social problems.<footnote><para>A common theme in
        this book!</para></footnote></para>
      -->
  <para>所以, 在管理员限制用户的访问权限之前, 要问一下自己这是否真的有必要,
    是否只是为了 <quote>听起来不错</quote>, 是否值得牺牲服务器的性能. 放任
    用户的访问权限并不会带来非常大的风险, 而且依赖技术手段来解决社交问题是
    一种不好的做法!<footnote><para>这是本书的一个重要主题</para></footnote>
  </para>

      <!--
      <para>As an example to ponder, consider that the Subversion
        project itself has always had a notion of who is allowed to
        commit where, but it's always been enforced socially.  This is
        a good model of community trust, especially for open source
        projects.  Of course, sometimes there <emphasis>are</emphasis>
        truly legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</para>
      -->
      <para>考虑一个例子, 假设 Subversion 项目对哪些人应该向哪些目录提交
        有一套自己约定俗成的规则, 但这些规则总是通过社交来实施. 这是一种
        良好地社区信任模型, 特别是对于开源项目而言. 当然, 有时候确实需要
        基于路径的访问控制, 比如说在公司内部, 某些数据非常敏感, 只能把访问
        权授予给少数人.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.getting-started">

      <!--
      <title>Getting Started with Path-Based Access Control</title>
      -->
      <title>基于路径的访问控制</title>

      <!--
      <para>Subversion offers path-based access control in Apache via
        the <command>mod_authz_svn</command> module, which must be
        loaded using the <literal>LoadModule</literal> directive
        in <filename>httpd.conf</filename> in the same fashion
        that <command>mod_dav_svn</command> itself is loaded.  To
        enable the use of this module for your repositories, you'll
        add the <literal>AuthzSVNAccessFile</literal> or
        <literal>AuthzSVNReposRelativeAccessFile</literal> directives (again
        within the <filename>httpd.conf</filename> file) pointing to
        your own access rules file.  (For a full explanation, see
        <xref linkend="svn.serverconfig.httpd.authz.perdir"/>.)</para>
      -->
      <para>Subversion 通过模块 <command>mod_authz_svn</command> 向 Apache
        提供基于路径的访问控制, 模块 <command>mod_authz_svn</command> 必须
        在配置文件 <filename>httpd.conf</filename> 内, 使用配置指令
        <literal>LoadModule</literal> 进行加载, 加载方式与模块
        <command>mod_dav_svn</command> 相同. 为了让仓库能够使用这个模块,
        在配置文件 <filename>httpd.conf</filename> 内用配置指令
        <literal>AuthzSVNAccessFile</literal> 或
        <literal>AuthzSVNReposRelativeAccessFile</literal> 指定访问权限配置
        文件. (详细的说明见 <xref
          linkend="svn.serverconfig.httpd.authz.perdir"/>.)</para>

      <!--
      <para>To configure path-based authorization
        in <command>svnserve</command>, simply point
        the <literal>authz-db</literal> configuration variable (within
        your <filename>svnserve.conf</filename> file) to your access
        rules file.</para>
      -->
      <para>为了给 <command>svnserve</command> 配置基于路径的访问控制,
        只需要把 <filename>svnserve.conf</filename> 内的配置变量
        <literal>authz-db</literal> 的值指定成你的访问权限配置文件.</para>

      <!--
      <para>Once your server knows where to look for your access
        rules, it's time to define those rules.</para>
      -->
      <para>一旦服务器知道了去哪儿查找你的访问权限配置文件, 接下来需要做的就是
        定义访问规则.</para>

      <!--
      <para>The syntax of the Subversion access file is the same
        familiar one used by <filename>svnserve.conf</filename> and
        the runtime configuration files.  Lines that start with a hash
        (<literal>#</literal>) are ignored.  In its simplest form,
        each section names a versioned path and, optionally, the
        repository in which that path is found.  In other words,
        except for a few reserved sections, section names are of one
        of two forms: either <literal>[repos-name:path]</literal>
        or <literal>[path]</literal> when
        <literal>AuthzSVNAccessFile</literal> is used.  If you configured
        per repository access files via <literal>AuthzSVNReposRelativeAccessFile</literal>
        directive, you should always use <literal>[path]</literal> form
        only.  Authenticated usernames are the
        option names within each section, and an option's value
        describes that user's level of access to the repository path:
        either <literal>r</literal> (read-only) or <literal>rw</literal>
        (read/write).  If the user is not mentioned at all, no access is
        allowed.</para>
      -->
      <para>Subversion 访问权限配置文件的语法与 <filename>svnserve.conf</filename>
        和运行时配置文件的语法相同. 忽略以 <literal>#</literal> 开始的行,
        在最简单的形式中, 文件的每一节的名字都指定了一个被版本控制的路径,
        可能还指定了包含该路径的仓库. 换句话说, 除了少数几个被保留的节外,
        节名只有这两种形式: 如果使用了配置指令
        <literal>AuthzSVNAccessFile</literal>, 则要么是
        <literal>[repos-name:path]</literal>, 要么是 <literal>[path]</literal>.
        如果使用了配置指令 <literal>AuthzSVNReposRelativeAccessFile</literal>
        指定了每个仓库的访问权限配置文件, 则只能使用 <literal>[path]</literal>
        这种形式. 已认证的用户名是每一节的选项的名字, 选项的值描述了用户对该
        路径的访问权限: 只读 (<literal>r</literal>) 或读写
        (<literal>rw</literal>). 如果用户名未出现在节中, 则不具有该路径的
        任何访问权限.</para>

      <note>
      <!--
        <para>Paths used in access file sections must be specified
          using Subversion's <quote>internal style</quote>, which
          mostly just means that they are encoded in UTF-8 and use
          forward slash (<literal>/</literal>) characters as directory
          separators (even on Windows systems).  Note also that these
          paths do not employ any character escaping mechanism (such
          as URI-encoding)&mdash;spaces in path names should be
          represented exactly as such in access file section names
          (<literal>[repos-name:path&nbsp;with&nbsp;spaces]</literal>,
          e.g.)</para>
      -->
        <para>出现在访问权限配置文件中的路径必须使用 Subversion 的
          <quote>内部风格</quote> 编写, 在大部分情况下, 这意味着路径使用
          UTF-8 编码, 使用斜杠 (<literal>/</literal>) 作为路径中各个分量
          的分隔符 (即使是 Windows 系统, 也要使用斜杠). 还要注意这些路径
          中的字符不会进行任何形式地转义&mdash;比如说路径中的空格必须与
          文件中的节名 (例如
          <literal>[repos-name:path&nbsp;with&nbsp;spaces]</literal>) 完全
          一致.</para>
      </note>

      <!--
      <para>Here's a simple example demonstrating a piece of the
        access configuration which grants read access Sally, and
        read/write access to Harry, for the
        path <filename>/branches/calc/bug-142</filename> (and all its
        children) in the repository <literal>calc</literal>:</para>
      -->
      <para>下面是访问权限配置文件的一个例子, 文件把仓库 <literal>calc</literal>
        的路径 <filename>/branches/calc/bug-142</filename> (及其子目录) 的
        读权限授予 Sally, 把读写权限授予 Harry:</para>

      <informalexample>
        <programlisting>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</programlisting>
      </informalexample>

      <warning>
      <!--
        <para>Prior to version 1.7, Subversion treated repository names
          and paths in a case-insensitive fashion for the purposes of
          access control, converting them to lower case internally
          before comparing them against the contents of your access
          file.  It now does these comparisons case-sensitively.  If you
          upgraded to Subversion 1.7 from an older version, you should
          review your access files for case correctness.</para>
      -->
        <para>Subversion 1.7 之前的版本会把仓库名和路径都转化成小写形式后,
          再与访问权限配置文件进行匹配, 因此是不区分大小写的. 但从 Subversion 1.7
          开始不再如此. 因此, 如果你需要从较旧的版本升级到 1.7, 你应该重新
          检查访问权限配置文件中的大小写是否正确.</para>
      </warning>

      <!--
      <para>The name of a repository as evaluated by the authorization
        subsystem is derived directly from the repository's path.
        Exactly how this happens differs between the two server
        options. <command>mod_dav_svn</command> uses only the basename
        of the repository's root URL<footnote><para>Any human-readable
        name for a repository configured via
        the <literal>SVNReposName</literal> <filename>httpd.conf</filename>
        directive will be ignored by the authorization subsystem.
        Your access control file sections must refer to repositories
        by their server-sensitive paths as previously
        described.</para></footnote>,
        while <command>svnserve</command> uses the entire relative
        path from the serving root (as determined by
        its <option>- -root</option> (<option>-r</option>) command-line
        option) to the repository.</para>
      -->
      <para>被授权模块检查的仓库名直接来自仓库的路径, 具体的表现受到两个服务
        器选项的影响. <command>mod_dav_svn</command> 只使用仓库根目录 URL 的
        最后一个分量 <footnote><para>通过配置指令
            <literal>SVNReposName</literal>, 在 <filename>httpd.conf</filename>
            里配置的任意一个人类可读懂的仓库名, 都将被授权模块忽略. 前面已经
            说过, 访问权限配置文件里的节名必须引用到对服务器敏感的仓库路径.
        </para></footnote>, 而 <command>svnserve</command> 则使用完整的, 相对
        于服务器根目录 (由命令行选项 <option>--root</option>
        (<option>-r</option>) 指定) 的仓库路径.</para>

      <warning>
      <!--
        <para>The differences in the ways that a repository's name is
          determined by each of <command>mod_dav_svn</command>
          and <command>svnserve</command> can cause problems when
          trying to serve a repository via both servers
          simultaneously.  Naturally, an administrator would prefer to
          point both servers' configurations toward a common access
          file.  However, for this to work, you must ensure that the
          repository name portion of the file's section names are
          compatible with each server's idea of what the repository
          name should be&mdash;for example, by
          configuring <command>svnserve</command>'s root to be the
          same as <command>mod_dav_svn</command>'s configured
          <literal>SVNParentPath</literal>, or by using a different
          access file per repository so that section names needn't
          reference the repository at all.</para>
      -->
        <para>如果同时通过 Apache 服务器与 <command>svnserve</command> 为
          同一个仓库服务, 那么 <command>mod_dav_svn</command> 与
          <command>svnserve</command> 决定仓库名的不同之外将会带来问题.
          通常情况下, 管理员更喜欢为两种服务器配置同一个访问权限配置文件, 然而,
          为了能让访问权限配置文件正常工作, 管理员必须确保访问权限配置文件里
          的仓库名对于两种服务器而言都是兼容的&mdash;例如把
          <command>svnserve</command> 的根目录配置成和
          <command>mod_dav_svn</command> 的配置指令
          <literal>SVNParentPath</literal> 相同的值, 或者为每个仓库指定一个
          单独的访问权限配置文件, 这样就不用在文件里提到仓库名.</para>
      </warning>

      <!--
      <para>If you're using the <literal>SVNParentPath</literal>
        directive, it's important to specify the repository names in
        your sections.  If you omit them, a section such as
        <literal>[/some/dir]</literal> will match the path
        <filename>/some/dir</filename> in <emphasis>every</emphasis>
        repository.  If you're using the <literal>SVNPath</literal>
        directive, however, it's fine to provide only paths in your
        sections&mdash;after all, there's only one repository.</para>
      -->
      <para>如果你使用了配置指令 <literal>SVNParentPath</literal>, 在访问规则
        文件的节名中指定仓库名就非常重要, 因为如果省略了仓库名, 例如把节名写
        成 <literal>[/home/dir]</literal>, 那么该节将匹配
        <emphasis>每个</emphasis> 仓库中的 <filename>/some/dir</filename>.
        然而, 如果使用了配置指令 <literal>SVNPath</literal>, 那么在节名中
        只提供路径也是可以的&mdash;毕竟这时候只存在一个仓库.</para>

      <!--
      <para>Permissions are inherited from a path's parent directory.
        That means we can specify a subdirectory with a different
        access policy for Sally.  Let's continue our previous
        example, and grant Sally write access to a child of the branch
        that she's otherwise permitted only to read:</para>
      -->
      <para>路径的权限继承自父目录, 这意味着我们可以为 Sally 指定一个访问
        策略不同的子目录. 继续我们前面的例子, 现在我们要为 Sally 授予分支中
        某个子目录的写权限, 而 Sally 原来只对分支拥有只读权限.</para>

      <informalexample>
        <programlisting>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</programlisting>
      </informalexample>

      <!--
      <para>Now Sally can write to the <filename>testing</filename>
        subdirectory of the branch, but can still only read other parts.
        Harry, meanwhile, continues to have complete read/write access
        to the whole branch.</para>
      -->
      <para>现在 Sally 对分支的子目录 <filename>testing</filename> 拥有写权
        限, 但对于分支的其他部分仍然只具有只读权限. 而 Harry 对整个分支拥有
        读写权限.</para>

      <!--
      <para>It's also possible to explicitly deny permission to someone
        via inheritance rules, by setting the username variable to
        nothing:</para>
      -->
      <para>我们还可以通过规则的继承, 显式地阻止用户的权限, 方法是把用户名
        设置成空:</para>

      <informalexample>
        <programlisting>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</programlisting>
      </informalexample>

      <!--
      <para>In this example, Harry has read/write access to the
        entire <filename>bug-142</filename> tree, but has absolutely no
        access at all to the <filename>secret</filename> subdirectory
        within it.</para>
      -->
      <para>在这个例子里, Harry 对整个 <filename>bug-142</filename> 目录具有
        读写权限, 但却无法访问其中的子目录 <filename>secret</filename>.</para>

      <tip>
      <!--
        <para>The thing to remember is that the most specific path
          always matches first.  The server tries to match the path
          itself, and then the parent of the path, then the parent of
          that, and so on.  The net effect is that mentioning a specific
          path in the access file will always override any permissions
          inherited from parent directories.</para>
      -->
        <para>需要记住的是最明确的路径总是最先被匹配. 服务器总
          是试图匹配路径本身, 然后是路径的父路径, 然后再是父路径的父路径,
          以此类推. 这样做的影响是如果我们在访问权限配置文件里添加一个特定的
          路径, 那么它的权限配置就会覆盖从父目录继承而来的权限配置.</para>

      <!--
        <para>Similarly, sections that specify a repository name have
          precedence over those that don't: if both
          <literal>[calc:/some/path]</literal> and
          <literal>[/some/path]</literal> are present, the former will be used
          and the latter ignored for <literal>calc</literal>.</para>
      -->
        <para>类似的, 指定了仓库名的节的权限配置将覆盖那些没有指定仓库名的节,
          比如说访问权限配置文件里同时出现了 <literal>[calc:/some/path]</literal>
          和 <literal>[/some/path]</literal>, 那么对于仓库
          <literal>calc</literal>, 将会使用第一种配置, 而忽略第二种.</para>
      </tip>

      <!--
      <para>By default, nobody has any access to any repository at all.
        That means that if you're starting with an empty file, you'll
        probably want to give at least read permission to all users at
        the roots of the repositories.  You can do this by using the
        asterisk variable (<literal>*</literal>), which means <quote>all
        users</quote>:</para>
      -->
    <para>在默认情况下, 任何用户对任意一个仓库都不具备访问权限, 这意味着
      如果从头开始写访问权限配置文件, 你可能希望所有用户至少对仓库的根目录具有
      只读权限. 可以通过把用户名设置成通配符 (<literal>*</literal>) 实现这
      种配置, 此时通配符 <literal>*</literal> 表示 <quote>所有用户</quote>:
    </para>

      <informalexample>
        <programlisting>
[/]
* = r
</programlisting>
      </informalexample>

      <!--
      <para>This is a common setup; notice that no repository
        name is mentioned in the section name.  This makes all repositories
        world-readable to all users.  Once all users have read access to
        the repositories, you can give explicit
        <literal>rw</literal> permission to certain users on specific
        subdirectories within specific repositories.</para>
      -->
      <para>这是一种很常见的配置, 注意在节的名字中没有指定仓库的名字. 上面的
        配置将把所有仓库的读权限授予给所有用户. 一旦用户对仓库具有了读权限,
        接下来就可以根据具体的需要, 把特定仓库的特定目录的读写权限
        (<literal>rw</literal>) 授予特定的用户.</para>

      <!--
      <para>Note that while all of the previous examples use
        directories, that's only because defining access rules on
        directories is the most common case.  You may similarly
        restrict access on file paths, too.</para>
      -->
      <para>虽然前面的例子都是针对目录的权限配置, 因为这是最常见的情况,
        实际上管理员完全可以针对文件设置访问权限.</para>

      <informalexample>
        <programlisting>
[calendar:/projects/calendar/manager.ics]
harry = rw
sally = r
</programlisting>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.groups">

      <!--
      <title>Access Control Groups</title>
      -->
      <title>用户组</title>

      <!--
      <para>The access file also allows you to define whole groups of
        users, much like the Unix <filename>/etc/group</filename>
        file.  To do this, create a <literal>groups</literal> section
        in your access file, and then describe your groups within that
        section: each variable's name defines the name of the group,
        and its value is a comma-delimited list of usernames which
        are part of that group.</para>
      -->
      <para>访问权限配置文件还允许管理员定义用户组, 就像 Unix 里的
        <filename>/etc/group</filename>. 为了定义用户组, 在访问权限配置文件里
        创建一个名为 <literal>groups</literal> 的节, 然后在节内描述每一个
        用户组: 变量名定义了用户组的名字, 而变量的值则是逗号分隔的, 属于该
        用户组的用户名.</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, jane
</programlisting>
      </informalexample>

      <!--
      <para>Groups can be granted access control just like users.
        Distinguish them with an <quote>at sign</quote>
        (<literal>@</literal>) prefix:</para>
      -->
      <para>用户组的权限授予和用户名相同, 为了与用户名相区别, 在用户组的名字前
        要加一个 <literal>@</literal> 符号:</para>

      <informalexample>
        <programlisting>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
jane = r
@paint-developers = rw
</programlisting>
      </informalexample>

      <!--
      <para>Another important fact is that group permissions are not
        overridden by individual user permissions. Rather, the
        <emphasis>combination</emphasis> of all matching permissions is
        granted.  In the prior example, Jane is a member of the
        <literal>paint-developers</literal> group, which has read/write
        access.  Combined with the <literal>jane = r</literal> rule,
        this still gives Jane read/write access.  Permissions for group
        members can only be extended beyond the permissions the group
        already has. Restricting users who are part of a group to less
        than their group's permissions is impossible.</para>
      -->
      <para>需要特别注意的是用户组权限并不会被用户权限所覆盖, 而是会进行
        <emphasis>叠加</emphasis>. 在上面的例子里, Jane 是用户组
        <literal>paint-developers</literal> 的成员, 因此她对仓库
        <literal>paint</literal> 具有读写权限, 再叠加上
        <literal>jane = r</literal>, Jane 最终的权限仍然是可读写. 如果用户
        已经是某个用户组的成员, 那就不可能再把用户的权限限制得比用户组的权限
        还小.</para>

      <!--
      <para>Groups can also be defined to contain other groups:</para>
      -->
      <para>用户组还可以包含其他的用户组:</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</programlisting>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.aliases">

      <!--
      <title>Username Aliases</title>
      -->
      <title>用户别名</title>

      <!--
      <para>Some authentication systems expect and carry relatively
        short usernames of the sorts we've been describing
        here&mdash;<literal>harry</literal>,
        <literal>sally</literal>, <literal>joe</literal>, and so on.  But
        other authentication systems&mdash;such as those which use LDAP
        stores or SSL client certificates&mdash;may carry much more
        complex usernames.  For example, Harry's username in an
        LDAP-protected system might be <literal>CN=Harold
        Hacker,OU=Engineers,DC=red-bean,DC=com</literal>.  With
        usernames like that, the access file can become quite bloated
        with long or obscure usernames that are easy to
        mistype.</para>
      -->
      <para>某些认证系统仅支持相对较短的用户名, 例如 <literal>harry</literal>,
        <literal>sally</literal>, <literal>joe</literal> 这样简短的名字,
        而其他一些认证系统&mdash;例如那些使用了 LDAP 和 SSL 的认证系统&mdash;
        却支持更复杂的用户名, 例如在一个使用了 LDAP 的认证系统中, Harry 的
        用户名可以是
        <literal>CN=Harold Hacker,OU=Engineers,DC=red-bean,DC=com</literal>.
        如果在访问权限配置文件里出现这些用户名, 文件将变得非常臃肿, 这些又长又
        晦涩的用户名还很容易写错.</para>

      <!--
      <para>Fortunately, Subversion 1.5 introduced username aliases to
        the access file syntax.  Username aliases allow you to have to
        type the correct complex username only once, in a statement
        which assigns to it a more easily digestable alias.</para>
      -->
      <para>幸运的是, Subversion 1.5 为访问权限配置文件添加了对用户别名的支持.
        有了用户别名, 对于复杂的用户名, 管理员只需要在赋予别名的地方写一次
        就够了.</para>

      <!--
      <para>Username aliases are defined in the
        special <literal>aliases</literal> section of the access file,
        with each variable name in that section defining an alias, and
        the value of those variables carrying the real Subversion
        username which is being aliased.</para>
      -->
      <para>用户别名定义在访问权限配置文件的一个特殊的节&mdash;
        <literal>aliases</literal>, 节内的每一个变量名都定义了一个别名, 而
        变量值则是真实的用户名.</para>

      <informalexample>
        <programlisting>
[aliases]
harry = CN=Harold Hacker,OU=Engineers,DC=red-bean,DC=com
sally = CN=Sally Swatterbug,OU=Engineers,DC=red-bean,DC=com
joe = CN=Gerald I. Joseph,OU=Engineers,DC=red-bean,DC=com
&hellip;
</programlisting>
      </informalexample>

      <!--
      <para>Once you've defined a set of aliases, you can refer to the
        users elsewhere in the access file via their aliases in all the
        same places you could have instead used their actual usernames.
        Simply prepend an ampersand to the alias to distinguish it from
        a regular username:</para>
      -->
      <para>用户别名定义完成后, 在访问权限配置文件内, 只要是能出现真实用户名的
        地方都能用别名替代, 唯一的区别是要在别名前添加符号
        <literal>&amp;</literal>, 以便与真实的用户名进行区分.</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = &amp;harry, &amp;sally, &amp;joe
paint-developers = &amp;frank, &amp;sally, &amp;jane
everyone = @calc-developers, @paint-developers
</programlisting>
      </informalexample>

      <!--
      <para>You might also choose to use aliases if your users'
        usernames change frequently.  Doing so allows you to need to
        update only the aliases table when these username changes occur,
        instead of doing global search-and-replace operations on the
        whole access file.</para>
      -->
      <para>如果用户名经常发生变化, 那么使用别名也能带来方便. 利用别名, 当
        用户名发生变化时, 只需要在定义别名的地方更新一次即可, 而不用在整个
        文件内搜索并替换.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.authclass-tokens">

      <!--
      <title>Advanced Access Control Features</title>
      -->
      <title>访问权限控制的高级特性</title>

      <!--
      <para>Beginning with Subversion 1.5, the access file syntax also
        supports some <quote>magic</quote> tokens for helping you to
        make rule assignments based on the user's authentication
        class.  One such token is
        the <literal>$authenticated</literal> token.  Use this token
        where you would otherwise specify a username, alias, or group
        name in your authorization rules to declare the permissions
        granted to any user who has authenticated with any username at
        all.  Similarly employed is the <literal>$anonymous</literal>
        token, except that it matches everyone who has
        <emphasis>not</emphasis> authenticated with a username.</para>
      -->
      <para>从 Subversion 1.5 开始, 访问权限配置文件还支持一些
        <quote>魔力</quote> 符号, 这些符号可以帮助管理员基于用户的认证类别来
        制定访问规则. 其中一个符号是 <literal>$authenticated</literal>,
        用于将权限授予给所有已认证的用户. 类似的还有
        <literal>$anonymous</literal>, 它表示所有 <emphasis>未认证</emphasis>
        的用户.</para>

      <informalexample>
        <programlisting>
[calendar:/projects/calendar]
$anonymous = r
$authenticated = rw
</programlisting>
      </informalexample>

      <!--
      <para>Another handy bit of access file syntax magic is the use
        of the tilde (<literal>~</literal>) character as an exclusion
        marker.  In your authorization rules, prefixing a username,
        alias, group name, or authentication class token with a tilde
        character will cause Subversion to apply the rule to users who
        do <emphasis>not</emphasis> match the rule.  Though somewhat
        unnecessarily obfuscated, the following block is equivalent to
        the one in the previous example:</para>
      -->
      <para>访问权限配置文件语法的另一个很有用的魔力符号是波浪号
        (<literal>~</literal>), 用于排除某些用户. 在访问权限配置文件中, 如果
        在用户名, 用户别名, 用户组或认证类别前加上波浪号, 就表示将访问权限
        授予给与规则 <emphasis>不匹配</emphasis> 的用户. 虽然下面的配置容易
        让人产生不必要的困惑, 但它和上面的例子是等效的:</para>

      <informalexample>
        <programlisting>
[calendar:/projects/calendar]
~$authenticated = r
~$anonymous = rw
</programlisting>
      </informalexample>

      <!--
      <para>A less obvious example might be as follows:</para>
      -->
      <para>下面是一个更恰当的, 使用 <literal>~</literal> 的例子:</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = &amp;harry, &amp;sally, &amp;joe
calc-owners = &amp;hewlett, &amp;packard
calc = @calc-developers, @calc-owners

# Any calc participant has read-write access...
[calc:/projects/calc]
@calc = rw

# ...but only allow the owners to make and modify release tags.
[calc:/projects/calc/tags]
~@calc-owners = r
</programlisting>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.gotchas">

      <!--
      <title>Some Gotchas with Access Control</title>
      -->
      <title>访问权限控制的一些陷阱</title>

      <!--
      <para>If you're using Apache as your Subversion server and have
        made certain subdirectories of your repository unreadable to
        certain users, you need to be aware of a possible nonoptimal
        behavior with <command>svn checkout</command>.</para>
      -->
      <para>如果你使用 Apache 作为 Subversion 服务器, 而且还设置了仓库的
        某些子目录对某些用户是不可读的, 那么在执行
        <command>svn checkout</command> 时, 你需要意识到可能会出现的低效
        行为.</para>

      <!--
      <para>Depending on which HTTP communication library the
        Subversion client is using, it may request that the entire
        payload of a checkout or update be delivered in a single
        (often large) response to the primary checkout/update request.
        When this happens, this single request is the
        <emphasis>only</emphasis> opportunity Apache has to demand
        user authentication.  This has some odd side effects.  For
        example, if a certain subdirectory of the repository is
        readable only by user Sally, and user Harry checks out a
        parent directory, his client will respond to the initial
        authentication challenge as Harry.  As the server generates
        the large response, there's no way it can resend an
        authentication challenge when it reaches the special
        subdirectory; thus the subdirectory is skipped altogether,
        rather than asking the user to reauthenticate as Sally at the
        right moment.</para>
      -->
      <para>取决于 Subversion 客户端所使用的 HTTP 函数库, 它可能会要求检出或
        更新的全部载荷在一个单独的响应中递送, 当这种情况发生时, 一开始的认证
        请求就是 Apache 向用户要求认证的 <emphasis>唯一</emphasis> 机会,
        这会产生一些很奇怪的副作用. 比如说, 如果仓库的某个子目录只有 Sally
        具有读权限, 而 Harry 检出了该目录的父目录, 他的客户端将以 Harry 的身
        份完成最初的认证. 随着服务器向客户端发送大块的响应数据, 当发送 Harry
        不具有读权限的那个子目录时, 服务器再也没有办法再次发送认证请求, 于是
        该子目录被忽略, 而用户却无法通过重新以 Sally 的身份进行认证来避免这
        种情况.</para>

      <!--
      <para>In a similar way, if the root of the repository is
        anonymously world-readable, the entire checkout will be done
        without authentication&mdash;again, skipping the unreadable
        directory, rather than asking for authentication partway
        through.<footnote><para>For more on this, see the blog
        post <emphasis>Authz and Anon Authn Agony</emphasis> at
        <ulink url="http://blogs.collab.net/subversion/2007/03/authz_and_anon_/"
        />.</para></footnote></para>
      -->
      <para>类似的道理, 如果仓库的根目录对于匿名用户是可读的, 那么检出整个仓库
        时就不会向用户要求认证&mdash;同样, 服务器将直接忽略不可读的目录, 而不
        会在检出到一半时向用户要求认证.<footnote><para>关于这个问题的更多信息,
        见
        <ulink url="http://blogs.collab.net/subversion/2007/03/authz_and_anon_/"
          /> 的博文 <emphasis>Authz and Anon Authn Agony</emphasis>.</para>
      </footnote></para>
      <!-- TODO: Merge content from the blog post into the book. --> 

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.operational-logging">
      <!--
    <title>High-level Logging</title>
      -->
    <title>高层日志记录</title>

      <!--
    <para>Both the Apache <command>httpd</command>
      and <command>svnserve</command> Subversion servers provide
      support for high-level logging of Subversion operations.
      Configuring each of the server options to provide this level of
      logging is done differently, of course, but the output from each
      is designed to conform to a uniform syntax.</para>
      -->
    <para>Apache 的 <command>httpd</command> 和 Subversion 的
      <command>svnserve</command> 都支持在较高的层次为 Subversion 操作记录
      日志. 虽然这两种服务器配置高层日志的方式不太一样, 但它们输出的日志都
      遵循相同的语法.</para>

      <!--
    <para>To enable high-level logging in <command>svnserve</command>,
      you need only use the <option>- -log-file</option> command-line
      option when starting the server, passing as the value to the
      option the file to which <command>svnserve</command> should
      write its log output.</para>
      -->
    <para>为了让 <command>svnserve</command> 开启高层日志, 只需在启动
      <command>svnserve</command> 时带上选项 <option>--log-file</option>,
      选项的值是日志文件路径.</para>

    <informalexample>
      <screen>
$ svnserve -d -r /path/to/repositories --log-file /var/log/svn.log
</screen>
    </informalexample>

      <!--
    <para>Enabling the same in Apache is a bit more involved, but is
      essentially an extension of Apache's stock log output
      configuration mechanisms&mdash;see
      <xref linkend="svn.serverconfig.httpd.extra.logging"/> for
      details.</para>
      -->
    <para>在 Apache 中启用高层日志要稍微复杂一些, 但本质上就是 Apache 日志
      输出机制的扩展, 配置方式见 <xref
        linkend="svn.serverconfig.httpd.extra.logging"/>.</para>

      <!--
    <para>The following is a list of Subversion action log messages
      produced by its high-level logging mechanism, followed by one or
      more examples of the log message as it appears in the log
      output.</para>
      -->
    <para>下面列出了在启用高层日志后, 服务器将为 Subversion 记录的日志消息列表,
      还给出了具体的日志消息示例.</para>

    <variablelist>
      <varlistentry>
      <!--
        <term>Checkout or export</term>
      -->
        <term>检出或导出</term>
        <listitem>
          <programlisting>
checkout-or-export /path r62 depth=infinity
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Commit</term>
      -->
        <term>提交</term>
        <listitem>
          <programlisting>
commit harry r100
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Diffs</term>
      -->
        <term>差异比较</term>
        <listitem>
          <programlisting>
diff /path r15:20 depth=infinity ignore-ancestry
diff /path1@15 /path2@20 depth=infinity ignore-ancestry
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Fetch a directory</term>
      -->
        <term>抓取一个目录</term>
        <listitem>
          <programlisting>
get-dir /trunk r17 text
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Fetch a file</term>
      -->
        <term>抓取一个文件</term>
        <listitem>
          <programlisting>
get-file /path r20 props
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Fetch a file revision</term>
      -->
        <term>抓取一个文件版本号</term>
        <listitem>
          <programlisting>
get-file-revs /path r12:15 include-merged-revisions
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Fetch merge information</term>
      -->
        <term>抓取合并信息</term>
        <listitem>
          <programlisting>
get-mergeinfo (/path1 /path2)
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Lock</term>
      -->
        <term>加锁</term>
        <listitem>
          <programlisting>
lock /path steal
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Log</term>
      -->
        <term>日志</term>
        <listitem>
          <programlisting>
log (/path1,/path2,/path3) r20:90 discover-changed-paths revprops=()
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Replay revisions (svnsync)</term>
      -->
        <term>重放版本号 (<command>svnsync</command>)</term>
        <listitem>
          <programlisting>
replay /path r19
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Revision property change</term>
      -->
        <term>修改版本号属性</term>
        <listitem>
          <programlisting>
change-rev-prop r50 propertyname
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Revision property list</term>
      -->
        <term>版本号属性列表</term>
        <listitem>
          <programlisting>
rev-proplist r34
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Status</term>
      -->
        <term>状态</term>
        <listitem>
          <programlisting>
status /path r62 depth=infinity
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Switch</term>
      -->
        <term>切换</term>
        <listitem>
          <programlisting>
switch /pathA /pathB@50 depth=infinity
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Unlock</term>
      -->
        <term>解锁</term>
        <listitem>
          <programlisting>
unlock /path break
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
      <!--
        <term>Update</term>
      -->
        <term>更新</term>
        <listitem>
          <programlisting>
update /path r17 send-copyfrom-args
</programlisting>
        </listitem>
      </varlistentry>
    </variablelist>

      <!--
    <para>As a convenience to administrators who wish to post-process
      their Subversion high-level logging output (perhaps for
      reporting or analysis purposes), Subversion source code
      distributions provide a Python module (located at
      <filename>tools/server-side/svn_server_log_parse.py</filename>)
      which can be used to parse Subversion's log output.</para>
      -->
    <para>为了方便管理员对 Subversion 高层日志输出进行后期处理, Subversion
      源代码包提供了一个 Python 模块, (位于
      <filename>tools/server-side/svn_server_log_parse.py</filename>),
      可用于解析 Subversion 的日志.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.optimization">
      <!--
    <title>Server Optimization</title>
      -->
    <title>服务器优化</title>

      <!--
    <para>Part of the due diligence when offering a service such as a
      Subversion server involves capacity planning and performance
      tuning.  Subversion doesn't tend to be particularly greedy in
      terms of server resources such as CPU cycles and memory, but any
      service can benefit from optimizations, especially when usage of
      ### TODO
      the service skyrockets<footnote><para>In Subversion's case, the
      skyrocketing affect is, of course, due to its cool name.  Well,
      that and its popularity, reliability, ease of
      use&hellip;.</para></footnote>.  In this section, we'll discuss
      some ways you can tweak your Subversion server configuration
      to offer even better performance and scalability.</para>
      -->
    <para>在向用户提供 Subversion 服务时, 一个尽职的管理员还应该考虑容量规划
      与性能调优. Subversion 对于服务器资源 (例如 CPU 和内存) 并不是非常贪婪,
      但是任意一个服务都能从优化中获益, 特别是当服务的使用量急剧增加时. 本节
      我们将介绍如何调整服务器配置, 以便 Subversion 提供更好的性能与可扩展性.
    </para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.optimization.caching">
      <!--
      <title>Data Caching</title>
      -->
      <title>数据缓存</title>

      <!--
      <para>Generally speaking, the most expensive part of a
        Subversion server's job is fetching data from the repository.
        Subversion 1.6 attempted to offset this cost by introducing
        some in-memory caching of certain classes of data read from
        the repository.  But Subversion 1.7 takes this a step further,
        not only caching the results of some of the more costly
        operations, but also by providing in each of the available
        servers the means by which fine-tune the size and some
        behaviors of the cache.</para>
      -->
      <para>一般来说, Subversion 服务器代价最高的工作就是从仓库中读取数据,
        Subversion 1.6 试图通过在内存中缓存特定种类的数据来减小这种代价.
        Subversion 1.7 在这方面走得更远, 它不仅缓存了代价较高的操作的执行
        结果, 还向服务器提供了调整缓存大小与行为的方法.</para>

      <!--
      <para>For <command>svnserve</command>, you can specify the size
        of the cache using the <option>- -memory-cache-size</option>
        (<option>-M</option>) command-line option.  You can also
        dictate whether <command>svnserve</command> should attempt to
        cache content fulltexts and deltas via the
        boolean <option>- -cache-fulltexts</option>
        and <option>- -cache-txdeltas</option> options,
        respectively.</para>
      -->
      <para>对于 <command>svnserve</command>, 管理员可以通过命令行选项
        <option>--memory-cache-size</option> (<option>-M</option>) 指定缓存
        的大小, 还可以通过布尔选项 <option>--cache-fulltexts</option> 和
        <option>--cache-txdeltas</option>, 分别指定是否需要缓存文件内容的
        全文本与差异文本.</para>

      <informalexample>
        <screen>
$ svnserve -d -r /path/to/repositories \
           --memory-cache-size 1024 \
           --cache-txdeltas yes \
           --cache-fulltexts yes
&hellip;
$
</screen>
      </informalexample>

      <!--
      <para><command>mod_dav_svn</command> provides the same degree of
        cache configurability via <filename>httpd.conf</filename>
        directives.
        The <literal>SVNInMemoryCacheSize</literal>,
        <literal>SVNCacheFullTexts</literal>,
        and <literal>SVNCacheTextDeltas</literal> directives may be
        used at the server configuration level to control Subversion's
        data cache characteristics:</para>
      -->
      <para><command>mod_dav_svn</command> 向 <filename>httpd.conf</filename>
        提供了等价的缓存配置, 与上面三个 <command>svnserve</command> 命令行
        选项对应的配置指令分别是 <literal>SVNInMemoryCacheSize</literal>,
        <literal>SVNCacheFullTexts</literal> 和
        <literal>SVNCacheTextDeltas</literal>:</para>

      <informalexample>
        <programlisting>
&lt;IfModule dav_svn_module&gt;
  # Enable a 1 Gb Subversion data cache for both fulltext and deltas.
  SVNInMemoryCacheSize 1048576
  SVNCacheTextDeltas On
  SVNCacheFullTexts On
&lt;/IfModule&gt;
</programlisting>
      </informalexample>

      <!--
      <para>So what settings should you use?  Certainly you need to
        consider what resources are available on your server.  To get
        any benefit out of the cache at all, you'll probably want to
        let the cache be at least large enough to hold all the files
        which are most commonly accessed in your repository (for
        example, your project's <filename>trunk</filename> directory
        tree).</para>
      -->
      <para>那么, 应该把这些选项设置成什么值呢? 当然, 你需要考虑服务器的哪些
        资源是可用的. 为了尽量从缓存中获益, 缓存的大小应至少能够存放仓库中最
        常被访问的全部文件 (例如项目的主干分支 <filename>trunk</filename>).
      </para>

      <tip>
      <!--
        <para>Setting the memory cache size to <literal>0</literal>
          will disable this enhanced caching mechanism and cause
          Subversion to fall back to using the older cache mechanisms
          introduced in Subversion 1.6.</para>
      -->
        <para>把缓存大小设置成 <literal>0</literal> 将使得 Subversion 转而
          使用 1.6 引入的旧的缓存机制.</para>
      </tip>

      <note>
      <!--
        <para>Currently, only repositories which make use of the FSFS
          backend data store make use of this data caching
          functionality.</para>
      -->
        <para>到目前为止, 只有使用了 FSFS 作为后端存储的仓库才能利用本节
          提到的缓存功能.</para>
      </note>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.optimization.compression">
      <!--
      <title>Network Compression of Data</title>
      -->
      <title>网络数据压缩</title>

      <!--
      <para>Compressing the data transmitted across the wire can
        greatly reduce the size of those network transmissions, but
        comes at the cost of server (and client) CPU cycles.
        Depending on your server's CPU capacity, the typical access
        patterns of the clients who use your servers, and the
        bandwidth of the networks between them, you might wish to fine
        tune just how hard your server will work to compress the data
        it sends across the wire.  To assist with this fine tuning
        process, Subversion 1.7 offers
        the <option>- -compression</option> (<option>-c</option>)
        option to <command>svnserve</command> and
        the <literal>SVNCompressionLevel</literal> directive
        for <command>mod_dav_svn</command>.  Both accept a value which
        is an integer between 0 and 9 (inclusive), where 9 offers the
        best compression of wire data, and 0 disables compression
        altogether.</para>
      -->
      <para>对数据进行压缩后再传输, 可以大大减少网络流量, 但这也会造成服务
        器端 (和客户端) 消耗更多的 CPU 资源. 根据服务器的 CPU 能力, 客户端
        访问服务器的典型模式, 以及客户端与服务器之间的网络带宽, 管理员可能会
        想调整服务器应该尽多大的努力来压缩数据. 为了帮助管理员进行这种调整,
        Subversion 1.7 为 <command>svnserve</command> 提供了选项
        <option>--compression</option> (<option>-c</option>), 为
        <command>mod_dav_svn</command> 提供了配置指令
        <literal>SVNCompressionLevel</literal>, 它们都接受一个 0 到 9 (含 9)
        之间的整数, 9 表示尽最大努力压缩数据, 0 则禁止压缩.</para>

      <!--
      <para>For example, on a local area network (LAN) with 1-Gigabit
        connections, it might not make sense to have the server
        compress its network transmissions (which also forces the
        clients to decompress them), as the network itself is so fast
        that users won't really benefit from the smaller overall
        network payload.  On the other hand, servers which are
        accessed primarily by clients with low-bandwidth connections
        would be doing those clients a favor by minimizing the overall
        size of its network communications.</para>
      -->
      <para>比如说, 在一个 1 G 带宽的本地局域网 (LAN) 内, 服务器就没必要对
        待传输的数据进行压缩 (如果服务器对数据进行了压缩, 客户端在接收到数据
        后还要解压), 因为网速已经足够快了, 即使对待传输的数据进行压缩, 用户
        也不会感觉到明显的性能提升. 另一方面, 如果访问服务器的大多数客户端,
        其网络带宽都比较低, 那么对待传输的数据进行压缩可以大大改善用户检验.
      </para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">

      <!--
    <title>Supporting Multiple Repository Access Methods</title>
      -->
    <title>支持多种仓库访问方法</title>

      <!--
    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible&mdash;or safe&mdash;for your
      repository to be accessed by multiple methods simultaneously?
      ### TODO
      The answer is yes, provided you use a bit of foresight.</para>
      -->
    <para>读者已经见到了访问仓库的多种方式, 但是否有可能同时以多种方式
      (安全地) 访问仓库? 答案是肯定的.</para>

      <!--
    <para>At any given time, these processes may require read and
      write access to your repository:</para>
      -->
    <para>在任意时刻, 下面这些进程都可能需要仓库的读写权限:</para>

    <itemizedlist>
      <listitem>
      <!--
        <para>Regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <literal>file://</literal> URLs</para>
      -->
        <para>普通的系统用户使用 Subversion 客户端 (以用户的身份运行), 通过
          URL <literal>file://</literal> 直接访问仓库</para>
      </listitem>
      <listitem>
      <!--
        <para>Regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves), which access the repository</para>
      -->
        <para>普通的系统用户连接到 SSH 派生的私有 <command>svnserve</command>
          进程 (以用户的身份运行), 通过该进程修改仓库</para>
      </listitem>
      <listitem>
      <!--
        <para>An <command>svnserve</command> process&mdash;either a
          daemon or one launched by
          <command>inetd</command>&mdash;running as a particular fixed
          user</para>
      -->
        <para>以特定身份运行的 <command>svnserve</command> 进程&mdash;
          或者是一个守护进程, 或者由 <command>inetd</command> 启动</para>
      </listitem>
      <listitem>
      <!--
        <para>An Apache <command>httpd</command> process, running as a
          particular fixed user</para>
      -->
        <para>一个 Apache <command>httpd</command> 进程, 以一个特定的身份
          运行</para>
      </listitem>
    </itemizedlist>

      <!--
    <para>The most common problem administrators run into is
      repository ownership and permissions.  Does every process (or
      user) in the preceding list have the rights to read and write the
      repository's underlying data files?  Assuming you have a
      Unix-like operating system, a straightforward approach might be
      to place every potential repository user into a
      new <literal>svn</literal> group, and make the repository wholly
      owned by that group.  But even that's not enough, because a
      process may write to the database files using an unfriendly
      umask&mdash;one that prevents access by other users.</para>
      -->
    <para>如果仓库要同时支持多种访问方式, 那么管理员最常遇到的问题通常与仓库
      的所有权和权限有关. 前面列表中提到的进程 (或用户) 是否应该具有读写仓库
      底层数据文件的权限? 假设你有一个类 Unix 系统, 一种比较简单直接的做法是
      把所有可能使用仓库的用户都加入到名为 <literal>svn</literal> 的用户组,
      而用户组 <literal>svn</literal> 对仓库拥有完整的所有权. 但这样做还不足够,
      因为进程可能使用了不太友好的文件模式创建屏蔽字&mdash;该进程创建的文件
      完全禁止了其他进程的访问.</para>

      <!--
    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first runs <userinput>umask 002</userinput> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <userinput>umask
      002</userinput> command to Apache's own startup script,
      <filename>apachectl</filename>.  For example:</para>
      -->
    <para>因此, 为仓库用户创建了公共的用户组之后, 下一步是强制每一个访问仓库
      的进程使用一个合理的文件模式创建屏蔽字. 对于直接访问仓库的用户, 你可以
      把程序 <command>svn</command> 封装成一个脚本, 脚本首先执行
      <userinput>umask 002</userinput>, 然后再运行真实的 <command>svn</command>
      程序. 你也可以为 <command>svnserve</command> 程序写一个类似的封装脚本,
      以及在 Apache 的启动脚本 <filename>apachectl</filename> 内添加一行
      <userinput>umask 002</userinput>. 例如:</para>

    <informalexample>
      <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"
</screen>
    </informalexample>

      <!--
    <para>Another common problem is often encountered on Unix-like
      systems.  If your repository is backed by Berkeley DB, for
      example, it occasionally creates new log files to journal its
      actions.  Even if the Berkeley DB repository is wholly owned by
      the <literal>svn</literal> group, these newly created log files
      won't necessarily be owned by that same group, which then
      creates more permissions problems for your users.  A good
      workaround is to set the group SUID bit on the
      repository's <filename>db</filename> directory.  This causes all
      newly created log files to have the same group owner as the
      parent directory.</para>
      -->
    <para>在类 Unix 系统上还会遇到另一个常见的问题: 比如说, 如果你的仓库是使用
      Berkeley DB 作为后端存储, 那么它很少会去创建新的日志文件来记录自己的
      操作. 即使整个仓库都被用户组 <literal>svn</literal> 所拥有, 这些新创建
      的日志文件也不一定属于用户组 <literal>svn</literal>, 这会导致更多的权限
      问题. 一种比较好的解决办法是为仓库的 <filename>db</filename> 子目录设置
      SUID, 这将使得所有新创建的日志文件都具有和父目录相同的用户组.</para>

      <!--
    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write access to common files are classic
      ones that are not often elegantly solved.</para>
      -->
    <para>一旦你克服了这些困难, 此时仓库对于所有必要的进程来说, 应该都是可访问
      的了. 虽然看起来可能有点凌乱和复杂, 但是对于如何处理多个用户共享相同文件
      的写权限这个问题, 一直都没有一个优雅的解决办法.</para>

      <!--
    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs&mdash;they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URL.
      And maintaining multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend that you choose a single server that best meets your
      needs and stick with it!</para>
      -->
    <para>幸运的是, 大多数仓库管理员 <emphasis>不必</emphasis> 进行这么复杂
      的配置. 如果用户想访问托管在本机上的仓库, 除了
      <literal>file://</literal>, 其实还可以使用 <literal>http://</literal> 或
      <literal>svn://</literal>, 在填写主机名时需要写成
      <literal>localhost</literal>. 为仓库支持多种访问方法可能比看上去更麻烦,
      我们建议你选择一种满足自己需要的访问方式, 然后坚持用它!</para>

    <sidebar>
      <!--
      <title>The svn+ssh:// Server Checklist</title>
      -->
      <title>svn+ssh:// 服务器检查列表</title>

      <!--
      <para>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of the
        topics discussed in this section:</para>
      -->
      <para>对于已经有了 SSH 账户的用户, 为了让他们共享仓库而不会产生权限上
        的问题, 其中的过程可能会比较麻烦. 如果你 (作为一个管理员) 对需要在类
        Unix 系统上完成的工作不太清楚, 这里列出了一个检查列表, 总结了本节
        讨论的几个主题:</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>All of your SSH users need to be able to read and
            write to the repository, so put all the SSH users into a
            single group.</para>
      -->
          <para>所有的 SSH 用户都需要仓库的读写权限, 因此要把他们都放到一个
            用户组内.</para>
        </listitem>
        <listitem>
      <!--
          <para>Make the repository wholly owned by that group.</para>
      -->
          <para>仓库完全被用户组所拥有.</para>
        </listitem>
        <listitem>
      <!--
          <para>Set the group permissions to read/write.</para>
      -->
          <para>把用户组的权限设置成可读写.</para>
        </listitem>
        <listitem>
      <!--
          <para>Your users need to use a sane umask when accessing the
            repository, so make sure <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename>, or wherever it
            lives in <literal>$PATH</literal>) is actually a wrapper
            script that runs <userinput>umask 002</userinput> and
            executes the real <command>svnserve</command>
            binary.</para>
      -->
          <para>在访问仓库时, 用户需要使用合理的文件模式创建屏蔽字, 因此把
            可执行文件 <command>svnserve</command> 包装成一个脚本, 脚本先执行
            <userinput>umask 002</userinput>, 然后再运行真实的
            <command>svnserve</command> 程序.</para>
        </listitem>
        <listitem>
      <!--
          <para>Take similar measures when using
            <command>svnlook</command> and
            <command>svnadmin</command>.  Either run them with a sane
            umask or wrap them as just described.</para>
      -->
          <para>采取类似的方式处理 <command>svnlook</command> 和
            <command>svnadmin</command>, 例如先设置好文件模式创建屏蔽字再执行
            命令, 或者使用和上面一样的包装脚本.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
