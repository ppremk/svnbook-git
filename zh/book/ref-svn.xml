<!-- -*- sgml -*- -->

<reference id="svn.ref.svn">
  <title>svn 参考手册&mdash;Subversion 命令行客户端</title>
    
  <partintro>
      <!--
    <para><command>svn</command> is the official command-line client
      of Subversion.  Its functionality is offered via a collection of
      task-specific subcommands, most of which accept a number of
      options for fine-grained control of the program's
      behavior.</para>
      -->
    <para><command>svn</command> 是 Subversion 官方的命令行客户端, 通过一
      系列特定于任务的子命令向用户提供功能, 大多数子命令都接受很多参数, 用
      于精细地控制程序的行为.</para>

      <!--
    <para>When using the <command>svn</command> program, subcommands
      and other non-option arguments must appear in a specified order
      on the command line.  Options, on the other hand, may appear
      anywhere on the command line (after the program name, of
      course), and in general, their order is irrelevant.  For
      example, all of the following are valid ways to use <command>svn
      status</command>, and are interpreted in exactly the same
      way:</para>
      -->
    <para>使用 <command>svn</command> 程序时, 子命令和非选项参数必须按照特定
      的顺序出现在命令行上, 但是选项却可能以任意地顺序出现 (当然, 选项必须
      出现在程序名之后), 通常情况下选项的顺序是无关紧要的. 例如, 下面的命令
      都是 <command>svn status</command> 的有效使用形式, 而且都是按照相同的
      方式进行解释:</para>

    <informalexample>
      <screen>
$ svn -vq status myfile
$ svn status -v -q myfile
$ svn -q status -v myfile
$ svn status -vq myfile
$ svn status myfile -qv
</screen>
    </informalexample>

      <!--
    <para>The following sections describe each of the various
      subcommands and options provided by the <command>svn</command>
      command-line client program, including some examples of each
      subcommand's typical uses.</para>
      -->
    <para>下面几节介绍了各个子命令以及 <command>svn</command> 的命令行选项,
      同时还展示了每个子命令的典型用法.</para>

      <!--
    <para>While Subversion has different options for its
      subcommands, all options exist in a single
      namespace&mdash;that is, each option is guaranteed to mean the
      roughly same thing regardless of the subcommand you use it
      with.  For example, <option>- -verbose</option>
      (<option>-v</option>) always means <quote>verbose
      output,</quote> regardless of the subcommand you use it
      with.</para>
      -->
    <para>虽然各个子命令的选项不完全相同, 但所有的选项都在同一个名字空间内
      &mdash;无论对于哪个子命令, 选项的意义是完全相同的. 例如无论用户执行
      的是哪个子命令, 选项 <option>--verbose</option> (<option>-v</option>)
      的意义总是 <quote>详细输出</quote>.</para>

      <!--
    <para>The <command>svn</command> command-line client usually
      exits quickly with an error if you pass it an option which
      does not apply to the specified subcommand.  But as of
      Subversion 1.5, several of the options which apply to
      all&mdash;or nearly all&mdash;of the subcommands have been
      deemed acceptable by all subcommands, even if they have no
      effect on some of them.  (This change was made primarily to
      improve the client's ability to called from custom wrapping
      scripts.)  These options appear grouped together in the
      command-line client's usage messages as global options, as can
      be seen in the following bit of output:</para>
      -->
    <para>如果用户向 <command>svn</command> 传递了子命令不支持的选项, 那么
      程序通常会马上报错退出, 但是从 Subversion 1.5 开始, 有几个选项可被
      所有 (或者说几乎所有) 的子命令支持, 因此它们就被当成了可被所有的子命
      令接受, 即使该选项对子命令不会产生任何效果. (这种行为主要是为了方便从
      定制化的封装脚本中调用 <command>svn</command>.) 这些选项作为全局选项
      出现在命令行客户端的帮助信息中, 可以用下面的命令看到它们:</para>

    <informalexample>
      <screen>
$ svn help upgrade
upgrade: Upgrade the metadata storage format for a working copy.
usage: upgrade [WCPATH...]

  Local modifications are preserved.

Valid options:
  -q [--quiet]             : print nothing, or only summary information

Global options:
  --username ARG           : specify a username ARG
  --password ARG           : specify a password ARG
  --no-auth-cache          : do not cache authentication tokens
  --non-interactive        : do no interactive prompting (default is to prompt
                             only if standard input is a terminal device)
  --force-interactive      : do interactive prompting even if standard input
                             is not a terminal device
  --trust-server-cert      : accept SSL server certificates from unknown
                             certificate authorities without prompting (but only
                             with '--non-interactive')
  --config-dir ARG         : read user configuration files from directory ARG
  --config-option ARG      : set user configuration option in the format:
                                 FILE:SECTION:OPTION=[VALUE]
                             For example:
                                 servers:global:http-library=serf
$
</screen>
    </informalexample>

      <!--
    <para><command>svn</command> subcommands recognize the following
      options:</para>
      -->
    <para><command>svn</command> 的子命令支持以下选项:</para>
      
    <variablelist id="svn.ref.svn.sw">
      <!--
      <title>svn Options</title>
      -->
      <title>svn 选项</title>
      
      <varlistentry id="svn.ref.svn.sw.accept">
        <term><option>--accept</option> <replaceable>ACTION</replaceable></term>
        <listitem>
      <!--
          <para>Specifies an action for automatic conflict
            resolution, disabling the interactive prompts which ask
            the user how to handle each conflict as it is noticed.
            Though which of the specific actions are applicable
            differs depending on which subcommand is in use,
            Subversion supports the following long (and short)
            values for <replaceable>ACTION</replaceable>:</para>
      -->
          <para>为自动的冲突解决指定处理措施, 当 Subversion 注意到冲突发生时不
            会再询问用户如何处理. Subversion 支持的
            <replaceable>ACTION</replaceable> 如下所示, 但不同的子命令, 其可用
            的 <replaceable>ACTION</replaceable> 是不同的:</para>
          <variablelist>
            <varlistentry>
              <term><literal>postpone</literal>
                (<literal>p</literal>)</term>
              <listitem>
      <!--
                <para>Take no resolution action at all and instead
                  allow the conflicts to be recorded for future
                  resolution.</para>
      -->
                <para>对冲突不采取任何措施, 将冲突记录起来, 以便稍后再作处理.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>edit</literal>
                (<literal>e</literal>)</term>
              <listitem>
      <!--
                <para>Open each conflicted file in a text editor for
                  manual resolution of line-based conflicts.</para>
      -->
                <para>在文本编辑器中打开每一个冲突文件, 由用户手工处理冲突.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>launch</literal>
                (<literal>l</literal>)</term>
              <listitem>
      <!--
                <para>Launch an interactive merge conflict
                  resolution tool for each conflicted file.</para>
      -->
                <para>为每一个冲突文件调用交互式的冲突合并工具.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>base</literal></term>
              <listitem>
      <!--
                <para>Choose the file that was the (unmodified)
                  <literal>BASE</literal> revision before you tried
                  to integrate changes from the server into
                  your working copy.</para>
      -->
                <para>在把服务器上的修改合并到工作副本之前, 把文件指定成版本
                  号为 <literal>BASE</literal>, 且未修改的版本.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>working</literal></term>
              <listitem>
      <!--
                <para>Assuming that you've manually handled the
                  conflict resolution, choose the version of the file
                  as it currently stands in your working copy.</para>
      -->
                <para>将文件在工作副本中的当前版本作为冲突解决后的版本, 在这
                  之前用户应该手工处理了文件里的冲突.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>mine-full</literal>
                (<literal>mf</literal>)</term>
              <listitem>
      <!--
                <para>Resolve conflicted files by preserving all
                  local modifications and discarding all changes
                  fetched from the server during the operation which
                  caused the conflict.</para>
      -->
                <para>如果文件发生了冲突, 则保留文件里的所有本地修改, 丢弃
                  该文件从服务器接收到的所有修改.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>theirs-full</literal>
                (<literal>tf</literal>)</term>
              <listitem>
      <!--
                <para>Resolve conflicted files by discarding all
                  local modifications and integrating all changes
                  fetched from the server during the operation which
                  caused the conflict.</para>
      -->
                <para>如果文件发生了冲突, 则丢弃文件里的所有本地修改, 保留
                  从服务器接收到的所有修改.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>mine-conflict</literal>
                (<literal>mc</literal>)</term>
              <listitem>
      <!--
                <para>Resolve conflicted files by preferring local
                  modifications over the changes fetched from the
                  server in conflicting regions of each file's
                  content.</para>
      -->
                <para>如果文件的某一区域发生了冲突, 则保留该区域的本地修改,
                  丢弃从服务器接收到的同一区域上的修改.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>theirs-conflict</literal>
                (<literal>tc</literal>)</term>
              <listitem>
      <!--
                <para>Resolve conflicted files by preferring the
                  changes fetched from the server over local
                  modifications in conflicting regions of each file's
                  content.</para>
      -->
                <para>如果文件的某一区域发生了冲突, 则丢弃该区域的本地修改,
                  保留从服务器接收到的同一区域上的修改.</para>
              </listitem>
            </varlistentry>
          </variablelist>
      <!--
          <para>Consult the output of <command>svn help
            <replaceable>SUBCOMMAND</replaceable></command> to see
            exactly which actions are supported by the specific
            subcommand of interest.</para>
      -->
          <para>为了查看特定的子命令支持哪些 <replaceable>ACTION</replaceable>,
            阅读 <command>svn help <replaceable>SUBCOMMAND</replaceable>
          </command> 的输出.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.allow_mixed_revisions">
        <term><option>--allow-mixed-revisions</option></term>
        <listitem>
      <!--
          ### TODO
          <para>Disables the verification&mdash;performed by default
            by <command>svn merge</command> as of Subversion
            1.7&mdash;that the target of a merge operation and all
            of its children are at a uniform revision.  While
            merging into a single-revision working copy target is
            the recommended best practice, this option may be used
            to permit merges into mixed-revision working copies as
            necessary.</para>
      -->
          <para>在合并时, 不去核实目标及其子文件的版本号是否是相同的, 从
            Subversion 1.7 开始, 默认都会去核实版本号是否相同. 虽然推荐的
            做法是让工作副本处于一个单一的版本号下, 但必要时还是可以用这个
            选项允许向版本号混合的工作副本执行合并.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.auto_props">
        <term><option>--auto-props</option></term>
        <listitem>
      <!--
                                                       ### TODO
          <para>Enables automatic property assignment (per runtime
            configuration rules), overriding the
            <literal>enable-auto-props</literal> runtime
            configuration directive.</para>
      -->
          <para>允许自动属性设置, 它将覆盖运行时配置指令
            <literal>enable-auto-props</literal> 的设置.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.change">
        <term><option>--change</option> (<option>-c</option>) <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Perform the requested operation using a specific
            <quote>change</quote>.  Generally speaking, this option
            is syntactic sugar for <userinput>-r
            <replaceable>ARG-1</replaceable>:<replaceable>ARG</replaceable></userinput>.
            Some subcommands permit a comma-separated list of
            revision number arguments (e.g., <userinput>-c
            <replaceable>ARG1</replaceable>,<replaceable>ARG2</replaceable>,<replaceable>ARG3</replaceable></userinput>).
            Alternatively, you can provide two arguments separated
            by a dash (as
            in <userinput>-c <replaceable>ARG1</replaceable>-<replaceable>ARG2</replaceable></userinput>)
            to identify the range of revisions
            between <replaceable>ARG1</replaceable>
            and <replaceable>ARG2</replaceable>, inclusive.
            Finally, if the revision argument is negated, the
            implied revision range is reversed: <userinput>-c
            -45</userinput> is equivalent to <userinput>-r
            45:44</userinput>.</para>
      -->
        <para>使用一个特定的 <quote>修改</quote> 执行所请求的操作. 通常来说,
          这个选项是 <userinput>-r
            <replaceable>ARG-1</replaceable>:<replaceable>ARG</replaceable></userinput>
          的同义语. 某些子命令允许选项的参数是逗号分隔的版本号列表 (即
          <userinput>-c
            <replaceable>ARG1</replaceable>,<replaceable>ARG2</replaceable>,<replaceable>ARG3</replaceable></userinput>),
          用户还可以用连字符分隔的两个版本号指定一个版本号范围 (即
          <userinput>-c <replaceable>ARG1</replaceable>-<replaceable>ARG2</replaceable></userinput>
          ), 范围包括起始与结束版本号. 最后, 如果版本号是一个负数, 则表示相反
          的版本号范围, 例如 <userinput>-c -45</userinput> 等价于
          <userinput>-r 45:44</userinput>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.changelist">
        <term><option>--changelist</option> (<option>--cl</option>) <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Instructs Subversion to operate only on members of the changelist named
            <replaceable>ARG</replaceable>.  You can use this option
            multiple times to specify sets of changelists.</para>
      -->
          <para>告诉 Subversion 只去操作属于变更列表
            <replaceable>ARG</replaceable> 的文件, 用户可以多次使用这个选项,
            从而指定多个变更列表.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.config_dir">
        <term><option>--config-dir</option> <replaceable>DIR</replaceable></term>
        <listitem>
      <!--
          <para>Instructs Subversion to read configuration
            information from the specified directory instead of the
            default location (<filename>.subversion</filename> in
            the user's home directory).</para>
      -->
          <para>告诉 Subversion 从指定的目录 (而不是默认的
            <filename>.subversion</filename>) 中读取配置信息.</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.config_option">
        <term><option>--config-option</option> <replaceable>CONFSPEC</replaceable></term>
        <listitem>
      <!--
          <para>Sets, for the duration of the command, the value of
            a runtime configuration
            option.  <replaceable>CONFSPEC</replaceable> is a string
            which specifies the configuration option namespace, name
            and value that you'd like to assign, formatted as
            <replaceable>FILE</replaceable>:<replaceable>SECTION</replaceable>:<replaceable>OPTION</replaceable>=[<replaceable>VALUE</replaceable>].
            In this syntax, <replaceable>FILE</replaceable>
            and <replaceable>SECTION</replaceable> are the runtime
            configuration file (either <literal>config</literal>
            or <literal>servers</literal>) and the section thereof,
            respectively, which contain the option whose value you
            wish to change.  <replaceable>OPTION</replaceable> is,
            of course, the option itself,
            and <replaceable>VALUE</replaceable> the value (if any)
            you wish to assign to the option.  For example, to
            temporarily disable the use of the compression in the
            HTTP protocol,
            use <option>- -config-option=servers:global:http-compression=no</option>.
            You can use this option multiple times to change
            multiple option values simultaneously.</para>
      -->
          <para>在命令执行期间设置运行时配置选项.
            <replaceable>CONFSPEC</replaceable> 是一个字符串, 指定了运行时配置
            选项的名字空间, 选项名和选项值, 形式是
            <replaceable>FILE</replaceable>:<replaceable>SECTION</replaceable>:<replaceable>OPTION</replaceable>=[<replaceable>VALUE</replaceable>],
            其中, <replaceable>FILE</replaceable> 和
            <replaceable>SECTION</replaceable> 分别是选项所在的运行时配置文件
            (<literal>config</literal> 或 <literal>server</literal>) 和配置
            文件里的节. <replaceable>OPTION</replaceable> 就是选项本身, 而
            <replaceable>VALUE</replaceable> (如果有的话) 就是选项的值. 比如
            说用户想要临时禁止 HTTP 压缩, 那就可以把
            <option>--config-option</option> 写成
            <option>--config-option=servers:global:http-compression=no</option>.
            该选项可以在命令行上出现多次.</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.depth">
        <term><option>--depth</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Instructs Subversion to limit the scope of an
            operation to a particular tree
            depth.  <replaceable>ARG</replaceable> is one of
            <literal>empty</literal> (only the target
            itself), <literal>files</literal> (the target and any
            immediate file children thereof),
            <literal>immediates</literal> (the target and any
            immediate children thereof), or
            <literal>infinity</literal> (the target and all of its
            descendants&mdash;full recursion).</para>
      -->
          <para>告诉 Subversion 把命令的操作范围限制在一个指定的目录深度内.
            <replaceable>ARG</replaceable> 可以是 <literal>empty</literal>
            (目标本身), 或 <literal>files</literal> (目标和目标的直接子文件,
            不包括直接子目录), <literal>immediates</literal> (目标和目标的直接
            子文件, 包括直接子目录), 或 <literal>infinity</literal> (目标和
            目标的所有子孙&mdash;即完全递归).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.diff">
        <term><option>--diff</option></term>
        <listitem>
      <!--
          <para>Enables a special output mode for <command>svn
            log</command> which includes a difference report (a
            la <command>svn diff</command>) as part of each
            revision's information.</para>
      -->
          <para>告诉 <command>svn log</command> 输出版本号所包含的差异
            (按照 <command>svn diff</command> 的方式进行输出).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.diff_cmd">
        <term><option>--diff-cmd</option> <replaceable>CMD</replaceable></term>
        <listitem>
      <!--
          <para>Specifies an external program to use to show
            differences between files.  When <command>svn
            diff</command> is invoked without this option, it uses
            Subversion's internal differencing engine, which provides
            unified diffs by default.  If you want to use an
            external differencing program, use <option>- -diff-cmd</option>.
            You can then pass options to the specified program using the
            <option>- -extensions</option> (<option>-x</option>)
            option.</para>
      -->
          <para>指定一个外部差异比较工具. 如果在执行 <command>svn diff</command>
            时没有指定该选项, Subversion 将会使用它自己的差异比较引擎, 默认
            按照标准差异格式进行输出. 如果用户希望使用一个外部的差异比较工具,
            就可以用该选项实现, 然后还可以用选项 <option>--extensions</option>
            (<option>-x</option>) 为外部差异比较工具传递选项.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.diff3_cmd">
        <term><option>--diff3-cmd</option> <replaceable>CMD</replaceable></term>
        <listitem>
      <!--
          <para>Specifies an external 3-way differencing program
            (used to merge line-based changes into files).</para>
      -->
          <para>指定一个外部的三路差异比较工具 (用于合并文件的修改).</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.dry_run">
        <term><option>--dry-run</option></term>
        <listitem>
      <!--
          <para>Goes through all the motions of running a command,
            but makes no actual changes&mdash;either on disk or in
            the repository.</para>
      -->
          <para>执行命令的所有过程, 除了做出实际的修改&mdash;无论是修改工作
            副本还是仓库.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.editor_cmd">
        <term><option>--editor-cmd</option> <replaceable>CMD</replaceable></term>
        <listitem>
      <!--
          <para>Specifies an external program to use to edit a log message
            or a property value.  See the <literal>editor-cmd</literal>
            section in <xref linkend="svn.advanced.confarea.opts.config"/>
            for ways to specify a default editor.</para>
      -->
          <para>指定一个外部文本编辑器, 用于编辑日志消息或属性值. 关于如何
            指定一个默认文本编辑器, 见 <xref
              linkend="svn.advanced.confarea.opts.config"/> 的
            <literal>editor-cmd</literal> 节.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.encoding">
        <term><option>--encoding</option> <replaceable>ENC</replaceable></term>
        <listitem>
      <!--
          <para>Tells Subversion that your commit message is
            composed using the character encoding provided.  The
            default character encoding is derived from your
            operating system's native locale; use this option if
            your commit message is composed using any other
            encoding.</para>
      -->
          <para>告诉 Subversion 你的提交消息是用该选项所指定的字符集编码编写的.
            默认情况下, Subversion 根据操作系统的本地语言环境判断提交消息的
            字符集编码, 如果你用了其他字符集编码, 就要用该选项显式地告诉
            Subversion 你所用的字符集编码.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.extensions">
        <term><option>--extensions</option> (<option>-x</option>) <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Specifies customizations which Subversion should
            make when performing difference calculations.  Valid
            extensions include:</para>
      -->
          <para>为 Subversion 的差异比较指定扩展选项, 有效的扩展选项有:</para>
          <variablelist>
            <varlistentry>
              <term><option>--ignore-space-change</option> (<option>-b</option>)</term>
              <listitem>
      <!--
                <para>Ignore changes in the amount of white space.</para>
      -->
                <para>忽略空白字符在数量方面的变化.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--ignore-all-space</option> (<option>-w</option>)</term>
              <listitem>
      <!--
                <para>Ignore all white space.</para>
      -->
                <para>忽略所有的空白字符.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--ignore-eol-style</option></term>
              <listitem>
      <!--
                <para>Ignore changes in EOL (end-of-line) style.</para>
      -->
                <para>忽略 EOL (end-of-line, 行结束标记) 的变化.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--show-c-function</option> (<option>-p</option>)</term>
              <listitem>
      <!--
                <para>Show C function names in the diff output.</para>
      -->
                <para>在差异比较输出中显示 C 语言的函数名.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--unified</option> (<option>-u</option>)</term>
              <listitem>
      <!--
                <para>Show three lines of unified diff context.</para>
      -->
                <para>显示宽度为 3 行的标准差异上下文.</para>
              </listitem>
            </varlistentry>
          </variablelist>
      <!--
          <para>The default value of <replaceable>ARG</replaceable>
            is <literal>-u</literal>.  If you wish to pass multiple
            arguments, you must enclose all of them in quotes.</para>
      -->
          <para><replaceable>ARG</replaceable> 的默认值是
            <literal>-u</literal>, 如果你希望指定多个扩展选项, 就把它们放在一
            对双引号中.</para>
      <!--
          <para>Note that when Subversion is configured to invoke an
            external diff command, the value of
            the <option>- -extensions</option> (<option>-x</option>)
            option isn't restricted to the previously mentioned
            options, but may be <emphasis>any</emphasis> additional
            arguments which Subversion should pass to that command.</para>
      -->
          <para>需要注意的是, 如果差异比较引擎是一个外部的差异比较工具, 那么
            选项 <option>--extensions</option> (<option>-x</option>) 的值
            不仅限于以上提到的这些, 而是可以设置成 <emphasis>任意</emphasis>
            值.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.file">
        <term><option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable></term>
        <listitem>
      <!--
          <para>Uses the contents of the named file for the
            specified subcommand.  Different subcommands do
            different things with this content.  For example,
            <command>svn commit</command> uses the content as a
            commit log message, whereas <command>svn
            propset</command> uses it as a property value.</para>
      -->
        <para>将文件的内容传递给子命令, 不同的子命令将文件内容用于不同的目的,
          例如 <command>svn commit</command> 把文件内容作为提交日志消息, 而
          <command>svn propset</command> 把文件内容作为属性值.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.force">
        <term><option>--force</option></term>
        <listitem>
      <!--
          <para>Forces a particular command or operation to run.
            Subversion will prevent you from performing some
            operations in normal usage, but you can pass this option
            to tell Subversion <quote>I know what I'm doing as well
            as the possible repercussions of doing it, so let me at
            'em.</quote> This option is the programmatic equivalent
            of doing your own electrical work with the power
            on&mdash;if you don't know what you're doing, you're
            likely to get a nasty shock.</para>
      -->
          <para>强迫命令或操作往下执行. 在正常使用时, Subversion 会阻止用户
            执行某些操作, 但是用户可以用这个选项告诉 Subversion: <quote>我
              知道我正在做什么, 也知道这样做的可能后果, 所以请继续往下执行.
            </quote> 用这个选项就好像一个电工在未断电的情况下工作&mdash;如果
            你不知道自己正在做什么, 你可能会对命令的执行结果感到震惊.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.force_log">
        <term><option>--force-log</option></term>
        <listitem>
      <!--
          <para>Forces a suspicious parameter passed to the
            <option>- -message</option> (<option>-m</option>) or
            <option>- -file</option> (<option>-F</option>) option to
            be accepted as valid.  By default, Subversion will
            produce an error if parameters to these options look
            like they might instead be targets of the subcommand.
            For example, if you pass a versioned file's path to the
            <option>- -file</option> (<option>-F</option>) option,
            Subversion will assume you've made a mistake, that the
            path was instead intended as the target of the
            operation, and that you simply failed to provide some
            other&mdash;unversioned&mdash;file as the source of your
            log message.  To assert your intent and override these
            types of errors, pass the <option>- -force-log</option>
            option to subcommands that accept log messages.</para>
      -->
          <para>迫使 Subversion 接受传递给 <option>--message</option>
            (<option>-m</option>) 或 <option>--file</option>
            (<option>-F</option>) 的可疑参数, 默认情况下, 如果传递给这两个
            选项的参数看起来好像是子命令的目标参数, 那么 Subversion 将会报
            错退出. 比如说用户向选项 <option>--file</option>
            (<option>-F</option>) 传递了一个处于版本控制下的文件路径,
            Subversion 将会认为用户犯了一个错误: 这个文件路径应该作为子命令
            的目标参数, 选项 <option>--file</option> (<option>-F</option>)
            的参数应该是一个未被版本控制的文件路径. 为了表明自己的意图, 并且
            防止 Subversion 进行这种检查, 用户就可以用选项
            <option>--force-log</option> 迫使 Subversion 无条件地接受日志消息.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.force_interactive">
        <term><option>--force-interactive</option></term>
        <listitem>
      <!--
          <para>Forces the <command>svn</command> command-line client to run in
            interactive mode when standard input is not a terminal device.</para>
      -->
          <para>如果标准输入不是一个终端设备, 强制 <command>svn</command> 以
            交互模式运行.</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.git">
        <term><option>--git</option></term>
        <listitem>
      <!--
          <para>Enables a special output mode for <command>svn
            diff</command> designed for cross-compatibility with the
            popular Git distributed version control system.</para>
      -->
          <para>按照分布式版本控制系统 Git 的格式, 输出 <command>svn
              diff</command> 的标准差异输出.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.help">
        <term><option>--help</option> (<option>-h</option>, <option>-?</option>)</term>
        <listitem>
      <!--
          <para>If used with one or more subcommands, shows the
            built-in help text for each.  If used alone, it displays
            the general client help text.</para>
      -->
          <para>如果在执行时带了一个或多个子命令, 则显示各个子命令的内建帮助
            文档. 如果只是单独使用, 则显示客户端命令行工具的总体帮助文档.
          </para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.ignore_ancestry">
        <term><option>--ignore-ancestry</option></term>
        <listitem>
      <!--
          <para>Tells Subversion to ignore ancestry when calculating
                         ### TODO
            differences (rely on path contents alone).  Also disables
            <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
            when used with the <command>svn merge</command> subcommand.
        </para>
      -->
        <para>告诉 Subversion 在计算差异时忽略祖先 (仅依赖路径内容), 对
          <command>svn merge</command> 而言, 该选项还会禁止
          <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        </para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.ignore_externals">
        <term><option>--ignore-externals</option></term>
        <listitem>
      <!--
          <para>Tells Subversion to ignore externals definitions and
            the external working copies managed by them.</para>
      -->
          <para>忽略外部定义和外部工作副本.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.ignore_keywords">
        <term><option>--ignore-keywords</option></term>
        <listitem>
      <!--
          <para>Disables keyword expansion.</para>
      -->
          <para>禁止关键字替换.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.ignore_properties">
        <term><option>--ignore-properties</option></term>
        <listitem>
      <!--
          <para>Instructs <command>svn diff</command> to suppress
            output of property changes.</para>
      -->
          <para>告诉 <command>svn diff</command> 忽略属性的变化.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.ignore_whitespace">
        <term><option>--ignore-whitespace</option></term>
        <listitem>
      <!--
          <para>Instructs <command>svn patch</command> to ignore
            whitespace when attempting to identify patch
            context.</para>
      -->
          <para>告诉 <command>svn patch</command> 在识别补丁上下文时忽略
            空白字符.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.incremental">
        <term><option>--incremental</option></term>
        <listitem>
      <!--
          <para>Prints output in a format suitable for
            concatenation to prior similar output.</para>
      -->
          <para>按照一种增量的格式打印输出, 该格式允许将本次输出级连到之前
            的相同类型的输出.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.internal_diff">
        <term><option>--internal-diff</option></term>
        <listitem>
      <!--
          <para>Instructs Subversion to use its built-in
            differencing engine despite any external differencing
            mechanism that may be specified for use in the user's
            runtime configuration.</para>
      -->
          <para>告诉 Subversion 始终使用内建的差异比较引擎, 无论用户是否在
            运行时配置中指定了外部差异比较工具.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.keep_changelists">
        <term><option>--keep-changelists</option></term>
        <listitem>
      <!--
          <para>Tells Subversion not to remove the changelist assigments
            from working copy items after committing.</para>
      -->
          <para>告诉 Subversion 在提交成功后不要把文件从变更列表中移除.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.keep_local">
        <term><option>--keep-local</option></term>
        <listitem>
      <!--
          <para>Keeps the local copy of a file or directory (used
            with the <command>svn delete</command> command).</para>
      -->
          <para>执行完 <command>svn delete</command> 后, 在工作副本中保留
            文件.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.limit">
        <term><option>--limit</option> (<option>-l</option>) <replaceable>NUM</replaceable></term>
        <listitem>
      <!--
          <para>Shows only the first <replaceable>NUM</replaceable>
            log messages.</para>
      -->
          <para>显示日志消息的前 <replaceable>NUM</replaceable> 项.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.message">
        <term><option>--message</option> (<option>-m</option>) <replaceable>MESSAGE</replaceable></term>
        <listitem>
      <!--
          <para>Indicates that you will specify either a log message
            or a lock comment on the command line, following this
            option.  For example:</para>
      -->
          <para>表示用户将在命令行上编写日志消息或锁的注释, 选项的后面即是
            用户写的内容, 例如:</para>

          <informalexample>
            <screen>
$ svn commit -m "They don't make Sunday."
</screen>
          </informalexample>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.native_eol">
        <term><option>--native-eol</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Causes <command>svn export</command> to use a
            specific end-of-line sequence as if it was the native
            sequence for the client platform.
            <replaceable>ARG</replaceable> may be one
            of <literal>CR</literal>, <literal>LF</literal>,
            or <literal>CRLF</literal>.</para>
      -->
          <para>告诉 <command>svn export</command> 使用指定的行结束标记作为
            系统的本地标记, 这将会影响那些 <literal>svn:eol-style</literal>
            属性值为 <literal>native</literal> 的文件.
            <replaceable>ARG</replaceable> 的有效值包括 <literal>CR</literal>,
            <literal>LF</literal> 和 <literal>CRLF</literal>.</para>
        </listitem>
      </varlistentry>
            
      <varlistentry id="svn.ref.svn.sw.new">
        <term><option>--new</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Uses <replaceable>ARG</replaceable> as the newer
            target (for use with <command>svn diff</command>).</para>
      -->
          <para>使用 <replaceable>ARG</replaceable> 作为较新的目标 (与
            <command>svn diff</command> 配合使用).</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.no_auth_cache">
        <term><option>--no-auth-cache</option></term>
        <listitem>
      <!--
          <para>Prevents caching of authentication information
            (e.g., username and password) in the Subversion runtime
            configuration directories.</para>
      -->
          <para>禁止在 Subversion 运行时配置目录里缓存认证信息 (例如用户名
            和密码).</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_auto_props">
        <term><option>--no-auto-props</option></term>
        <listitem>
      <!--
          <para>Disables automatic property setting, overriding the
            <literal>enable-auto-props</literal> runtime
            configuration directive.</para>
      -->
          <para>禁止自动属性设置, 该选项会覆盖运行时配置选项
            <literal>enable-auto-props</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_diff_added">
        <term><option>--no-diff-added</option></term>
        <listitem>
      <!--
          <para>Prevents Subversion from printing differences for
            added files.  The default behavior when you add a file is to print
            the same differences that you would see if you had added the entire
            contents of an existing (empty) file.</para>
      -->
          <para>禁止为新增的文件输出差异. 默认情况下, 新文件的差异输出就像是
            往一个已有的空文件内写入了全部内容后的差异输出效果.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_diff_deleted">
        <term><option>--no-diff-deleted</option></term>
      <listitem>
      <!--
          <para>Prevents Subversion from printing differences for
            deleted files.  The default behavior when you remove a
            file is for <command>svn diff</command> to print the
            same differences that you would see if you had kept
            the file but removed all of its content.</para>
      -->
          <para>禁止为删除了的文件输出差异. 默认情况下, 删除了的文件的差异
            输出就像是删除了文件的所有内容 (但不删除文件) 后的差异输出效果.
          </para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.no_ignore">
        <term><option>--no-ignore</option></term>
        <listitem>
      <!--
          <para>Shows files in the status listing or adds/imports files
            that would normally be omitted since they match a pattern
            in the <literal>global-ignores</literal> configuration
            option or the <literal>svn:ignore</literal> or
            <literal>svn:global-ignores</literal>properties.  See <xref
            linkend="svn.advanced.confarea.opts.config"/> and <xref
            linkend="svn.advanced.props.special.ignore"/> for more
            information.</para>
      -->
          <para>在显示工作副本状态, 添加文件或导入文件时不要忽略任何文件
            (即使文件名与运行时配置选项 <literal>global-ignores</literal>,
            属性 <literal>svn:ignore</literal> 或属性
            <literal>svn:global-ignores</literal> 里的模式相匹配), 更多的
            信息见 <xref linkend="svn.advanced.confarea.opts.config"/> 和
            <xref linkend="svn.advanced.props.special.ignore"/>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_unlock">
        <term><option>--no-unlock</option></term>
        <listitem>
      <!--
          <para>Tells Subversion not to automatically unlock files.
            (The default commit behavior is to unlock all files
            listed as part of the commit.)  See
            <xref linkend="svn.advanced.locking"/> for more
            information.</para>
      -->
          <para>告诉 Subversion 不要自动释放锁. (默认的提交行为会释放所有已
            提交的文件上的锁.) 更多的信息见 <xref
              linkend="svn.advanced.locking"/>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.non_interactive">
        <term><option>--non-interactive</option></term>
        <listitem>
      <!--
          <para>Disables all interactive prompting.  Some examples
            of interactive prompting include requests for
            authentication credentials and conflict resolution
            decisions.  This is useful if you're running Subversion
            inside an automated script and it's more appropriate to
            have Subversion fail than to prompt for more
            information.</para>
      -->
          <para>禁止所有的交互式提示. 交互式提示的例子包括向用户请求认证证书
            和冲突解决. 如果你是在一个自动化的脚本中运行 Subversion, 那么比
            起向用户发出交互式请求, 更方便的做法是报错退出.</para>

      <!--
          <para>Beginning with Subversion 1.8, the <command>svn</command>
            command-line client, by default, is non-interactive when standard
            input is not a terminal device. Pass the
            <option>- -force-interactive</option> option to make the client run
            in interactive mode.</para>
      -->
          <para>从 Subversion 1.8 开始, 如果标准输入不是一个终端设备, 那么
            <command>svn</command> 默认以非交互式模式运行. 为了强制
            <command>svn</command> 以交互式模式运行, 可使用选项
            <option>--force-interactive</option>.</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.non_recursive">
        <term><option>--non-recursive</option> (<option>-N</option>)</term>
        <listitem>
      <!--
          <para><emphasis>Deprecated</emphasis>.  Stops a subcommand
            from recursing into subdirectories.  Most subcommands
            recurse by default, but some do not.  Users should avoid
            this option and use the more precise <option>- -depth</option>
            option instead.  For most subcommands, specifying
            <option>- -non-recursive</option> produces behavior which
            is the same as if you'd specified
            <option>- -depth=files</option>, but there are exceptions:
            non-recursive <command>svn status</command> operates at the
            <literal>immediates</literal> depth, and the  non-recursive
            forms of <command>svn revert</command>,
            <command>svn add</command>, and <command>svn commit</command>
            operate at an <literal>empty</literal> depth.</para>
      -->
          <para><emphasis>不再推荐使用该选项</emphasis>. 禁止子命令递归执行到
            子目录内. 大多数子命令默认都会递归执行到子目录内, 但有些不会. 用户
            应该不再使用该选项, 而使用更精确的 <option>--depth</option>, 对于
            大多数子命令而言, 选项 <option>--non-interactive</option> 等价于
            <option>--depth=files</option>, 但是对于 <command>svn
              status</command> 来说, 与 <option>--non-recursive</option> 等价
            的选项是 <option>--depth=immediates</option>, 对于
            <command>svn revert</command>, <command>svn add</command> 和
            <command>svn commit</command> 来说, 等价的选项则是
            <option>--depth=empty</option>.</para>

        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.notice_ancestry">
        <term><option>--notice-ancestry</option></term>
        <listitem>
      <!--
          <para>Pays attention to ancestry when calculating 
            differences.</para>
      -->
          <para>在计算差异时要考虑祖先.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.old">
        <term><option>--old</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Uses <replaceable>ARG</replaceable> as the older
            target (for use with <command>svn diff</command>).</para>
      -->
          <para>使用 <replaceable>ARG</replaceable> 作为较旧的目标 (与
            <command>svn diff</command> 配合使用).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.parents">
        <term><option>--parents</option></term>
        <listitem>
      <!--
          <para>Creates and adds nonexistent or nonversioned parent
            directories to the working copy or repository as part
            of an operation.  This is useful for automatically
            creating multiple subdirectories where none currently
            exist.  If performed on a URL, all the directories will
            be created in a single commit.</para>
      -->
          <para>作为操作的一部分, 在工作副本或仓库中自动创建不存在的父目录.
            这个选项对于自动创建多级子目录非常方便, 如果目标是一个 URL, 那么
            所有的目录都会在一个提交中创建完成.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.password">
        <term><option>--password</option> <replaceable>PASSWD</replaceable></term>
        <listitem>
      <!--
          <para>Specifies the password to use when authenticating
            against a Subversion server.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
      -->
          <para>指定用于 Subversion 服务器认证的密码. 如果没有在命令行上指定
            密码, 或者密码有误, 在需要时 Subversion 将提示用户输入密码.</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.patch_compatible">
        <term><option>--patch-compatible</option></term>
        <listitem>
      <!--
          <para>Instructs <command>svn diff</command> to produce output
            compatible with generic third-party patch tools.  The result of
            using this option is the same as running <command>svn diff</command>
            with <option>- -show-copies-as-adds - -ignore-properties</option>
            options.</para>
      -->
          <para>告诉 <command>svn diff</command> 的输出要和通用的第三方补丁
            工具保持兼容. 该选项等价于 <option>--show-copies-as-adds
              --ignore-properties</option>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.properties_only">
        <term><option>--properties-only</option></term>
        <listitem>
      <!--
          <para>Instructs <command>svn diff</command> to show only property
            changes.</para>
      -->
          <para>告诉 <command>svn diff</command> 只输出属性上的变化.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.quiet">
        <term><option>--quiet</option> (<option>-q</option>)</term>
        <listitem>
      <!--
          <para>Requests that the client print only essential
            information while performing an operation.</para>
      -->
          <para>告诉 <command>svn</command> 在执行时只打印必要的信息.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.record_only">
        <term><option>--record-only</option></term>
        <listitem>
      <!--
          <para>Enables a special mode of <command>svn
          merge</command> in which the specified merge operation is
          recorded in the local merge tracking information, but is
          not actually performed.</para>
      -->
        <para>告诉 <command>svn merge</command> 只合并合并信息, 不合并文件
          上的修改.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.recursive">
        <term><option>--recursive</option> (<option>-R</option>)</term>
        <listitem>
      <!--
          <para>Makes a subcommand recurse into subdirectories.
            (Most subcommands recurse by default.)</para>
      -->
          <para>告诉子命令要递归地执行到子目录内 (大多数子命令都会默认递归
            执行).</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.reintegrate">
        <term><option>--reintegrate</option></term>
        <listitem>
      <!--
          <para>Deprecated.  Used with the <command>svn merge</command>
            subcommand to merge changes from a feature branch back into
            the feature branch's ancestor branch.  Since Subversion 1.8
            the <command>svn merge</command> subcommand automatically
            detects this scenario and performs the appropriate merge.
            See
            <xref linkend="svn.branchmerge.basicmerging.reintegrate"/>
            for details.</para>
      -->
          <para><emphasis>不再推荐使用该选项</emphasis>. 该选项用于
            <command>svn merge</command>
            把特性分支上的修改合并到特性分支的祖先分支上. 从 Subversion 1.8
            开始, <command>svn merge</command> 能够自动检测这种合并场景并执行
            恰当的合并操作, 更多的细节见
            <xref linkend="svn.branchmerge.basicmerging.reintegrate"/>.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.relocate">
        <term><option>--relocate</option></term>
        <listitem>
      <!--
          <para>Deprecated.  When used with the <command>svn
            switch</command> subcommand, changes the location of the
            repository that your working copy references.  The
            preferred approach as of Subversion 1.7, however, is to
            use the <command>svn relocate</command> subcommand.  See
            <xref linkend="svn.ref.svn.c.relocate" /> for more
            details and an example.</para>
      -->
          <para><emphasis>不再推荐使用该选项</emphasis>. 该选项用于
            <command>svn switch</command>
            改变工作副本所指向的仓库位置, 从 Subversion 1.7 开始, 更好的做法
            是用命令 <command>svn relocate</command>, 更多的细节和示例见
            <xref linkend="svn.ref.svn.c.relocate" />.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.remove">
        <term><option>--remove</option></term>
        <listitem>
      <!--
          <para>Used with <command>svn changelist</command> to
            disassociate&mdash;rather than associate (which is the
            default operation)&mdash;the target(s) from a
            changelist.</para>
      -->
          <para>用于 <command>svn changelist</command> 解除&mdash;而不是建立
            (默认行为)&mdash;文件与变更列表之间的关联.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.reverse_diff">
        <term><option>--reverse-diff</option></term>
        <listitem>
      <!--
          <para>Causes <command>svn patch</command> to interpret the
            input patch instructions in reverse&mdash;treating added
            lines as removed ones and vice-versa.</para>
      -->
          <para>告诉 <command>svn patch</command> 反向应用补丁&mdash;把新增
            的行看成是被删除的行, 把删除的行看成是新增的行.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.revision">
        <term><option>--revision</option> (<option>-r</option>) <replaceable>REV</replaceable></term>
        <listitem>
      <!--
          <para>Specifies a revision (or range of revisions) on with
            which to operate.  You can provide revision numbers,
            keywords, or dates (in curly braces) as arguments to the
            revision option.  If you wish to offer a range of
            revisions, you can provide two revisions separated by a
            colon.  For example:</para>
      -->
          <para>指定待操作的版本号 (或版本号范围). 该选项接受的参数有整数,
            关键字或日期 (日期被花括号包围). 如果你希望指定一个版本号范围,
            就在起始版本号与终止版本号之间加个冒号, 例如:</para>

          <informalexample>
            <screen>
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
</screen>
          </informalexample>

      <!--
          <para>See <xref linkend="svn.tour.revs.keywords"/> for more
            information.</para>
      -->
          <para>更多的信息见 <xref linkend="svn.tour.revs.keywords"/>.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.revprop">
        <term><option>--revprop</option></term>
        <listitem>
      <!--
          <para>Operates on a revision property instead of a
            property specific to a file or directory.  This option
            requires that you also pass a revision with the
            <option>- -revision</option> (<option>-r</option>)
            option.</para>
      -->
          <para>针对版本号属性 (而不是文件或目录上的属性) 进行操作, 该选项
            还要求你同时用选项 <option>--revision</option>
            (<option>-r</option>) 指定了一个版本号.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.search">
        <term><option>--search</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Filters log messages to show only those that match
            the search pattern <replaceable>ARG</replaceable>.  Log
            messages are displayed only if the provided search
            pattern matches any of the author, date, log message
            text (unless <option>- -quiet</option> is used), or, if
            the <option>- -verbose</option> option is also provided,
            a changed path.  If multiple <option>- -search</option>
            options are provided, a log message is shown if it
            matches any of the provided search patterns.  If
            <option>- -limit</option> is used, it restricts the
            number of log messages searched, rather than
            restricting the output to a particular number of
            matching log messages.</para>
      -->
          <para>从日志消息中过滤出和模式 <replaceable>ARG</replaceable> 匹配
            的那些消息. 如果日志消息的作者, 日期, 消息的文本内容 (除非指定了
            选项 <option>--quiet</option>) 或被修改的路径中的任意一条与模式
            匹配, 该日志消息就被认为是匹配的. 如果选项
            <option>--search</option> 出现了多次, 只要日志消息和其中的任意一
            个 <option>--search</option> 匹配, 该日志消息就被认为是匹配的.
            如果同时还指定了选项 <option>--limit</option>, 那么
            <option>--limit</option> 限制的是被搜索的日志消息数量, 而不是匹配
            的日志消息数量.</para>

      <!--
          <para>The search pattern (also called glob or shell wildcard
            pattern) can contain regular characters and the following
            wildcard characters:</para>
      -->
          <para>搜索模式 (也被叫作文件名模式或 Shell 通配符模式) 可以包含普通
            字符和下面的通配符:</para>

          <variablelist>
            <varlistentry>
              <term>
                <literal>?</literal>
              </term>
              <listitem>
      <!--
                <para>Matches any single character.</para>
      -->
                <para>匹配任意一个字符.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>*</literal>
              </term>
              <listitem>
      <!--
                <para>Matches a sequence of arbitrary characters.</para>
      -->
                <para>匹配任意一个字符串, 字符串的长度可以为零.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>[ABC]</literal>
              </term>
              <listitem>
      <!--
                <para>Matches any of the characters listed inside the
                  brackets.</para>
      -->
                <para>匹配方括号内的任意一个字符.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.search_and">
        <term><option>--search-and</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>The option's argument is combined with the pattern from
            the previous <option>- -search</option>
            or <option>- -search-and</option> option on the command
            line.  Log message is shown only if it matches the
            combined search pattern.</para>
      -->
          <para>该选项的参数和前面的 <option>--search</option> 或
            <option>--search-and</option> 的参数联合起来, 只有匹配
            <emphasis>所有</emphasis> 模式的日志消息才被认为是匹配的.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.set_depth">
        <term><option>--set-depth</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Sets the sticky depth on a directory in a working copy
            to one of <literal>exclude</literal>, <literal>empty</literal>,
            <literal>files</literal>, <literal>immediates</literal>,
            or <literal>infinity</literal>.  For detailed coverage
            of what these mean and how to use this option, see
            <xref linkend="svn.advanced.sparsedirs" />.</para>
      -->
          <para>把目录的粘着 (sticky) 深度设置成 <literal>exclude</literal>,
            <literal>empty</literal>, <literal>files</literal>,
            <literal>immediates</literal> 或 <literal>infinity</literal>,
            关于这些参数的详细信息以及如何使用它们, 见
            <xref linkend="svn.advanced.sparsedirs" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.show_copies_as_adds">
        <term><option>--show-copies-as-adds</option></term>
        <listitem>
      <!--
          <para>Enables a special output mode for <command>svn
            diff</command> in which the content difference for a
            file created via a copy operation appears as it would
            for a brand new file (with each line therein appearing
            as an addition to an empty file) rather than as a delta
            against the original file from which the copy was
            created.</para>
      -->
          <para>告诉 <command>svn diff</command> 在显示通过复制得到的文件
            的差异时, 不要显示它们与被复制的源文件之间的差异, 而是把它们当作
            全新的文件 (就好像往一个空文件中写了内容后的差异输出).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.show_inherited_props">
        <term><option>--show-inherited-props</option></term>
        <listitem>
      <!--
          <para>Causes <command>svn propget</command> and <command>
            svn proplist</command> to display the versioned properties
            inherited by the target file or directory.</para>
      -->
          <para>告诉 <command>svn propget</command> 和 <command>svn
              proplist</command> 显示继承到的版本化属性.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.show_revs">
        <term><option>--show-revs</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>Used to make <command>svn mergeinfo</command>
            display certain classes of merge tracking
            information.  <replaceable>ARG</replaceable> may be
            either <literal>merged</literal>
            or <literal>eligible</literal>, indicating a desire to
            see revisions either already merged or eligible for future
            merge from the specified source URL, respectively.</para>
      -->
          <para>告诉 <command>svn mergeinfo</command> 显示特定种类的合并跟踪
            信息. <replaceable>ARG</replaceable> 可以是
            <literal>merged</literal> 或 <literal>eligible</literal>, 分别表示
            已经合并的版本号和未来有资格被合并的版本号.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.show_updates">
        <term><option>--show-updates</option> (<option>-u</option>)</term>
        <listitem>
      <!--
          <para>Causes the client to display information about
            which files in your working copy are out of date.
            This doesn't actually update any of your
            files&mdash;it just shows you which files will be
            updated if you then use <command>svn update</command>.</para>
      -->
          <para>要求客户端显示关于文件是否过时的信息, 它不会更新工作副本中的
            文件&mdash;它只是会告诉你在下一次执行 <command>svn update</command>
            时, 哪些文件将被更新.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.stop_on_copy">
        <term><option>--stop-on-copy</option></term>
        <listitem>
      <!--
          <para>Causes a Subversion subcommand that traverses
            the history of a versioned resource to stop harvesting
            that historical information when a copy&mdash;that is, a
            location in history where that resource was copied from
            another location in the repository&mdash;is
            encountered.</para>
      -->
          <para>该选项将导致 Subversion 子命令在遍历历史时, 如果遇到了复制
            &mdash;即历史中某一位置上的资源是通过复制仓库中其他位置来得到的
            &mdash;则不再往前遍历历史.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.strict">
        <term><option>--strict</option></term>
        <listitem>
      <!--
          <para>Causes Subversion to use strict semantics, a notion
            that is rather vague unless talking about specific
            subcommands (namely, <command>svn propget</command>).</para>
      -->
          <para>告诉 Subversion 使用更严格的语义, 在谈到
            <quote>更严格的语义</quote> 时, 必须关联上特定的子命令 (即
            <command>svn propget</command>) 才能解释清楚.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.strip">
        <term><option>--strip</option> <replaceable>NUM</replaceable></term>
        <listitem>
      <!--
          <para>Used by <command>svn patch</command> to
            ignore <replaceable>NUM</replaceable> leading path
            components found on paths specified in the patch input
            file.</para>
      -->
          <para>用于 <command>svn patch</command> 忽略补丁文件中的前
            <replaceable>NUM</replaceable> 个路径分量.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.summarize">
        <term><option>--summarize</option></term>
        <listitem>
      <!--
          <para>Display only high-level summary notifications about
            the operation instead of its detailed output.</para>
      -->
          <para>告诉子命令只显示总结性的信息.</para>
        </listitem>
      </varlistentry>
       
      <varlistentry id="svn.ref.svn.sw.targets">
        <term><option>--targets</option> <replaceable>FILENAME</replaceable></term>
        <listitem>
      <!--
          <para>Tells Subversion to read additional target paths for
            the operation from <replaceable>FILENAME</replaceable>.
            <replaceable>FILENAME</replaceable> should contain one
            path per line, with each path expected to use the same
            ### TODO
            encoding and formatting that it would if you had
            specified it directly as an argument on the command
            line.</para>
      -->
          <para>告诉子命令从文件 <filename>FILENAME</filename> 读取额外的目标
            路径参数. <filename>FILENAME</filename> 的每一行都是一个路径, 路径
            的编码和格式应该和命令行上的路径参数相同.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.trust_server_cert">
        <term><option>--trust-server-cert</option></term>
        <listitem>
      <!--
          <para>When used with <option>- -non-interactive</option>,
            instructs Subversion to accept SSL server certificates
            issued by unknown certificate authorities without first
            prompting the user.  For security's sake, you should use
            this option only when the integrity of the remote server
            and the network path between it and your client is known
            to be trustworthy.</para>
      -->
          <para>和选项 <option>--non-interactive</option> 一起使用时, 指示
            Subversion 接受由未知的证书机构颁发的 SSL 服务器证书, 而不必提
            示用户. 为了安全起见, 只有当远程服务器和网络路径的完整性很可靠
            时才能使用该选项.</para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.use_merge_history">
        <term><option>--use-merge-history</option> (<option>-g</option>)</term>
        <listitem>
      <!--
          <para>Uses or displays additional information from merge
            history.</para>
      -->
          <para>使用或显示来自合并历史的额外信息.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.username">
        <term><option>--username</option> <replaceable>NAME</replaceable></term>
        <listitem>
      <!--
          <para>Specifies the username to use when authenticating
            against a Subversion server.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
      -->
          <para>指定用于向 Subversion 服务器认证的用户名, 如果没有指定用户名
            或者指定的用户名不正确, Subversion 将会再次提示用户输入用户名.
          </para>

          <note>
      <!--
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
      -->
            <para>所有的 <command>svn</command> 子命令都支持该选项.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.verbose">
        <term><option>--verbose</option> (<option>-v</option>)</term>
        <listitem>
      <!--
          <para>Requests that the client print out as much
            information as it can while running any subcommand.
            This may result in Subversion printing out additional
            fields, detailed information about every file, or
            additional information regarding its actions.</para>
      -->
          <para>要求子命令输出更详细的信息, 这可能会导致客户端输出额外的字段,
            关于每个文件的详细信息, 或与操作有关的额外信息.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.version">
        <term><option>--version</option></term>
        <listitem>
      <!--
          <para>Prints the client version info.  This information
            includes not only the version number of the client, but
            also a listing of all repository access modules that the
            client can use to access a Subversion repository.
            With <option>- -quiet</option> (<option>-q</option>) it
            prints only the version number in a compact form.</para>
      -->
          <para>打印客户端的版本信息. 版本信息不仅包括客户端的版本号 (这里的
            版本号指的是软件的版本, 注意不要和 Subversion 的版本号 (revision)
            混淆), 还有客户端支持的所有仓库访问模块. 如果加上了选项
            <option>--quiet</option> (<option>-q</option>), 则只打印版本号.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.with_all_revprops">
        <term><option>--with-all-revprops</option></term>
        <listitem>
      <!--
          <para>Used with the <option>- -xml</option> option
          to <command>svn log</command>, instructs Subversion to
          retrieve and display all revision properties&mdash;the
          standard ones used internally by Subversion as well as any
          user-defined ones&mdash;in the log output.</para>
      -->
        <para>和选项 <option>--xml</option> 一起使用, 指示 Subversion 检索并
          输出所有的版本号属性&mdash;包括 Subversion 保留给自己内部使用的属性
          和用户的自定义属性&mdash;到日志中.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.with_no_revprops">
        <term><option>--with-no-revprops</option></term>
        <listitem>
      <!--
          <para>Used with the <option>- -xml</option> option
          to <command>svn log</command>, instructs Subversion to
          omit all revision properties&mdash;including the standard
          log message, author, and revision datestamp&mdash;from the
          log output.</para>
      -->
        <para>和选项 <option>--xml</option> 一起用在命令 <command>svn
            log</command> 时, 指示 Subversion 在日志输出中忽略所有的版本号
          属性&mdash;包括标准的日志消息, 作者和版本号时间戳属性.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.with_revprop">
        <term><option>--with-revprop</option> <replaceable>ARG</replaceable></term>
        <listitem>
      <!--
          <para>When used with any command that writes to the
            repository, sets the revision property, using the
            <replaceable>NAME=VALUE</replaceable> format,
            <replaceable>NAME</replaceable> to
            <replaceable>VALUE</replaceable>.  When used with
            <command>svn log</command> in <option>- -xml</option> mode, this displays the value of
            <replaceable>ARG</replaceable> in the log output.</para>
      -->
          <para>如何该选项和其他需要向仓库写数据的命令一起使用时, 它可用于设置
            版本号属性, 格式是
            <userinput><replaceable>NAME</replaceable>=<replaceable>VALUE</replaceable></userinput>,
            意思是把属性 <replaceable>NAME</replaceable> 的值设置成
            <replaceable>VALUE</replaceable>; 如果该选项和
            <option>--xml</option> 一起用在命令 <command>svn log</command> 里,
            那么 <replaceable>ARG</replaceable> 的值将会显示在日志输出中.
          </para>

        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.xml">
        <term><option>--xml</option></term>
        <listitem>
      <!--
          <para>Prints output in XML format.  XML schemas for the
            output (in RELAX NG format) are maintained in
            the <filename>subversion/svn/schema/</filename>
            directory of the Subversion source tree.</para>
      -->
          <para>按照 XML 格式打印输出. 输出所使用的 XML 模式 (使用 RELAX NG
            格式) 的相关文件位于 Subversion 源代码树的
            <filename>subversion/svn/schema/</filename> 目录内.</para>
        </listitem>
      </varlistentry>
      
    </variablelist>
      
  </partintro>
    
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.add">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>add</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn add</refname>
      <!--
      <refpurpose>Add files, directories, or symbolic links.</refpurpose>
      -->
      <refpurpose>添加文件, 目录或符号链接.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn add PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      
      <!--
      ### TODO
      <para>Schedule files, directories, or symbolic links in your
        working copy for addition to the repository.  They will be
        uploaded and added to the repository on your next commit.
        If you add something and change your mind before
        committing, you can unschedule the addition using
        <command>svn revert</command>.</para>
      -->
      <para>计划将文件, 目录或符号链接添加到仓库中, 在下次提交时, 它们就
        会被正式地上传并添加到仓库中. 如果用户已经添加了某些文件, 但后面又不
        想要这些文件了, 可以使用 <command>svn rever</command> 取消未提交的
        新增.</para>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.auto_props" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.no_auto_props" />
<xref linkend="svn.ref.svn.sw.no_ignore" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>
      
      <!--
      <para>To add a file to your working copy:</para>
      -->
      <para>往工作副本中添加一个新文件:</para>

      <informalexample>
        <screen>
$ svn add foo.c 
A         foo.c
</screen>
      </informalexample>

      <!--
      <para>When adding a directory, the default behavior of
        <command>svn add</command> is to recurse:</para>
      -->
      <para>添加目录时, <command>svn add</command> 的默认行为是递归的:</para>

      <informalexample>
        <screen>
$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
</screen>
      </informalexample>

      <!--
      <para>You can add a directory without adding its
        contents:</para>
      -->
      <para>用户可以只添加目录, 而不添加目录里的子文件:</para>

      <informalexample>
        <screen>
$ svn add --depth=empty otherdir
A         otherdir
</screen>
      </informalexample>

      <!--
      <para>Attempts to schedule the addition of an item which is
        already versioned will fail by default.  This behavior
        foils the most common scenario under which users attempt
        this: when trying to get to Subversion to recursively
        examine a versioned directory and add any unversioned
        items inside of it.  To override the default behavior and
        force Subversion to recurse into already-versioned
        directories, pass the <option>- -force</option>
        option:</para>
      -->
      <para>如果用户试图添加一个已经被版本控制了的文件, 那么 <command>svn
          add</command> 将会报错. 这种行为会影响用户执行这种操作: 递归已经
        被版本控制了的目录, 添加目录中所有未被版本控制的子文件. 为了迫使
        Subversion 递归已被版本控制的目录, 需要加上选项
        <option>--force</option>:</para>

      <informalexample>
        <screen>
$ svn add versioned-dir
svn: warning: W150002: '/home/cmpilato/projects/subversion/site' is already un\
der version control
$ svn add versioned-dir --force
A         versioned-dir/foo.c
A         versioned-dir/somedir/bar.c
A  (bin)  versioned-dir/otherdir/docs/baz.doc
&hellip;
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.blame">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>blame</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn blame (praise, annotate, ann)</refname>
      <!--
      <refpurpose>Show author and revision information inline
        for the specified files or URLs.</refpurpose>
      -->
      <refpurpose>显示文件的每一行最近一次是被谁, 在什么时候被修改的.
      </refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn blame TARGET[@REV]...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      
      <!--
      <para>Show author and revision information inline for the
        specified files or URLs.  Each line of text is annotated
        at the beginning with the author (username) and the
        revision number for the last change to that line.</para>
      -->
      <para>显示文件的每一行最近一次被修改的作者与版本号信息, Subversion 在
        每一行的开头都加上了最后最近一次修改该行的作者的用户名和版本号.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.use_merge_history" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>If you want to see blame-annotated source for
        <filename>readme.txt</filename> in your test
        repository:</para>
      -->
      <para>如果用户想查看 <filename>readme.txt</filename> 的每一行的最近一次
        修改都是谁, 在什么时候做的, 就执行:</para>

      <informalexample>
        <screen>
$ svn blame http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     5      harry Don't bother reading it.  The boss is a knucklehead.
     3      sally 
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Now, just because <command>svn blame</command> says
        that Harry last modified <filename>readme.txt</filename>
        in revision 5, understand that this subcommand is by
        default very picky about what constitutes a change.
        Before clubbing Harry over the head for what appears to be
        insubordination, first consider that perhaps the change he
        made to the file might have been only to its specific
        character content, not to its overall semantic meaning.
        Perhaps his changes were the result of blindly running a
        whitespace cleanup script on this file.  You might need
        to examine the specific differences and related log
        message to understand exactly what Harry did to this file
        in revision 5.</para>
      -->
      <para>从 <command>svn blame</command> 的输出可以看到,
        <filename>readme.txt</filename> 最近一次是 Harry 在版本号 5 修改的,
        用户还要理解 <command>svn blame</command> 对于修改的成立条件是很挑剔
        的. 老板在责骂 Harry 之前, 应首先考虑 Harry 是不是只修改了这一行
        里的某个字符, 甚至他只是删除了这一行里的一个多余的空格, 整句话一开始
        可能并不是他写的. 为了不冤枉 Harry, 你需要认真地查看版本号 5 的日志和
        Harry 所做的修改:</para>

      <informalexample>
        <screen>
$ svn log -c 5 http://svn.red-bean.com/repos/test/readme.txt
------------------------------------------------------------------------
r5 | harry | 2008-05-29 07:26:12 -0600 (Thu, 29 May 2008) | 1 line

Commit the results of 'double-space-after-period.sh'.

------------------------------------------------------------------------
$ svn diff -c 5 http://svn.red-bean.com/repos/test/readme.txt
Index: http://svn.red-bean.com/repos/test/readme.txt
===================================================================
--- http://svn.red-bean.com/repos/test/readme.txt	(revision 4)
+++ http://svn.red-bean.com/repos/test/readme.txt	(revision 5)
@@ -1,5 +1,5 @@
 This is a README file.
-Don't bother reading it. The boss is a knucklehead.
+Don't bother reading it.  The boss is a knucklehead.
  
 INSTRUCTIONS
 ============
$
</screen>
      </informalexample>

      <!--
      <para>Sure enough, Harry only changed the whitespace in that
        line.  Fortunately, the <option>- -extensions</option>
        (<option>-x</option>) option can help you better determine
        the last time that a <emphasis>meaningful</emphasis>
        change was made to a given line of text.  For example,
        here's how you can see the annotation information while
        disregarding mere whitespace changes:</para>
      -->
      <para>从版本号 5 的修改来看, 结果已经很清晰了, Harry 只是去掉了一个
        多余的空格. 幸运的是, 选项 <option>--extensions</option>
        (<option>-x</option>) 可以帮助用户找出最近一次针对该行的
        <emphasis>有意义的</emphasis> 的修改. 例如下面的例子在显示最近一
        次修改时忽略了空白字符的变化:</para>

      <informalexample>
        <screen>
$ svn blame -x -b http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     4       jess Don't bother reading it.  The boss is a knucklehead.
     3      sally 
&hellip;
</screen>
      </informalexample>

      <!--
      <para>If you use the <option>- -xml</option> option, you can
        get XML output describing the blame annotations, but not
        the contents of the lines themselves:</para>
      -->
      <para>如果带上了选项 <option>--xml</option>, 用户就可以得到 XML 格式
        的输出, 但不会出现行本身的内容:</para>

      <informalexample>
        <screen>
$ svn blame --xml http://svn.red-bean.com/repos/test/readme.txt
&lt;?xml version="1.0"?&gt;
&lt;blame&gt;
&lt;target
   path="readme.txt"&gt;
&lt;entry
   line-number="1"&gt;
&lt;commit
   revision="3"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2008-05-25T19:12:31.428953Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;entry
   line-number="2"&gt;
&lt;commit
   revision="5"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-05-29T13:26:12.293121Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;entry
   line-number="3"&gt;
&hellip;
&lt;/entry&gt;
&lt;/target&gt;
&lt;/blame&gt;
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.cat">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>cat</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn cat</refname>
      <!--
      <refpurpose>Output the contents of the specified files or
        URLs.</refpurpose>
      -->
      <refpurpose>输出指定的文件的内容.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn cat TARGET[@REV]...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      
      <!--
      <para>Output the contents of the specified files or URLs.
        For listing the contents of directories, see <command>svn
        list</command> later in this chapter.</para>
      -->
    <para>输出指定的文件的内容. 如果只是想看目录包含了哪些文件, 见本章后面的
      <command>svn list</command>.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.revision" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>If you want to view <filename>readme.txt</filename> in
        your repository without checking it out:</para>
      -->
      <para>如果你想查看仓库里的 <filename>readme.txt</filename> 文件, 但又不
        想把它检出, 可以这样做:</para>

      <informalexample>
        <screen>
$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
Don't bother reading it.  The boss is a knucklehead.
 
INSTRUCTIONS
============

Step 1:  Do this.

Step 2:  Do that.
$
</screen>
      </informalexample>

      <!--
      <para>You can view specific versions of files, too.</para>
      -->
      <para>还可以查看文件在特定版本号下的内容:</para>

      <informalexample>
        <screen>
$ svn cat -r 3 http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
 
INSTRUCTIONS
============

Step 1:  Do this.

Step 2:  Do that.
$
</screen>
      </informalexample>

      <note>
      <!--
        <para>You might develop a reflex action of
          using <command>svn cat</command> to view your working
          file contents.  But keep in mind that the default peg
          revision for <command>svn cat</command> when used on a
          working copy file target is <literal>BASE</literal>, the
          unmodified base revision of that file.  Don't be
          surprised when a simple <userinput>svn cat
          /path/to/file</userinput> invocation fails to display
          your local modifications to that file!</para>
      -->
        <para>你可能很自然地想到用 <command>svn cat</command> 查看工作副本中的
          文件, 但是要注意的是 <command>svn cat</command> 用在工作副本文件上的
          默认限定版本号是 <literal>BASE</literal>, 它是文件未修改时的基础版本
          号, 所以如果在 <command>svn cat</command> 的输出中看不到本地修改时请
          不会感到惊讶.</para>
      </note>

      <tip>
      <!--
        <para>If your working copy is out of date (or you have
          local modifications) and you want to see the
          <literal>HEAD</literal> revision of a file in your
          working copy, use the <option>- -revision</option>
          (<option>-r</option>) option:  <userinput>svn cat -r
          HEAD <replaceable>FILENAME</replaceable></userinput></para>
      -->
      <para>如果工作副本已经过期了 (或者含有本地修改), 而你想查看文件在
        版本号 <literal>HEAD</literal> 的内容, 就加上选项
        <option>--revision</option> (<option>-r</option>):
        <userinput>svn cat -r HEAD <replaceable>FILENAME</replaceable>
      </userinput></para>
      </tip>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.changelist">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>changelist</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn changelist (cl)</refname>
      <!--
      <refpurpose>Associate (or deassociate) local paths with a
        changelist.</refpurpose>
      -->
      <refpurpose>为工作副本里的路径关联 (或解除关联) 一个变更列表.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>changelist CLNAME TARGET...</literal></para>
      <para><literal>changelist --remove TARGET...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      
      <!--
      <para>Used for dividing files in a working copy into a
        changelist (logical named grouping) in order to allow
        users to easily work on multiple file collections within a
        single working copy.</para>
      -->
      <para>将工作副本里的文件分组到一个变更列表 (命名的逻辑分组), 以便于用户
        在一个工作副本中同时应付多个文件集合.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.remove" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Example</title>
      -->
      <title>示例</title>

      <!--
      <para>Edit three files, add them to a changelist, then
        commit only files in that changelist:</para>
      -->
      <para>编辑三个文件, 然后把它们关联到一个变更列表, 最后提交变更列表里的
        文件:</para>

      <informalexample>
        <screen>
$ svn changelist issue1729 foo.c bar.c baz.c
A [issue1729] foo.c
A [issue1729] bar.c
A [issue1729] baz.c
$ svn status
A       someotherfile.c
A       test/sometest.c

--- Changelist 'issue1729':
A       foo.c
A       bar.c
A       baz.c
$ svn commit --changelist issue1729 -m "Fixing Issue 1729."
Adding         bar.c
Adding         baz.c
Adding         foo.c
Transmitting file data ...
Committed revision 2.
$ svn status
A       someotherfile.c
A       test/sometest.c
$
</screen>
      </informalexample>

      <!--
      <para>Note that in the previous example, only the files in
        changelist <literal>issue1729</literal> were
        committed.</para>
      -->
      <para>注意在上面的例子里, 只有变更列表 <literal>issue1729</literal>
        里的三个文件的修改被提交了.</para>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.checkout">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>checkout</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn checkout (co)</refname>
      <!--
      <refpurpose>Check out a working copy from a repository.</refpurpose>
      -->
      <refpurpose>从仓库中检出一个工作副本到本地.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn checkout URL[@REV]... [PATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      
      <!--
      <para>Check out a working copy from a repository.  If
        <replaceable>PATH</replaceable> is omitted, the
        basename of the URL will be used as the destination.
        If multiple URLs are given, each will be checked out into a
        subdirectory of <replaceable>PATH</replaceable>, with the
        name of the subdirectory being the basename of the
        URL.</para>
      -->
      <para>从仓库中检出一个工作副本到本地. 如果忽略
        <replaceable>PATH</replaceable>, 就使用 URL 的最后一个分量作为
        <replaceable>PATH</replaceable>. 如果出现了多个 URL, 那么每个 URL
        都会被检出到 <replaceable>PATH</replaceable> 的一个子目录内, 子目录的
        名字是 URL 的最后一个分量.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Check out a working copy into a directory called
        <filename>mine</filename>:</para>
      -->
      <para>将工作副本检出到名为 <filename>mine</filename> 的目录内:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test mine
A    mine/a
A    mine/b
A    mine/c
A    mine/d
Checked out revision 20.
$ ls
mine
$
</screen>
      </informalexample>

      <!--
      <para>Check out two different directories into two separate
        working copies:</para>
      -->
      <para>把两个不同的目录检出到两个工作副本中:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test \
               file:///var/svn/repos/quiz
A    test/a
A    test/b
A    test/c
A    test/d
Checked out revision 20.
A    quiz/l
A    quiz/m
Checked out revision 13.
$ ls
quiz  test
$
</screen>
      </informalexample>

      <!--
      <para>Check out two different directories into two separate
        working copies, but place both into a directory called
        <filename>working-copies</filename>:</para>
      -->
      <para>把两个不同的目录检出到两个工作副本中, 不过这两个工作副本都在
        <filename>working-copies</filename> 目录里:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test \
               file:///var/svn/repos/quiz \
               working-copies
A    working-copies/test/a
A    working-copies/test/b
A    working-copies/test/c
A    working-copies/test/d
Checked out revision 20.
A    working-copies/quiz/l
A    working-copies/quiz/m
Checked out revision 13.
$ ls
working-copies
</screen>
      </informalexample>

      <!--
      <para>If you interrupt a checkout (or something else
        interrupts your checkout, such as loss of connectivity,
        etc.), you can restart it either by issuing the identical
        checkout command again or by updating the incomplete
        working copy:</para>
      -->
      <para>如果检出被中断 (例如被用户主动中断, 或者网络连接断开), 为了从
        中断的地方继续往下执行, 你可以再次执行相同的检出命令, 或者在不完整的
        工作副本里执行更新命令:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test mine
A    mine/a
A    mine/b
^C
svn: E200015: Caught signal
$ svn checkout file:///var/svn/repos/test mine
A    mine/c
^C
svn: E200015: Caught signal
$ svn update mine
Updating 'mine':
A    mine/d
Updated to revision 20.
$
</screen>
      </informalexample>

      <!--
      <para>If you wish to check out some revision other than the
        most recent one, you can do so by providing the
        <option>- -revision</option> (<option>-r</option>) option
        to the <command>svn checkout</command> command:</para>
      -->
      <para>如果你希望检出特定版本号的工作副本, 就为命令 <command>svn
          checkout</command> 加上选项 <option>--revision</option>
        (<option>-r</option>):</para>

      <informalexample>
        <screen>
$ svn checkout -r 2 file:///var/svn/repos/test mine
A    mine/a
Checked out revision 2.
$
</screen>
      </informalexample>

      <!--
      <para>Prior to version 1.7, Subversion would complain by
        default if you try to check out a directory atop an
        existing directory which contains files or subdirectories
        that the checkout itself would have created.  Subversion
        1.7 handles this situation differently, allowing the
        checkout to proceed but marking any obstructing objects as
        tree conflicts.  Use the <option>- -force</option> option
        to override this safeguard.  When you check out with
        the <option>- -force</option> option, any unversioned file
        in the checkout target tree which ordinarily would
        obstruct the checkout will still become versioned, but
        Subversion will preserve its contents as-is.  If those
        contents differ from the repository file at that path
        (which was downloaded as part of the checkout), the file
        will appear to have local modifications&mdash;the changes
        ### TODO
        required to transform the versioned file you checked out
        into the unversioned file you had before checking
        out&mdash;when the checkout completes.</para>
      -->
      <para>在 Subversion 1.7 之前, 如果检出命令将要创建的文件已经在目录中存
        在了, 那么默认情况下 Subversion 将会发出抱怨. Subversion 1.7 对这种
        情况采取了不同的处理方式, 它将继续执行检出操作, 同时把所有妨碍命令的
        对象都标记成目录冲突, 除非带上了选项 <option>--force</option>. 如果
        检出命令带上了选项 <option>--force</option>, 那么工作副本中未被版本
        控制的文件如果和检出命令将要创建的文件重名, 那么这些文件仍然会变成
        被版本控制了的文件, 但是 Subversion 不会去修改文件内容, 所以说如果这
        些已有的文件和仓库里的文件内容不一样, 文件将会包含本地修改.</para>

      <informalexample>
        <screen>
$ mkdir project
$ mkdir project/lib
$ touch project/lib/file.c
$ svn checkout file:///var/svn/repos/project/trunk project --force
E    project/lib
A    project/lib/subdir
E    project/lib/file.c
A    project/lib/anotherfile.c
A    project/include/header.h
Checked out revision 21.
$ svn status wc
M       project/lib/file.c
$ svn diff wc
Index: project/lib/file.c
===================================================================
--- project/lib/file.c	(revision 1)
+++ project/lib/file.c	(working copy)
@@ -3 +0,0 @@
-/* file.c: Code for acting file-ishly. */
-#include &lt;stdio.h&gt;
-/* Not feeling particularly creative today. */

$
</screen>
      </informalexample>

      <!--
      <para>As in any other working copy, you have the choices
        typically available:  reverting some or all of those
        local <quote>modifications</quote>, committing them, or
        continuing to modify your working copy.</para>
      -->
      <para>现在, 接下来你的选择有: 撤消全部或部分的本地 <quote>修改</quote>,
        提交这些修改, 或继续修改你的工作副本. </para>

      <!--
      <para>This feature is especially useful for performing
        ### TODO
        in-place imports of unversioned directory trees.  By first
        importing the tree into the repository, and then checking
        out new repository location atop the unversioned tree with
        the <option>- -force</option> option, you effectively
        transform the unversioned tree into a working
        copy.</para>
      -->
      <para>这个特性很适合用来在位地导入未被版本控制的目录树. 首先把目录树
        导入仓库中, 然后带上选项 <option>--force</option> 把工作副本检出到
        一个未被版本控制的目录树中, 在效果上等价于把未被版本控制的目录树转换
        成一个工作副本.</para>

      <informalexample>
        <screen>
$ svn mkdir -m "Create newproject project root." \
      file://var/svn/repos/newproject
$ svn import -m "Import initial newproject codebase." newproject \
      file://var/svn/repos/newproject/trunk
Adding         newproject/include
Adding         newproject/include/newproject.h
Adding         newproject/lib
Adding         newproject/lib/helpers.c
Adding         newproject/lib/base.c
Adding         newproject/notes
Adding         newproject/notes/README

Committed revision 22.
$ svn checkout file://`pwd`/repos-1.6/newproject/trunk newproject --force
E    newproject/include
E    newproject/include/newproject.h
E    newproject/lib
E    newproject/lib/helpers.c
E    newproject/lib/base.c
E    newproject/notes
E    newproject/notes/README
Checked out revision 2.
$ svn status newproject
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.cleanup">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>cleanup</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn cleanup</refname>
      <!--
      <refpurpose>Recursively clean up the working copy</refpurpose>
      -->
      <refpurpose>递归地清理工作副本</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn cleanup [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Recursively clean up the working copy, removing
        working copy locks and resuming unfinished operations.  If
        you ever get a <literal>working copy locked</literal>
        error, run this command to remove stale locks and get your
        working copy into a usable state again.</para>
      -->
      <para>递归地清理工作副本, 删除所有的工作副本锁, 并恢复未完成的操作. 如果
        用户看到了一个 <literal>working copy locked</literal> 错误, 就执行
        <command>svn cleanup</command> 删除所有过期的锁, 然后工作副本就能恢复
        到一个可用的状态.</para>

      <!--
      ### TODO
      <para>If, for some reason, an <command>svn update</command>
        fails due to a problem running an external diff program
        (e.g., user input or network failure), pass the
        <option>- -diff3-cmd</option> to allow the cleanup process
        to complete any required merging using your external diff
        program.  You can also specify any configuration directory
        with the <option>- -config-dir</option> option, but you
        should need these options extremely infrequently.</para>
      -->
      <para>假设由于某种原因 (例如用户输入或网络连接断开), <command>svn
          update</command> 在执行一个外部差异比较工具时报错退出, 那么我们可
        以在执行 <command>svn cleanup</command> 时带上选项
        <option>--diff3-cmd</option>, 此时 Subversion 在清理工作副本时就
        会使用外部差异比较工具继续完成未完成的合并. 用户还可以用选项
        <option>--config-dir</option> 为 <command>svn cleanup</command> 指定
        任意的配置文件目录, 不过选项 <option>--config-dir</option> 和
        <option>--diff3-cmd</option> 的使用频率应该会很低.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
</screen>
      </informalexample>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Well, there's not much to the examples here, as
        <command>svn cleanup</command> generates no output.  If
        you pass no <replaceable>PATH</replaceable>, then
        <quote><filename>.</filename></quote> is used:</para>
      -->
      <para>这里的例子不是很多, 因为 <command>svn cleanup</command> 不会产生
        什么输出. 如果没有指定参数 <replaceable>PATH</replaceable>, 命令将会
        使用 <filename>.</filename>:</para>

      <informalexample>
        <screen>
$ svn cleanup
$ svn cleanup /var/svn/working-copy
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.commit">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>commit</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn commit (ci)</refname>
      <!--
      <refpurpose>Send changes from your working copy to the repository.</refpurpose>
      -->
      <refpurpose>把工作副本里的修改发送到仓库中.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn commit [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Send changes from your working copy to the repository.
        If you do not supply a log message with your commit by
        using either the <option>- -file</option>
        (<option>-F</option>) or <option>- -message</option>
        (<option>-m</option>) option,
        <command>svn</command> will launch your editor for you
        to compose a commit message.  See the
        <literal>editor-cmd</literal> list entry in <xref
        linkend="svn.advanced.confarea.opts.config"/>.</para>
      -->
    <para>把工作副本里的修改发送到仓库中. 如果用户没有用选项
      <option>--file</option> (<option>-F</option>) 或
      <option>--message</option> (<option>-m</option>) 提供日志消息,
      <command>svn</command> 将打开一个文本编辑器供用户编写提交日志, 见
      <xref linkend="svn.advanced.confarea.opts.config"/>.</para>

      <!--
      <para><command>svn commit</command> will send any lock
        tokens that it finds and will release locks on all
        <replaceable>PATH</replaceable>s committed (recursively)
        unless <option>- -no-unlock</option> is passed.</para>
      -->
      <para>如果没有带上选项 <option>--no-unlock</option>, <command>svn
          commit</command> 会把所有已提交的 <replaceable>PATH</replaceable>
        上的锁令牌 (如果有的话) 发送给仓库, 并在提交完成后解锁.</para>

      <tip>
      <!--
        <para>If you begin a commit and Subversion launches your
          editor to compose the commit message, you can still
          abort without committing your changes.  If you want to
          cancel your commit, just quit your editor without saving
          your commit message and Subversion will prompt you to
          either abort the commit, continue with no message, or
          edit the message again.</para>
      -->
        <para>如果用户已经开始提交并且 Subversion 已经启动了一个文本编辑器
          等待用户输入提交日志, 此时仍然可以中止提交. 如果用户希望中止提交,
          只需要不保存提交日志并退出编辑器, 此时 Subversion 将会询问用户是
          想中止提交, 还是不输入日志直接提交, 还是重新打开编辑器编写日志.
        </para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.keep_changelists" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.no_unlock" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Commit a simple modification to a file with the
        commit message on the command line and an implicit
        target of your current directory
        (<quote><filename>.</filename></quote>):</para>
      -->
      <para>把提交日志直接写在命令行上, 如果没有指定目标文件, 则默认提交的是
        当前目录 (<quote><filename>.</filename></quote>) 下的所有修改:</para>

      <informalexample>
        <screen>
$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
</screen>
      </informalexample>

      <!--
      <para>Commit a modification to the file
        <filename>foo.c</filename> (explicitly specified on the
        command line) with the commit message in a file named
        <filename>msg</filename>:</para>
      -->
      <para>提交 <filename>foo.c</filename> 的修改, 并从文件
        <filename>msg</filename> 读取提交日志:</para>

      <informalexample>
        <screen>
$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
</screen>
      </informalexample>

      <!--
      <para>If you want to use a file that's under version control
        for your commit message with <option>- -file</option>
        (<option>-F</option>), you need to pass the
        <option>- -force-log</option> option:</para>
      -->
      <para>如果选项 <option>--file</option> (<option>-F</option>) 所指定的
        文件处于版本控制中, 而你的确想从该文件中读取提交日志, 就要额外加上
        选项 <option>--force-log</option>:</para>

      <informalexample>
        <screen>
$ svn commit -F file_under_vc.txt foo.c
svn: E205004: Log message file is a versioned file; use '--force-log' to override

$ svn commit --force-log -F file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
</screen>
      </informalexample>

      <!--
      <para>To commit a file scheduled for deletion:</para>
      -->
      <para>提交一个将被删除的文件:</para>

      <informalexample>
        <screen>
$ svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.copy">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>copy</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn copy (cp)</refname>
      <!--
      <refpurpose>Copy a file or directory in a working copy or
        in the repository.</refpurpose>
      -->
      <refpurpose>在工作副本或仓库中复制一个文件或目录.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn copy SRC[@REV]... DST</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      
      <!--
      <para>Copy one or more files in a working copy or in the
        repository. <replaceable>SRC</replaceable> and
        <replaceable>DST</replaceable> can each be either a
        working copy (WC) path or URL.  When copying multiple
        sources, add the copies as immediate children
        of <replaceable>DST</replaceable> (which, of course, must
        be an existing directory).</para>
      -->
      <para>在工作副本或仓库中复制一个或多个文件.
        <replaceable>SRC</replaceable> 和 <replaceable>DST</replaceable>
        可以是一个工作副本 (WC) 路径或 URL. 当复制多个源文件时, 每个源文件
        都将是 <replaceable>DST</replaceable> (此时
        <replaceable>DST</replaceable> 必须是一个已存在的目录) 的直接子文件.
      </para>
        
        <variablelist>

          <varlistentry>
            <term>WC &rarr; WC</term>
            <listitem>
      <!--
              <para>Copy and schedule an item for
                addition (with history).</para>
      -->
              <para>复制并添加一个工作副本路径 (包含历史).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>WC &rarr; URL</term>
            <listitem>
      <!--
              <para>Immediately commit a copy of WC to URL.</para>
      -->
              <para>立刻把 WC 的副本提交到 URL.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>URL &rarr; WC</term>
            <listitem>
      <!--
              <para>Check out URL into WC and schedule it for
                addition.</para>
      -->
              <para>把 URL 检出到 WC, 并添加 WC.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>URL &rarr; URL</term>
            <listitem>
      <!--
              <para>Complete server-side copy.  This is
                usually used to branch and tag.</para>
      -->
              <para>执行一个服务器端的复制. 这通常用于创建分支和标签.</para>
            </listitem>
          </varlistentry>

        </variablelist>

      <!--
      <para>If no peg revision (i.e.,
        <literal>@<replaceable>REV</replaceable></literal>) is supplied,
        by default
        the <literal>BASE</literal> revision will be used for
        files copied from the working copy, while the
        <literal>HEAD</literal> revision will be used for files
        copied from a URL.</para>
      -->
      <para>如果没有提供限定版本号 (即
        <literal>@<replaceable>REV</replaceable></literal>), 那么在复制工作
        副本路径时, 默认使用 <literal>BASE</literal> 版本号, 在复制 URL
        时默认使用 <literal>HEAD</literal> 版本号.</para>

      <note>
      <!--
        <para>You can only copy files within a single repository.
          Subversion does not support cross-repository copying.</para>
      -->
        <para>你只能在同一个仓库内复制文件, Subversion 不支持在不同的仓库之间
          进行复制.</para>
      </note>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Copy an item within your working copy (this
        schedules the copy&mdash;nothing goes into the repository
        until you commit):</para>
      -->
      <para>复制工作副本里的一个文件, 并把它添加到需要被版本控制的列表里
        (在提交之前, 这个复制操作丝毫不会影响到仓库):</para>

      <informalexample>
        <screen>
$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +    bar.txt
</screen>
      </informalexample>

      <!--
      <para>Copy several files in a working copy into a directory:</para>
      -->
      <para>把工作副本里的多个文件复制到一个目录内:</para>

      <informalexample>
        <screen>
$ svn copy bat.c baz.c qux.c src
A         src/bat.c
A         src/baz.c
A         src/qux.c
</screen>
      </informalexample>

      <!--
      <para>Copy revision 8 of <filename>bat.c</filename> into your
        working copy under a different name:</para>
      -->
      <para>复制工作副本文件 <filename>bat.c</filename> 的版本号 8, 并重新
        命名复制后的文件.</para>

      <informalexample>
        <screen>
$ svn copy -r 8 bat.c ya-old-bat.c
A         ya-old-bat.c
</screen>
      </informalexample>

      <!--
      <para>Copy an item in your working copy to a URL in the
        repository (this is an immediate commit, so you must supply a
        commit message):</para>
      -->
      <para>把工作副本里的文件复制到仓库中 (这个复制会马上提交, 所以用户
        需要提供提交日志消息):</para>

      <informalexample>
        <screen>
$ svn copy near.txt file:///var/svn/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
</screen>
      </informalexample>

      <!--
      <para>Copy an item from the repository to your working
        copy (this just schedules the copy&mdash;nothing goes into the
        repository until you commit):</para>
      -->
      <para>从仓库复制一个文件到工作副本中 (在提交之前, 这个复制操作丝毫不会
        影响到仓库):</para>

      <informalexample>
        <screen>
$ svn copy file:///var/svn/repos/test/far-away -r 6 near-here
A         near-here
</screen>
      </informalexample>

      <tip>
      <!--
        <para>This is the recommended way to resurrect a dead
          file in your repository!</para>
      -->
        <para>这是找回仓库中已被删除文件的推荐方式!</para>
      </tip>

      <!--
      <para>And finally, copy between two URLs:</para>
      -->
      <para>最后是从一个 URL 复制到另一个 URL:</para>

      <informalexample>
        <screen>
$ svn copy file:///var/svn/repos/test/far-away \
           file:///var/svn/repos/test/over-there -m "remote copy."

Committed revision 9.
</screen>
      </informalexample>

      <informalexample>
        <screen>
$ svn copy file:///var/svn/repos/test/trunk \
           file:///var/svn/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
</screen>
      </informalexample>

      <tip>
      <!--
        <para>This is the easiest way to <quote>tag</quote> a
          revision in your repository&mdash;just <command>svn
          copy</command> that revision (usually
          <literal>HEAD</literal>) into your <filename>tags</filename> directory.</para>
      -->
        <para>这是打标签最简单的方法&mdash;只需要用 <command>svn copy</command>
          把版本号 (通常是 <literal>HEAD</literal>) 复制到
          <filename>tags</filename> 目录中.</para>
      </tip>

      <!--
      <para>And don't worry if you forgot to tag&mdash;you can
        always specify an older revision and tag anytime:</para>
      -->
      <para>即使忘记打标签也不需要担心&mdash;在任何时候, 你总是可以为一个较
        老的版本号创建标签:</para>

      <informalexample>
        <screen>
$ svn copy -r 11 file:///var/svn/repos/test/trunk \
           file:///var/svn/repos/test/tags/0.6.32-prerelease \
           -m "Forgot to tag at rev 11"

Committed revision 13.
</screen>
      </informalexample>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.delete">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>delete</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn delete (del, remove, rm)</refname>
      <!--
      <refpurpose>Delete an item from a working copy
        or the repository.</refpurpose>
      -->
      <refpurpose>从工作副本或仓库中删除文件.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn delete PATH...</literal></para>
      <para><literal>svn delete URL...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Items specified by <replaceable>PATH</replaceable> are
        scheduled for deletion upon the next commit.  Files (and
        directories that have not been committed) are immediately
        removed from the working copy unless the
        <option>- -keep-local</option> option is given.  The
        command will not remove any unversioned or modified items;
        use the <option>- -force</option> option to override this
        behavior. A directory that contains unversioned or modified
        items will not be deleted, unless the <option>- -force</option>
        is used.</para>
      -->
      <para>由 <replaceable>PATH</replaceable> 指定的文件将在提交时从仓库中
        删除. 执行完命令后, 文件和未被提交的目录会马上从工作副本中删除, 除非
        指定了选项 <option>--keep-local</option>. 命令不会删除未被版本控制或
        含有本地修改的文件, 除非指定了选项 <option>--force</option>. 如果目录
        内含有未被版本控制的文件, 或者文件含有本地修改, 这个目录就不会被删除,
        除非指定了选项 <option>--force</option>.</para>

      <!--
      <para>Items specified by URL are deleted from
        the repository via an immediate commit.  Multiple URLs are
        committed atomically.</para>
      -->
      <para>由 URL 指定的文件会马上触发一个提交操作, 然后直接从仓库中删除.
        如果指定了多个 URL, 它们将在同一个提交中完成删除.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.keep_local" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Using <command>svn</command> to delete a file from
        your working copy deletes your local copy of the file, but
        it merely schedules the file to be deleted from the
        repository.  When you commit, the file is deleted in the
        repository.</para>
      -->
      <para><command>svn delete</command> 会删除工作副本里的文件, 但要等到
        提交后才会从仓库中删除.</para>

      <informalexample>
        <screen>
$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
</screen>
      </informalexample>

      <!--
      <para>Deleting a URL, however, is immediate, so you have
        to supply a log message:</para>
      -->
      <para>删除由 URL 指定的文件会马上触发一个提交操作, 所以用户需要提供
        提交日志:</para>

      <informalexample>
        <screen>
$ svn delete -m "Deleting file 'yourfile'" \
             file:///var/svn/repos/test/yourfile

Committed revision 15.
</screen>
      </informalexample>

      <!--
      <para>Here's an example of how to force deletion of a file
        that has local modifications:</para>
      -->
      <para>下面的例子展示了如何强制删除含有本地修改的文件:</para>

      <informalexample>
        <screen>
$ svn delete over-there 
svn: E195006: Use --force to override this restriction (local modifications m\
ay be lost)
svn: E195006: '/home/sally/project/over-there' has local modifications -- com\
mit or revert them first
$ svn delete --force over-there 
D         over-there
$
</screen>
      </informalexample>

      <!--
      <para>Use the <option>- -keep-local</option> option to
        override the default <command>svn delete</command>
        behavior of also removing the target file that was
        scheduled for versioned deletion.  This is helpful when
        you realize that you've accidentally committed the
        addition of a file that you need to keep around in your
        working copy, but which shouldn't have been added to
        version control.</para>
      -->
      <para>加上选项 <option>--keep-local</option> 后, 被 <command>svn
          delete</command> 删除的文件将保留在本地. 这个选项在处理下面这种
        情况时很有用: 用户不小心把一个本不应该提交的文件提交到了仓库中,
        现在他想从仓库中删除该文件, 但又想把它留在工作副本里.</para>

      <informalexample>
        <screen>
$ svn delete --keep-local conf/program.conf
D         conf/program.conf

$ svn commit -m "Remove accidentally-added configuration file."
Deleting       conf/program.conf
Transmitting file data .
Committed revision 21.
$ svn status
?       conf/program.conf
$
</screen>
      </informalexample>

      <note>
      <!--
        <para>The behavior of the <option>- -keep-local</option>
          option does not propagate to other working copies which
          contain the items you've scheduled for deletion.  If you
          commit the deletion of those items they will remain in
          your working copy, but they will be deleted from other
          working copies which contain them when those working
          copies are then updated.</para>
      -->
        <para>选项 <option>--keep-local</option> 的效果不会扩展到其他工作
          副本, 也就是说如果用户提交了删除操作, 这些文件虽然会保留在你的
          工作副本里, 但是在更新其他工作副本里, 其他工作副本里的文件仍然会
          被删除.</para>
      </note>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.diff">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>diff</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn diff (di)</refname>
      <!--
      <refpurpose>This displays the differences between two revisions or paths.</refpurpose>
      -->
      <refpurpose>显示两个版本号或路径之间的差异.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>diff [-c M | -r N[:M]] [TARGET[@REV]...]</literal></para>
      <para><literal>diff [-r N[:M]] --old=OLD-TGT[@OLDREV] [--new=NEW-TGT[@NEWREV]] [PATH...]</literal></para>
      <para><literal>diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</literal></para>

    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Display the differences between two paths.  You can
        use <command>svn diff</command> in the following ways:</para>
      -->
      <para>显示两个路径之间的差异, 用户可以按照如下方式使用 <command>svn
          diff</command>:</para>

      <itemizedlist>

        <listitem>
      <!--
          <para>Use just <command>svn diff</command> to display local
            modifications in a working copy.</para>
      -->
          <para>直接执行 <userinput>svn diff</userinput> 来查看工作副本的
            本地修改.</para>
        </listitem>

        <listitem>
      <!--
          <para>Display the changes made to
            <replaceable>TARGET</replaceable>s as they are seen in
            <replaceable>REV</replaceable> between two revisions.
            <replaceable>TARGET</replaceable>s may be all working copy
            paths or all <replaceable>URL</replaceable>s.  If
            <replaceable>TARGET</replaceable>s are working copy paths,
            <replaceable>N</replaceable> defaults to
            <literal>BASE</literal> and <replaceable>M</replaceable>
            to the working copy; if <replaceable>TARGET</replaceable>s
            are <replaceable>URL</replaceable>s,
            <replaceable>N</replaceable> must be specified and
            <replaceable>M</replaceable> defaults to
            <literal>HEAD</literal>.  The <literal>-c M</literal> option
            is equivalent to <literal>-r N:M</literal> where <literal>N =
            M-1</literal>.  Using <literal>-c -M</literal> does the
            reverse: <literal>-r M:N</literal> where <literal>N =
            M-1</literal>.</para>
      -->
        <para>显示限定版本号为 <replaceable>REV</replaceable> 时,
          <replaceable>TARGET</replaceable> 在两个版本号之间的变化.
          <replaceable>TARGET</replaceable> 可以全是工作副本路径或
          <replaceable>URL</replaceable>. 如果 <replaceable>TARGET</replaceable>
          是工作副本路径, 则 <replaceable>N</replaceable> 默认是
          <literal>BASE</literal>, <replaceable>M</replaceable> 默认是工作副本.
          如果 <replaceable>TARGET</replaceable> 是
          <replaceable>URL</replaceable>, 则用户必须指定
          <replaceable>N</replaceable>, 而 <replaceable>M</replaceable> 默认
          是 <literal>HEAD</literal>. 选项 <literal>-c M</literal> 等价于
          <literal>-r N:M</literal>, 其中 <literal>N = M-1</literal>;
          而 <literal>-c -M</literal> 正好相反, 它等价于
          <literal>-r M:N</literal>, 其中 <literal>N = M-1</literal>.</para>
        </listitem>

        <listitem>
      <!--
          <para>Display the differences between
            <replaceable>OLD-TGT</replaceable> as it was seen in
            <replaceable>OLDREV</replaceable> and
            <replaceable>NEW-TGT</replaceable> as it was seen in
            <replaceable>NEWREV</replaceable>.
            <replaceable>PATH</replaceable>s, if given, are relative
            to <replaceable>OLD-TGT</replaceable> and
            <replaceable>NEW-TGT</replaceable> and restrict the output
            to differences for those paths.
            <replaceable>OLD-TGT</replaceable> and
            <replaceable>NEW-TGT</replaceable> may be working copy
            paths or <replaceable>URL[@REV]</replaceable>.
            <replaceable>NEW-TGT</replaceable> defaults to
            <replaceable>OLD-TGT</replaceable> if not specified.
            <literal>-r N</literal>
            makes <replaceable>OLDREV</replaceable> default to
            <literal>N</literal>; <literal>-r N:M</literal>
            makes <replaceable>OLDREV</replaceable> default to
            <replaceable>N</replaceable> and
            <replaceable>NEWREV</replaceable> default to
            <replaceable>M</replaceable>.</para>
      -->
          <para>显示限定版本号为 <replaceable>OLDREV</replaceable> 的
            <replaceable>OLD-TGT</replaceable> 和限定版本号
            <replaceable>NEWREV</replaceable> 的
            <replaceable>NEW-TGT</replaceable> 之间的差异. 如果指定了相对于
            <replaceable>OLD-TGT</replaceable> 和
            <replaceable>NEW-TGT</replaceable> 的
            <replaceable>PATH</replaceable>, 那么输出的就是这些路径的差异.
            <replaceable>OLD-TGT</replaceable> 和
            <replaceable>NEW-TGT</replaceable> 可以是工作副本路径或
            <replaceable>URL[@REV]</replaceable>. 如果没有指定
            <replaceable>NEW-TGT</replaceable>, 那么它默认就是
            <replaceable>OLD-TGT</replaceable>. <literal>-r N</literal> 使得
            <replaceable>OLDREV</replaceable> 默认是 <literal>N</literal>;
            <literal>-r N:M</literal> 使得 <replaceable>OLDREV</replaceable>
            默认是 <replaceable>N</replaceable>,
            <replaceable>NEWREV</replaceable> 默认是
            <replaceable>M</replaceable>.</para>
        </listitem>

      </itemizedlist>

      <!--
      <para><userinput>svn diff OLD-URL[@OLDREV]
        NEW-URL[@NEWREV]</userinput> is shorthand for <userinput>svn
        diff - -old=OLD-URL[@OLDREV]
        - -new=NEW-URL[@NEWREV]</userinput>.</para>
      -->
      <para><userinput>svn diff OLD-URL[@OLDREV]
        NEW-URL[@NEWREV]</userinput> 是 <userinput>svn
        diff --old=OLD-URL[@OLDREV]
        --new=NEW-URL[@NEWREV]</userinput> 的缩写形式.</para>

      <!--
      <para><userinput>svn diff -r N:M URL</userinput> is shorthand
        for <userinput>svn diff -r N:M - -old=URL
        - -new=URL</userinput>.</para>
      -->
      <para><userinput>svn diff -r N:M URL</userinput> 是
        <userinput>svn diff -r N:M --old=URL
        --new=URL</userinput> 的缩写形式.</para>

      <!--
      <para><userinput>svn diff [-r N[:M]] URL1[@N]
        URL2[@M]</userinput> is shorthand for <userinput>svn diff [-r
        N[:M]] - -old=URL1 - -new=URL2</userinput>.</para>
      -->
      <para><userinput>svn diff [-r N[:M]] URL1[@N]
        URL2[@M]</userinput> 是 <userinput>svn diff [-r
        N[:M]] --old=URL1 --new=URL2</userinput> 的缩写形式.</para>

      <!--
      <para>If <replaceable>TARGET</replaceable> is a URL, then
        revisions <replaceable>N</replaceable> and <replaceable>M</replaceable>
        can be
        given either via the
        <option>- -revision</option> (<option>-r</option>) option
        or by using the
        <quote>@</quote> notation as described earlier.</para>
      -->
      <para>如果 <replaceable>TARGET</replaceable> 是一个 URL, 那么
        <replaceable>N</replaceable> 和 <replaceable>M</replaceable> 可以
        用选项 <option>--revision</option> (<option>-r</option>) 指定,
        或者用以前介绍过的 <quote>@</quote> 记号.</para>

      <!--
      <para>If <replaceable>TARGET</replaceable> is a working copy
        path, the default behavior (when no
        <option>- -revision</option> (<option>-r</option>) option
        is provided) is to display the differences between the
        base and working copies
        of <replaceable>TARGET</replaceable>.  If a
        <option>- -revision</option> (<option>-r</option>) option
        is specified in this scenario, though, it means:</para>
      -->
      <para>如果 <replaceable>TARGET</replaceable> 是一个工作副本路径, 那么
        命令的默认行为 (没有指定选项 <option>--revision</option>
        (<option>-r</option>)) 就是显示 <replaceable>TARGET</replaceable>
        的 <literal>BASE</literal> 与工作副本之间的差异. 如果指定了选项
        <option>--revision</option> (<option>-r</option>), 这意味着:</para>

      <variablelist>

        <varlistentry>
          <term><option>--revision N:M</option></term>
          <listitem>
      <!--
            <para>The server compares <replaceable>TARGET@N</replaceable>
              and <replaceable>TARGET@M</replaceable>.</para>
      -->
            <para>服务器将比较 <replaceable>TARGET@N</replaceable> 和
              <replaceable>TARGET@M</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--revision N</option></term>
          <listitem>
      <!--
            <para>The client compares
              <replaceable>TARGET@N</replaceable>
              against the working copy.</para>
      -->
            <para>客户端将比较 <replaceable>TARGET@N</replaceable> 和工作
              副本.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>If the alternate syntax is used, the server compares
        <replaceable>URL1</replaceable> and
        <replaceable>URL2</replaceable> at revisions
        <replaceable>N</replaceable> and
        <replaceable>M</replaceable>, respectively.  If either
        <replaceable>N</replaceable> or
        <replaceable>M</replaceable> is omitted, a value of
        <literal>HEAD</literal> is assumed.</para>
      -->
      <para>如果使用了替代语法, 服务器将比较分别处于版本号
        <replaceable>N</replaceable> 和 <replaceable>M</replaceable> 下
        的 <replaceable>URL1</replaceable> 和 <replaceable>URL2</replaceable>.
        如果没有指定 <replaceable>N</replaceable> 或
        <replaceable>M</replaceable>, 将默认使用 <literal>HEAD</literal>.
      </para>

      <!--
      <para>By default, <command>svn diff</command> ignores the
        ancestry of files and merely compares the contents of the
        two files being compared.  If you use
        <option>- -notice-ancestry</option>, the ancestry of the
        paths in question will be taken into consideration when
        comparing revisions (i.e., if you run <command>svn
        diff</command> on two files with identical contents but
        different ancestry, you will see the entire contents of
        the file as having been removed and added again).</para>
      -->
      <para>默认情况下, <command>svn diff</command> 会忽略文件的祖先, 而只
        比较文件的内容. 如果使用了选项 <option>--notice-ancestry</option>,
        那么在比较版本号时就是考虑相关路径的祖先 (也就是说,如果你用
        <command>svn diff</command> 比较了两个内容相同, 但祖先不同的文件, 你
        将会看到文件的整个内容曾经被删除, 然后又被添加).</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.change" />
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff_cmd" />
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.git" />
<xref linkend="svn.ref.svn.sw.ignore_properties" />
<xref linkend="svn.ref.svn.sw.internal_diff" />
<xref linkend="svn.ref.svn.sw.new" />
<xref linkend="svn.ref.svn.sw.no_diff_added" />
<xref linkend="svn.ref.svn.sw.no_diff_deleted" />
<xref linkend="svn.ref.svn.sw.notice_ancestry" />
<xref linkend="svn.ref.svn.sw.old" />
<xref linkend="svn.ref.svn.sw.patch_compatible" />
<xref linkend="svn.ref.svn.sw.properties_only" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.show_copies_as_adds" />
<xref linkend="svn.ref.svn.sw.summarize" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Compare <literal>BASE</literal> and your working copy
        (one of the most popular uses of <command>svn
        diff</command>):</para>
      -->
    <para>比较 <literal>BASE</literal> 与工作副本 (<command>svn diff</command>
      最常见的用途之一):</para>

      <informalexample>
        <screen>
$ svn diff COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
&hellip;
</screen>
      </informalexample>

      <!--
      <para>See what changed in the file
        <filename>COMMITTERS</filename> revision 9115:</para>
      -->
      <para>查看 <filename>COMMITTERS</filename> 在版本号 9115 发生了哪些
        变化:</para>

      <informalexample>
        <screen>
$ svn diff -c 9115 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
&hellip;
</screen>
      </informalexample>


      <!--
      <para>See how your working copy's modifications compare
        against an older revision:</para>
      -->
      <para>比较工作副本和更老的版本号:</para>

      <informalexample>
        <screen>
$ svn diff -r 3900 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Compare revision 3000 to revision 3500 using <quote>@</quote>
        syntax:</para>
      -->
      <para>使用 <quote>@</quote> 语法比较版本号 3000 和 3500:</para>

      <informalexample>
        <screen>
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 \
           http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Compare revision 3000 to revision 3500 using range
        notation (pass only the one URL in this
        case):</para>
      -->
      <para>使用范围记号比较版本号 3000 与 3500 (这时候只需要一个 URL 参数):
      </para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
&hellip;
</screen>
      </informalexample>


      <!--
      <para>Compare revision 3000 to revision 3500 of all the files in
        <filename>trunk</filename> using range notation:</para>
      -->
      <para>使用范围记号比较 <filename>trunk</filename> 内的所有文件在
        版本号 3000 到 3500 之间的变化:</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
</screen>
      </informalexample>


      <!--
      <para>Compare revision 3000 to revision 3500 of only three
        files in <filename>trunk</filename> using range
        notation:</para>
      -->
      <para>使用范围记号比较 <filename>trunk</filename> 内的三个文件在版本
        号 3000 到 3500 之间的变化:</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk \
       COMMITTERS README HACKING
</screen>
      </informalexample>

      <!--
      <para>If you have a working copy, you can obtain the
        differences without typing in the long URLs:</para>
      -->
      <para>如果你已经有了一个工作副本, 就不用再输入冗长的 URL:</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Use <option>- -diff-cmd</option>
        <replaceable>CMD</replaceable> <option>- -extensions</option>
        (<option>-x</option>) to pass arguments directly to the
        external diff program:</para>
      -->
      <para>使用选项 <option>--diff-cmd</option> <replaceable>CMD</replaceable>
        <option>--extensions</option> (<option>-x</option>) 向外部差异比较
        工具传递参数:</para>

      <informalexample>
        <screen>
$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt; 
$
</screen>
      </informalexample>

      <!--
      <para>Lastly, you can use the <option>- -xml</option> option
        along with the <option>- -summarize</option> option to view
        XML describing the changes that occurred between
        revisions, but not the contents of the diff itself:</para>
      -->
      <para>最后, 可以同时使用选项 <option>--xml</option> 和
        <option>--summarize</option> 查看修改的 XML 描述, 修改的具体内容不
        会显示出来:</para>

      <informalexample>
        <screen>
$ svn diff --summarize --xml http://svn.red-bean.com/repos/test@r2 \
           http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;diff&gt;
&lt;paths&gt;
&lt;path
   props="none"
   kind="file"
   item="modified"&gt;http://svn.red-bean.com/repos/test/sandwich.txt&lt;/path&gt;
&lt;path
   props="none"
   kind="file"
   item="deleted"&gt;http://svn.red-bean.com/repos/test/burrito.txt&lt;/path&gt;
&lt;path
   props="none"
   kind="dir"
   item="added"&gt;http://svn.red-bean.com/repos/test/snacks&lt;/path&gt;
&lt;/paths&gt;
&lt;/diff&gt;
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.export">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>export</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn export</refname>
      <!--
      <refpurpose>Export a clean directory tree.</refpurpose>
      -->
      <refpurpose>导出一个干净的目录树.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn export [-r REV] URL[@PEGREV] [PATH]</literal></para>
      <para><literal>svn export [-r REV] PATH1[@PEGREV] [PATH2]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>The first form exports a clean directory tree from the
        repository specified by <replaceable>URL</replaceable>&mdash;at revision
        <replaceable>REV</replaceable> if it is given; otherwise,
        at <literal>HEAD</literal>, into
        <replaceable>PATH</replaceable>.  If
        <replaceable>PATH</replaceable> is omitted, the last
        component of the <replaceable>URL</replaceable> is used
        for the local directory name.</para>
      -->
      <para>命令的第一种形式从 <replaceable>URL</replaceable> 所指定的仓库
        导出一个干净的目录树到 <replaceable>PATH</replaceable>. 如果指定了
        <replaceable>REV</replaceable>, 将导出仓库在版本号
        <replaceable>REV</replaceable> 时的目录树, 否则的话版本号默认就是
        <literal>HEAD</literal>. 如果省略 <replaceable>PATH</replaceable>,
        那么 <replaceable>URL</replaceable> 的最后一个分量将作为导出后的
        目录名.</para>

      <!--
      <para>The second form exports a clean directory tree from
        the working copy specified by
        <replaceable>PATH1</replaceable> into
        <replaceable>PATH2</replaceable>.  All local changes will
        be preserved, but files not under version control will not
        be copied.</para>
      -->
      <para>命令的第二种形式从 <replaceable>PATH1</replaceable> 指定的工作
        副本导出一个干净的目录树到 <replaceable>PATH2</replaceable>. 所有的
        本地修改都会保留在导出的目录中, 但不包括不被版本控制的文件.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.ignore_keywords" />
<xref linkend="svn.ref.svn.sw.native_eol" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Export from your working copy (doesn't print every
        file and directory):</para>
      -->
      <para>从工作副本导出 (被导出的文件或目录的名字不会打印出来):</para>

      <informalexample>
        <screen>
$ svn export a-wc my-export
Export complete.
</screen>
      </informalexample>

      <!--
      <para>Export directly from the repository (prints every
        file and directory):</para>
      -->
      <para>从仓库导出 (被导出的每一个文件或目录的名字都会打印出来):</para>

      <informalexample>
        <screen>
$ svn export file:///var/svn/repos my-export
A    my-export/test
A    my-export/quiz
&hellip;
Exported revision 15.
</screen>
      </informalexample>

      <!--
      <para>When rolling operating-system-specific release
        packages, it can be useful to export a tree that uses a
        specific EOL character for line endings.  The
        <option>- -native-eol</option> option will do this, but it
        affects only files that have <literal>svn:eol-style =
        native</literal> properties attached to them.  For
        example, to export a tree with all CRLF line endings
        (possibly for a Windows <filename>.zip</filename> file
        distribution):</para>
      -->
      <para>在制作特定于操作系统的发行包时, 如果能为导出的目录树指定特定的
        EOL, 那将会非常方便, 选项 <option>--native-eol</option> 就是用于这
        个目的, 但是它只会影响设置了属性
        <literal>svn:eol-style=native</literal> 的文件. 例如, 为 Windows
        导出以 CRLF 作为 EOL 的目录树:</para>

      <informalexample>
        <screen>
$ svn export file:///var/svn/repos my-export --native-eol CRLF
A    my-export/test
A    my-export/quiz
&hellip;
Exported revision 15.
</screen>
      </informalexample>

      <!--
      <para>You can specify <literal>LR</literal>,
        <literal>CR</literal>, or <literal>CRLF</literal> as a
        line-ending type with the <option>- -native-eol</option>
        option.</para>
      -->
      <para>选项 <option>--native-eol</option> 接受的参数有
        <literal>LR</literal>, <literal>CR</literal> 和
        <literal>CRLF</literal>.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.help">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn help (h, ?)</refname>
      <!--
      <refpurpose>Help!</refpurpose>
      -->
      <refpurpose>帮助!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn help [SUBCOMMAND...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>This is your best friend when you're using
        Subversion and this book isn't within reach!</para>
      -->
      <para>如果你无法获取这本书, 那么这个命令就是你使用 Subversion
        的最好帮手!</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>
      <!--
      <para>None</para>
      -->
      <para>没有选项</para>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.import">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>import</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn import</refname>
      <!--
      <refpurpose>Commit an unversioned file or tree into the 
        repository.</refpurpose>
      -->
      <refpurpose>把未被版本控制的文件或目录树提交到仓库中.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn import [PATH] URL</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Recursively commit a copy of
        <replaceable>PATH</replaceable> to
        <replaceable>URL</replaceable>.  If
        <replaceable>PATH</replaceable> is omitted,
        <quote><filename>.</filename></quote> is assumed.  Parent
        directories are created in the repository as necessary.
        Unversionable items such as device files and pipes are
        ignored even if <option>- -force</option> is
        specified.</para>
      -->
      <para>递归地把 <replaceable>PATH</replaceable> 提交到
        <replaceable>URL</replaceable>, 如果省略了
        <replaceable>PATH</replaceable>, 将使用
        <quote><filename>.</filename></quote>. 在必要时会在仓库中创建父目录.
        即使添加了选项 <option>--force</option>, 无法被版本控制的文件 (例如
        设备文件和命名管道) 也会被忽略.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.auto_props" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.no_auto_props" />
<xref linkend="svn.ref.svn.sw.no_ignore" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>This imports the local directory
        <filename>myproj</filename> into
        <filename>trunk/misc</filename> in your repository.  The
        directory <filename>trunk/misc</filename> need not exist
        before you import into it&mdash;<command>svn
        import</command> will recursively create directories for
        you.</para>
      -->
      <para>下面的命令把本地目录 <filename>myproj</filename> 导入到仓库的
        <filename>trunk/misc</filename> 目录中. 在导入前不用事先创建
        <filename>trunk/misc</filename>&mdash;<command>svn import</command>
        会自动创建所需的目录.</para>

      <informalexample>
        <screen>
$ svn import -m "New import" myproj \
             http://svn.red-bean.com/repos/trunk/misc
Adding         myproj/sample.txt
&hellip;
Transmitting file data .........
Committed revision 16.
</screen>
      </informalexample>

      <!--
      <para>Be aware that this will <emphasis>not</emphasis>
        create a directory named <filename>myproj</filename> in
        the repository.  If that's what you want, simply add
        <filename>myproj</filename> to the end of the URL:</para>
      -->
      <para>需要注意的是上面的命令 <emphasis>不会</emphasis> 在仓库中创建目录
        <filename>myproj</filename>, 但是如果你希望创建该目录, 就把
        <filename>myproj</filename> 作为 URL 的最后一个分量:</para>

      <informalexample>
        <screen>
$ svn import -m "New import" myproj \
            http://svn.red-bean.com/repos/trunk/misc/myproj
Adding         myproj/sample.txt
&hellip;
Transmitting file data .........
Committed revision 16.
</screen>
      </informalexample>

      <!--
      <para>After importing data, note that the original tree is
        <emphasis>not</emphasis> under version control.  To start
        working, you still need to <command>svn checkout</command>
        a fresh working copy of the tree.</para>
      -->
      <para>导入完成后, 被导入的本地目录 <emphasis>不会</emphasis> 变成工作
        副本, 用户还是需要使用 <command>svn checkout</command> 检出工作副本.
      </para>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.info">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>info</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn info</refname>
      <!--
      <refpurpose>Display information about a local or remote 
        item.</refpurpose>
      -->
      <refpurpose>显示文件的相关信息, 该文件可以在本地工作副本或远程服务器
        上.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn info [TARGET[@REV]...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Print information about the working copy paths or URLs
        specified.  The information displayed for each path may
        include (as pertinent to the object at that path):</para>
      -->
      <para>打印工作副本路径或 URL 的相关信息, 相关信息可能包括:</para>

      <itemizedlist>
      <!--
        <listitem><para>information about the repository in which
          the object is versioned</para></listitem>
      -->
      <listitem><para>该对象所在的仓库信息</para></listitem>
      <!--
        <listitem><para>the most recent commit made to the
          specified version of the object</para></listitem>
      -->
      <listitem><para>该对象的最近一次提交</para></listitem>
      <!--
        <listitem><para>any user-level locks held on the
          object</para></listitem>
      -->
      <listitem><para>该对象上的用户级别的锁</para></listitem>
      <!--
        <listitem><para>local scheduling information (added,
          deleted, copied, etc.)</para></listitem>
      -->
      <listitem><para>本地的调度信息 (添加, 删除, 复制等)</para></listitem>
      <!--
        <listitem><para>local conflict information</para></listitem>
      -->
        <listitem><para>本地的冲突信息</para></listitem>
      </itemizedlist>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para><command>svn info</command> will show you all the
        useful information that it has for items in your working
        copy.  It will show information for files:</para>
      -->
      <para><command>svn info</command> 会显示工作副本路径的所有相关信息,
        例如显示文件的信息:</para>

      <informalexample>
        <screen>
$ svn info foo.c
Path: foo.c
Name: foo.c
Working Copy Root Path: /home/sally/projects/test
URL: http://svn.red-bean.com/repos/test/foo.c
Relative URL: ^/foo.c
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: d6aeb60b0662ccceb6bce4bac344cb66
</screen>
      </informalexample>

      <!--
      <para>It will also show information for directories:</para>
      -->
      <para>显示目录的信息:</para>

      <informalexample>
        <screen>
$ svn info vendors
Path: vendors
Working Copy Root Path: /home/sally/projects/test
URL: http://svn.red-bean.com/repos/test/vendors
Relative URL: ^/vendors
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-16 23:39:02 -0600 (Thu, 16 Jan 2003)
</screen>
      </informalexample>

      <!--
       <para><command>svn info</command> also acts on URLs (also
         note that the file <filename>readme.doc</filename> in
         this example is locked, so lock information is also
         provided):</para>
      -->
       <para><command>svn info</command> 也能针对 URL 进行操作 (注意在下面
         例子里, 文件 <filename>readme.doc</filename> 是被加锁的, 所以输出中
         包含了关于锁的信息):</para>

       <informalexample>
         <screen>
$ svn info http://svn.red-bean.com/repos/test/readme.doc
Path: readme.doc
Name: readme.doc
URL: http://svn.red-bean.com/repos/test/readme.doc
Relative URL: ^/readme.doc
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 1
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 42
Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2
Lock Owner: harry
Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)
Lock Comment (1 line):
My test lock comment
</screen>
       </informalexample>

      <!--
       <para>Lastly, <command>svn info</command> output is
         available in XML format by passing
         the <option>- -xml</option> option:</para>
      -->
       <para>最后, 如果添加了选项 <option>--xml</option>,
         <command>svn info</command> 还能以 XML 格式打印输出:</para>

       <informalexample>
         <screen>
$ svn info --xml http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;info&gt;
&lt;entry
   kind="dir"
   path="."
   revision="1"&gt;
&lt;url&gt;http://svn.red-bean.com/repos/test&lt;/url&gt;
&lt;relative-url&gt;^/&lt;/relative-url&gt;
&lt;repository&gt;
&lt;root&gt;http://svn.red-bean.com/repos/test&lt;/root&gt;
&lt;uuid&gt;5e7d134a-54fb-0310-bd04-b611643e5c25&lt;/uuid&gt;
&lt;/repository&gt;
&lt;wc-info&gt;
&lt;schedule&gt;normal&lt;/schedule&gt;
&lt;depth&gt;infinity&lt;/depth&gt;
&lt;/wc-info&gt;
&lt;commit
   revision="1"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2003-01-15T23:35:12.847647Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;/info&gt;
</screen>
       </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.list">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>list</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn list (ls)</refname>
      <!--
      <refpurpose>List directory entries in the repository.</refpurpose>
      -->
      <refpurpose>列出仓库中的目录项.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn list [TARGET[@REV]...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>List each <replaceable>TARGET</replaceable> file and
        the contents of each <replaceable>TARGET</replaceable>
        directory as they exist in the repository.  If
        <replaceable>TARGET</replaceable> is a working copy path,
        the corresponding repository URL will be used.</para>
      -->
      <para>列出仓库中的每一个 <replaceable>TARGET</replaceable> 文件和
        <replaceable>TARGET</replaceable> 目录的内容. 如果
        <replaceable>TARGET</replaceable> 是一个工作副本路径, 命令将自动使用
        工作路径的 URL.</para>

      <!--
      <para>The default <replaceable>TARGET</replaceable> is
        <quote><filename>.</filename></quote>, meaning the
        repository URL of the current working copy
        directory.</para>
      -->
      <para><replaceable>TARGET</replaceable> 的默认值是
        <quote><filename>.</filename></quote>, 即当前工作副本目录在仓库中的
        URL.</para>

      <!--
      <para>With <option>- -verbose</option>
        (<option>-v</option>), <command>svn list</command> shows
        the following fields for each item:</para>
      -->
      <para>如果带上了选项 <option>--verbose</option> (<option>-v</option>),
        <command>svn list</command> 将额外显示项目的如下字段:</para>

      <itemizedlist>
      <!--
        <listitem><para>Revision number of the last
          commit</para></listitem>
      -->
      <listitem><para>最近一次提交的版本号</para></listitem>

      <!--
        <listitem><para>Author of the last commit</para></listitem>
      -->
        <listitem><para>最近一次提交的作者</para></listitem>

      <!--
        <listitem><para>If locked, the letter <quote>O</quote> (see the preceding section on <xref
          linkend="svn.ref.svn.c.info"/> for details).</para></listitem>
      -->
    <listitem><para>如果文件被锁定了, 则显示字母 <quote>O</quote> (更多的细节
        见前面的 <xref linkend="svn.ref.svn.c.info"/></para></listitem>

      <!--
        <listitem><para>Size (in bytes)</para></listitem>
      -->
        <listitem><para>大小 (以字节为单位)</para></listitem>

      <!--
        <listitem><para>Date and time of the last
          commit</para></listitem>
      -->
      <listitem><para>最近一次提交的日期和时间</para></listitem>
      </itemizedlist>

      <!--
      <para>With <option>- -xml</option>, output is in XML format
        (with a header and an enclosing document element unless
        <option>- -incremental</option> is also specified).  All of
        the information is present; the <option>- -verbose</option>
        (<option>-v</option>) option is not accepted.</para>
      -->
      <para>如果添加了选项 <option>--xml</option>, 输出将会是 XML 格式
        (带有头部信息和封闭的文件元素, 除非还添加了选项
        <option>--incremental</option>), 所有的信息都会被呈现出来, 但
        此时不能再使用选项 <option>--verbose</option> (<option>-v</option>).
      </para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para><command>svn list</command> is most useful if you
        want to see what files a repository has without
        downloading a working copy:</para>
      -->
      <para>如果你想查看仓库里有哪些文件, 但又不想检出工作副本, 那么
        <command>svn list</command> 就显得很方便了:</para>

      <informalexample>
        <screen>
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
&hellip;
</screen>
      </informalexample>

      <!--
      <para>You can pass the <option>- -verbose</option>
        (<option>-v</option>) option for additional information,
        rather like the Unix command
        <command>ls -l</command>:</para>
      -->
      <para>如果你想查看更多的信息, 就添加选项 <option>--verbose</option>,
        就像 Unix 命令 <command>ls -l</command>:</para>

      <informalexample>
        <screen>
$ svn list -v file:///var/svn/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
</screen>
      </informalexample>

      <!--
      <para>You can also get <command>svn list</command> output in
        XML format with the <option>- -xml</option> option:</para>
      -->
      <para>添加选项 <option>--xml</option> 后, <command>svn list</command>
        将以 XML 格式显示输出:</para>

      <informalexample>
        <screen>
$ svn list --xml http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;lists&gt;
&lt;list
   path="http://svn.red-bean.com/repos/test"&gt;
&lt;entry
   kind="dir"&gt;
&lt;name&gt;examples&lt;/name&gt;
&lt;size&gt;0&lt;/size&gt;
&lt;commit
   revision="24"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-01-18T06:35:53.048870Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
...
&lt;/list&gt;
&lt;/lists&gt;
</screen>
      </informalexample>

      <!--
      <para>For further details, see the earlier section <xref
        linkend="svn.tour.history.browsing.list"/>.</para>
      -->
    <para>更多的信息见 <xref linkend="svn.tour.history.browsing.list"/>.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.lock">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>lock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn lock</refname> 
      <!--
        <refpurpose>Lock working copy paths or URLs in the
          repository so that no other user can commit changes to
          them.</refpurpose>
      -->
        <refpurpose>根据工作副本路径或 URL, 为仓库里的文件加锁, 从而阻止其他
          用户提交这些文件的修改.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn lock TARGET...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Lock each <replaceable>TARGET</replaceable>.  If any
        <replaceable>TARGET</replaceable> is already locked by
        another user, print a warning and continue locking the
        rest of the <replaceable>TARGET</replaceable>s.  Use
        <option>- -force</option> to steal a lock from another user
        or working copy.</para>
      -->
      <para>锁定每一个 <replaceable>TARGET</replaceable>. 如果存在
        <replaceable>TARGET</replaceable> 已经被其他用户锁定了, Subversion
        将打印一个警告, 然后继续锁定剩下的 <replaceable>TARGET</replaceable>.
        如果想要从其他用户或工作副本那儿窃取锁, 就加上选项
        <option>--force</option>.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Lock two files in your working copy:</para>
      -->
      <para>锁定工作副本中的两个文件:</para>

      <informalexample>
        <screen>
$ svn lock tree.jpg house.jpg
'tree.jpg' locked by user 'harry'.
'house.jpg' locked by user 'harry'.
</screen>
      </informalexample>

      <!--
      <para>Lock a file in your working copy that is currently
        locked by another user:</para>
      -->
      <para>锁定一个已经被其他用户锁定的文件:</para>

      <informalexample>
        <screen>
$ svn lock tree.jpg
svn: warning: W160035: Path '/tree.jpg is already locked by user 'sally' in fi
lesystem '/var/svn/repos/db'
$ svn lock --force tree.jpg
'tree.jpg' locked by user 'harry'.
</screen>
      </informalexample>

      <!--
      <para>Lock a file without a working copy:</para>
      -->
      <para>在没有工作副本的情况下锁定一个文件:</para>

      <informalexample>
        <screen>
$ svn lock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg' locked by user 'harry'.
</screen>
      </informalexample>

      <!--
      <para>For further details, see <xref
        linkend="svn.advanced.locking"/>.</para>
      -->
    <para>更多的细节, 见 <xref linkend="svn.advanced.locking"/>.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.log">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>log</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn log</refname>
      <!--
      <refpurpose>Display commit log messages.</refpurpose>
      -->
      <refpurpose>显示提交日志消息.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn log [PATH]</literal></para>
      <para><literal>svn log URL[@REV] [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Shows log messages from the repository.
        If no arguments are supplied, <command>svn
        log</command> shows the log messages for all files and
        directories inside (and including) the current working
        directory of your working copy.  You can refine the
        results by specifying a path, one or more revisions, or
        any combination of the two.  The default revision range
        for a local path is <literal>BASE:1</literal>.</para>
      -->
      <para>显示仓库的日志消息. 如果没有指定目标参数, <command>svn
          log</command> 将显示当前工作副本目录的日志消息. 为了提炼输出结果,
        你可以指定一个路径, 一个或多个版本号, 或路径与版本号的组合. Subversion
        为一个本地路径打印的默认版本号范围是 <literal>BASE:1</literal>.</para>

      <!--
      <para>If you specify a URL alone, it prints log
        messages for everything the URL contains.  If you
        add paths past the URL, only messages for those paths
        under that URL will be printed.  The default revision range
        for a URL is <literal>HEAD:1</literal>.</para>
      -->
      <para>如果用户只指定了一个 URL, 命令将会为 URL 内的所有文件打印日志
        消息, 如果你在 URL 中添加了路径, 命令将只打印该路径的日志消息.
        Subversion 为一个 URL 打印的默认版本号范围是 <literal>BASE:1</literal>.
      </para>

      <!--
      <para>With <option>- -verbose</option>
        (<option>-v</option>), <command>svn log</command> will
        also print all affected paths with each log message.
        With <option>- -quiet</option>
        (<option>-q</option>), <command>svn log</command> will not
        print the log message body itself, this is compatible
        with <option>- -verbose</option>
        (<option>-v</option>).</para>
      -->
      <para>如果添加了选项 <option>--verbose</option> (<option>-v</option>),
        <command>svn log</command> 还会额外打印在本次修改中受到影响的路径.
        如果添加了选项 <option>--quiet</option> (<option>-q</option>),
        <command>svn log</command> 将不会打印日志消息的文本内容, 这个选项和
        选项 <option>--verbose</option> (<option>-v</option>) 是兼容的.</para>

      <!--
      <para>Each log message is printed just once, even if more
        than one of the affected paths for that revision were
        explicitly requested.  Logs follow copy history by
        default.  Use <option>- -stop-on-copy</option> to disable
        this behavior, which can be useful for determining branch
        points.</para>
      -->
      <para>即使在一次提交中受到影响的路径在命令行中出现了多次, 对应的日志
        消息也只显示一次. 日志默认会跟随复制历史, 但可以用选项
        <option>--stop-on-copy</option> 禁止跟随, 这可以用来判断创建分支的
        时间点.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.change" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff" />
<xref linkend="svn.ref.svn.sw.diff_cmd" />
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.internal_diff" />
<xref linkend="svn.ref.svn.sw.limit" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.search" />
<xref linkend="svn.ref.svn.sw.search_and" />
<xref linkend="svn.ref.svn.sw.stop_on_copy" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.use_merge_history" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.with_all_revprops" />
<xref linkend="svn.ref.svn.sw.with_no_revprops" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>You can see the log messages for all the paths that
        changed in your working copy by running <userinput>svn
        log</userinput> from the top:</para>
      -->
    <para>如果直接运行 <userinput>svn log</userinput>, 则查看的是当前工作
      副本目录中, 所有路径的修改历史:</para>

      <informalexample>
        <screen>
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Examine all log messages for a particular file in
        your working copy:</para>
      -->
      <para>查看工作副本中, 某个特定文件的修改历史:</para>

      <informalexample>
        <screen>
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>
      </informalexample>

      <!--
      <para>If you don't have a working copy handy, you can log
        a URL:</para>
      -->
      <para>如果手上没有工作副本, 还可以根据 URL 查询历史:</para>

      <informalexample>
        <screen>
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>
      </informalexample>

      <!--
      <para>If you want several distinct paths underneath the
        same URL, you can use the <literal>URL [PATH...]</literal>
        syntax:</para>
      -->
      <para>如果你想查看同一个 URL 下的多个路径, 可以使用
        <literal>URL [PATH...]</literal> 语法:</para>

      <informalexample>
        <screen>
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>
      </informalexample>

      <!--
      <para>The <option>- -verbose</option> (<option>-v</option>)
        option causes <command>svn log</command> to include
        information about the paths that were changed in each
        displayed revision.  These paths appear, one path per line
        of output, with action codes that indicate what type of
        change was made to the path.</para>
      -->
      <para>如果添加了选项 <option>--verbose</option> (<option>-v</option>),
        <command>svn log</command> 还会打印在版本号中被修改的路径, 每个路径
        都占据单独的一行, 并在行的开头添加能够表示修改类型的操作码.</para>

      <informalexample>
        <screen>
$ svn log -v http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line
Changed paths:
   M /foo.c

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line
Changed paths:
   A /bar.c

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>
      </informalexample>

      <!--
      <para><command>svn log</command> uses just a handful of action codes,
        and they are similar to the
        ones the <command>svn update</command>
        command uses:</para>
      -->
      <para><command>svn log</command> 只使用了几种操作码, 这些操作码和命令
        <command>svn update</command> 使用的操作码非常类似:</para>

      <variablelist>
        <varlistentry>
          <term><literal>A</literal></term>
      <!--
          <listitem><para>The item was added.</para></listitem>
      -->
          <listitem><para>该项是新增的.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>D</literal></term>
      <!--
          <listitem><para>The item was deleted.</para></listitem>
      -->
          <listitem><para>该项被删除了.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>M</literal></term>
      <!--
          <listitem><para>Properties or textual contents on the
            item were changed.</para></listitem>
      -->
        <listitem><para>该项的属性或内容被修改了.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>R</literal></term>
      <!--
          <listitem><para>The item was replaced by a different one
            at the same location.</para></listitem>
      -->
        <listitem><para>该项被其他项目替换了.</para></listitem>
        </varlistentry>
      </variablelist>

      <!--
      <para>In addition to the action codes which precede the
        changed paths, <command>svn log</command> with
        the <option>- -verbose</option> (<option>-v</option>)
        option will note whether a path was added or replaced as
        the result of a copy operation.  It does so by
        printing <literal>(from
        <replaceable>COPY-FROM-PATH</replaceable>:<replaceable>COPY-FROM-REV</replaceable>)</literal>
        after such paths.</para>
      -->
      <para>除了在路径前加上操作码, 添加了选项 <option>--verbose</option>
        (<option>-v</option>) 的 <command>svn log</command> 还会注释路径
        是否是通过复制得到的, 注释的形式是在路径后加上 <literal>(from
          <replaceable>COPY-FROM-PATH</replaceable>:<replaceable>COPY-FROM-REV</replaceable>)</literal>.</para>

      <!--
      <para>When you're concatenating the results of multiple
        calls to the log command, you may want to use the
        <option>- -incremental</option> option. <command>svn
        log</command> normally prints out a dashed line at the
        beginning of a log message, after each subsequent log
        message, and following the final log message.  If you
        ran <command>svn log</command> on a range of two
        revisions, you would get this:</para>
      -->
      <para>如果你想串联多个 <command>svn log</command> 的执行结果, 那你可能
        需要选项 <option>--incremental</option>. <command>svn log</command>
        通常会在开始打印日志消息之前, 在打印完一条日志消息之后, 以及打印完最
        后一条日志消息之后打印一行连字符. 如果你用 <command>svn log</command>
        查询一段版本号范围内的日志, 你将会得到:</para>

      <informalexample>
        <screen>
$ svn log -r 14:15
------------------------------------------------------------------------
r14 | &hellip;

------------------------------------------------------------------------
r15 | &hellip;

------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>However, if you wanted to gather two nonsequential log
        messages into a file, you might do something like
        this:</para>
      -->
      <para>然而, 如果你想把多个不连续的日志消息写到一个文件中, 你可能会这
        样做:</para>

      <informalexample>
        <screen>
$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | &hellip;

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | &hellip;

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | &hellip;

------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>You can avoid the clutter of the double dashed lines
        in your output by using the <option>- -incremental</option>
        option:</para>
      -->
      <para>为了避免出现凌乱的双条连字符行, 可以为 <command>svn log</command>
        加上选项 <option>--incremental</option>:</para>

      <informalexample>
        <screen>
$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | &hellip;

------------------------------------------------------------------------
r19 | &hellip;

------------------------------------------------------------------------
r27 | &hellip;
</screen>
      </informalexample>

      <!--
      <para>The <option>- -incremental</option> option provides
        similar output control when using the
        <option>- -xml</option> option:</para>
      -->
      <para>如果已经添加了选项 <option>--xml</option>, 再加上选项
        <option>--incremental</option> 后能提供类似的输出控制:</para>

      <informalexample>
        <screen>
$ svn log --xml --incremental -r 1 sandwich.txt
&lt;logentry
   revision="1"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-06-03T06:35:53.048870Z&lt;/date&gt;
&lt;msg&gt;Initial Import.&lt;/msg&gt;
&lt;/logentry&gt;
</screen>
      </informalexample>

      <tip>
      <!--
        <para>Sometimes when you run <command>svn log</command> on
          a specific path and a specific revision, you see no log
          information output at all, as in the following:</para>
      -->
        <para>有时候, 如果你用 <command>svn log</command> 查询某个路径在
          特定版本号上的历史, 你可能看不到任何日志被打印出来, 例如:</para>

        <informalexample>
          <screen>
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
</screen>
        </informalexample>

      <!--
        <para>That just means the path wasn't modified in that
          revision.  To get log information for that revision,
          either run the log operation against the repository's
          root URL, or specify a path that you happen to know was
          changed in that revision:</para>
      -->
        <para>这仅仅意味着该路径在该版本号上没有发生任何修改. 为了得到该版本
          号的日志消息, 要么把仓库的根目录 URL 作为目标, 要么你很清楚该版本
          号修改了哪个路径, 并把它作为目标:</para>

        <informalexample>
          <screen>
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
</screen>
        </informalexample>
      </tip>

      <!--
      <para>Beginning with Subversion 1.7, users can take
        advantage of a special output mode which combines the
        information from <command>svn log</command> with what you
        would see when running <command>svn diff</command> on the
        same targets for each revision of the log.  Simply
        invoke <command>svn log</command> with
        the <option>- -diff</option> option to trigger this output
        mode.</para>
      -->
      <para>从 Subversion 1.7 开始, <command>svn log</command> 支持一种特殊
        的输出模式, 该模式和 <command>svn diff</command> 一样能够把修改以
        标准差异格式输出, 方法就是为 <command>svn log</command> 加上选项
        <option>--diff</option>:</para>

      <informalexample>
        <screen>
$ svn log -r 20 touched.txt --diff
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.

Index: touched.txt
===================================================================
--- touched.txt	(revision 19)
+++ touched.txt	(revision 20)
@@ -1 +1,2 @@
 This is the file 'touched.txt'.
+We add such exciting text to files around here!
------------------------------------------------------------------------
$
</screen>
      </informalexample>

      <!--
      <para>As with <command>svn diff</command>, you may also make
        use of many of the various options which control the way
        the difference is generated,
        including <option>- -depth</option>, <option>- -diff-cmd</option>,
        and <option>- -extensions</option>
        (<option>-x</option>).</para>
      -->
      <para>和 <command>svn diff</command> 一样, 用户可以利用选项
        <option>--depth</option>, <option>--diff-cmd</option> 和
        <option>--extensions</option> (<option>-x</option>) 控制差异比较的
        具体行为.</para>

      <!--
      <para>Beginning with Subversion 1.8, users can filter <command>svn log</command>
        output using <option>- -search</option> and <option>- -search-and</option>
        options.  When using these options, a log message is shown only if a
        revision's author, date, log message text, or list of changed paths,
        matches a search pattern. Searching by changed patch requires
        <option>- -verbose</option> option, otherwise <command>svn log</command>
        does not show changed paths therefore they can't be filtered.</para>
      -->
      <para>从 Subversion 1.8 开始, 用户可以用选项 <option>--search</option>
        和 <option>--search-and</option> 过滤 <command>svn log</command> 的
        输出. 如果在命令中用到了这两个选项, 那么仅当版本号的作者, 提交日期,
        日志消息内容或被修改的路径和模式匹配时, 日志消息才会被打印出来. 在
        匹配被修改的路径时, 还要求加上选项 <option>--verbose</option>, 否则
        的话 <command>svn log</command> 不会去匹配被修改的路径.</para>

      <!--
      <para>The search pattern (also called glob or shell wildcard
        pattern) can contain regular characters and the following
        wildcard characters:</para>
      -->
      <para>搜索模式 (也被称作文本表达式或 Shell 通配符模式) 可以包含普通
        字符和下面的通配符:</para>

       <variablelist>
         <varlistentry>
           <term>
             <literal>?</literal>
           </term>
           <listitem>
      <!--
             <para>Matches any single character.</para>
      -->
             <para>匹配任意一个字符.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term>
             <literal>*</literal>
           </term>
           <listitem>
      <!--
             <para>Matches a sequence of arbitrary characters.</para>
      -->
             <para>匹配任意一个字符序列.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term>
             <literal>[ABC]</literal>
           </term>
           <listitem>
      <!--
             <para>Matches any of the characters listed inside the
               brackets.</para>
      -->
             <para>匹配中括号内的任意一个字符.</para>
           </listitem>
         </varlistentry>
       </variablelist>

      <!--
      <para>Using multiple <option>- -search</option> parameters will show
        log messages that match the pattern specified at least in one of the
        options.  For example:</para>
      -->
      <para>如果选项 <option>--search</option> 出现了多次, 那么只要任意一个
        模式得到匹配, 日志消息就会被打印, 例如:</para>
      <informalexample>
<screen>
$ svn log --search sally --search harry https://svn.red-bean.com/repos/test
------------------------------------------------------------------------
r1701 | sally | 2011-10-12 22:35:30 -0600 (Wed, 12 Oct 2011) | 1 line

Add a reminder.
------------------------------------------------------------------------
r1564 | harry | 2011-10-09 22:35:30 -0600 (Sun, 09 Oct 2011) | 1 line

Merge r1560 to the 1.0.x branch.
------------------------------------------------------------------------
$
        </screen>
      </informalexample>
      <!--
      <para>
        Using <option>- -search</option> with <option>- -search-and</option> options will show log messages
        that match the combined pattern from both options. For example:
      </para>
      -->
        <para>如果选项 <option>--search</option> 和
          <option>--search-and</option> 一起使用, 则只有同时匹配所有模式的
          日志消息才会被打印, 例如:</para>
      <informalexample>
<screen>
$ svn log --verbose --search sally --search-and /foo/bar https://svn.red-bean.com/repos/test
------------------------------------------------------------------------
r1555 | sally | 2011-07-15 22:33:14 -0600 (Fri, 15 Jul 2011) | 1 line
Changed paths:
M /foo/bar/src.c

Typofix.
------------------------------------------------------------------------
r1530 | sally | 2011-07-13 07:24:11 -0600 (Wed, 13 Jul 2011) | 1 line
Changed paths:
M /foo/bar
M /foo/build

Fix up some svn:ignore properties.
------------------------------------------------------------------------
$
</screen>
      </informalexample>
      <tip>
      <!--
        <para>
          <option>- -search</option> and <option>- -search-and</option>
          options does not actually perform a search.  They just filter
          the <command>svn log</command> output to display only log
          messages that match the specified pattern.  Therefore, if
          <option>- -limit</option> is used, it restricts the number
          of log messages searched, rather than restricting the
          output to a particular number of matching log messages.
        </para>
      -->
        <para>选项 <option>--search</option> 和 <option>--search-and</option>
          实际上并没有执行搜索, 它们仅仅是过滤 <command>svn log</command> 的
          输出. 因此, 如果还使用了选项 <option>--limit</option>, 它将会限制
          过滤前的日志消息数量, 而不是限制已过滤的日志消息数量.</para>
      </tip>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.merge">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>merge</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn merge</refname>
      <!--
      <refpurpose>Apply the differences between two sources to a
      working copy path.</refpurpose>
      -->
    <refpurpose>把两个源的差异应用到工作副本上.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn merge SOURCE[@REV] [TARGET_WCPATH]</literal></para>
      <para><literal>svn merge [-c M[,N...] | -r N:M ...] SOURCE[@REV] [TARGET_WCPATH]</literal></para>
      <para><literal>svn merge SOURCE1[@N] SOURCE2[@M] [TARGET_WCPATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>In all three forms
        <replaceable>TARGET_WCPATH</replaceable> is
        the working copy path that will receive the differences. If
        <replaceable>TARGET_WCPATH</replaceable> is omitted, the
        changes are applied to the current working directory,
        unless the sources have identical basenames that match a
        file within the current working directory.  In
        that case, the differences will be applied to that
        file.</para>
      -->
      <para>在上面的三种形式中, <replaceable>TARGET_WCPATH</replaceable>
        都是一个接收差异的工作副本路径. 如果省略了
        <replaceable>TARGET_WCPATH</replaceable>, 接收差异的将是当前工作目录,
        如果源的最后一个分量和当前工作目录内的某个文件名相同, 则接收差异的将
        会是这个文件.</para>

      <!--
      <para>In the first two forms, <replaceable>SOURCE</replaceable>
        can be either a URL or a working copy path (in which case its
        corresponding URL is used). If the peg revision
        <replaceable>REV</replaceable> is not specified, then
        <literal>HEAD</literal> is assumed.  In the third form the
        same rules apply for
        <replaceable>SOURCE1</replaceable>,
        <replaceable>SOURCE2</replaceable>,
        <replaceable>M</replaceable>, and <replaceable>N</replaceable>
        with the only difference being that if either source is a
        working copy path, then the peg revisions
        <emphasis>must</emphasis> be explicitly stated.</para>
      -->
      <para>在前两种形式中, <replaceable>SOURCE</replaceable> 是一个 URL 或
        工作副本路径 (此时 Subversion 将自动使用工作副本路径对应的 URL).
        如果没有指定限定版本号 <replaceable>REV</replaceable>, 就默认使用
        <literal>HEAD</literal>. 对于第三种形式, 相同的规则同样适用于
        <replaceable>SOURCE1</replaceable>, <replaceable>SOURCE2</replaceable>,
        <replaceable>M</replaceable> 和 <replaceable>N</replaceable>, 唯一的
        不同点是如果 <replaceable>SOURCE1</replaceable> 或
        <replaceable>SOURCE2</replaceable> 是一个工作副本路径, 则必须
        <emphasis>显式地</emphasis> 指定限定版本号.</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>Automatic Merges</para>
      -->
          <para>自动合并</para>
      <!--
          <para>The first form is called an <quote>automatic
            merge</quote> and is used to perform <quote>sync</quote>
            and <quote>reintegrate</quote> merges.
            <quote>Sync</quote> merges merge eligible changes to a
            branch (<replaceable>TARGET_WCPATH</replaceable>) from
            the branch's ancestor branch
            (<replaceable>SOURCE</replaceable>).
            <quote>Eligible</quote> changes are defined as those that
            were not previously merged from
            <replaceable>SOURCE</replaceable> to
            <replaceable>TARGET_WCPATH</replaceable>.  See
            <xref linkend="svn.branchmerge.basicmerging.stayinsync"/>.
            <quote>Reintegrate</quote> merges merge changes from a
            feature branch (<replaceable>SOURCE</replaceable>)
            back into the feature branch's ancestor branch
            (<replaceable>TARGET_WCPATH</replaceable>), see
            <xref linkend="svn.branchmerge.basicmerging.reintegrate"/>
            and
            <xref linkend="svn.branchmerge.commonpatterns.feature"/>.
            </para>
      -->
            <para>第一种形式称为 <quote>自动合并</quote>, 它用于执行
              <quote>同步</quote> 合并和 <quote>再整合</quote> 合并.
              <quote>同步</quote> 合并把祖先分支
              (<replaceable>SOURCE</replaceable>) 中可以合并的修改合并到
              目标分支 (<replaceable>TARGET_WCPATH</replaceable>) 上.
              <quote>可以合并的</quote> 修改指的是那些还没有从
              <replaceable>SOURCE</replaceable> 合并到
              <replaceable>TARGET_WCPATH</replaceable> 的修改, 见
              <xref linkend="svn.branchmerge.basicmerging.stayinsync"/>.
              <quote>再整合</quote> 合并是把特性分支的修改
              (<replaceable>SOURCE</replaceable>) 合并到祖先分支
              (<replaceable>TARGET_WCPATH</replaceable>) 上, 见
              <xref linkend="svn.branchmerge.basicmerging.reintegrate"/> 和
              <xref linkend="svn.branchmerge.commonpatterns.feature"/>.</para>

        </listitem>
        <listitem>
      <!--
          <para>Cherrypick Merges</para>
      -->
          <para>精选合并</para>
      <!--
          <para>The second form is called a <quote>cherry-pick</quote>
            merge and is used to merge an explicitly defined set of
            changes from one branch to another.
            <replaceable>SOURCE</replaceable> in revision
            <replaceable>REV</replaceable> is compared as it existed
            between revisions <replaceable>N</replaceable> and
            <replaceable>M</replaceable> for each revision range
            provided.  See
            <xref linkend="svn.branchmerge.cherrypicking"/> for more
            information.</para>
      -->
          <para>第二种形式称为 <quote>精选</quote> 合并, 用于合并特定的修改,
            修改来自 <replaceable>SOURCE</replaceable> (限定版本号为
            <replaceable>REV</replaceable>) 的版本号
            <replaceable>N</replaceable> 和 <replaceable>M</replaceable> 的
            比较. 更多的信息见 <xref
              linkend="svn.branchmerge.cherrypicking"/>.</para>
          <tip>
      <!--
            <para>Multiple <literal>-c</literal> and/or
              <literal>-r</literal> instances may be specified, and
              mixing of forward and reverse ranges is allowed&mdash;
              the ranges are internally compacted to their minimum
              representation before merging begins (which may result
              in a no-op merge or conflicts that cause the merge to
              stop before merging all of the requested revisions).</para>
      -->
            <para><literal>-c</literal> 或 <literal>-r</literal> 可以出现多次,
              也可以混合正向和反向的版本号范围&mdash;在合并开始前, Subversion
              自动地把版本号范围压缩成最简的表示形式 (这可能会导致空合并或
              冲突, 从而导致合并中止).</para>
          </tip>
        </listitem>
        <listitem>
      <!--
          <para>2-URL Merges</para>
      -->
          <para>二路 URL 合并</para>
      <!--
          <para>In the third form, called a <quote>2-URL Merge</quote>,
            the difference between <replaceable>SOURCE1</replaceable>
            at revision <replaceable>N</replaceable> and
            <replaceable>SOURCE2</replaceable> at revision
            <replaceable>M</replaceable> is generated and applied to
            <replaceable>TARGET_WCPATH</replaceable>.  The revisions
            default to <literal>HEAD</literal> if omitted.</para>
      -->
          <para>第三种形式称为 <quote>二路 URL 合并</quote>, 限定版本号为
            <replaceable>N</replaceable> 的 <replaceable>SOURCE1</replaceable>
            和限定版本号为 <replaceable>M</replaceable> 的
            <replaceable>SOURCE2</replaceable> 之间的差异将被应用到
            <replaceable>TARGET_WCPATH</replaceable> 上. 如果省略了限定版本号,
            则使用 <literal>HEAD</literal>.</para>
        </listitem>
      </itemizedlist>

      <!--
      <para>If
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
        is active, then Subversion will internally track metadata
        (i.e. the <literal>svn:mergeinfo</literal> property) about
        merge operations when the two merge sources are ancestrally
        related&mdash;if the first source is an ancestor of the
        second or vice versa&mdash;this is guaranteed to be the case
        when performing automatic merges.  Subversion will also take
        preexisting merge metadata on the working copy target into
        account when determining what revisions to merge and in an
        effort to avoid repeat merges and needless conflicts it may
        only merge a subset of the requested ranges.</para>
      -->
      <para>当两个合并的源路径具有祖先关系时&mdash;第一个源路径是另一个源路径
        的祖先, 或反之 (自动合并总是符合这一条件&mdash;如果 <xref
          linkend="svn.branchmerge.basicmerging.mergetracking"/> 是可用的,
        则 Subversion 会在内部更新合并操作的元数据. 在判断需要合并哪些版本号
        时, Subversion 还会把工作副本目标路径上已存在的合并元数据考虑进来,
        从而避免重复的合并和不必要的冲突.</para>

      <!--
      <para>Unlike <command>svn diff</command>, the merge command
        takes the ancestry of a file into consideration when
        performing a merge operation. This is very important when
        you're merging changes from one branch into another and you've
        renamed a file on one branch but not the other.</para>
      -->
      <para>和 <command>svn diff</command> 不一样的是, <command>svn
          merge</command> 在执行合并时还会考虑到文件的祖先, 这在处理下面这种
        情况时非常有用: 把一个分支上的修改合并到另一个分支中, 而在其中一个分
        支中文件被重命名了.</para>

      <tip>
      <!--
        <para>The <option>- -ignore-ancestry</option> option will cause
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
        to be disabled and makes merge act like
        <command>svn diff</command>, ignoring the ancestry of files
        when merging.</para>
      -->
      <para>选项 <option>--ignore-ancestry</option> 将禁止 <xref
          linkend="svn.branchmerge.basicmerging.mergetracking"/>, 使得
        <command>svn merge</command> 在合并时不考虑祖先关系, 就像
        <command>svn diff</command> 那样工作.</para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.allow_mixed_revisions" />
<xref linkend="svn.ref.svn.sw.change" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
<xref linkend="svn.ref.svn.sw.dry_run" />
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_ancestry" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.record_only" />
<xref linkend="svn.ref.svn.sw.reintegrate" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.verbose" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Reintegrate a branch back into the trunk&mdash;assuming
        that you have an up-to-date working copy of the trunk (the
        <option>- -verbose</option> option prints additional
        information regarding what the merge is doing prior to
                                    ### TODO
        actually applying any diff; useful in very large which
        might take a significant amount of time to complete):</para>
      -->
      <para>把分支重新整合到主干上&mdash;假设你已经有了一个处于最新状态
        下的主干工作副本 (选项 <option>--verbose</option> 使得 <command>svn
          merge</command> 在应用差异前打印额外的信息, 这些信息指出了现在
        正在执行什么合并):</para>

      <informalexample>
        <screen>
$ svn merge ^/branches/feature-branch-calc-enhancements trunk --verbose
checking branch relationship...
calculating automatic merge...
merging...
--- Merging r12 through r37 into 'trunk':
U    trunk/calc/brush.c
--- Recording mergeinfo for merge of r12 through r37 into 'trunk':
 U   trunk

$ # build, test, verify, ...

$ svn commit trunk -m "Reintegrate the calc enhancements back to trunk!"
Sending        trunk
Sending        trunk/calc/brush.c
Transmitting file data .
Committed revision 38.
</screen>
      </informalexample>
      
      <!--
    <para>Cherry-pick merge a single change to a file:</para>
      -->
    <para>为文件合并一个单独的修改 (精选合并):</para>

    <informalexample>
      <screen>
$ svn merge ^/trunk/calc/brush.c branches/1.x/calc/brush.c -c38
--- Merging r38 into 'branches/1.x/calc/brush.c':
U    branches/1.x/calc/brush.c
--- Recording mergeinfo for merge of r38 into 'branches/1.x/calc/brush.c':
 G   branches/1.x/calc/brush.c
</screen>
    </informalexample>

      <!--
    <para>Merge the differences between two unrelated branches
      into a third branch:</para>
      -->
    <para>把两个不相关的分支间的差异合并到第三个分支上:</para>

    <informalexample>
      <screen>
$ svn merge ^/vendor-drop/vendor-1.0 ^/vendor-drop/vendor-1.1 \
            trunk --ignore-ancestry
--- Merging differences between repository URLs into 'trunk':
U    trunk/draw/draw.py
</screen>
    </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.mergeinfo">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>mergeinfo</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn mergeinfo</refname>
      <!--
      <refpurpose>Query merge-related information.  See <xref
        linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details.</refpurpose>
      -->
      <refpurpose>查询合并信息, 见 <xref
          linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn mergeinfo SOURCE_URL[@REV] [TARGET[@REV]]</literal></para>

    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>
      <!--
      <para>Query information related to merges (or potential
        merges) between <replaceable>SOURCE-URL</replaceable> and
        <replaceable>TARGET</replaceable>.  If
        the <option>- -show-revs</option> option is not provided,
        display a graphical representation of revisions which have
        been fully merged from <replaceable>SOURCE-URL</replaceable>
        to <replaceable>TARGET</replaceable>.  Otherwise, list
        either the <literal>merged</literal>
        or <literal>eligible</literal> revisions as specified by
        the <option>- -show-revs</option> option.</para>
      -->
      <para>查询 <replaceable>SOURCE-URL</replaceable> 和
        <replaceable>TARGET</replaceable> 之间与合并 (或潜在的合并) 相关的
        信息. 如果没有添加选项 <option>--show-revs</option>, 命令会把已合并
        的版本号以图形化的方式打印出来; 否则的话, 命令将会列出已合并或可以
        合并 (但还未合并) 的版本号.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.show_revs" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Graphical summary of the merges from one branch to
        another:</para>
      -->
      <para>以图形化的方式总结从一个分支合并到另一个分支上的修改:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/trunk feature-branch
    youngest  last               repos.
    common    full     tip of    path of
    ancestor  merge    branch    branch

    11        16       33
    |         |        |
  -------| |------------         trunk
     \         \
      \         \
       --| |------------         feature-branch
                       |
                       33
</screen>
      </informalexample>

      <!--
      <para>List the operative revisions merged from one branch to
        another:</para>
      -->
      <para>列出某个分支上已经合并到另一个分支的所有版本号:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/trunk feature-branch --show-revs merged
r15
r16
</screen>
      </informalexample>

      <!--
      <para>List the operative revisions eligible to be merged from
        one branch to another:</para>
      -->
      <para>列出某个分支上可以合并 (但还未合并) 到另一个分支的版本号:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/trunk feature-branch --show-revs eligible
r28
r30
</screen>
      </informalexample>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.mkdir">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>mkdir</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn mkdir</refname>
      <!--
      <refpurpose>Create a new directory under version control.</refpurpose>
      -->
      <refpurpose>创建一个新目录.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn mkdir PATH...</literal></para>
      <para><literal>svn mkdir URL...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Create a directory with a name given by the final
        component of the <replaceable>PATH</replaceable> or <replaceable>URL</replaceable>.
        A directory specified by a working copy
        <replaceable>PATH</replaceable> is scheduled for addition
        in the working copy.  A directory specified by a URL is
        created in the repository via an immediate commit.
        Multiple directory URLs are committed atomically.  In both
        cases, all the intermediate directories must already exist
        unless the <option>- -parents</option> option is
        used.</para>
      -->
      <para>创建一个新目录, 新目录的名字是 <replaceable>PATH</replaceable>
        或 <replaceable>URL</replaceable> 的最后一个分量. 如果参数是工作副本
        路径 <replaceable>PATH</replaceable>, 那么目录在创建后被自动置于版本
        控制之下; 如果参数是 <replaceable>URL</replaceable>, 那么新目录会被
        直接提交到仓库中, 如果出现了多个 <replaceable>URL</replaceable>, 则
        它们都是在同一个版本号中提交. 除非添加了选项
        <option>--parents</option>, 否则的话中间目录必须事先存在.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Create a directory in your working copy:</para>
      -->
      <para>在工作副本中创建新目录:</para>

      <informalexample>
        <screen>
$ svn mkdir newdir
A         newdir
</screen>
      </informalexample>

      <!--
      <para>Create one in the repository (this is an instant commit, so a
        log message is required):</para>
      -->
      <para>在仓库中创建目录 (这会马上产生一个提交操作, 所以必须提供日志消息):
      </para>

      <informalexample>
        <screen>
$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.move">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>move</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn move (mv)</refname>
      <!--
      <refpurpose>Move a file or directory.</refpurpose>
      -->
      <refpurpose>移动一个文件或目录.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn move SRC... DST</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>This command moves files or directories in your
        working copy or in the repository.</para>
      -->
      <para>该命令用于在工作副本或仓库中移动文件或目录.</para>

      <tip>
      <!--
        <para>This command is equivalent to an <command>svn
          copy</command> followed by <command>svn
          delete</command>.</para>
      -->
      <para>这个命令等价于先执行 <command>svn copy</command>, 再执行
        <command>svn delete</command>.</para>
      </tip>

      <!--
      <para>When moving multiple sources, they will be added as
        children of <replaceable>DST</replaceable>, which must be
        a directory.</para>
      -->
      <para>如果 <replaceable>SRC</replaceable> 出现了多次, 它们将被移动
        到 <replaceable>DST</replaceable> 内, 这就意味着
        <replaceable>DST</replaceable> 必须是一个目录.</para>

      <note>
      <!--
        <para>Subversion does not support moving between working
          copies and URLs.  In addition, you can only move files
          within a single repository&mdash;Subversion does not
          support cross-repository moving.  Subversion supports
          the following types of moves within a single repository:</para>
      -->
        <para>Subversion 不支持在工作副本和 URL 之间移动, 而且只能在同一仓库
          内移动&mdash;即 Subversion 不支持在不同的仓库之间移动. 在同一仓库
          内, Subversion 支持以下类型的移动:</para>
      </note>

      <variablelist>

        <varlistentry>
          <term>WC &rarr; WC</term>
          <listitem>
      <!--
            <para>Move and schedule a file or directory for
              addition (with history).</para>
      -->
            <para>在工作副本内移动文件, 但还未提交到仓库中.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>URL &rarr; URL</term>
          <listitem>
      <!--
            <para>Complete server-side rename.</para>
      -->
            <para>在仓库内完成移动, 会马上触发一个提交操作. </para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>When moving large trees you should be aware that the
        URL &rarr; URL moves are lighter than WC &rarr; WC moves. Moving
        nodes inside a working copy does more than just change directory
        listings (it will copy files, manage temporary files, and expand
        keywords) and may be significantly slower.</para>
      -->
      <para>如果被移动的文件较多, 那么用户应该使用更轻量的 URL &rarr; URL,
        在工作副本内移动文件不仅仅是修改目录列表 (还要复制文件, 管理临时文件
        和扩展关键字), 可能会耗费较多的时间.</para>

      <!--
      <para>Also bear in mind that a WC &rarr; WC move in a
        mixed-revision working copy may yield unexpected results
        (see <xref linkend="svn.basic.in-action.mixedrevs" />).</para>
      -->
      <para>还要注意的是 WC &rarr; WC 移动版本号混合的工作副本可能会产生无法
        预知的后果 (见 <xref linkend="svn.basic.in-action.mixedrevs" />).
      </para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Move a file in your working copy:</para>
      -->
      <para>移动工作副本里的一个文件:</para>

      <informalexample>
        <screen>
$ svn move foo.c bar.c
A         bar.c
D         foo.c
</screen>
      </informalexample>

      <!--
      <para>Move several files in your working copy into a
        subdirectory:</para>
      -->
      <para>把工作副本里的几个文件移动到一个目录内:</para>

      <informalexample>
        <screen>
$ svn move baz.c bat.c qux.c src
A         src/baz.c
D         baz.c
A         src/bat.c
D         bat.c
A         src/qux.c
D         qux.c
</screen>
      </informalexample>

      <!--
      <para>Move a file in the repository (this is an immediate commit,
        so it requires a commit message):</para>
      -->
      <para>在仓库内移动一个文件 (这会产生一个提交操作, 所以需要提供提交日志
        消息):</para>

      <informalexample>
        <screen>
$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.patch">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>patch</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn patch</refname>
      <!--
      <refpurpose>Apply changes represented in a unidiff patch to
        the working copy.</refpurpose>
      -->
      <refpurpose>把一个标准差异格式的补丁应用到工作副本中.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn patch PATCHFILE [WCPATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>This subcommand will apply changes described a
        unidiff-formatted patch
        file <replaceable>PATCHFILE</replaceable> to the working
        copy <replaceable>WCPATH</replaceable>.  As with most
        other working copy subcommands,
        if <replaceable>WCPATH</replaceable> is omitted, the
        changes are applied to the current working directory.  A
        unidiff patch suitable for application to a working copy
        can be produced with the <command>svn diff</command>
        command or third-party differencing tools.  Any
        non-unidiff content found in the patch file is
        ignored.</para>
      -->
      <para>该命令把标准差异格式的补丁 <replaceable>PATCHFILE</replaceable>
        应用到工作副本路径 <replaceable>WCPATH</replaceable> 上. 和大多数
        操作工作副本的子命令一样, 如果省略了 <replaceable>WCPATH</replaceable>,
        应用补丁的将会是当前工作目录. 有很多工具都能生成标准差异格式的补丁,
        例如 <command>svn diff</command> 和 Unix 命令 <command>diff</command>.
        <command>svn patch</command> 会忽略补丁中不是标准差异的内容.</para>

      <!--
      <para>Changes listed in the patch file will either be
        applied or rejected.  If a change does not match at its
        exact line offset, it may be applied earlier or later in
        the file if a match is found elsewhere for the surrounding
        lines of context provided by the patch.  A change may also
                                   ### TODO
        be applied with <firstterm>fuzz</firstterm>&mdash;meaning,
        one or more lines of context are ignored when attempting
        to match the change location.  If no matching context can
        be found for a change, the change conflicts and will be
        written to a reject file which bears the extension
        <filename>.svnpatch.rej</filename>.</para>
      -->
      <para>补丁中的修改要么被接受, 要么被拒绝. 如果没办法在准确的位置上
        匹配一个修改, 那么 Subversion 将会在更前或更后的位置进行匹配. 还
        可以 <firstterm>模糊地</firstterm> (<firstterm>fuzz</firstterm>)
        应用修改&mdash;也就是在尝试匹配应用修改的位置时, 忽略上下文中的一
        行或更多的行. 如果无法为一个修改找到匹配的位置, 该修改将被认为发生
        了冲突, 并被写到一个扩展名为 <filename>.svnpatch.rej</filename> 的
        文件中.</para>

      <!--
      <para><command>svn patch</command> reports a status line for
        patched file or directory using letter codes, very similar
        to the way that <command>svn update</command> provides
        notification.  The letter codes have the following
        meanings:</para>
      -->
      <para><command>svn patch</command> 为每一个打了补丁的文件或目录打印一
        行状态, 状态用一个字母表示, 和 <command>svn update</command> 非常类似.
        用来表示状态的字母有:</para>

      <variablelist>

        <varlistentry>
          <term><literal>A</literal></term>
          <listitem>
      <!--
            <para>Added</para>
      -->
            <para>新增 (Added)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>D</literal></term>
          <listitem>
      <!--
            <para>Deleted</para>
      -->
            <para>删除 (Deleted)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>C</literal></term>
          <listitem>
      <!--
            <para>Conflicted</para>
      -->
            <para>冲突 (Conflicted)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>G</literal></term>
          <listitem>
      <!--
            <para>Merged</para>
      -->
            <para>合并 (Merged)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>U</literal></term>
          <listitem>
      <!--
            <para>Updated</para>
      -->
            <para>更新 (Updated)</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>Changes applied with an offset or fuzz are reported on
        lines starting with the '<literal>&gt;</literal>'
        symbol. You should review such changes carefully.</para>
      -->
      <para>如果修改是在调整了偏移后应用的, 或者是被模糊应用的, 那么 Subversion
        将报告这一情况, 相关的信息在输出时以字符 <literal>&gt;</literal> 开始,
        用户应该认真审核这些修改.</para>

      <!--
      <para>If the patch removes all content from a file, that
        file is automatically scheduled for deletion.  Likewise,
        if the patch creates a new file, that file is
        automatically scheduled for addition.  Use <command>svn
        revert</command> to undo undesired deletions and
        additions.</para>
      -->
      <para>如果补丁把文件的所有内容都删除了, 该文件将被自动删除. 类似的,
        如果补丁创建了新文件, 那么该文件将被自动添加. 命令 <command>svn
          revert</command> 可以撤消所有不需要的删除或添加.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.dry_run" />
<xref linkend="svn.ref.svn.sw.ignore_whitespace" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.reverse_diff" />
<xref linkend="svn.ref.svn.sw.strip" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Apply a simple patch file generated by
        the <command>svn diff</command> command.  Our patch file
        will create a new file, delete another file, and modify a
        third's contents and properties.  Here's the patch file
        itself (which we'll assume is creatively named
        <filename>PATCH</filename>):</para>
      -->
      <para>应用一个由 <command>svn diff</command> 生成的补丁, 该补丁删除了
        一个文件, 创建了另一个新文件, 并修改了第三个文件的内容和属性. 下面是
        补丁的内容 (假设该补丁的文件名就是 <filename>PATCH</filename>):</para>

      <informalexample>
        <programlisting>
Index: deleted-file
===================================================================
--- deleted-file	(revision 3)
+++ deleted-file	(working copy)
@@ -1 +0,0 @@
-This file will be deleted.
Index: changed-file
===================================================================
--- changed-file	(revision 4)
+++ changed-file	(working copy)
@@ -1,6 +1,6 @@
 The letters in a line of text
 Could make your day much better.
 But expanded into paragraphs,
-I'd tell of kangaroos and calves
+I'd tell of monkeys and giraffes
 Until you were all smiles and laughs
 From my letter made of letters.

Property changes on: changed-file
___________________________________________________________________
Added: propname
## -0,0 +1 ##
+propvalue
Index: added-file
===================================================================
--- added-file	(revision 0)
+++ added-file	(working copy)
@@ -0,0 +1 @@
+This is an added file.
</programlisting>
      </informalexample>
      
      <!--
      <para>We can apply the previous patch file to another
        working copy from our repository using <command>svn
        patch</command>, and verify that it did the right thing by
        using <command>svn diff</command>:</para>
      -->
      <para>下面我们将在工作副本中应用该补丁, 然后再用 <command>svn
          diff</command> 检查 <command>svn patch</command> 的执行结果是否正确:
      </para>

      <informalexample>
        <screen>
$ cd /some/other/workingcopy
$ svn patch /path/to/PATCH
D         deleted-file
UU        changed-file
A         added-file
$ svn diff
Index: deleted-file
===================================================================
--- deleted-file	(revision 3)
+++ deleted-file	(working copy)
@@ -1 +0,0 @@
-This file will be deleted.
Index: changed-file
===================================================================
--- changed-file	(revision 4)
+++ changed-file	(working copy)
@@ -1,6 +1,6 @@
 The letters in a line of text
 Could make your day much better.
 But expanded into paragraphs,
-I'd tell of kangaroos and calves
+I'd tell of monkeys and giraffes
 Until you were all smiles and laughs
 From my letter made of letters.

Property changes on: changed-file
___________________________________________________________________
Added: propname
## -0,0 +1 ##
+propvalue
Index: added-file
===================================================================
--- added-file	(revision 0)
+++ added-file	(working copy)
@@ -0,0 +1 @@
+This is an added file.
$
</screen>             
      </informalexample>
    
      <!--
      <para>Sometimes you might need Subversion to interpret a
        patch <quote>in reverse</quote>&mdash;where added things
        get treated as removed things, and vice-versa.  Use
        the <option>- -reverse-diff</option> option for this
        purpose.  In the following example, we'll squirrel away
        a patch file which describes the changes in our working
        copy, and then use a reverse patch operation to undo those
        changes.</para>
      -->
      <para>有时候, 用户可能想 <quote>逆向</quote> 应用补丁&mdash; 删除新增的
        行, 添加被删除的行. 选项 <option>--reverse-diff</option> 就是用来完成
        这一操作. 在下面的例子中, 我们先把工作副本的修改存放到一个补丁文件中,
        然后再通过逆向应用补丁来撤消工作副本的修改.</para>

      <informalexample>
        <screen>
$ svn status
M       foo.c
$ svn diff > PATCH
$ cat PATCH
Index: foo.c
===================================================================
--- foo.c	(revision 128)
+++ foo.c	(working copy)
@@ -1003,7 +1003,7 @@
     return ERROR_ON_THE_G_STRING;
 
   /* Do something in a loop. */
-  for (i = 0; i &lt; txns->nelts; i++)
+  for (i = 0; i &lt; txns->nelts; i--)
     {
       status = do_something(i);
       if (status)
$ svn patch --reverse-diff PATCH
U         foo.c
$ svn status
$
</screen>             
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propdel">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propdel</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propdel (pdel, pd)</refname>
      <!--
      <refpurpose>Remove a property from an item.</refpurpose>
      -->
      <refpurpose>删除一个属性.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propdel PROPNAME [PATH...]</literal></para>
      <para><literal>svn propdel PROPNAME --revprop -r REV [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>This removes properties from files, directories, or
        revisions.  The first form removes versioned properties in
        your working copy, and the second removes unversioned
        remote properties on a repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
      -->
      <para>该命令将从文件, 目录或版本号上删除一个属性. 命令的第一种形式在
        工作副本中删除一个版本化的属性; 第二种形式在仓库的版本号上删除一个
        非版本化的属性 (可选参数 <replaceable>TARGET</replaceable> 指定仓库
        的 URL).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Delete a property from a file in your working
        copy:</para>
      -->
      <para>删除文件上的一个属性, 该文件是在工作副本中.</para>

      <informalexample>
        <screen>
$ svn propdel svn:mime-type some-script
property 'svn:mime-type' deleted from 'some-script'.
</screen>
      </informalexample>

      <!--
      <para>Delete a revision property:</para>
      -->
      <para>删除一个版本号上的属性:</para>

      <informalexample>
        <screen>
$ svn propdel --revprop -r 26 release-date 
property 'release-date' deleted from repository revision '26'
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propedit">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propedit</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propedit (pedit, pe)</refname>
      <!--
      <refpurpose>Edit the property of one or more items under
        version control.  See <xref
        linkend="svn.ref.svn.c.propset"/> later in this chapter.</refpurpose>
      -->
      <refpurpose>编辑一个或多个项目的版本化属性, 参考后面的 <xref
          linkend="svn.ref.svn.c.propset"/>.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propedit PROPNAME TARGET...</literal></para>
      <para><literal>svn propedit PROPNAME --revprop -r REV [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Edit one or more properties using your favorite
        editor.  The first form edits versioned properties in
        your working copy, and the second edits unversioned
        remote properties on a repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
      -->
      <para>在编辑器中编辑一个或多个项目属性. 命令的第一种形式在工作副本中编辑
        版本化的属性; 第二种形式在仓库的版本号上编辑非版本化的属性 (可选参数
        <replaceable>TARGET</replaceable> 指定仓库的 URL).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para><command>svn propedit</command> makes it easy to
        modify properties that have multiple values:</para>
      -->
      <para><command>svn propedit</command> 非常适合编辑属性值比较复杂的属性.
      </para>

      <informalexample>
        <screen>
$ svn propedit svn:keywords foo.c 

    # svn will open in your favorite text editor a temporary file
    # containing the current contents of the svn:keywords property.  You
    # can add multiple values to a property easily here by entering one
    # value per line.  When you save the temporary file and exit,
    # Subversion will re-read the temporary file and use its updated
    # contents as the new value of the property.

Set new value for property 'svn:keywords' on 'foo.c'
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propget">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propget</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propget (pget, pg)</refname>
      <!--
      <refpurpose>Print the value of a property.</refpurpose>
      -->
      <refpurpose>打印属性的值.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propget PROPNAME [TARGET[@REV]...]</literal></para>
      <para><literal>svn propget PROPNAME --revprop -r REV [URL]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Print the value of a property on files,
        directories, or revisions.  The first form prints the
        versioned property of an item or items in your working
        copy, and the second prints unversioned remote
        properties on a repository revision.  See <xref
        linkend="svn.advanced.props"/> for more information on
        properties.</para>
      -->
      <para>打印文件, 目录或版本号上的属性值. 命令的第一种形式打印工作副本
        里的一个或多个项目的属性值; 第二种形式打印版本号上的属性值. 关于属性
        的更多信息, 见 <xref linkend="svn.advanced.props"/>.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.show_inherited_props" />
<xref linkend="svn.ref.svn.sw.strict" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Examine a property of a file in your working
        copy:</para>
      -->
      <para>查看工作副本中某个文件的属性值:</para>

      <informalexample>
        <screen>
$ svn propget svn:keywords foo.c
Author
Date
Rev
</screen>
      </informalexample>

      <!--
      <para>The same goes for a revision property:</para>
      -->
      <para>查看一个版本号的属性值:</para>

      <informalexample>
        <screen>
$ svn propget svn:log --revprop -r 20 
Began journal.
</screen>
      </informalexample>

      <!--
      <para>For a more structured display of properties, use
        the <option>- -verbose</option> (<option>-v</option>)
        option:</para>
      -->
      <para>为了获得更加结构化的输出, 可以加上选项 <option>--verbose</option>
        (<option>-v</option>):</para>

      <informalexample>
        <screen>
$ svn propget svn:keywords foo.c --verbose
Properties on 'foo.c':
  svn:keywords
    Author
    Date
    Rev
</screen>
      </informalexample>

      <!--
      <para>Examine the versioned properties inherited by a URL in
        your repository using the <option>- -show-inherited-props
        </option> option:</para>
      -->
        <para>为了查看继承而来的属性, 可以加上选项
          <option>--show-inherited-props</option>:</para>

      <informalexample>
        <screen>
$ svn pg svn:global-ignores --verbose --show-inherited-props ^/branches/1.x
Inherited properties on 'http://svn.example.com/repos/branches/1.x',
from 'http://svn.example.com/repos':
  svn:global-ignores
    *.diff
    *.patch
</screen>
      </informalexample>

      <!--
      <para>By default, <command>svn propget</command> will append
        a trailing end-of-line sequence to the property value it
        prints.  Most of the time, this is a desirable feature
        that has a positive effect on the printed output.  But
        there are times when you might wish to capture the precise
        property value, perhaps because that value is not textual
        in nature, but of some binary format (such as a JPEG
        thumbnail stored as a property value, for example).  To
        disable pretty-printing of property values, use
        the <option>- -strict</option> option.</para>
      -->
      <para>默认情况下, <command>svn propget</command> 在打印完属性值后会额外
        打印一个换行符, 在大多数情况下这是一种比较合理的行为, 但有时候用户
        可能想精确地打印属性值, 比如属性值根本就不是纯文本, 例如 JPEG 缩略
        图. 为了禁止打印额外的换行符, 可以加上选项 <option>--strict</option>.
      </para>

      <!--
      <para>Lastly, you can get <command>svn propget</command>
        output in XML format with the <option>- -xml</option>
        option:</para>
      -->
      <para>最后, 为了让 <command>svn propget</command> 以 XML 格式显示输出,
        可以加上选项 <option>--xml</option>:</para>

      <informalexample>
        <screen>
$ svn propget --xml svn:ignore .
&lt;?xml version="1.0"?&gt;
&lt;properties&gt;
&lt;target
   path=""&gt;
&lt;property
   name="svn:ignore"&gt;*.o
&lt;/property&gt;
&lt;/target&gt;
&lt;/properties&gt;
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.proplist">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>proplist</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn proplist (plist, pl)</refname>
      <!--
      <refpurpose>List all properties.</refpurpose>
      -->
      <refpurpose>列出所有的属性.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn proplist [TARGET[@REV]...]</literal></para>
      <para><literal>svn proplist --revprop -r REV [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>List all properties on files, directories, or
        revisions.  The first form lists versioned properties in
        your working copy, and the second lists unversioned remote
        properties on a repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
      -->
      <para>列出文件, 目录或版本号上的所有属性. 命令的第一种形式为工作副本里
        的项目列出属性; 第二种形式列出版本号上的属性 (可选参数
        <replaceable>TARGET</replaceable> 指定仓库的 URL).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.show_inherited_props" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>You can use <command>proplist</command> to see the properties on an
        item in your working copy:</para>
      -->
      <para>显示工作副本中中的某个文件上已经设置了哪些属性:</para>

      <informalexample>
        <screen>
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
</screen>
      </informalexample>

      <!--
      <para>But with the <option>- -verbose</option>
        (<option>-v</option>) flag, <command>svn
        proplist</command> is extremely handy as it also shows you
        the values for the properties:</para>
      -->
      <para>加上选项 <option>--verbose</option> (<option>-v</option>) 后,
        <command>svn proplist</command> 不仅会打印属性名, 还会打印属性值:
      </para>

      <informalexample>
        <screen>
$ svn proplist -v foo.c
Properties on 'foo.c':
  svn:mime-type
    text/plain
  svn:keywords
    Author Date Rev
  owner
    sally
</screen>
      </informalexample>

      <!--
      <para>List all the versioned properties inherited by a file in
        your working copy using the <option>- -show-inherited-props
        </option> option:</para>
      -->
        <para>为了列出继承而来的属性, 可以加上选项
          <option>--show-inherited-props</option>:</para>

      <informalexample>
        <screen>
$ svn proplist --show-inherited-props foo.c
Inherited properties on 'foo.c',
from 'http://svn.example.com/repos':
  svn:auto-props
  svn:global-ignores
Inherited properties on 'foo.c',
from '/home/theob/svn/working-copies/baz-wc':
  svn:auto-props
</screen>
      </informalexample>

      <!--
      <para>Lastly, you can get <command>svn proplist</command>
        output in XML format with the <option>- -xml</option>
        option:</para>
      -->
      <para>最后, 为了让 <command>svn proplist</command> 以 XML 格式显示输出,
        可以加上选项 <option>--xml</option>:</para>

      <informalexample>
        <screen>
$ svn proplist --xml 
&lt;?xml version="1.0"?&gt;
&lt;properties&gt;
&lt;target
   path="."&gt;
&lt;property
   name="svn:ignore"/&gt;
&lt;/target&gt;
&lt;/properties&gt;
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propset">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propset</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propset (pset, ps)</refname>
      <!--
      <refpurpose>Set <replaceable>PROPNAME</replaceable>
        to <replaceable>PROPVAL</replaceable> on files, directories,
        or revisions.</refpurpose>
      -->
      <refpurpose>把文件, 目录或版本号上的属性
        <replaceable>PROPNAME</replaceable> 的值设置成
        <replaceable>PROPVAL</replaceable>.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</literal></para>
      <para><literal>svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Set <replaceable>PROPNAME</replaceable> to
        <replaceable>PROPVAL</replaceable> on files, directories,
        or revisions.  The first example creates a versioned, local
        property change in the working copy, and the second
        creates an unversioned, remote property change on a
        repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
      -->
      <para>把文件, 目录或版本号上的属性 <replaceable>PROPNAME</replaceable>
        的值设置成 <replaceable>PROPVAL</replaceable>. 命令的第一种形式在工作
        副本的项目上设置或修改一个属性; 第二种形式为版本号设置或修改一个属性
        (可选参数 <replaceable>TARGET</replaceable> 指定仓库的 URL).</para>

      <tip>
      <!--
        <para>Subversion has a number of <quote>special</quote>
          properties that affect its behavior.  See <xref
          linkend="svn.advanced.props.ref"/> for details.</para>
      -->
      <para>Subversion 预定义了很多 <quote>特殊</quote> 属性, 见 <xref
          linkend="svn.advanced.props.ref"/>.</para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Set the MIME type for a file:</para>
      -->
      <para>为一个文件设置 MIME 类型:</para>

      <informalexample>
        <screen>
$ svn propset svn:mime-type image/jpeg foo.jpg 
property 'svn:mime-type' set on 'foo.jpg'
</screen>
      </informalexample>

      <!--
      <para>On a Unix system, if you want a file to have the
        executable permission set:</para>
      -->
      <para>在 Unix 系统中, 如果你希望文件具有可执行权限, 可以这样做:</para>

      <informalexample>
        <screen>
$ svn propset svn:executable ON somescript
property 'svn:executable' set on 'somescript'
</screen>
      </informalexample>

      <!--
      <para>Perhaps you have an internal policy to set certain
        properties for the benefit of your coworkers:</para>
      -->
      <para>为了方便协作, 你可能需要设置自定义属性:</para>

      <informalexample>
        <screen>
$ svn propset owner sally foo.c
property 'owner' set on 'foo.c'
</screen>
      </informalexample>

      <!--
      <para>If you made a mistake in a log message for a
        particular revision and want to change it, use
        <option>- -revprop</option> and set <literal>svn:log</literal>
        to the new log message:</para>
      -->
      <para>如果你不小心把一个版本号的日志写错了, 现在想把它改回来,
        可以这样做:</para>

      <informalexample>
        <screen>
$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property 'svn:log' set on repository revision '25'
</screen>
      </informalexample>

      <!--
      <para>Or, if you don't have a working copy, you can
        provide a URL:</para>
      -->
      <para>如果你没有工作副本, 可以使用仓库的 URL:</para>

      <informalexample>
        <screen>
$ svn propset --revprop -r 26 svn:log "Document nap." \
              http://svn.red-bean.com/repos
property 'svn:log' set on repository revision '25'
</screen>
      </informalexample>

      <!--
      <para>Lastly, you can tell <command>propset</command> to take its input from
        a file.  You could even use this to set the contents of a
        property to something binary:</para>
      -->
      <para>最后, 还可以让 <command>svn propset</command> 从一个文件中获取属性
        值, 可以利用这个特性把属性设置成二进制内容:</para>

      <informalexample>
        <screen>
$ svn propset owner-pic -F sally.jpg moo.c 
property 'owner-pic' set on 'moo.c'
</screen>
      </informalexample>

      <note>
      <!--
        <para>By default, you cannot modify revision properties
          in a Subversion repository.  Your repository
          administrator must explicitly enable revision property
          modifications by creating a hook named
          <literal>pre-revprop-change</literal>.  See
          <xref linkend="svn.reposadmin.hooks" /> for more
          information on hook scripts.</para>
      -->
        <para>默认情况下, Subversion 禁止用户修改版本号的属性, 为了允许修改,
          仓库管理员必须通过创建钩子脚本 pre-revprop-change 来显式地允许
          用户修改版本号的属性. 关于钩子脚本的更多信息, 见
          <xref linkend="svn.reposadmin.hooks" />.</para>
      </note>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.relocate">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>relocate</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn relocate</refname>
      <!--
      <refpurpose>Relocate the working copy to point to a
        different repository root URL.</refpurpose>
      -->
      <refpurpose>修改工作副本所映射的仓库的根 URL.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn relocate FROM-PREFIX TO-PREFIX [PATH...]</literal></para>
      <para><literal>svn relocate TO-URL [PATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Sometimes an administrator might change the location
        (or apparent location, from the client's perspective) of a
        repository.  The content of the repository doesn't change,
        but the repository's root URL does.  The hostname may
        change because the repository is now being served from a
        different computer.  Or, perhaps the URL scheme changes
        because the repository is now being served via SSL
        (using <literal>https://</literal>) instead of over plain
        HTTP.  There are many different reasons for these types of
        repository relocations.  But ideally, a <quote>change of
        address</quote> for a repository shouldn't suddently cause
        all the working copies which point to that repository to
        become forever unusable.  And fortunately, that's not the
        case.  Rather than force users to check out a new working
        copy when a repository is relocated, Subversion provides
        the <command>svn relocate</command> command, which 
        <quote>rewrites</quote> the working copy's administrative
        metadata to refer to the new repository location.</para>
      -->
      <para>有时候, 管理员可能会改变仓库的存放位置, 虽然仓库的内容并没有发生
        变化, 但是它的根 URL 变了. 例如由于更换了托管服务器, 所以仓库的主机
        名发生了变化, 又或者说修改了仓库的访问协议, 由原来的普通 HTTP
        (<literal>http://</literal> 改成了 SSL (<literal>https://</literal>).
        导致仓库根 URL 发生变化的原因还有很多, 但是仓库位置的变化不应该导致
        现有的工作副本失效, 幸运的是 Subversion 早就考虑到了这一问题. 当仓库
        的根 URL 发生变化时, 用户不必再重新检出一份工作副本, 而是可以用命令
        <command>svn relocate</command> <quote>重写</quote> 工作副本的元数据,
        使其指向新的仓库根 URL.</para>

      <!--
      <para>The first <command>svn relocate</command> syntax
        allows you to update one or more working copies by what
        essentially amounts to a find-and-replace within the
        repository root URLs recorded in those working copies.
        Subversion will replace the initial substring
        <replaceable>FROM-PREFIX</replaceable> with the
        string <replaceable>TO-PREFIX</replaceable> in those URLs.
        These initial URL substrings can be as long or as short as
        is necessary to differentiate between them.  Obviously, to
        use this syntax form, you need to know both the current
        root URL of the repository to which the working copy is
        pointing, and the new URL of that repository.
        (You can use <command>svn info</command> to determine
        the former.)</para>
      -->
      <para>命令的第一种形式本质上是在给工作副本中记录的仓库根 URL 做一次
        <quote>搜索并替换</quote> 操作. Subversion 把 URL 中的子字符串
        <replaceable>FROM-PREFIX</replaceable> 替换成
        <replaceable>TO-PREFIX</replaceable>. 这些 URL 子字符串可以任意地
        长或任意地短, 只要能够把它们区分出来即可. 显然, 为了使用这种语法,
        用户必须同时知道工作副本当前的仓库根 URL 和新的仓库根 URL. (可以使用
        命令 <command>svn info</command> 得到工作副本当前的仓库根 URL.)</para>

      <!--
      <para>The second syntax does not require that you know the
        current repository root URL with which the working copy is
        associated at all&mdash;only the new repository URL
        (<replaceable>TO-URL</replaceable>) to which it should be
        pointing.  In this syntax form, only one working copy may
        be relocated at a time.</para>
      -->
      <para>命令的第二种形式只要求用户知道新的仓库根 URL, 但一次只能更新一个
        工作副本.</para>

      <warning>
      <!--
        <para>Users often get confused about the difference
          between <command>svn switch</command> and <command>svn
          relocate</command>.  Here's the rule of thumb:</para>
      -->
      <para>用户常常搞不清楚 <command>svn switch</command> 和 <command>svn
          relocate</command> 之间的区别, 这里有 2 条经验规则:</para>
        
        <itemizedlist>
          <listitem>
      <!--
            <para>If the working copy needs to reflect a new
              directory <emphasis>within</emphasis> the
              repository, use <command>svn
              switch</command>.</para>
      -->
          <para>如果工作副本需要映射到 <emphasis>仓库内</emphasis> 另一个目录
            上, 就用 <command>svn switch</command>.</para>
          </listitem>
          <listitem>
      <!--
            <para>If the working copy still reflects the
              same repository directory, but the location of the
              repository itself has changed, use <command>svn
              relocate</command>.</para>
      -->
          <para>如果工作副本仍然需要映射到相同的仓库目录, 但仓库的位置发生了
            变化, 就用 <command>svn relocate</command>.</para>
          </listitem>
        </itemizedlist>
      </warning>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.ignore_externals" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Let's start with a working copy that reflects a local
        repository URL:</para>
      -->
      <para>假设开始时工作副本是映射到一个本地仓库的 URL:</para>

      <informalexample>
        <screen>
$ svn info | grep ^URL:
URL: file:///var/svn/repos/trunk
$
</screen>
      </informalexample>

      <!--
      <para>One day the administrator decides to rename the
        on-disk repository directory.  We missed the memo, so we
        see an error the next time we try to update our working
        copy.</para>
      -->
      <para>突然有一天, 管理员决定重命名本地的仓库目录, 但是他忘记把这件事
        通知给大家, 于是我们在下一次更新工作副本时出错了.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
svn: E180001: Unable to connect to a repository at URL 'file:///var/svn/repos/trunk'
</screen>
      </informalexample>

      <!--
      <para>After cornering the administrator over by the vending
        machines, we learn about the repository being moved and
        are told the new URL.  Rather than checkout a new working
        copy, though, we simply ask Subversion to rewrite the
        working copy metadata to point to the new repository
        location.</para>
      -->
      <para>向管理员咨询后得知仓库已经更换了位置, 并得到了仓库新的 URL. 我们不
        想重新检出工作副本, 而是让 Subversion 更新现有工作副本的元数据, 以便
        映射到新的仓库根 URL.</para>

      <informalexample>
        <screen>
$ svn relocate file:///var/svn/new-repos/trunk
$
</screen>
      </informalexample>

      <!--
      <para>Subversion doesn't tell us much about what it did, but
        hey&mdash;error-free operation is really all we need,
        right?  Our working copy is functional for online
        operations again.</para>
      -->
      <para>在命令执行期间 Subversion 不会输出什么信息, 但我们要的不就是这
        种不会出错的命令吗? 现在我们的工作副本已经准备好再次执行
        <command>svn up</command>.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
A    lib/new.c
M    src/code.h
M    src/headers.h
&hellip;
</screen>
      </informalexample>

      <note>
      <!--
        <para>Once again, this type of relocation
          affects <emphasis>working copy metadata only</emphasis>.
          It will not change your versioned or unversioned file
          contents, perform any version control operations (such
          as commits or updates), and so on.</para>
      -->
        <para>再次强调, <command>svn relocate</command> 只会影响工作副本的
          元数据, 不会修改任何被版本控制或不被版本控制的文件, 更不会执行
          版本控制操作 (例如提交或更新).</para>
      </note>

      <!--
      <para>A few months later, we're told that the company is
        moving development to separate machines and that we'll be
        using HTTP to access the repository.  So we relocate our
        working copy again.</para>
      -->
      <para>几个月后, 我们又被告知公司将为代码托管设立单独的服务器, 开发人员
        必须使用 HTTP 访问仓库, 于是我们又要更新工作副本的仓库根 URL.</para>

      <informalexample>
        <screen>
$ svn relocate http://svn.company.com/repos/trunk
$
</screen>
      </informalexample>

      <!--
      <para>Now, each time we perform a relocation of this sort,
        Subversion contacts the repository&mdash;at its new URL,
        of course&mdash;to verify a few things.</para>
      -->
      <para>我们每次执行 <command>svn relocate</command> 时, Subversion 都
        会使用新的 URL 与仓库通信, 以便确认以下几点:</para>

      <!--
      <para>First, it wants to compare the UUID of the repository
        against what is stored in the working copy.  If these UUIDs
        don't match, the working copy relocation is disallowed.
        Maybe this isn't the same repository (just in a new
        location) after all?</para>
      -->
      <para>首先, Subversion 将仓库的 UUID 和存放在工作副本中的仓库 UUID
        进行比较, 如果这两个 UUID 不相同, Subversion 将禁止修改工作副本的
        仓库根 URL. 这样做的考虑是避免工作副本映射到一个不同的仓库上.</para>

      <!--
      <para>Secondly, Subversion wants to ensure that the updated
        working copy metadata jives with respect to the directory
        location <emphasis>inside</emphasis> the repository.
        Subversion won't let you accidentally relocate a working
        copy of a branch in your repository to the URL of a
        different branch in the same repository.  (That's
        what <command>svn switch</command>, described in
        <xref linkend="svn.ref.svn.c.switch" />, is for.)</para>
      -->
      <para>第二, Subversion 需要确认元数据更新后的工作副本仍然映射到仓库
        内的相同目录上. 这样做的考虑是避免用户不小心把工作副本映射到一个不
        同的目录上 (这本是 <command>svn switch</command> 的工作, 见
        <xref linkend="svn.ref.svn.c.switch" />).</para>

      <!--
      <para>Also, Subversion will not allow you to relocate a
        subtree of the working copy.  If you're going to relocate
        the working copy at all, you must relocate the whole
        thing.  This is to protect the integrity of the working
        copy metadata and behavior as a whole.  (And really, you'd
        be hard pressed to come up with a compelling reason to
        relocate only a piece of your working copy anyway.)</para>
      -->
      <para>另外, Subversion 不允许对工作副本的子目录执行 <command>svn
          relocate</command>, 如果你想修改工作副本的仓库根目录, 就必须整个
        工作副本一起修改. 这是为了保护工作副本元数据和行为的一致性. (而且
        在实际工作中, 你很难找到一个信服的理由来为工作副本的子目录执行
        <command>svn relocate</command>)</para>

      <!--
      <para>Let's look at one final relocation opportunity.  After
        using HTTP access for some time, the company moves to
        SSL-only access.  Now, the only change to the repository
        URL is that the scheme goes from
        being <literal>http://</literal> to
        being <literal>https://</literal>.  There are two
        different ways that we could make our working copy reflect
        ths change.  The first is to do exactly as we've done
        before and relocate to the new repository URL.</para>
      -->
      <para>最后再介绍一个使用 <command>svn relocate</command> 的场景. 在使用
        了 HTTP 一段时间后, 公司决定切换到 SSL. 而仓库 URL 唯一变化的部分是从
        <literal>http://</literal> 变成了 <literal>https://</literal>, 更新工
        作副本的仓库根 URL 的做法有两种, 第一种和之前的做法相同, 就直接让工作
        副本指向新的仓库根 URL:</para>

      <informalexample>
        <screen>
$ svn relocate https://svn.company.com/repos/trunk
$
</screen>
      </informalexample>

      <!--
      <para>But we have another option here, too.  We could simply
        ask Subversion to swap out the changed prefixes of the
        URL.</para>
      -->
      <para>第二种做法是中替换新旧 URL 中不同的部分:</para>

      <informalexample>
        <screen>
$ svn relocate http https
$
</screen>
      </informalexample>

      <!--
      <para>Either approach leaves us a working copy whose
        metadata has been updated to point to the right repository
        location.</para>
      -->
      <para>上面两种做法中的任意一种都能让工作副本指向新的仓库:</para>

      <!--
      <para>By default, <command>svn relocate</command> will
        traverse any external working copies nested within your
        working copy and attempt relocation of those working
        copies, too.  Use the <option>- -ignore-externals</option>
        option to disable this behavior.</para>
      -->
      <para>默认情况下, <command>svn relocate</command> 将会遍历所有的外部
        工作副本并更新它们的仓库根 URL, 选项
        <option>--ignore-externals</option> 将禁止这一行为.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.resolve">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>resolve</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn resolve</refname>
      <!--
      <refpurpose>Resolve conflicts on working copy files or
        directories.</refpurpose>
      -->
      <refpurpose>解决工作副本里的冲突.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn resolve [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Resolve <quote>conflicted</quote> state on working
        copy files or directories.  This routine does not
        semantically resolve conflict markers; however, it
        replaces the conflicted item with the version specified
        (interactively or via the <option>- -accept</option>
        argument) and then removes conflict-related artifact
        files.  This allows <replaceable>PATH</replaceable> to be
        committed again&mdash;that is, it tells Subversion that
        the conflicts have been <quote>resolved.</quote></para>
      -->
      <para>解决工作副本里的 <quote>冲突</quote> 状态. <command>svn
          resolve</command> 不会从语义上解决冲突标记, 而是把发生冲突的项目替换
        成指定的版本 (交互式地或通过选项 <option>--accept</option> 指定),
        然后再删除与冲突有关的辅助文件. <command>svn resolve</command> 将允许
        <replaceable>PATH</replaceable> 被提交, 也就是告诉 Subversion
        <replaceable>PATH</replaceable> 上的冲突已经被 <quote>解决</quote> 了.
      </para>

      <!--
      <para>See <xref linkend="svn.tour.cycle.resolve" /> for an
        in-depth look at resolving conflicts.</para>
      -->
      <para>关于冲突解决的更多信息, 见 <xref
          linkend="svn.tour.cycle.resolve" />.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>
      
      <!--
      <para>Here's an example where, after a postponed conflict
        resolution during update, <command>svn resolve</command>
        replaces the all conflicts in
        file <filename>foo.c</filename> with your edits:</para>
      -->
      <para>下面的例子推迟了冲突的解决, 然后 <command>svn resolve</command>
        用用户的内容替换掉所有的冲突:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
Conflict discovered in 'foo.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: p
C    foo.c
Updated to revision 5.
Summary of conflicts:
  Text conflicts: 1
$ svn resolve --accept mine-full foo.c
Resolved conflicted state of 'foo.c'
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.resolved">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>resolved</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn resolved</refname>
      <!--
      <refpurpose><emphasis>Deprecated</emphasis>.
        Remove <quote>conflicted</quote> state on working copy
        files or directories.</refpurpose>
      -->
      <refpurpose><emphasis>不再推荐使用</emphasis>. 删除工作副本项目上的
        <quote>冲突</quote> 状态.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn resolved PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>This command has been deprecated in favor of
        running <userinput>svn resolve - -accept
        working <replaceable>PATH</replaceable></userinput>.  See
        <xref linkend="svn.ref.svn.c.resolve"/> in the preceding
        section for details.</para>
      -->
      <para>已不再推荐使用该命令, 而应该使用 <userinput>svn resolve --accept
          working <replaceable>PATH</replaceable></userinput>. 关于
        <command>svn resolve</command>, 见前面的 <xref
          linkend="svn.ref.svn.c.resolve"/>.</para>

      <!--
      <para>Remove <quote>conflicted</quote> state on working copy
        files or directories.  This routine does not semantically
        resolve conflict markers; it merely removes
        conflict-related artifact files and allows
        <replaceable>PATH</replaceable> to be committed again;
        that is, it tells Subversion that the conflicts have been
        <quote>resolved.</quote>  See <xref
        linkend="svn.tour.cycle.resolve"/> for an in-depth look at
        resolving conflicts.</para>
      -->
      <para><command>svn resolved</command> 删除工作副本项目上的
        <quote>冲突</quote> 状态. 命令不会从语义上解决冲突标记, 它仅仅是删除
        与冲突有关的辅助文件, 并允许 <replaceable>PATH</replaceable> 被提交
        到仓库中, 也就是告诉 Subversion 冲突已经被 <quote>解决了</quote>.
        关于冲突解决的更多信息, 见 <xref linkend="svn.tour.cycle.resolve"/>.
      </para>
  </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>
      
      <!--
      <para>If you get a conflict on an update, your working
        copy will sprout three new files:</para>
      -->
      <para>如果你在更新 <filename>foo.c</filename> 时发生了冲突, 工作副本里
        将会出现 3 个新文件:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
C    foo.c
Updated to revision 31.
Summary of conflicts:
  Text conflicts: 1
$ ls foo.c*
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
$
</screen>
      </informalexample>

      <!--
      <para>Once you've resolved the conflict and
        <filename>foo.c</filename> is ready to be committed, run
        <command>svn resolved</command> to let your working copy
        know you've taken care of everything.</para>
      -->
      <para>一旦你已经解决了冲突, 文件 <filename>foo.c</filename> 就已经
        准备好提交, 执行 <command>svn resolved</command> 告诉 Subversion 你
        已经处理好了所有问题.</para>

      <warning>
      <!--
        <para>You <emphasis>can</emphasis> just remove the
          conflict files and commit, but <command>svn
          resolved</command> fixes up some bookkeeping data
          in the working copy administrative area in addition
          to removing the conflict files, so we recommend that
          you use this command.</para>
      -->
        <para>用户 <emphasis>可以</emphasis> 直接删除与冲突有关的辅助文件,
          然后提交, 但是 <command>svn resolved</command> 还会在工作副本管理区
          内更新一些薄记数据, 所以我们建议用户使用命令, 而不是手工操作.</para>
      </warning>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.revert">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>revert</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn revert</refname>
      <!--
      <refpurpose>Undo all local edits.</refpurpose>
      -->
      <refpurpose>撤消所有的本地修改.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn revert PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Reverts any local changes to a file or directory and
        resolves any conflicted states.  <command>svn
        revert</command> will revert not only the contents of an
        item in your working copy, but also any property
        changes.  Finally, you can use it to undo any scheduling
        operations that you may have performed (e.g., files scheduled
        for addition or deletion can be
        <quote>unscheduled</quote>).</para>
      -->
      <para>撤消文件或目录上的本地修改, 并解决可能存在的冲突状态. <command>svn
          revert</command> 不仅撤消内容上的修改, 还会撤消属性上的修改. 最后,
        <command>svn revert</command> 还能撤消被添加, 删除或移动 (但还未提交)
        的项目.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Discard changes to a file:</para>
      -->
      <para>撤消文件上的所有修改:</para>

      <informalexample>
        <screen>
$ svn revert foo.c
Reverted foo.c
</screen>
      </informalexample>

      <!--
      <para>If you want to revert a whole directory of files,
        use the <option>- -depth=infinity</option> option:</para>
      -->
      <para>如果你希望递归地撤消一个目录内的所有修改, 就加上选项
        <option>--depth=infinity</option>:</para>

      <informalexample>
        <screen>
$ svn revert --depth=infinity .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
</screen>
      </informalexample>

      <!--
      <para>Lastly, you can undo any scheduling
        operations:</para>
      -->
      <para>最后, 你还可以撤消已添加的项目:</para>

      <informalexample>
        <screen>
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?       mistake.txt
?       whoops
</screen>
      </informalexample>

      <warning>
      <!--
        <para><command>svn revert</command> is inherently
          dangerous, since its entire purpose is to throw away
          data&mdash;namely, your uncommitted changes.  Once
          you've reverted, Subversion provides <emphasis>no
          way</emphasis> to get back those uncommitted
          changes.</para>
      -->
        <para>使用 <command>svn revert</command> 具有一定的危险性, 因为它会
          丢弃所有的本地修改, 也就是用户未提交的修改. 这些本地修改一旦被撤消
          了, Subversion <emphasis>没有任何办法</emphasis> 再把它们恢复回来.
        </para>

      <!--
        <para>If you provide no targets to <command>svn
          revert</command>, it will do nothing.  To protect you
          from accidentally losing changes in your working
          copy, <command>svn revert</command> requires you to
          explicitly provide at least one target.</para>
      -->
        <para>如果用户没有为 <command>svn revert</command> 指定任何目标路径,
          它将什么也不会做, 这是为了避免用户不小心丢失自己的本地修改, 因此
          <command>svn revert</command> 要求用户必须显式地指定目标路径.</para>
      </warning>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.status">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>status</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn status (stat, st)</refname>
      <!--
      <refpurpose>Print the status of working copy files and directories.</refpurpose>
      -->
      <refpurpose>打印工作副本中文件或目录的状态.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn status [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Print the status of working copy files and
        directories.  With no arguments, it prints only locally
        modified items (no repository access).  With
        <option>- -show-updates</option> (<option>-u</option>), it
                                  ### TODO
        adds working revision and server out-of-date information.
        With <option>- -verbose</option> (<option>-v</option>), it
        prints full revision information on every item.
        With <option>- -quiet</option> (<option>-q</option>), it
        prints only summary information about locally modified
        items.</para>
      -->
      <para>打印工作副本中文件或目录的状态. 如果没有指定任何选项, <command>svn
          status</command> 将只打印本地已修改的项目 (不会访问仓库). 如果添加了
        <option>--show-updates</option> (<option>-u</option>), 命令除了会打印
        工作副本内的版本号外, 还会打印服务器上的信息. 如果添加了选项
        <option>--verbose</option> (<option>-v</option>), 它将打印每一项的
        完整的版本号信息. 如果添加了选项 <option>--quiet</option>
        (<option>-q</option>), 它就只打印与本地已修改项目有关的总结信息.</para>

      <!--
      <para>The first seven columns in the output are each one
        character wide, and each column gives you information
        about a different aspect of each working copy item.</para>
      -->
      <para>输出中每一行的前 7 列包含了描述项目状态的字符, 每一列都从不同
        的角度描述项目的状态.</para>
      
      <!--
      <para>The first column indicates that an item
        was added, deleted, or otherwise changed:</para>
      -->
      <para>第一列指出项目是新增的, 被删除的, 还是已修改的:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>No modifications.</para>
      -->
            <para>没有任何变化.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'A'</literal></term>
          <listitem>
      <!--
            <para>Item is scheduled for addition.</para>
      -->
            <para>该项是新增的.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'D'</literal></term>
          <listitem>
      <!--
            <para>Item is scheduled for deletion.</para>
      -->
            <para>该项已被删除.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'M'</literal></term>
          <listitem>
      <!--
            <para>Item has been modified.</para>
      -->
            <para>该项已被修改.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'R'</literal></term>
          <listitem>
      <!--
            <para>Item has been replaced in your working copy.
            This means the file was scheduled for deletion, and
            then a new file with the same name was scheduled for
            addition in its place.</para>
      -->
          <para>该项被工作副本中的其他项目替换了. 这意味着原来的项目已被删除,
            然后在原来的位置上添加了一个新项目.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'C'</literal></term>
          <listitem>
      <!--
            <para>The contents (as opposed to the properties) of
              the item conflict with updates received from the
              repository.</para>  
      -->
            <para>项目在工作副本中的内容 (不包含属性) 和从服务器上接收到的
              更新有冲突.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'X'</literal></term>
          <listitem>
      <!--
            <para>Item is present because of an externals definition.</para>
      -->
            <para>项目是通过外部定义创建的.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'I'</literal></term>
          <listitem>
      <!--
            <para>Item is being ignored (e.g., with the 
              <literal>svn:ignore</literal> property).</para>
      -->
            <para>项目是被忽略的 (例如由于属性 <literal>svn:ignore</literal>).
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'?'</literal></term>
          <listitem>
      <!--
            <para>Item is not under version control.</para>
      -->
            <para>项目不被版本控制.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'!'</literal></term>
          <listitem>
      <!--
            <para>Item is missing (e.g., you moved or deleted it
              without using <command>svn</command>).  This also
              indicates that a directory is incomplete (a checkout
              or update was interrupted).</para>
      -->
            <para>项目失踪了 (例如用户没有使用 <command>svn</command> 提供的
              命令来移动或删除项目). 这同时也意味着目录是不完整的 (例如检出或
              更新操作被中断了).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'~'</literal></term>
          <listitem>
      <!--
            <para>Item is versioned as one kind of object (file,
              directory, link), but has been replaced by a different
              kind of object.</para>
      -->
            <para>项目是作为一种文件类型 (例如普通文件, 目录文件或符号链接)
              存放到仓库中, 但是现在工作副本中的项目已经被另一种文件类型所
              取代.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The second column tells the status of a file's or
        directory's properties:</para>
      -->
      <para>第二列指出文件或目录的属性的状态:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>No modifications.</para>
      -->
            <para>没有变化.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'M'</literal></term>
          <listitem>
      <!--
            <para>Properties for this item have been
              modified.</para>
      -->
            <para>属性被修改了.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'C'</literal></term>
          <listitem>
      <!--
            <para>Properties for this item are in conflict with
              property updates received from the
              repository.</para>
      -->
            <para>属性的修改含有冲突.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The third column is populated only if the
        working copy directory is locked (see
        <xref linkend="svn.tour.cleanup"/>):</para>
      -->
      <para>第三列指出工作副本目录是否被锁定了 (见
        <xref linkend="svn.tour.cleanup"/>):</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>Item is not locked.</para>
      -->
            <para>项目未被锁定.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'L'</literal></term>
          <listitem>
      <!--
            <para>Item is locked.</para>
      -->
            <para>项目已被锁定.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The fourth column is populated only if the item is
        scheduled for addition-with-history:</para>
      -->
      <para>第四列指出被添加的项目是否含有历史:</para>
      
      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>No history scheduled with commit.</para>
      -->
            <para>被添加的项目不含有历史.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'+'</literal></term>
          <listitem>
      <!--
            <para>History scheduled with commit.</para>
      -->
            <para>被添加的项目含有历史.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The fifth column is populated only if the item is
        switched relative to its parent (see <xref
        linkend="svn.branchmerge.switchwc"/>):</para>
      -->
    <para>第五列指出项目是否相对于父目录进行了切换 (见 <xref
        linkend="svn.branchmerge.switchwc"/>):</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>Item is a child of its parent directory.</para>
      -->
            <para>项目是父目录的子文件.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'S'</literal></term>
          <listitem>
      <!--
            <para>Item is switched.</para>
      -->
            <para>项目被切换过了.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The sixth column is populated with lock information:</para>
      -->
      <para>第六列指出了关于锁的信息:</para>
      
      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>When <option>- -show-updates</option>
              (<option>-u</option>) is used, this means the file is not
              locked.  If <option>- -show-updates</option>
              (<option>-u</option>) is <emphasis>not</emphasis>
              used, this merely means that the file is not locked
              in this working copy.</para>
      -->
            <para>如果指定了选项 <option>--show-updates</option>
              (<option>-u</option>), 则说明文件未被锁定. 如果没有指定选项
              <option>--show-updates</option> (<option>-u</option>), 则说明
              文件在工作副本中未被锁定.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'K'</literal></term>
          <listitem>
      <!--
            <para>File is locked in this working copy.</para>
      -->
            <para>文件在工作副本中被锁定.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'O'</literal></term>
          <listitem>
      <!--
            <para>File is locked either by another user or in
            another working copy.  This appears only when
            <option>- -show-updates</option>
            (<option>-u</option>) is used.</para>
      -->
          <para>文件被另一个用户或者在另一个工作副本中被锁定, 仅当指定选项
            <option>--show-updates</option> (<option>-u</option>) 时才会出
            现该状态.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'T'</literal></term>
          <listitem>
      <!--
            <para>File was locked in this working copy, but the
            lock has been <quote>stolen</quote> and is invalid.
            The file is currently locked in the repository.  This
            appears only when <option>- -show-updates</option>
            (<option>-u</option>) is used.</para>
      -->
          <para>文件在工作副本中被锁定, 但是锁已经被 <quote>窃取</quote>, 并
            且不再有效. 文件当前在仓库中是处于被锁定的状态. 只有指定选项
            <option>--show-updates</option> (<option>-u</option>) 时才会显示
            该状态.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'B'</literal></term>
          <listitem>
      <!--
            <para>File was locked in this working copy, but the
              lock has been <quote>broken</quote> and is invalid.
              The file is no longer locked.  This appears only
              when <option>- -show-updates</option>
              (<option>-u</option>) is used.</para>
      -->
            <para>文件在工作副本中被锁定, 但是锁已经被 <quote>破坏</quote> 了,
              并且不再有效. 文件当前在仓库中未被锁定. 只有指定选项
              <option>--show-updates</option> (<option>-u</option>) 时才会显示
              该状态.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The seventh column is populated only if the item is
        the victim of a tree conflict:</para>
      -->
      <para>第七列指出项目是否是目录冲突的受害者:</para>

      <variablelist>

        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>Item is not the victim of a tree conflict.</para>
      -->
            <para>项目不是目录冲突的受害都.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'C'</literal></term>
          <listitem>
      <!--
            <para>Item is the victim of a tree conflict.</para>
      -->
            <para>项目是目录冲突的受害者.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The eighth column is always blank.</para>
      -->
      <para>第八列总是一个空格.</para>

      <!--
      <para>The out-of-date information appears in the ninth
        column (only if you pass the
        <option>- -show-updates</option> (<option>-u</option>)
        option):</para>
      -->
      <para>第九列指出仓库中是否有更新的版本 (只有指定选项
        <option>--show-updates</option> (<option>-u</option>) 时才会显示该
        状态):</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
      <!--
            <para>The item in your working copy is up to date.</para>
      -->
            <para>仓库中没有更新的版本.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'*'</literal></term>
          <listitem>
      <!--
            <para>A newer revision of the item exists on the
              server.</para>
      -->
            <para>仓库中有更新的版本.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>The remaining fields are variable width and delimited
        by spaces.  The working revision is the next field if
        the <option>- -show-updates</option> (<option>-u</option>)
        or <option>- -verbose</option> (<option>-v</option>) option
        is passed.</para>
      -->
      <para>剩下的字段长度不一, 字段之间用空格分开. 如果指定了选项
        <option>--show-updates</option> (<option>-u</option>) 或
        <option>--verbose</option> (<option>-v</option>), 则下一个字段是
        工作版本号.</para>
      
      <!--
      <para>If the <option>- -verbose</option>
        (<option>-v</option>) option is passed, the last committed
        revision and last committed author are displayed
        next.</para>
      -->
      <para>如果指定了选项 <option>--verbose</option> (<option>-v</option>),
        则下一个字段是最后一次提交的版本号和作者.</para>
      
      <!--
      <para>The working copy path is always the final field, so
        it can include spaces.</para>
      -->
      <para>因为项目的工作副本路径总是最后一个字段, 因此路径内可以包含空格.
      </para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.no_ignore" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.show_updates" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>This is the easiest way to find out what changes you
        have made to your working copy:</para>
      -->
      <para>如果你想检查工作副本包含了哪些修改, 最方便的做法是:</para>

      <informalexample>
        <screen>
$ svn status wc
 M      wc/bar.c
A  +    wc/qax.c
</screen>
      </informalexample>

      <!--
      <para>If you want to find out what files in your working
        copy are out of date, pass
        the <option>- -show-updates</option> (<option>-u</option>)
        option (this will <emphasis>not</emphasis> make any
        changes to your working copy).  Here you can see that
        <filename>wc/foo.c</filename> has changed in the
        repository since we last updated our working
        copy:</para>
      -->
      <para>如果你想查看工作副本中的哪些文件已经过时了, 就加上选项
        <option>--show-updates</option> (<option>-u</option>) (这个选项
        <emphasis>不会</emphasis> 对工作副本作出任何修改). 下面的例子说明
        仓库中的 <filename>wc/foo.c</filename> 比工作副本中的更新:</para>

      <informalexample>
        <screen>
$ svn status -u wc
 M            965    wc/bar.c
        *     965    wc/foo.c
A  +          965    wc/qax.c
Status against revision:    981
</screen>
      </informalexample>

      <note>
      <!--
        <para><option>- -show-updates</option>
          (<option>-u</option>) <emphasis>only</emphasis> places
          an asterisk next to items that are out of date (i.e.,
          items that will be updated from the repository if you
          later use <command>svn update</command>).
          <option>- -show-updates</option> (<option>-u</option>)
          does <emphasis>not</emphasis> cause the status listing
          to reflect the repository's version of the item
          (although you can see the revision number in the
          repository by passing the <option>- -verbose</option>
          (<option>-v</option>) option).</para>
      -->
        <para>选项 <option>--show-updates</option> (<option>-u</option>)
          <emphasis>只会</emphasis> 在项目旁边打印一个星号 (意思是说仓库中
          有更新的版本). 选项 <option>--show-updates</option>
          (<option>-u</option>) <emphasis>不会</emphasis> 打印该项目在仓库中
          的版本号 (但你仍然可以用选项 <option>--verbose</option>
          (<option>-v</option>) 查看项目在仓库中的版本号).</para>
      </note>

      <!--
      <para>The most information you can get out of
        the status subcommand is as follows:</para>
      -->
      <para>在最详细的情况下, <command>svn status</command> 打印的信息如下:
      </para>

      <informalexample>
        <screen>
$ svn status -u -v wc
 M            965       938 sally        wc/bar.c
        *     965       922 harry        wc/foo.c
A  +          965       687 harry        wc/qax.c
              965       687 harry        wc/zig.c
Status against revision:   981
</screen>
      </informalexample>

      <!--
      <para>Lastly, you can get <command>svn status</command>
        output in XML format with the <option>- -xml</option>
        option:</para>
      -->
      <para>最后, 如果指定了选项 <option>--xml</option>, 则 <command>svn
          status</command> 将以 XML 格式打印输出:</para>

      <informalexample>
        <screen>
$ svn status --xml wc
&lt;?xml version="1.0"?&gt;
&lt;status&gt;
&lt;target
   path="wc"&gt;
&lt;entry
   path="qax.c"&gt;
&lt;wc-status
   props="none"
   item="added"
   revision="0"&gt;
&lt;/wc-status&gt;
&lt;/entry&gt;
&lt;entry
   path="bar.c"&gt;
&lt;wc-status
   props="normal"
   item="modified"
   revision="965"&gt;
&lt;commit
   revision="965"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2008-05-28T06:35:53.048870Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/wc-status&gt;
&lt;/entry&gt;
&lt;/target&gt;
&lt;/status&gt;
</screen>
      </informalexample>

      <!--
      <para>For many more examples of <command>svn status</command>,
        see <xref linkend="svn.tour.cycle.examine.status"/>.</para>
      -->
      <para>关于 <command>svn status</command> 的更多例子, 见
        <xref linkend="svn.tour.cycle.examine.status"/>.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.switch">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>switch</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn switch (sw)</refname>
      <!--
      <refpurpose>Update working copy to a different URL.</refpurpose>
      -->
      <refpurpose>将工作副本更新到另一个 URL.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn switch URL[@PEGREV] [PATH]</literal></para>
      <para><literal>svn switch --relocate FROM TO [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>The first variant of this subcommand (without the
        <option>- -relocate</option> option) updates your working
        copy to point to a new URL.  This is the Subversion way to
        make a working copy begin tracking a new branch.  If
        specified, <replaceable>PEGREV</replaceable> determines in
        which revision the target is first looked up.  See
        <xref linkend="svn.branchmerge.switchwc"/> for an in-depth
        look at switching.</para>
      -->
      <para>命令的第一种形式 (不带有选项 <option>--relocate</option>) 把工作
        副本更新到一个新的 URL. 这是 Subversion 提供的, 用于让工作副本跟踪一
        个新分支的方式. 如果指定了 <replaceable>PEGREV</replaceable>, 则
        <replaceable>PEGREV</replaceable> 决定了 Subversion 在哪个版本号内
        查找目标路径. 关于分支切换的更多信息, 见 <xref
          linkend="svn.branchmerge.switchwc"/>.</para>

      <note>
      <!--
        <para>Beginning with Subversion 1.7, the <command>svn
          switch</command> command will demand by default that the
          URL to which you are switching your working copy shares
          a common ancestry with item that the working copy
          currently reflects.  You can override this behavior by
          specifying the <option>- -ignore-ancestry</option>
          option.</para>
      -->
        <para>从 Subversion 1.7 开始, <command>svn switch</command> 要求新
          的 URL 必须和工作副本当前的 URL 具有相同的祖先. 为了忽略这一要求,
          可以指定选项 <option>--ignore-ancestry</option>.</para>
      </note>

      <!--
      <para>If <option>- -force</option> is used, unversioned
        obstructing paths in the working copy do not automatically
        cause a failure if the switch attempts to add the same
        path.  If the obstructing path is the same type (file or
        directory) as the corresponding path in the repository, it
        becomes versioned but its contents are left untouched in
        the working copy.  This means that an obstructing
        directory's unversioned children may also obstruct and
        become versioned.  For files, any content differences
        between the obstruction and the repository are treated
        like a local modification to the working copy.  All
        properties from the repository are applied to the
        obstructing path.</para>
      -->
      <para>如果指定了选项 <option>--force</option>, 那么 <command>svn
          switch</command> 在添加一个新路径时, 如果该路径在切换前是一个未
        被版本控制的路径, 将不会产生一个错误. 如果未被版本控制的路径和
        切换后的新路径类型相同 (文件或目录), 则路径将被纳入版本控制, 但原来
        的内容保持不变, 这也意味着目录的子文件也可能被纳入版本控制. 对于文件
        来说, 不同的部分将被当作本地修改. 来自仓库的所有属性都会被应用到路径
        上.</para>

      <!--
      <para>As with most subcommands, you can limit the scope of
        the switch operation to a particular tree depth using the
        <option>- -depth</option> option.  Alternatively, you can
        use the <option>- -set-depth</option> option to set a new
        <quote>sticky</quote> working copy depth on the switch
        target.</para>
      -->
      <para>和大多数子命令一样, 用户可以通过选项 <option>--depth</option>
        限制 <command>svn switch</command> 的作用深度. 相应地, 用户还可以用
        选项 <option>--set-depth</option> 为目标路径设置新的
        <quote>粘着</quote> 深度.</para>

      <!--
      <para>The <option>- -relocate</option> option is deprecated
        as of Subversion 1.7.  Use <command>svn relocate</command>
        (described in <xref linkend="svn.ref.svn.c.relocate" />)
        to perform working copy relocation instead.</para>
      -->
      <para>从 Subversion 1.7 开始, 选项 <option>--relocate</option> 已不再
        推荐使用, 而应直接使用 <command>svn relocate</command> (见 <xref
          linkend="svn.ref.svn.c.relocate" />) 完成工作副本仓库根 URL 的
        更新.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_ancestry" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.relocate" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.set_depth" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>If you're currently inside the directory
        <filename>vendors</filename>, which was branched to
        <filename>vendors-with-fix</filename>, and you'd like to
        switch your working copy to that branch:</para>
      -->
      <para>如果你现在正在目录 <filename>vendors</filename> 内, 而现在你想
        让该目录指向分支 <filename>vendors-with-fix</filename>:</para>

      <informalexample>
        <screen>
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U    myproj/foo.txt
U    myproj/bar.txt
U    myproj/baz.c
U    myproj/qux.c
Updated to revision 31.
</screen>
      </informalexample>

      <!--
      <para>To switch back, just provide the URL to the
        location in the repository from which you originally
        checked out your working copy:</para>
      -->
      <para>工作完成后, 可以再切换回分支 <filename>vendors</filename>:</para>

      <informalexample>
        <screen>
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U    myproj/foo.txt
U    myproj/bar.txt
U    myproj/baz.c
U    myproj/qux.c
Updated to revision 31.
</screen>
      </informalexample>

      <tip>
      <!--
        <para>You <emphasis>can</emphasis> switch just part of
          your working copy to a branch if you don't want to
          switch your entire working copy, but this is not
          generally recommended.  It's too easy to forget that
          you've done this and wind up accidentally making and
          committing changes both to the switched and unswitched
          portions of your tree.</para>
      -->
        <para>用户 <emphasis>可以</emphasis> 只切换工作副本的一部分到一个
          新的分支, 但这不是推荐的做法. 因为很容易忘记工作副本只是部分切换
          的, 然后用户意外地同时修改并提交到已切换到未切换的目录树中.</para>
      </tip>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.unlock">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>unlock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn unlock</refname> 
      <!--
        <refpurpose>Unlock working copy paths or URLs.</refpurpose>
      -->
        <refpurpose>解锁工作副本路径或 URL.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn unlock TARGET...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>Unlock each <replaceable>TARGET</replaceable>.  If any
        <replaceable>TARGET</replaceable> is locked by
        another user or no valid lock token exists in the working
        copy, print a warning and continue unlocking the rest of
        the <replaceable>TARGET</replaceable>s.  Use
        <option>- -force</option> to break a lock belonging to
        another user or working copy.</para>
      -->
      <para>解锁每一个 <replaceable>TARGET</replaceable>. 如果有任意一个
        <replaceable>TARGET</replaceable> 被其他用户加锁了, 或者在工作副本
        中不存在有效的锁令牌, Subversion 就会打印一个警告, 然后继续解锁剩下
        的 <replaceable>TARGET</replaceable>. 为了破坏属于其他用户或工作副本
        的锁, 可以加上选项 <option>--force</option>.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Unlock two files in your working copy:</para>
      -->
      <para>解锁工作副本中的两个文件:</para>

      <informalexample>
        <screen>
$ svn unlock tree.jpg house.jpg
'tree.jpg' unlocked.
'house.jpg' unlocked.
</screen>
      </informalexample>

      <!--
      <para>Unlock a file in your working copy that is currently
        locked by another user:</para>
      -->
      <para>解锁工作副本里的一个文件, 但是该文件已经被其他用户加锁了:</para>

      <informalexample>
        <screen>
$ svn unlock tree.jpg
svn: E195013: 'tree.jpg' is not locked in this working copy
$ svn unlock --force tree.jpg
'tree.jpg' unlocked.
</screen>
      </informalexample>

      <!--
      <para>Unlock a file without a working copy:</para>
      -->
      <para>在没有工作副本的情况下解锁一个文件:</para>

      <informalexample>
        <screen>
$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg unlocked.
</screen>
      </informalexample>

      <!--
      <para>For further details, see <xref
        linkend="svn.advanced.locking"/>.</para>
      -->
    <para>更多的内容, 见 <xref linkend="svn.advanced.locking"/>.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.update">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>update</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn update (up)</refname>
      <!--
      <refpurpose>Update your working copy.</refpurpose>
      -->
      <refpurpose>更新工作副本.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn update [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para><command>svn update</command> brings changes from the
        repository into your working copy.  If no revision is
        given, it brings your working copy up to date with the
        <literal>HEAD</literal> revision.  Otherwise, it
        synchronizes the working copy to the revision given by the
        <option>- -revision</option> (<option>-r</option>) option.
        As part of the synchronization, <command>svn
        update</command> also removes any stale locks (see
        <xref linkend="svn.tour.cleanup"/>) found in the working
        copy.</para>
      -->
      <para><command>svn update</command> 把仓库里的更新应用到工作副本里.
        如果没有指定版本号, 则默认是 <literal>HEAD</literal>, 否则的话,
        <command>svn update</command> 把工作副本更新到由选项
        <option>--revision</option> (<option>-r</option>) 所指定的版本号.
        作为更新操作的一部分, <command>svn update</command> 还会删除工作副本
        中已过时的锁 (见 <xref linkend="svn.tour.cleanup"/>).</para>

      <!--
      <para>For each updated item, it prints a line that starts
        with a character reporting the action taken.  These
        characters have the following meaning:</para>
      -->
      <para>对每一个被更新的项目, Subversion 都会打印一行信息, 信息的开头是
        一个字符, 用于表示对项目所采取的动作, 这些字符有:</para>

      <variablelist>

        <varlistentry>
          <term><literal>A</literal></term>
          <listitem>
      <!--
            <para>Added</para>
      -->
            <para>新增</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>B</literal></term>
          <listitem>
      <!--
            <para>Broken lock (third column only)</para>
      -->
            <para>被破坏的锁 (只出现在第 3 列)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>D</literal></term>
          <listitem>
      <!--
            <para>Deleted</para>
      -->
            <para>被删除</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>U</literal></term>
          <listitem>
      <!--
            <para>Updated</para>
      -->
            <para>被更新</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>C</literal></term>
          <listitem>
      <!--
            <para>Conflicted</para>
      -->
            <para>发生冲突</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>G</literal></term>
          <listitem>
      <!--
            <para>Merged</para>
      -->
            <para>被合并</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>E</literal></term>
          <listitem>
      <!--
            <para>Existed</para>
      -->
            <para>已存在</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>A character in the first column signifies an update to
        the actual file, whereas updates to the file's properties
        are shown in the second column.  Lock information is
        printed in the third column.</para>
      -->
      <para>出现在第一列的状态字符描述的是文件内容的更新, 出现在第二列的
        状态字符描述的是文件属性的更新, 出现在第三列的状态字符则描述的是
        关于锁的信息.</para>

      <!--
      <para>As with most subcommands, you can limit the scope of
        the update operation to a particular tree depth using the
        <option>- -depth</option> option.  Alternatively, you can
        use the <option>- -set-depth</option> option to set a new
        <quote>sticky</quote> working copy depth on the update
        target.</para>
      -->
      <para>和大多数子命令一样, 你可以通过选项 <option>--depth</option>,
        把更新操作的作用范围限制在一定的范围内. 同样地, 还可以用选项
        <option>--set-depth</option> 为目标路径设置新的 <quote>粘着</quote>
        深度.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.set_depth" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>Pick up repository changes that have happened since
        your last update:</para>
      -->
      <para>把仓库中最新的内容更新到本地:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
A    newdir/toggle.c
A    newdir/disclose.c
A    newdir/launch.c
D    newdir/README
Updated to revision 32.
</screen>
      </informalexample>

      <!--
      <para>You can also <quote>update</quote> your working copy
        to an older revision (Subversion doesn't have the concept
        of <quote>sticky</quote> files like CVS does; see <xref
        linkend="svn.forcvs"/>):</para>
      -->
    <para>还可以把工作副本 <quote>更新</quote> 一个更旧的版本 (与 CVS 相比,
      Subversion 没有 <quote>粘着</quote> 文件的概念, 见 <xref
        linkend="svn.forcvs"/>):</para>

      <informalexample>
        <screen>
$ svn update -r30
Updating '.':
A    newdir/README
D    newdir/toggle.c
D    newdir/disclose.c
D    newdir/launch.c
U    foo.c
Updated to revision 30.
</screen>
      </informalexample>

      <tip>
      <!--
        <para>If you want to examine an older revision of a
          single file, you may want to use <command>svn
          cat</command> instead&mdash;it won't change your working
          copy.</para>
      -->
        <para>如果你只是想看看某个文件在老版本时的内容, 更方便的做法是使用
          命令 <command>svn cat</command>&mdash;它不会修改工作副本.</para>
      </tip>

      <!--
      <para><command>svn update</command> is also the primary
        mechanism used to configure sparse working copies.  When
        used with the <option>- -set-depth</option>, the update
                               ### TODO
        operation will omit or reenlist individual working copy
        members by modifying their recorded ambient depth to the
        depth you specify (fetching information from the
        repository as necessary).  See
        <xref linkend="svn.advanced.sparsedirs" /> for more about
        sparse directories.</para>
      -->
      <para><command>svn update</command> 还是配置稀疏工作副本的主要命令.
        如果指定了选项 <option>--set-depth</option>, 命令将会把工作副本路径
        的周围深度修改成用户指定的深度, 从而忽略或延伸工作副本路径 (必要时
        将从仓库中抓取数据). 关于稀疏目录的更多信息, 见
        <xref linkend="svn.advanced.sparsedirs" />.</para>
      
      <!--
      <para>You can update multiple targets with a single
        invocation, and Subversion will not only gracefully skip
        any unversioned targets you provide it, but as of
        Subversion 1.7 will also include a post-update summary of
        all the updates it performed:</para>
      -->
      <para>用户可以只调用一次 <command>svn update</command> 就能更新多个
        目录, Subversion 不仅会忽略不被版本控制的目标, 如果是 Subversion 1.7,
        它还会在最后打印一段总结信息:</para>

      <informalexample>
        <screen>
$ cd my-projects
$ svn update *
Updating 'calc':
U    button.c
U    integer.c
Updated to revision 394.
Skipped 'tempfile.tmp'
Updating 'paint':
A    palettes.c
U    brushes.c
Updated to revision 60.
Updating 'ziptastic':
At revision 43.
Summary of updates:
  Updated 'calc' to r394.
  Updated 'paint' to r60.
  Updated 'ziptastic' to r43.
Summary of conflicts:
  Skipped paths: 1
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.upgrade">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>upgrade</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn upgrade</refname>
      <!--
      <refpurpose>Upgrade the metadata storage format for a
        working copy.</refpurpose>
      -->
      <refpurpose>更新工作副本的元数据格式.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn upgrade [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Description</title>
      -->
      <title>描述</title>

      <!--
      <para>As new versions of Subversion are released, the format
        used for the working copy metadata changes to accomodate
        new features or fix bugs.  Older versions of Subversion
        would automatically upgrade working copies to the new
        format the first time the working copy was used by the new
        version of the software.  Beginning with Subversion 1.7,
        working copy upgrades must be explicitly performed at the
        user's request.  <command>svn upgrade</command> is the
        subcommand used to trigger that upgrade process.</para>
      -->
      <para>随着新版 Subversion 的发布, 为了适应新版所添加的特性或为了修复
        问题, 工作副本的元数据格式可能会发生变化. 在 Subversion 1.7 之前,
        新版 Subversion 在首次使用旧版 Subversion 所创建的工作副本时, 将会
        自动升级工作副本的元数据格式. 但是从 Subversion 1.7 开始, 用户必须
        通过执行命令 <command>svn upgrade</command> 来显式地请求 Subversion
        去更新工作副本的元数据格式.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Options</title>
      -->
      <title>选项</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.quiet" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <!--
      <title>Examples</title>
      -->
      <title>示例</title>

      <!--
      <para>If you attempt to use Subversion 1.7 on a working copy
        created with an older version of Subversion, you will see
        an error:</para>
      -->
      <para>如果你试图在一个版本较旧的工作副本中使用 Subversion 1.7, Subversion
        将会报告:</para>

      <informalexample>
        <screen>
$ svn status
svn: E155036: Please see the 'svn upgrade' command
svn: E155036: Working copy '/home/sally/project' is too old (format 10, create
d by Subversion 1.6)
$
</screen>
      </informalexample>

      <!--
      <para>Use the <command>svn upgrade</command> command to
        upgrade the working copy to the most recent metadata
        format supported by your version of Subversion.</para>
      -->
      <para>这时候就需要执行 <command>svn upgrade</command> 把工作副本的元数据
        格式升级到当前 Subversion 所支持的格式:</para>

      <informalexample>
        <screen>
$ svn upgrade
Upgraded '.'
Upgraded 'A'
Upgraded 'A/B'
Upgraded 'A/B/E'
Upgraded 'A/B/F'
Upgraded 'A/C'
Upgraded 'A/D'
Upgraded 'A/D/G'
Upgraded 'A/D/H'
$ svn status
D       A/B/E/alpha
M       A/D/gamma
A       A/newfile
$
</screen>
      </informalexample>

      <!--
      <para>Notice that <command>svn upgrade</command> preserved
        the local modifications present in the working copy at the
        time of the upgrade, which were introduced by the version
        of Subversion previously used to manipulate this working
        copy.</para>
      -->
      <para>注意, <command>svn upgrade</command> 会保留工作副本的本地修改,
        即使这些修改是由旧版 Subversion 引入的 (例如 <command>svn
          mv</command>).</para>

      <warning>
      <!--
        <para>As was the case with automatically upgraded working
          copies in the past, explicitly upgraded working copies
          will be unusable by older versions of Subversion,
          too.</para>
      -->
        <para>和过去自动升级工作副本元数据的行为相比, 显式地升级工作副本
          元数据后, 旧的 Subversion 将不再支持升级后的工作副本.</para>
      </warning>
      
    </refsect1>
  </refentry>

</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
