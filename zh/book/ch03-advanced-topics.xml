<!-- -*- sgml -*- -->

<chapter id="svn.advanced">
    <!--
  <title>Advanced Topics</title>
    -->
  <title>高级主题</title>

    <!--
  <para>If you've been reading this book chapter by chapter, from
    start to finish, you should by now have acquired enough
    knowledge to use the Subversion client to perform the most
    common version control operations.  You understand how to
    check out a working copy from a Subversion repository.  You are
    comfortable with submitting and receiving changes using the
    <command>svn commit</command> and <command>svn update</command>
    operations.  You've probably even developed a reflex that causes
    you to run the <command>svn status</command> command almost
    unconsciously.  For all intents and purposes, you are ready to
    use Subversion in a typical environment.</para>
    -->
  <para>如果读者是从头开始, 一章一章地阅读本书, 那么你应该拥有了足够的知识
    去使用 Subversion 客户端工具完成最常见的版本控制操作. 你已经知道了如何
    从 Subversion 仓库检出工作副本, 如何用 <command>svn commit</command>
    和 <command>svn update</command> 提交和接收修改, 甚至运行
    <command>svn status</command> 已经成为了你的下意识动作. 总之, 你已经准备
    好在一个典型的应用环境中使用 Subversion.</para>

    <!--
  <para>But the Subversion feature set doesn't stop at <quote>common
    version control operations.</quote>  It has other bits of
    functionality besides just communicating file and
    directory changes to and from a central repository.</para>
    -->
  <para>但是 Subversion 远远不止 <quote>常见的版本控制操作</quote>, 除了
    和中央仓库沟通文件和目录的变化外, 它还具备很多功能.</para>

    <!--
  <para>This chapter highlights some of Subversion's features that,
    while important, may not be part of the typical user's daily routine.
    It assumes that you are familiar with Subversion's basic file and
    directory versioning capabilities.  If you aren't, you'll want to
    first read <xref linkend="svn.basic" /> and <xref
    linkend="svn.tour" />.  Once you've mastered those basics and
    consumed this chapter, you'll be a Subversion power user!</para>
    -->
  <para>本章将要介绍的 Subversion 特性, 用户在自己的日常工作中可能不会用到,
    但是却很重要. 本章假设读者已经熟悉了 Subversion 基本的文件与目录的版本
    控制功能, 如果读者还不了解这方面的内容, 先阅读
    <xref linkend="svn.basic"/> 和 <xref linkend="svn.tour"/> 这两章. 一旦
    读者消耗了本章内容, 你将会成为一位强大的 Subversion 用户.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.revs.specifiers">
    <!--
    <title>Revision Specifiers</title>
    -->
    <title>版本号指示器</title>

    <!--
    <para>As we described in <xref linkend="svn.basic.in-action.revs"
      />, revision numbers in Subversion are pretty
      straightforward&mdash;integers that keep getting larger as you
      commit more changes to your versioned data.  Still, it doesn't
      take long before you can no longer remember exactly what
      happened in each and every revision.  Fortunately, the typical
      Subversion workflow doesn't often demand that you supply
      arbitrary revisions to the Subversion operations you perform.
      For operations that <emphasis>do</emphasis> require a revision
      specifier, you generally supply a revision number that you saw
      in a commit email, in the output of some other Subversion
      operation, or in some other context that would give meaning to
      that particular number.</para>
    -->
    <para>我们已经在 <xref linkend="svn.basic.in-action.revs"/> 说过,
      Subversion 的版本号非常直观&mdash;随着提交的不断增多, 表示版本号的整数
      也不断增大, 但是用不了多久, 用户就再也记不清每个版本号包含了哪些修改.
      幸运的是, Subversion 的典型工作流程不太经常要求用户提供版本号, 对于
      那些确实需要版本号的操作而言, 用户可以从提交日志中看到所需的版本号, 或者
      使用在特定语境下可以表示特定版本号的关键字.</para>

    <note>
    <!--
      <para>Referring to revision numbers with
        an <quote><literal>r</literal></quote> prefix
        (<literal>r314</literal>, for example) is an established
        practice in Subversion communities, and is both supported and
        encouraged by many Subversion-related tools.  In most places
        where you would specify a bare revision number on the command
        line, you may also use
        the <literal>r</literal><replaceable>NNN</replaceable>
        syntax.</para>
    -->
      <para>在引用版本号时, 在数字的左边增加一个前缀
        <quote><literal>r</literal></quote> (例如 <literal>r314</literal>)
        是 Subversion 社区约定俗成的做法, 很多 Subversion 的相关工具都鼓励
        这种写法. 在需要提供裸版本号的大多数场合中, 你也可以使用
        <literal>r</literal><replaceable>NNN</replaceable> 形式的语法.</para>
    </note>

    <para>
      <indexterm>
        <primary>revisions (版本号)</primary>
        <secondary>keywords (关键字)</secondary>
      </indexterm>
    <!--
      But occasionally, you need to pinpoint a moment in
      time for which you don't already have a revision number
      memorized or handy.  So besides the integer revision numbers,
      <command>svn</command> allows as input some additional forms of
      revision specifiers: <firstterm>revision keywords</firstterm>
      and revision dates.</para>
    -->
    但是在少数情况下, 用户必须及时精确地描述出版本号, 可是手上却没有合适的参数.
    所以除了用整数指定版本号外, <command>svn</command> 还支持另外两种指定版本
    号的形式: <firstterm>版本号关键字</firstterm>
    (<firstterm>revision keywords</firstterm>) 和版本号日期.</para>

    <note>
    <!--
      <para>The various forms of Subversion revision specifiers can be
        mixed and matched when used to specify revision ranges.  For
        example, you can use <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        where <replaceable>REV1</replaceable> is a revision keyword
        and <replaceable>REV2</replaceable> is a revision number, or
        where <replaceable>REV1</replaceable> is a date and
        <replaceable>REV2</replaceable> is a revision keyword, and so
        on.  The individual revision specifiers are independently
        evaluated, so you can put whatever you want on the opposite
        sides of that colon.</para>
    -->
      <para>在指定版本号范围时, 可以混合使用不同形式的版本号指示器, 例如你可
        以把 <option>-r<replaceable>REV1</replaceable>:<replaceable>REV2
        </replaceable></option> 中的 <replaceable>REV1</replaceable> 写成
        版本号关键字, 把 <replaceable>REV2</replaceable> 写成整数, 或者把
        <replaceable>REV1</replaceable> 写成日期, 把 <replaceable>REV2
        </replaceable> 写成版本号关键字, 如此等等. 每个版本号指示器被单独求值,
        所以你可以把任意形式的版本号指示器放在冒号的两边.</para>
    </note>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.keywords">
    <!--
      <title>Revision Keywords</title>
    -->
      <title>版本号关键字</title>
       
      <indexterm>
        <primary>revisions (版本号)</primary>
        <secondary>keywords (关键字)</secondary>
      </indexterm>

    <!--
      <para>The Subversion client understands a number of revision
        keywords.  These keywords can be used instead of integer
        arguments to the <option>- -revision</option>
        (<option>-r</option>) option, and are resolved into specific
        revision numbers by Subversion:</para>
    -->
      <para>Subversion 支持理解的版本号关键字有很多个, 可以用这些关键字替换
        选项 <option>--revision</option> (<option>-r</option>) 后面的整数,
        这些关键字会被 Subversion 解释成特定的版本号:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>HEAD</literal></term>
          <listitem>
            <indexterm>
              <primary>HEAD</primary>
            </indexterm>
            <indexterm>
              <primary>revisions (版本号)</primary>
              <secondary>keywords (关键字)</secondary>
              <tertiary>HEAD</tertiary>
            </indexterm>
    <!--
            <para>The latest (or <quote>youngest</quote>) revision in
              the repository.</para>
    -->
            <para>仓库中最近的 (或最年轻的) 版本号.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>BASE</literal></term>
          <listitem>
            <indexterm>
              <primary>BASE</primary>
            </indexterm>
            <indexterm>
              <primary>revisions (版本号)</primary>
              <secondary>keywords (关键字)</secondary>
              <tertiary>BASE</tertiary>
            </indexterm>
    <!--
            <para>The revision number of an item in a working copy.
              If the item has been locally modified, this refers to
              the way the item appears without those local
              modifications.</para>
    -->
            <para>工作副本中的某一项目的版本号, 如果该项在本地被修改了, 则该
              版本号引用的是修改前的项目.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>COMMITTED</literal></term>
          <listitem>
            <indexterm>
              <primary>COMMITTED</primary>
            </indexterm>
            <indexterm>
              <primary>revisions (版本号)</primary>
              <secondary>keywords (关键字)</secondary>
              <tertiary>COMMITTED</tertiary>
            </indexterm>
    <!--
            <para>The most recent revision prior to, or equal to,
              <literal>BASE</literal>, in which an item changed.</para>
    -->
            <para>等于或早于 <literal>BASE</literal> 并且离它最近的一个版本号,
              在该版本号中项目被修改了.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>PREV</literal></term>
          <listitem>
            <indexterm>
              <primary>PREV</primary>
            </indexterm>
            <indexterm>
              <primary>revisions (版本号)</primary>
              <secondary>keywords (关键字)</secondary>
              <tertiary>PREV</tertiary>
            </indexterm>
    <!--
            <para>The revision immediately <emphasis>before</emphasis>
              the last revision in which an item changed.
              Technically, this boils down to
              <literal>COMMITTED</literal>-1.</para>
    -->
          <para>项目最后一次被修改时的版本号的前一个版本号, 从技术上讲它
          就是 <literal>COMMITTED</literal>-1.</para>
          </listitem>
        </varlistentry>
        
      </variablelist>

    <!--
      <para>As can be derived from their descriptions, the
        <literal>PREV</literal>, <literal>BASE</literal>, and
        <literal>COMMITTED</literal> revision keywords are used only
        when referring to a working copy path&mdash;they don't apply
        to repository URLs.  <literal>HEAD</literal>, on the other
        hand, can be used in conjunction with both of these path
        types.</para>
    -->
      <para>从它们的描述可以看出, <literal>PREV</literal>,
        <literal>BASE</literal> 和 <literal>COMMITTED</literal> 只能引用工作
        副本中的路径, 而 <literal>HEAD</literal> 既可以引用工作副本中的路径,
        也可以引用仓库的 URL.</para>
      
    <!--
      <para>Here are some examples of revision keywords in
        action:</para>
    -->
      <para>下面是一些版本号关键字的使用示例:</para>
      
      <informalexample>
        <screen>
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working copy (with all of its local changes) to the
# latest version of that tree in the repository

$ svn diff -r BASE:HEAD foo.c
# compares the unmodified version of foo.c with the latest version of
# foo.c in the repository

$ svn log -r BASE:HEAD
# shows all commit logs for the current versioned directory since you
# last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c, decreasing foo.c's working revision

$ svn diff -r BASE:14 foo.c
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14
</screen>
      </informalexample>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.dates">
    <!--
      <title>Revision Dates</title>
    -->
      <title>版本号日期</title>
      
      <indexterm>
        <primary>revisions (版本号)</primary>
        <secondary>as dates (日期)</secondary>
      </indexterm>

    <!--
      <para>Revision numbers reveal nothing about the world outside
        the version control system, but sometimes you need to
        correlate a moment in real time with a moment in version
        history.  To facilitate this, the <option>- -revision</option>
        (<option>-r</option>) option can also accept as input date
        specifiers wrapped in curly braces (<literal>{</literal> and
        <literal>}</literal>).  Subversion accepts the standard
        ISO-8601 date and time formats, plus a few others.  Here are
        some examples.</para>
    -->
      <para>版本号没有透露出一丝一毫与版本控制系统外部世界相关的信息, 但是有
        时候你需要把真实世界的时间与版本控制历史的时间联系起来. 为此, 选项
        <option>--revision</option> (<option>-r</option>) 也接受日期形式的
        参数, 日期用一对花括号 (<literal>{</literal> 和 <literal>}</literal>)
        包裹起来, Subversion 接受标准的 ISO-8601 格式的日期与时间, 以及其他
        一些形式, 下面是一些例子.</para>

      <informalexample>
        <screen>
$ svn update -r {2006-02-17}
$ svn update -r {15:30}
$ svn update -r {15:30:00.200000}
$ svn update -r {"2006-02-17 15:30"}
$ svn update -r {"2006-02-17 15:30 +0230"}
$ svn update -r {2006-02-17T15:30}
$ svn update -r {2006-02-17T15:30Z}
$ svn update -r {2006-02-17T15:30-04:00}
$ svn update -r {20060217T1530}
$ svn update -r {20060217T1530Z}
$ svn update -r {20060217T1530-0500}
&hellip;
</screen>
      </informalexample>

      <note>
    <!--
        <para>Keep in mind that most shells will require you to, at a
          minimum, quote or otherwise escape any spaces that are
          included as part of revision date specifiers.  Certain
          shells may also take issue with the unescaped use of curly
          braces, too.  Consult your shell's documentation for the
          requirements specific to your environment.</para>
    -->
        <para>如果版本号日期参数中含有空格, 那么大多数 shell 都会要求用引号
          包围参数, 或者对参数中的空格进行转义, 某些 shell 可能还会要求对花
          括号进行转义, 具体的细节可以查阅你所用的 shell 的文档.</para>
      </note>
    
    <!--
      <para>When you specify a date, Subversion resolves that date to
        the most recent revision of the repository as of that date,
        and then continues to operate against that resolved revision
        number:</para>
    -->
      <para>如果用户指定了一个日期, Subversion 就把该日期解析成最近的版本号,
        然后再针对该版本号进行操作:</para>
        
      <informalexample>
        <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
&hellip;
</screen>
      </informalexample>
        
      <sidebar>
    <!--
        <title>Is Subversion a Day Early?</title>
    -->
        <title>是 Subversion 早了一天吗</title>
        
    <!--
        <para>If you specify a single date as a revision without
          specifying a time of day (for example
          <literal>2006-11-27</literal>), you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <emphasis>most recent revision of the
          repository</emphasis> as of the date you give.  If you give
          a date without a timestamp, such as
          <literal>2006-11-27</literal>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the 27th.</para>
    -->
        <para>如果用户指定了一个日期作为版本号, 但没有指定一天中的时间 (例如
          <literal>2006-11-27</literal>), 你可能希望 Subversion 得到的是
          11 月 27 号这一天的最后一个版本号, 可事实上是 Subversion 得到的是
          26 号或者更早的版本号. 记住 Subversion 要找的是离那天 <emphasis>最近
            的仓库的版本号</emphasis>, 如果没有指定时间, 例如
            <literal>2006-11-27</literal>, Subversion 默认时间是
            <literal>00:00:00</literal>, 所以不会出现 27 号那天的版本号.</para>

    <!--
        <para>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<literal>{"2006-11-27
          23:59"}</literal>), or just specify the next day
          (<literal>{2006-11-28}</literal>).</para>
    -->
        <para>如果你希望 27 号的版本号也在搜索的范围里, 那就在参数中指定时间
          (<literal>{"2006-11-27 23:59"}</literal>), 或者干脆指定后一天
          (<literal>{2006-11-28}</literal>).</para>
        
      </sidebar>
      
    <!--
      <para>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</para>
    -->
      <para>还可以指定一段日期范围, 此时 Subversion 会找到这段时间内的所有
        版本号, 包括开始日期和结束日期:</para>
      
      <informalexample>
        <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
&hellip;
</screen>
      </informalexample>
        
      <warning>
    <!--
        <para>Subversion's ability to correctly convert revision dates
          into real revision numbers depends on revision datestamps
          maintaining a sequential ordering&mdash;the younger the
          revision, the younger its datestamp.  But datestamps are
          stored in the unversioned, modifiable
          <literal>svn:date</literal> property of the revision (see
          <xref linkend="svn.advanced.props" />), so it is possible
          for revision datestamps to get out of sequence.  Now, most
          of Subversion's operations are unaffected by this
          situation&mdash;after all, the revision number itself is the
          primary identifier of each revision.  But if the datestamp
          ordering isn't maintained, you will likely find that trying
          to use dates to specify revision ranges in your repository
          doesn't always return the data you might have expected.
          Combining the histories of multiple repositories into a
          single one (as described in
          <xref linkend="svn.reposadmin.maint.migrate" />) is the most
          common cause of this scenario.</para>
    -->
    <para>Subversion 能够根据版本号日期得到版本号是因为版本号的时间戳被维护
      成一个串行化的序列&mdash;版本号越年轻, 时间戳也就越年轻. 但是时间戳
      是存放在版本号的 <literal>svn:date</literal> 属性内 (见
      <xref linkend="svn.advanced.props"/>), 而该属性是可修改的, 且未被纳
      入版本管理, 所以说打乱版本号的时间戳是有可能的. 如果时间戳被打乱了,
      大多数操作都不会受到影响, 毕竟它们都是使用版本号的整数编号作为版本
      号的标识, 但是当你用日期指定版本号范围时, Subversion 返回的数据很可
      能不是你所想要的. 导致版本号时间戳不再有序的常见操作是把多个仓库的
      历史组合成单独的一个.</para>
      </warning>
        
    </sect2>
      
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
    <!--
    <title>Peg and Operative Revisions</title>
    -->
    <title>限定版本号与实施版本号</title>

    <!--
    <para>We copy, move, rename, and completely replace files and
      directories on our computers all the time.  And your version
      control system shouldn't get in the way of your doing these
      things with your version-controlled files and directories,
      either.  Subversion's file management support is quite
      liberating, affording almost as much flexibility for versioned
      files as you'd expect when manipulating your unversioned ones.
      But that flexibility means that across the lifetime of your
      repository, a given versioned object might have many paths, and
      a given path might represent several entirely different
      versioned objects.  This introduces a certain level of
      complexity to your interactions with those paths and
      objects.</para>
    -->
    <para>我们经常在自己的系统中对文件和目录进行复制, 移动, 重命名和替换,
      但是版本控制系统不能按照相同的方式操作它所管理的文件与目录. Subversion
      的文件管理非常灵活, 几乎和操作未版本化的文化一样灵活.
      但是这种灵活性也意味着在仓库的生命周期中, 一个版本
      控制对象可能会有多个路径, 而一个路径在不同时间可能表示完全不同的版本控制
      对象, 当用户同这些路径与对象交互时会产生一定的复杂度.</para>

    <!--
    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address.</quote>
      For example, if you ask for the revision history log of a
      particular file that was renamed last week, Subversion happily
      provides all those logs&mdash;the revision in which the rename
      itself happened, plus the logs of relevant revisions both before
      and after that rename.  So, most of the time, you don't even
      have to think about such things.  But occasionally, Subversion
      needs your help to clear up ambiguities.</para>
    -->
    <para>如果对象的版本历史里包含了 "地址上的变化", Subversion 自己就会注意
      到这点. 比如说用户要求查看上周被重命名的一个文件的版本历史, Subversion
      会提供全部的相关日志&mdash;重命名发生时版本号, 再加上重命名前与重命名后
      的相关版本号. 所以说在大部分情况下, 用户都不需要考虑对象的地址变化可能
      带来的影响, 但是在少数情况下, Subversion 需要你的帮助来消除歧义.</para>

    <!--
    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      The thing you deleted and the thing you later added aren't the
      same thing.  They merely happen to have had the same
      path&mdash;<filename>/trunk/object</filename>, for example.
      What, then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to <emphasis>all</emphasis> the objects that have
      ever lived at that path?  Subversion needs a hint about what you
      really want.</para>
    -->
    <para>最简单的一种场景是一个文件或目录从仓库中被删除后, 又有一个同名的
      文件或目录被添加到仓库中, 被删除的对象和新增的对象之间毫无关系, 只是
      碰巧路径相同, 假设都是 <filename>/trunk/object</filename>, 那么向
      Subversion 询问 <filename>/trunk/object</filename> 的历史是表示什么
      意思? 是在问当前对象的历史, 还是那个被删除的对象的历史? 或者是在问
      该路径上存在过的 <emphasis>所有</emphasis> 对象的操作历史? 为了得到
      自己想要的信息, Subversion 需要一些提示.</para>

    <!--
    <para>And thanks to moves, versioned object history can get far
      more twisted than even that.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.<footnote><para><quote>You're not
      supposed to name it.  Once you name it, you start getting
      attached to it.</quote>&mdash;Mike Wazowski</para></footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
    -->
    <para>由于移动操作, 对象的历史变得更加复杂. 比如说你有一个目录叫作
      <filename>concept</filename>, 它包含了几个初期的软件项目. 慢慢地,
      软件开始成型, 你开始考虑为项目取一个名字<footnote><para><quote>
            You're not supposed to name it. Once you name it, you start
            getting attached to it.</quote>&mdash;Mike Wazowski</para>
      </footnote>. 假设你要取的软件名字是 Frabnaggilywort, 把目录重命名成
      软件的名字是很合理的操作, 于是 <filename>concept</filename> 被重命名
      为 <filename>frabnaggilywort</filename>. 项目接着进行, Frabnaggilywort
      发布了 1.0 版, 很多用户都下载了并在日常工作中使用它.</para>
    
    <!--
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>
    -->
    <para>故事听起来还不错, 但是还没结束. 企业家的脑子里经常会有新想法出现,
      于是你又创建了一个新目录 <filename>concept</filename>, 循环再次开始.
      实际上, 在几年内循环会重复进行多次, 每一次都以创建
      <filename>concept</filename> 开始, 如果想法逐渐地明朗起来,
      <filename>concept</filename> 很可能会被重新命名; 如果想法被否定了,
      <filename>concept</filename> 就会被删除. 更有甚者, 用户还有可能把
      <filename>concept</filename> 改名一段时间后, 又改回到
      <filename>concept</filename>.</para>

    <!--
    <para>In scenarios like these, attempting to instruct
      Subversion to work with these reused paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      20 minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist&mdash;and our Subversion&mdash;need a
      little more detail to do the right thing.</para>
    -->
    <para>在这种场景下, 指挥 Subversion 操作这些重复使用的路径就好像在指挥
      一个摩托车手, 从芝加哥的 West Suburbs 向东行驶到 Roosevelt Road, 再向
      左驶入主街. 在短短的 20 分钟里, 你会穿过 Wheaton, Glen Ellyn 和
      Lombard 的 <quote>主街</quote>, 但它们并非是同一个地方, 我们的
      摩托车手&mdash;也就是 Subversion&mdash;需要更多的细节才能把事情做对.
    </para>

    <para>
      <indexterm>
        <primary>revisions (版本号)</primary>
        <secondary>peg revisions (限定版本号)</secondary>
      </indexterm>
      <indexterm>
        <primary>at syntax (at 语法)</primary>
      </indexterm>
      <indexterm>
        <primary>@</primary>
        <see>at syntax (at 语法)</see>
      </indexterm>
    <!--
      Fortunately, Subversion allows you to tell it
      exactly which Main Street you meant.  The mechanism used is
      called a <firstterm>peg revision</firstterm>, and you provide
      these to Subversion for the sole purpose of identifying unique
      lines of history.  Because at most one versioned object may
      occupy a path at any given time&mdash;or, more precisely, in any
      one revision&mdash;the combination of a path and a peg revision
      is all that is needed to unambiguously identify a specific line
      of history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>
    -->
    幸运的是, Subversion 允许用户精确地指定他想去的是哪一个主街, 其中
    用到的特性是 <firstterm>限定版本号</firstterm>
    (<firstterm>peg revision</firstterm>), 它的目的是确定一条唯一的历史线.
    因为在任意一个给定的时刻 (或者说给定的版本号) 一条路径上至多只能有一个版
    本控制对象, 所以说结合使用路径与限定版本号就可以明确地识别一条特定的
    历史线. 限定版本号使用 <firstterm>at 语法</firstterm>
    (<firstterm>at syntax</firstterm>) 在 Subversion 的命令行客户端工具上
    指定, 之所以叫作 <quote>at 语法</quote> 是因为指定版本号的方式是在路径
    的末尾加上符号 <literal>@</literal>, 然后再写上版本号.</para>

    <para>
      <indexterm>
        <primary>revisions (版本号)</primary>
        <secondary>operative revisions (实施版本号)</secondary>
      </indexterm>
      <indexterm>
        <primary>revisions (版本号)</primary>
        <secondary>operative revision range (实施版本号范围)</secondary>
      </indexterm>
    <!--
      But what of the <option>- -revision</option>
      (<option>-r</option>) of which we've spoken so much in this
      book?  That revision (or set of revisions) is called the
      <firstterm>operative revision</firstterm> (or
      <firstterm>operative revision range</firstterm>).  Once a
      particular line of history has been identified using a path and
      peg revision, Subversion performs the requested operation using
      the operative revision(s).  To map this to our Chicagoland
      streets analogy, if we are told to go to 606 N. Main Street in
      Wheaton,<footnote><para>606 N. Main Street, Wheaton, Illinois,
      is the home of the Wheaton <emphasis>History</emphasis> Center.
      It seemed appropriate&hellip;</para></footnote> we can think
      of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path that can be traveled (north or
      south on Main Street), and they keep us from traveling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>
    -->
    但是本书多次提到的 <option>--revision</option> (<option>-r</option>) 到底
    是什么? 这个版本号或版本号集合叫作 <firstterm>实施版本号</firstterm>
    (<firstterm>operative revision</firstterm>) 或
    <firstterm>实施版本号范围</firstterm> (<firstterm>operative revision range
    </firstterm>). 一旦用路径和限定版本号确定一条特定的历史线, Subversion 就
    对实施版本号执行用户请求的操作. 用芝加哥的道路进行类比, 如果我们要去
    Wheaton 的 606 N. 主街<footnote><para>把 606 N. 主街作为
        Wheaton 的历史中心应该是比较恰当的.</para></footnote>, 可以把
    <quote>主街</quote> 看成路径, 把 <quote>Wheaton</quote> 看成限定
    版本号, 这两项信息确定了一条唯一的路径, 避免我们走弯路. 现在我们把
    <quote>606 N.</quote> 作为实施版本号, 最终我们得到了一个精确的目的地.
  </para>

    <sidebar id="svn.advanced.pegrevs.algorithm">
    <!--
      <title>The Peg Revision Algorithm</title>
    -->
      <title>限定版本号算法</title>
      
    <!--
      <para>The Subversion command-line client performs the peg revision
        algorithm any time it needs to resolve possible ambiguities in
        the paths and revisions provided to it.  Here's an example of
        such an invocation:</para>
    -->
      <para>提供给客户端命令行工具的路径和版本号参数如果可能含有歧义,
        Subversion 就会运行限定版本号算法来消除歧义, 下面是一个说明用的
        示例:</para>

      <informalexample>
        <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>
</screen>
      </informalexample>
      
    <!--
      <para>If <replaceable>OPERATIVE-REV</replaceable> is older than
        <replaceable>PEG-REV</replaceable>, the algorithm is as
        follows:</para>
    -->
      <para>如果 <replaceable>OPERATIVE-REV</replaceable> 比 <replaceable>
          PEG-REV</replaceable> 老, 算法的执行过程是:</para>

      <orderedlist>
        <listitem>
    <!--
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>PEG-REV</replaceable>.  There
            can be only one such object.</para>
    -->
          <para>定位由版本号 <replaceable>PEG-REV</replaceable> 识别的
            <replaceable>item</replaceable>, 有且仅有一个对象.</para>
        </listitem>
        <listitem>
    <!--
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in the revision
            <replaceable>OPERATIVE-REV</replaceable>.</para>
    -->
          <para>反向追踪对象的历史 (还要考虑重命名操作带来的影响), 直到版本号
            <replaceable>OPERATIVE-REV</replaceable> 里的祖先.</para>
        </listitem>
        <listitem>
    <!--
          <para>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be or might have been at that time.</para>
    -->
          <para>对祖先执行用户所请求的操作, 无论当时这个祖先位于何处, 叫什么
            名字.</para>
        </listitem>
      </orderedlist>

    <!--
      <para>But what if <replaceable>OPERATIVE-REV</replaceable> is
        <emphasis>younger</emphasis> than
        <replaceable>PEG-REV</replaceable>?  Well, that adds some
        complexity to the theoretical problem of locating the path in
        <replaceable>OPERATIVE-REV</replaceable>, because the path's
        history could have forked multiple times (thanks to copy
        operations) between <replaceable>PEG-REV</replaceable> and
        <replaceable>OPERATIVE-REV</replaceable>.  And that's not
        all&mdash;Subversion doesn't store enough information to
        performantly trace an object's history forward, anyway.  So
        the algorithm is a little different:</para>
    -->
      <para>但是如果 <replaceable>OPERATIVE-REV</replaceable> 比 <replaceable>
          PEG-REV</replaceable> <emphasis>年轻</emphasis> 的话又会如何?
        这会给定位 <replaceable>OPERATIVE-REV</replaceable> 中的路径的理论
        问题增加一些复杂度, 因为在 <replaceable>PEG-REV</replaceable> 和
        <replaceable>OPERATIVE-REV</replaceable> 之间, 路径的历史可能会多
        次发生分叉 (由于复制操作). 不仅如此, Subversion 不会为了高效地正向
        追踪对象的历史而记录足够多的信息. 所以在这种情况下的算法会有一些差别:
      </para>

      <orderedlist>
        <listitem>
    <!--
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>OPERATIVE-REV</replaceable>.  There
            can be only one such object.</para>
    -->
          <para>定位由版本号 <replaceable>OPERATIVE-REV</replaceable> 识别的
            <replaceable>item</replaceable>, 有且仅有一个对象.</para>
        </listitem>
        <listitem>
    <!--
          <para>Trace the object's history backward (through any
            possible renames) to its ancestor in the revision
            <replaceable>PEG-REV</replaceable>.</para>
    -->
          <para>反向追踪对象的历史 (还要考虑重命名操作带来的影响), 直到版本号
            <replaceable>PEG-REV</replaceable> 里的祖先.</para>
        </listitem>
        <listitem>
    <!--
          <para>Verify that the object's location (path-wise) in
            <replaceable>PEG-REV</replaceable> is the same as it is in
            <replaceable>OPERATIVE-REV</replaceable>.  If that's the
            case, at least the two locations are known to be
            directly related, so perform the requested action on the
            location in <replaceable>OPERATIVE-REV</replaceable>.
            Otherwise, relatedness was not established, so error out
            with a loud complaint that no viable location was found.
            (Someday, we expect that Subversion will be able to handle
            this usage scenario with more flexibility and
            grace.)</para>
    -->
          <para>检查对象在 <replaceable>PEG-REV</replaceable> 和 <replaceable>
              OPERATIVE-REV</replaceable> 中的位置 (路径) 是否相同, 如果是,
            说明至少这两个位置是直接相关的, 那就在 <replaceable>OPERATIVE-REV
            </replaceable> 的位置上执行用户所请求的操作. 否则的话相关性无法
            建立, 输出错误信息, 表示无法找到可用的路径 (也许某一天 Subversion
            对这种情况会处理得更加灵活与优雅).</para>
        </listitem>
      </orderedlist>

    <!--
      <para>Note that even when you don't explicitly supply a peg
        revision or operative revision, they are still present.  For
        your convenience, the default peg revision is
        <literal>BASE</literal> for working copy items and
        <literal>HEAD</literal> for repository URLs.  And when no
        operative revision is provided, it defaults to being the same
        revision as the peg revision.</para>
    -->
      <para>注意, 即使用户没有显式地给出限定版本号或实施版本号, 它们仍然存在.
        为了方便用户, 工作副本里的项目的限定版本号默认是 <literal>BASE
        </literal>, 仓库 URL 默认是 <literal>HEAD</literal>. 如果没有显式
        指定实施版本号, 则默认与限定版本号相同.</para>
        
    </sidebar>

    <!--
    <para>Say that long ago we created our repository, and in revision 1
      we added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and thousands of revisions flew by,
      just like they would in any good romance story.</para>
    -->
    <para>比如说用户在很久以前就创建了仓库, 在版本号 1 添加了第一个目录
      <filename>concept</filename>, 用户后来在目录里放了一个介绍概念的文件
      <filename>IDEA</filename>. 几次提交后, 项目的代码逐渐成型, 在版本号
      20 用户把 <filename>concept</filename> 重命名为 <filename>frabnaggilywort
      </filename>. 在版本号 27, 用户又有了一个新主意, 所以在项目根目录下又
      创建了目录 <filename>concept</filename>, 里面也放了一个描述概念的文件
      <filename>IDEA</filename>. 然后又过了 5 年, 期间提交了几千次修改.</para>

    <!--
    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know whether we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      whether we are asking for the contents of whatever file lived at
      <filename>concept/IDEA</filename> in revision 1.  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask those questions.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>
    -->
    <para>几年后, 用户想知道文件 <filename>IDEA</filename> 在版本号 1 中是什么
      样子, 但是 Subversion 需要知道用户是在询问 <emphasis>当前</emphasis> 文件
      在版本号 1 时的内容, 还是在问版本号 1 中文件 <filename>concept/IDEA
      </filename> 的内容. 当然这两个问题的答案是不一样的, 利用限定版本号, 用户
      就可以向 Subversion 说明他想问的是哪一个问题. 为了确定当前的
      <filename>IDEA</filename> 在版本号 1 时的内容, 用户执行了:</para>

    <informalexample>
      <screen>
$ svn cat -r 1 concept/IDEA 
svn: E195012: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>
    </informalexample>

    <!--
    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The previous command is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>
    -->
    <para>当然, 在这个例子里, 当前的文件 <filename>IDEA</filename> 在版本号 1
      时并不存在, 于是 Subversion 报了一个错误. 上面的命令实际上是以下显式
      指定持勾版本号命令的简写形式:</para>

    <informalexample>
      <screen>
$ svn cat -r 1 concept/IDEA@BASE
svn: E195012: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>
    </informalexample>

    <!--
    <para>And when executed, it has the expected results.</para>
    -->
    <para>命令的执行结果是预料之中的.</para>

    <!--
    <para>The perceptive reader is probably wondering at this point whether
      the peg revision syntax causes problems for working copy paths
      or URLs that actually have at signs in them.  After
      all, how does <command>svn</command> know whether
      <literal>news@11</literal> is the name of a directory in my
      tree or just a syntax for <quote>revision 11 of
      <filename>news</filename></quote>?  Thankfully, while
      <command>svn</command> will always assume the latter, there is a
      trivial workaround.  You need only append an at sign to the
      end of the path, such as <literal>news@11@</literal>.
      <command>svn</command> cares only about the last at sign in
      the argument, and it is not considered illegal to omit a literal
      peg revision specifier after that at sign.  This workaround
      even applies to paths that end in an at sign&mdash;you would
      use <literal>filename@@</literal> to talk about a file named
      <filename>filename@</filename>.</para>
    -->
    <para>敏锐的读者可能想知道是否是限定版本号的语法导致了问题, 因为工作副本
      路径或 URL 本身可能就带有符号 <literal>@</literal>, 毕竟 <command>svn
      </command> 怎么知道 <literal>news@11</literal> 是表示一个目录的普通名字,
      还是表示 <quote><filename>news</filename> 的版本号 11</quote>? 谢天谢地,
      <filename>svn</filename> 总是当成后一种情况, 方法是在路径的末尾添加一
      个 <literal>@</literal> 符号, 例如 <literal>news@11@</literal>.
      <command>svn</command> 只关心参数中的最后一个 <literal>@</literal>,
      即使省略了 <literal>@</literal> 后面的版本号也是合法的. 这个方法也适用
      于以 <literal>@</literal> 结尾的路径&mdash;你可以用 <literal>filename@@
    </literal> 表示一个名为 <literal>filename@</literal> 的文件.</para>

    <!--
    <para>Let's ask the other question, then&mdash;in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>
    -->
    <para>再考虑另一个问题&mdash;在版本号 1 中, 占用路径
      <filename>concept/IDEA</filename> 的文件的内容是什么? 我们可以用一个
      带有显式限定版本号的命令来回答这个问题.</para>

    <informalexample>
      <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>
    </informalexample>

    <!--
    <para>Notice that we didn't provide an operative revision this
      time.  That's because when no operative revision is specified,
      Subversion assumes a default operative revision that's the same
      as the peg revision.</para>
    -->
    <para>注意在上面的命令中我们并没有提供实施版本号, 这是因为如果没有指定
      实施版本号, Subversion 默认使用限定版本号作为实施版本号.</para>

    <!--
    <para>As you can see, the output from our operation appears to be
      correct.  The text even mentions frabbing naggily worts, so this
      is almost certainly the file that describes the software now
      called Frabnaggilywort.  In fact, we can verify this using the
      combination of an explicit peg revision and explicit operative
      revision.  We know that in <literal>HEAD</literal>, the
      Frabnaggilywort project is located in the
      <filename>frabnaggilywort</filename> directory.  So we specify
      that we want to see how the line of history identified in
      <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>
    -->
    <para>命令的执行结果看来是正确的, 输出的文本甚至提到了 <quote>frab a
        naggily wort</quote>, 所以它描述的软件应该就是现在的 Frabnaggilywort,
      实际上我们还可以通过组合显式的限定版本号和显式的实施版本号来验证这一点.
      我们已经知道在 <literal>HEAD</literal> 里, 项目 Frabnaggilywort 位于目录
      <filename>frabnaggilywort</filename>, 于是我们希望看到 <literal>HEAD
    </literal> 的 <filename>frabnaggilywort/IDEA</filename> 在版本号 1 中
    的内容.</para>

    <informalexample>
      <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>
    </informalexample>

    <!--
    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had been deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>
    -->
    <para>限定版本号和实施版本号也不需要如此琐碎, 举例来说, <filename>
        frabnaggilywort</filename> 已经从 <literal>HEAD</literal> 删除,
      但是我们知道它在版本号 20 时还是存在的, 而且我们想知道其中存放的
      <filename>IDEA</filename> 在版本号 4 和版本号 10 之间的差异, 可以使用
      限定版本号 20, 结合上文件 <filename>IDEA</filename> 的版本号 20 的 URL,
      然后使用 4 和 10 作为实施版本号范围.</para>

    <informalexample>
      <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>
    </informalexample>

    <!--
    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>
    -->
    <para>幸运的是, 大多数人都不会碰到哪些复杂的情况, 但是如果遇到了, 记住
      限定版本号可以帮助 Subversion 消除歧义.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
    <!--
    <title>Properties</title>
    -->
    <title>属性</title>

    <!--
    <para>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.</para>
    -->
    <para>我们已经详细地描述了 Subversion 如何存放和检索存放在仓库中的不同
      版本的文件和目录, 介绍这些最基本的功能用了一整章的篇幅. 如果 Subversion
      对版本控制的支持就到此为止, 从版本控制的角度来看它的功能已经很完整了.
    </para>

    <!--
    <para>But it doesn't stop there.</para>
    -->
    <para>但 Subversion 并没有停下脚步.</para>

    <para>
      <indexterm>
        <primary>properties (属性)</primary>
      </indexterm>
    <!--
      In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <firstterm>properties</firstterm>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must contain only
      ASCII characters.  And the best part about these properties is
      that they, too, are versioned, just like the textual contents of
      your files.  You can modify, commit, and revert property changes
      as easily as you can file content changes.  And the sending and
      receiving of property changes occurs as part of your typical
      commit and update operations&mdash;you don't have to change your
      basic processes to accommodate them.</para>
    -->
    作为目录和文件版本控制的补充, Subversion 提供了为每一个文件和目录添加, 修
    改和删除版本化元数据的接口. 我们把这些元数据称为 <firstterm>属性</firstterm>
    (<firstterm>properties</firstterm>), 属性可看作是一张两列的表格, 附加到
    工作副本的每个项目上, 表格把属性的名字映射到任意值. 一般来说, 属性的名字
    和值可以是任意的, 唯一的要求是属性名只能使用 ASCII 字符. 属性最好的地方
    是它们也是被版本控制的对象, 就像文件的内容那样, 用户可以修改, 提交和撤销
    属性的修改. 用户执行提交和更新操作时, 属性的修改也会被发送和接收&mdash;
    用户的工作流程不会因为属性的加入而发生变化.</para>

    <note>
    <!--
      <para>Subversion has reserved the set of properties whose names
        begin with <literal>svn:</literal> as its own.  While there
        are only a handful of such properties in use today, you should
        avoid creating custom properties for your own needs whose names
        begin with this prefix.  Otherwise, you run the risk that a
        future release of Subversion will grow support for a feature
        or behavior driven by a property of the same name but with
        perhaps an entirely different interpretation.</para>
    -->
      <para>Subversion 保留了一组名字以 <literal>svn:</literal> 开始的属性,
        所以你在创建自己的属性时应该避免使用以 <literal>svn:</literal> 开始
        的名字, 否则的话, 未来 Subversion 的新版本可能会采用同名的属性来
        支持新特性, 而属性的含义可能与你创建时的完全不同.</para>
    </note>

    <!--
    <para>Properties show up elsewhere in Subversion, too.  Just as
      files and directories may have arbitrary property names and
      values attached to them, each revision as a whole may have
      arbitrary properties attached to it.  The same constraints
      apply&mdash;human-readable names and anything-you-want binary
      values.  The main difference is that revision properties are not
      versioned.  In other words, if you change the value of, or
      delete, a revision property, there's no way, within the scope of
      Subversion's functionality, to recover the previous value.</para>
    -->
    <para>除了文件和目录, 属性还可以出现在其他地方, 每一个版本号都是一个实体,
      可以在它上面附加任意的属性, 唯一的要求是属性名只能使用 ASCII 字符.
      同文件和目录的属性相比, 最大的不同是版本号的属性不会被版本控制, 也就是
      说如果版本号的属性被删除或修改了, Subversion 没有能力恢复以前的值.</para>

    <!--
    <para>Subversion has no particular policy regarding the use of
      properties.  It asks only that you do not use property names that
      begin with the prefix <literal>svn:</literal> as that's the
      namespace that it sets aside for its own use.  And Subversion
      does, in fact, use properties&mdash;both the versioned and
      unversioned variety.  Certain versioned properties have special
      meaning or effects when found on files and directories, or they
      house a particular bit of information about the revisions on
      which they are found.  Certain revision properties are
      automatically attached to revisions by Subversion's commit
      process, and they carry information about the revision.  Most of
      these properties are mentioned elsewhere in this or other
      chapters as part of the more general topics to which they are
      related.  For an exhaustive list of Subversion's predefined
      properties, see <xref linkend="svn.advanced.props.ref" />.</para>
    -->
    <para>关于属性的使用, Subversion 并没有很特别的策略, 唯一的要求是用户不
      要使用以 <literal>svn:</literal> 开始的属性名, 这是保留给 Subversion
      使用的名字空间, Subversion 使用的属性包括版本化的和未版本化的. 文件和
      目录上特定的版本化属性具有特殊的意义或效果, 或提供了版本号的一些信息.
      在提交时, 特定的版本号属性被自动地附加到版本号上, 属性包含了与版本号
      有关的信息. 大多数属性会在谈到相关的主题时再介绍, Subversion 的预定义
      属性的完整列表见 <xref linkend="svn.advanced.props.ref"/>.</para>

    <note>
    <!--
      <para>While Subversion automatically attaches properties
        (<literal>svn:date</literal>, <literal>svn:author</literal>,
        <literal>svn:log</literal>, and so on) to revisions, it does
        <emphasis>not</emphasis> presume thereafter the existence of
        those properties, and neither should you or the tools you use to
        interact with your repository.  Revision properties can be
        deleted programmatically or via the client (if allowed by the
        repository hooks) without damaging Subversion's ability to
        function.  So, when writing scripts which operate on your
        Subversion repository data, do not make the mistake of
        assuming that any particular revision property exists on a
        revision.</para>
    -->
      <para>虽然 Subversion 自动地把属性 (<literal>svn:date</literal>,
        <literal>svn:author</literal>, <literal>svn:log</literal> 等) 附加到
        版本号, 但它并 <emphasis>不</emphasis> 假设在这之后这些属性仍然存在,
        用户及其使用的工具也应如此. 版本号的属性可以通过 API 或客户端工具删除
        (如果仓库的钩子允许), 删除后并不影响 Subversion 的正常功能. 所以在
        编写与 Subversion 仓库交互的脚本时, 不能假定任意版本号的属性是存在的.
      </para>
    </note>

    <!--
    <para>In this section, we will examine the utility&mdash;both to
      users of Subversion and to Subversion itself&mdash;of property
      support.  You'll learn about the property-related
      <command>svn</command> subcommands and how property
      modifications affect your normal Subversion workflow.</para>
    -->
    <para>本节将检验 <command>svn</command>&mdash;不仅是对 Subversion 用户,
      也对 Subversion 自身&mdash;对属性的支持. 读者将会学到与属性相关的
      <command>svn</command> 子命令, 以及属性如何影响用户的工作检验.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
    <!--
      <title>Why Properties?</title>
    -->
      <title>为什么需要属性?</title>

    <!--
      <para>Just as Subversion uses properties to store extra
        information about the files, directories, and revisions that
        it contains, you might also find properties to be of similar
        use.  You might find it useful to have a place
        close to your versioned data to hang custom metadata about
        that data.</para>
    -->
      <para>Subversion 使用属性存放和文件, 目录, 版本号相关的额外信息, 读者
        可能也会发现属性的类似用法. 你会发现, 如果在数据附近能有个地方保存
        自定义元数据将会是一项非常有用的特性.</para>

    <!--
      <para>Say you wish to design a web site that houses many digital
        photos and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.</para>
    -->
      <para>假设你想要设计一个网站, 其中存放了很多数字照片, 在显示时会给照片
        加上标题和日期. 因为你的照片经常发生变化, 所以你希望网站能够尽量地自动
        处理由于照片变动而产生的影响. 照片可以很大, 你希望在网站上可以显示照片
        的缩略图.</para>

    <!--
      <para>Now, you can get this functionality using traditional
        files.  That is, you can have your
        <filename>image123.jpg</filename> and an
        <filename>image123-thumbnail.jpg</filename> side by side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, such as
        <filename>thumbnails/image123.jpg</filename>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  But the problem here
        is that your collection of files multiplies with each new
        photo added to the site.</para>
    -->
      <para>你可以用传统的文件实现缩略图, 也就是说你可以把照片
        <filename>image123.jpg</filename> 及其缩略图
        <filename>image123-thumbnail.jpg</filename> 放在同一个目录里. 如果你
        希望照片及其缩略图能使用相同的文件名, 也可以把缩略图放在不同的目录里,
        例如 <filename>thumbnails/image123.jpg</filename>. 你可以按照类似的方
        法存放标题和日期. 这里最大的问题是每增加一个新图片, 网站的文件数量都
        会成倍地增加.</para>

    <!--
      <para>Now consider the same web site deployed in a way that
        makes use of Subversion's file properties.  Imagine having a
        single image file, <filename>image123.jpg</filename>, with
        properties set on that file that are named
        <literal>caption</literal>, <literal>datestamp</literal>, and
        even <literal>thumbnail</literal>.  Now your working copy
        directory looks much more manageable&mdash;in fact, it looks
        to the casual browser like there are nothing but image files
        in it.  But your automation scripts know better.  They know
        that they can use <command>svn</command> (or better yet, they
        can use the Subversion language bindings&mdash;see <xref
        linkend="svn.developer.usingapi" />) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</para>
    -->
      <para>现在考虑如果利用 Subversion 的文件属性来部署网站. 设想有一个图片
        文件 <filename>image123.jpg</filename>, 带有属性
        <literal>caption</literal>, <literal>datestamp</literal> 和
        <literal>thumbnail</literal>. 使用属性后的工作副本看起来更容量管理
        &mdash;实际上, 普通的浏览器只能看到图片文件, 但是你的自动化管理脚本
        可以知道得更多. 脚本可以使用 <command>svn</command> (更好的做法是用
        Subversion 的语言绑定&mdash;见 <xref linkend="svn.developer.usingapi"/>)
        获取图片的属性信息, 而不必读取索引文件或处理路径.</para>

      <note>
    <!--
        <para>While Subversion places few restrictions on the names
          and values you use for properties, it has not been designed
          to optimally carry large property values or large sets of
          properties on a given file or directory.  Subversion
          commonly holds all the property names and values associated
          with a single item in memory at the same time, which can
          cause detrimental performance or failed operations when
          extremely large property sets are used.</para>
    -->
        <para>Subversion 对属性的名字和值有一些限制, 如果属性的值很大, 或者在
          单个的文件或目录上设置了很多的属性, 对于这两种情况 Subversion 处理
          起来非常笨拙. Subversion 通常会把单个项目的所有属性及其值同时加载
          到内存中, 如果属性过多, 性能就会受到影响, 甚至引起命令失败.</para>
      </note>

    <!--
      <para>Custom revision properties are also frequently used.  One
        common such use is a property whose value contains an issue
        tracker ID with which the revision is associated, perhaps
        because the change made in that revision fixes a bug filed in
        the tracker issue with that ID.  Other uses include hanging
        more friendly names on the revision&mdash;it might be hard to
        remember that revision 1935 was a fully tested revision.  But
        if there's, say, a <literal>test-results</literal> property on
        that revision with the value <literal>all passing</literal>,
        that's meaningful information to have.  And Subversion allows
        you to easily do this via the <option>- -with-revprop</option>
        option of the <command>svn commit</command> command:</para>
    -->
      <para>自定义版本号属性也经常用到, 一种常见的用法是为版本号添加一个包含
        问题跟踪 ID 的属性, 表示该版本号修复了这个问题. 其他一些用法还可以
        是为版本号附加一个更友好的名字&mdash;人们很难记住版本号 1935 是一个
        经过充分测试的版本, 但是如果给版本号 1935 添加一个属性
        <literal>test-results</literal>, 属性值是
        <literal>all passing</literal>, 这样一来就方便多了. 用户可以通过
        <command>svn commit</command> 的选项 <option>--with-revprop</option>
        为新提交的版本号附加属性 <literal>test-results</literal>:</para>

      <informalexample>
        <screen>
$ svn commit -m "Fix up the last remaining known regression bug." \
             --with-revprop "test-results=all passing"
Sending        lib/crit_bits.c
Transmitting file data .
Committed revision 912.
$
</screen>
      </informalexample>

      <sidebar>
    <!--
        <title>Searchability (or, Why <emphasis>Not</emphasis>
          Properties)</title>
    -->
        <title>可搜索性 (或者说, 为什么 <emphasis>不</emphasis> 使用属性)
        </title>

    <!--
        <para>For all their utility, Subversion properties&mdash;or,
          more accurately, the available interfaces to them&mdash;have
          a major shortcoming: while it is a simple matter to
          <emphasis>set</emphasis> a custom property,
          <emphasis>finding</emphasis> that property later is a whole
          different ball of wax.</para>
    -->
        <para>与 Subversion 属性相关的所有工具&mdash;说得更准确点就是所有可
          用的接口&mdash;都有一个比较严重的问题: 虽然 <emphasis>设置</emphasis>
          一个自定义属性非常简单, 但是 <emphasis>搜索</emphasis> 自定义属性就
          完全是另一回事了.</para>

    <!--
        <para>Trying to locate a custom revision property generally
          involves performing a linear walk across all the revisions
          of the repository, asking of each revision, <quote>Do you
          have the property I'm looking for?</quote>  Use
          the <option>- -with-all-revprops</option> option with
          the <command>svn log</command> command's XML output mode to
          facilitate this search.  Notice the presence of the custom
          revision property <literal>testresults</literal> in the
          following output:</para>
    -->
        <para>为了定位一个自定义版本号属性, 通常需要线性访问仓库的所有版本号,
          询问每一个版本号 <quote>你有没有我要找的属性?</quote>. 为了帮助
          搜索, 给命令 <command>svn log</command> 带上选项
          <option>--with-all-revprops</option>, 再把输出模式调成 XML. 在下面
          的输出中可以看到自定义属性 <literal>testresults</literal> 的信息:
        </para>

        <informalexample>
          <screen>
$ svn log --with-all-revprops --xml lib/crit_bits.c
&lt;?xml version="1.0"?&gt;
&lt;log&gt;
&lt;logentry
   revision="912"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2011-07-29T14:47:41.169894Z&lt;/date&gt;
&lt;msg&gt;Fix up the last remaining known regression bug.&lt;/msg&gt;
&lt;revprops&gt;
&lt;property
   name="testresults"&gt;all passing&lt;/property&gt;
&lt;/revprops&gt;
&lt;/logentry&gt;
&hellip;
$
</screen>
        </informalexample>

    <!--
        <para>Trying to find a custom versioned property is painful,
          too, and often involves a recursive <command>svn
          propget</command> across an entire working copy.  In your
          situation, that might not be as bad as a linear walk across
          all revisions.  But it certainly leaves much to be desired
          in terms of both performance and likelihood of success,
          especially if the scope of your search would require a
          working copy from the root of your repository.</para>
    -->
        <para>查找自定义的版本化属性也很痛苦, 经常要在整个工作副本中递归地调用
          <command>svn propget</command>. 也许递归访问不会像线性访问那样糟糕,
          但在性能和成功率上仍然还有很大的提升空间, 尤其是当搜索是从仓库的根
          目录开始时.</para>

    <!--
        <para>For this reason, you might choose&mdash;especially in
          the revision property use case&mdash;to simply add your
          metadata to the revision's log message using some
          policy-driven (and perhaps programmatically enforced)
          formatting that is designed to be quickly parsed from the
          output of <command>svn log</command>.  It is quite common to
          see the following in Subversion log messages:</para>
    -->
        <para>由于这个原因, 用户可能会选择&mdash;特别是版本号属性&mdash;把元
          数据直接写到日志消息里, 为了方便从日志消息里解析出元数据, 要使用一
          些策略驱动 (可能还会通过程序施加强制性) 的书写格式, 例如下面的
          Subversion 日志消息格式就很常见:</para>

        <informalexample>
          <programlisting>
Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process
&hellip;
</programlisting>
        </informalexample>

    <!--
        <para>But here again lies some misfortune.  Subversion doesn't
          yet provide a log message templating mechanism, which would
          go a long way toward helping users be consistent with the
          formatting of their log-embedded revision metadata.</para>
    -->
        <para>但是问题仍然存在, Subversion 没有日志消息模版机制, 所以用户必须
          自己协商出一套统一的, 嵌入版本号元数据的日志消息格式, 在使用时也只
          能由用户自己来保证格式的一致性.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
    <!--
      <title>Manipulating Properties</title>
    -->
      <title>操作属性</title>

    <!--
      <para>The <command>svn</command> program affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command line of the <command>svn propset</command>
        subcommand:</para>
    -->
      <para>命令 <command>svn</command> 提供了几种用于添加或修改文件和目录
        属性的方法. 如果属性的值比较短, 而且是人类可读的, 那么添加新属性的
        最简单的方法是在子命令 <command>svn propset</command> 的命令行参
        数上指定属性名和值:</para>

      <informalexample>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>
      </informalexample>
       
    <!--
      <para>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multiline textual, or even binary, property value, you
        probably do not want to supply that value on the command line.
        So the <command>svn propset</command> subcommand takes a
        <option>- -file</option> (<option>-F</option>) option for
        specifying the name of a file that contains the new property
        value.</para>
    -->
      <para>Subversion 对于属性值给予了很大的灵活性, 如果属性值包含多行文本,
        甚至是二进制格式, 此时用户就不太可能把值写在命令行参数上, 为了解决
        这个问题, <command>svn propset</command> 支持选项
        <option>--file</option> (<option>-F</option>), 该选项指定了一个包含
        属性值的文件的名字.</para>

      <informalexample>
        <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>
      </informalexample>

    <!--
      <para>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<literal>:</literal>), or an underscore
        (<literal>_</literal>); after that, you can also use digits,
        hyphens (<literal>-</literal>), and periods
        (<literal>.</literal>).<footnote><para>If you're familiar with
        XML, this is pretty much the ASCII subset of the syntax for
        XML <quote>Name</quote>.</para></footnote></para>
    -->
  <para>对属性名有一些限制条件, 属性名必须以字母, 冒号 (<literal>:</literal>)
    或下划线 (<literal>_</literal>) 开始, 接下来的字符, 除了前面介绍的, 还可
    以用数字, 连字符 (<literal>-</literal>), 句点 (<literal>.</literal>).
    <footnote><para>如果读者熟悉 XML, 就会发现这很像 XML <quote>Name</quote>
        语法的 ASCII 子集.</para></footnote></para>

    <!--
      <para>In addition to the <command>propset</command> command, the
        <command>svn</command> program supplies the
        <command>propedit</command> command.  This command uses the
        configured editor program (see <xref
        linkend="svn.advanced.confarea.opts.config" />) to add or
        modify properties.  When you run the command,
        <command>svn</command> invokes your editor program on a
        temporary file that contains the current value of the property
        (or that is empty, if you are adding a new property).  Then,
        you just modify that value in your editor program until it
        represents the new value you wish to store for the property,
        save the temporary file, and then exit the editor program.  If
        Subversion detects that you've actually changed the existing
        value of the property, it will accept that as the new property
        value.  If you exit your editor without making any changes, no
        property modification will occur:</para>
    -->
      <para>除了 <command>propset</command>, <command>svn</command> 还提供了
        子命令 <command>propedit</command>. <command>propedit</command> 使用
        预先配置的外部编辑器 (见
        <xref linkend="svn.advanced.confarea.opts.config"/>) 来添加或修改属性.
        执行 <command>svn propedit</command> 时, 命令在一个临时文件上打开
        编辑器, 临时文件的内容是属性的当前值 (如果是添加新属性, 内容就是空的),
        然后用户就可以按照自己的需要在编辑器里修改属性值, 修改完成后保存临时
        文件, 最后退出编辑器. 退出编辑器后, 如果 Subversion 检测到属性原来的
        值被修改了, 它就把修改后的值当作属性的新值. 如果用户没有修改便退出
        编辑器, 属性值就保持不变:</para>

      <informalexample>
        <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>
      </informalexample>

    <!--
      <para>We should note that, as with other <command>svn</command>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done the following:</para>
    -->
      <para>应该注意到, 和 <command>svn</command> 的其他子命令一样, 属性操作
        可以同时施加到多个路径上, 这就允许用户用一个命令修改整个文件集合的属性,
        例如我们可以这样做:</para>

      <informalexample>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
&hellip;
$
</screen>
      </informalexample>

    <!--
      <para>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <command>svn</command> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <command>svn proplist</command>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <command>svn
        propget</command>.  This command will, given a property name
        and a path (or set of paths), print the value of the property
        to the standard output stream.</para>
    -->
      <para>如果用户不能方便地获取属性值, 那么属性的添加和删除就没什么大用处,
        所以 <command>svn</command> 提供了两个子命令用于显示文件和目录上的
        属性名和值. 命令 <command>svn proplist</command> 列出指定路径上的属性
        的名字, 一旦知道了属性名, 就可以用命令 <command>svn propget</command>
        分别地获取各个属性的值, 它根据指定的属性名和一个路径 (或多个路径) 打印
        出属性的值.</para>

      <informalexample>
        <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2006 Red-Bean Software
</screen>
      </informalexample>

    <!--
      <para>There's even a variation of the
        <command>proplist</command> command that will list both the
        name and the value for all of the properties.  Simply supply the
        <option>- -verbose</option> (<option>-v</option>) option.</para>
    -->
      <para>执行命令 <command>svn proplist</command> 时如果加上选项
        <option>--verbose</option> (<option>-v</option>), 命令就会同时列出
        所有属性的名字和值.</para>

      <informalexample>
        <screen>
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright
    (c) 2006 Red-Bean Software
  license
    ================================================================
    Copyright (c) 2006 Red-Bean Software.  All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions 
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions, and the recipe for Fitz's famous
    red-beans-and-rice.
    &hellip;
</screen>
      </informalexample>

    <!--
      <para>The last property-related subcommand is
        <command>propdel</command>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <command>svn propedit</command> or
        <command>svn propset</command>.  For example, this command will
        <emphasis>not</emphasis> yield the desired effect:</para>
    -->
      <para>最后一个与属性相关的子命令是 <command>propdel</command>. 因为
        Subversion 允许为属性设置空值, 所以用户不能想当然地认为用
        <command>svn propedit</command> 和 <command>svn propset</command>
        把属性值设置成空值, 就能实现完全删除属性的效果, 比如说下面的命令不会产
        生用户想要的效果 (用户想要的效果是删除属性 <literal>license</literal>)
        :</para>

      <informalexample>
        <screen>
$ svn propset license "" calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright
    (c) 2006 Red-Bean Software
  license
    
$
</screen>
      </informalexample>

    <!--
      <para>You need to use the <command>propdel</command> subcommand
        to delete properties altogether.  The syntax is similar to the
        other property commands:</para>
    -->
      <para>为了完全删除属性, 需要使用子命令 <command>propdel</command>,
        它的使用语法和其他属性命令类似:</para>

      <informalexample>
        <screen>
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright
    (c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

    <!--
      <para>Remember those unversioned revision properties?  You can
        modify those, too, using the same <command>svn</command>
        subcommands that we just described.  Simply add the
        <option>- -revprop</option> command-line parameter and specify
        the revision whose property you wish to modify.  Since
        revisions are global, you don't need to specify a target path
        to these property-related commands so long as you are
        positioned in a working copy of the repository whose revision
        property you wish to modify.  Otherwise, you can simply
        provide the URL of any path in the repository of interest
        (including the repository's root URL).  For example, you might
        want to replace the commit log message of an existing
        revision.<footnote><para>Fixing spelling errors, grammatical
        gotchas, and <quote>just-plain-wrongness</quote> in commit log
        messages is perhaps the most common use case for
        the <option>- -revprop</option> option.</para></footnote>  If
        your current working directory is part of a working copy of
        your repository, you can simply run the
        <command>svn propset</command> command with no target path:</para>
    -->
      <para>还记得那些非版本化的版本号属性吗? 用户也可以用我们刚刚介绍过的
        <command>svn</command> 的子命令去修改它们, 只要加上选项
        <option>--revprop</option> 和欲修改的版本号. 因为版本号是全局的, 所以
        只要用户已经位于欲修改的版本号的工作副本中, 就不需要为命令指定目标路径,
        否则的话, 可以在命令行上提供目标路径的 URL 参数. 例如, 用户可能想修改
        一个已存在的版本号的提交日志,<footnote><para>修改提交日志的拼写错误,
            语法问题和其他的一般性错误可能是 <option>--revprop</option> 最常见
            的应用场景.</para></footnote> 如果你的当前工作目录是工作副本的一
        部分, 可以不带目标路径地执行命令 <command>svn propset</command>:</para>

      <informalexample>
        <screen>
$ svn propset svn:log "* button.c: Fix a compiler warning." -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</screen>
      </informalexample>

    <!--
      <para>But even if you haven't checked out a working copy from
        that repository, you can still effect the property change by
        providing the repository's root URL:</para>
    -->
      <para>即使用户没有检出仓库的工作副本, 仍然可以通过提供仓库的根 URL 来
        修改属性:</para>

      <informalexample>
        <screen>
$ svn propset svn:log "* button.c: Fix a compiler warning." -r11 --revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
$
</screen>
      </informalexample>

    <!--
      <para>Note that the ability to modify these unversioned
        properties must be explicitly added by the repository
        administrator (see <xref linkend="svn.reposadmin.maint.setlog" />).
        That's because the properties aren't versioned, so you run the risk of
        losing information if you aren't careful with your edits.
        The repository administrator can set up methods to protect
        against this loss, and by default, modification of
        unversioned properties is disabled.</para>
    -->
      <para>需要注意的是只有在仓库管理员配置后用户才能修改非版本化属性 (见
        <xref linkend="svn.reposadmin.maint.setlog"/>). 这是因为如果属性是非
        版本化的, 用户一不小心就有可能弄丢信息. 仓库管理员可以采取一定的措施
        防止信息丢失, 在默认上, 修改非版本化属性是被禁止的.</para>

      <tip>
    <!--
        <para>Users should, where possible, use <command>svn
          propedit</command> instead of <command>svn
          propset</command>.  While the end result of the commands is
          identical, the former will allow them to see the current
          value of the property that they are about to change, which helps
          them to verify that they are, in fact, making the change
          they think they are making.  This is especially true when
          modifying unversioned revision properties.  Also, it is
          significantly easier to modify multiline property values in
          a text editor than at the command line.</para>
    -->
        <para>如果可以的话, 用户应该尽量使用 <command>svn propedit</command>,
          而不是 <command>svn propset</command>. 虽然这两个命令的执行结果是
          一样的, 但是 <command>svn propedit</command> 允许用户看到将要被修改
          的属性的当前值, 这可以帮助他们确认自己是否正在按照自己想要的那样
          操作. 另外, 在编辑器中修改具有多行文本的属性, 要比在命令行上修改方便
          得多.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.workflow">
    <!--
      <title>Properties and the Subversion Workflow</title>
    -->
      <title>属性和 Subversion 工作流程</title>

    <!--
      <para>Now that you are familiar with all of the
        property-related <command>svn</command> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging&mdash;cleanly or with conflicts&mdash;someone
        else's modifications into your own.</para>
    -->
      <para>既然读者已经熟悉了所有与属性相关的 <command>svn</command> 子命令,
        现在来看属性修改将会如何影响 Subversion 的工作流程. 我们已经说过,
        文件和目录的属性是被版本控制的, 就像文件内容那样, 因此 Subversion 也
        支持属性的合并&mdash;或干净利落地, 或带有冲突.</para>

    <!--
      <para>As with file contents, your property changes are local
        modifications, made permanent only when you commit them to the
        repository with <command>svn commit</command>.  Your property
        changes can be easily unmade, too&mdash;the <command>svn
        revert</command> command will restore your files and
        directories to their unedited states&mdash;contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <command>svn status</command> and <command>svn diff</command>
        commands.</para>
    -->
      <para>和文件内容一样, 属性修改一开始只是本地的, 只有用
        <command>svn commit</command> 提交后, 属性的修改才会持久化. 属性的修改
        也能轻易地撤消&mdash;命令 <command>svn revert</command> 可以撤消所有
        文件和目录的本地修改, 包括属性修改, 内容修改, 以及其他所有的本地修改.
        你也可以用 <command>svn status</command> 和 <command>svn diff</command>
        获取文件和目录的属性状态.</para>

      <informalexample>
        <screen>
$ svn status calc/button.c
 M      calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Added: copyright
## -0,0 +1 ##
+(c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

    <!--
      <para>Notice how the <command>status</command> subcommand
        displays <literal>M</literal> in the second column instead of
        the first.  That is because we have modified the properties on
        <filename>calc/button.c</filename>, but not its textual
        contents.  Had we changed both, we would have seen
        <literal>M</literal> in the first column, too.  (We cover
        <command>svn status</command> in <xref
        linkend="svn.tour.cycle.examine.status" />).</para>
    -->
    <para>注意, 子命令 <command>status</command> 把 <literal>M</literal> 显示
      在了第二列, 而不是第一列, 这是因为我们修改的是
      <filename>calc/button.c</filename> 的属性, 而不是内容. 如果我们同时修改
      了内容和属性, 我们就会同时在第一列和第二列看到 <literal>M</literal>
      (我们在 <xref linkend="svn.tour.cycle.examine.status"/> 介绍了
      <command>svn status</command>).</para>

      <sidebar>
    <!--
        <title>Property Conflicts</title>
    -->
        <title>属性冲突</title>

    <!--
        <para>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned object that clash with your own,
          Subversion will report that the object is in a conflicted
          state.</para>
    -->
        <para>和文件内容一样, 本地的属性修改有可能和其他人提交的修改产生冲突,
          发生冲突后, Subversion 把条目设置成冲突状态.</para>
 
        <informalexample>
          <screen>
$ svn update calc
Updating 'calc':
M  calc/Makefile.in
Conflict for property 'linecount' discovered on 'calc/button.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (s) show all options: p
 C calc/button.c
Updated to revision 143.
Summary of conflicts:
  Property conflicts: 1
$ 
</screen>
        </informalexample>
         
    <!--
        <para>Subversion will also create, in the same directory as
          the conflicted object, a file with a
          <filename>.prej</filename> extension that contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <literal>C</literal> in the second column of <command>svn
          status</command> output for that object, and attempts to
          commit your local modifications will fail.</para>
    -->
        <para>发生冲突后, Subversion 也会在冲突对象的同一个目录下创建一个以
          <filename>.prej</filename> 作为后缀名的文件, 其中包含了冲突的细节,
          用户应该检查这个文件的内容, 从而决定应该如何解决冲突. 在冲突解决之
          前, 冲突条目的 <command>svn status</command> 输出信息的第二列会有
          一个字母 <literal>C</literal>, 如果试图提交修改, 提交操作将会失败.
        </para>

        <informalexample>
          <screen>
$ svn status calc
 C      calc/button.c
?       calc/button.c.prej
$ cat calc/button.c.prej 
Trying to change property 'linecount' from '1267' to '1301',
but property has been locally changed from '1267' to '1256'.
$
</screen>
        </informalexample>
 
    <!--
        <para>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <command>svn resolve - -accept=working</command>
          command to alert Subversion that you have manually resolved the
          problem.</para>
    -->
        <para>为了解决冲突, 只需要确保发生冲突的属性包含了正确的值, 然后用命令
          <command>svn resolve --accept=working</command> 告诉 Subversion 你
          已经手动解决了冲突问题.</para>

      </sidebar>

    <!--
      <para>You might also have noticed the nonstandard way that
        Subversion currently displays property differences.  You can
        still use <command>svn diff</command> and redirect its output
        to create a usable patch file.  The <command>patch</command>
        program will ignore property patches&mdash;as a rule, it
        ignores any noise it can't understand.  This does,
        unfortunately, mean that to fully apply a patch generated by
        <command>svn diff</command> using <command>patch</command>,
        any property modifications will need to be applied by
        hand.</para>
    -->
      <para>读者可能已经注意到了 Subversion 的属性差异输出并不是一种标准的
        格式, 用户仍然可以用 <command>svn diff</command> 并把它的输出重定向
        到补丁文件里, 但 <command>patch</command> 会忽略属性的补丁&mdash;
        <command>patch</command> 的一条规则是忽略所有不能理解的内容, 这就意味
        着如果用户用的是 <command>patch</command>, 为了完整地打上
        <command>svn diff</command> 生成的补丁, 用户必须手工地打上和属性相关的
        修改.</para>

    <!--
      <para>Subversion 1.7 improves this situation in two ways.
        First, its nonstandard display of property differences is at
        least machine-readable&mdash;an improvement over the display
        of properties in versions prior to 1.7.  But Subversion 1.7
        also introduces the <command>svn patch</command> subcommand,
        designed specifically to handle the additional information
        which <command>svn diff</command>'s output can carry, applying
        those changes to the Subversion working copy.  Of specific
        relevance to our topic, property differences present in patch
        files generated by <command>svn diff</command> in Subversion
        1.7 or better can be automatically applied to a working copy
        by the <command>svn patch</command> command.  For more
        about <command>svn patch</command>, see
        <xref linkend="svn.ref.svn.c.patch" /> in
        <xref linkend="svn.ref.svn"/>.</para>
    -->
      <para>Subversion 1.7 从两个方面改善了这个问题, 首先, 属性的差异输出至少
        是机器可读的&mdash;这是对 1.7 版之前的属性显示的改进. 然后 Subversion
        1.7 引入了新命令 <command>svn patch</command>, 专门用来处理
        <command>svn diff</command> 的输出中带有的额外信息, 并把这些信息应用
        到工作副本中. 对于属性来说, 使用 Subversion 1.7 及以后版本的
        <command>svn diff</command> 生成的补丁, 如果其中包含了属性差异, 那么
        <command>svn patch</command> 可以自动地把这些差异应用到工作副本.
        关于 <command>svn patch</command> 的更多信息, 见
        <xref linkend="svn.ref.svn"/> 的 <xref linkend="svn.ref.svn.c.patch"/>.
      </para>

      <note>
    <!--
        <para>There's one exception to how property changes are
          reported by <command>svn diff</command>: changes to
          Subversion's special <literal>svn:mergeinfo</literal>
          property&mdash;used to track information about merges which
          have been performed in your repository&mdash;are described
          in a more human-readable fashion.  This is quite helpful to
          the humans who have to read those descriptions.  But it also
          serves to cause patching programs (including <command>svn
          patch</command>) to skip those change descriptions as noise.
          This might sound like a bug, but it really isn't because
          this property is intended to be managed solely by
          the <command>svn merge</command> subcommand.  For more about
          merge tracking, see <xref linkend="svn.branchmerge"
          />.</para>
    -->
      <para><command>svn diff</command> 在报告属性的变化时有一个例外, 那就是
        特殊的 <literal>svn:mergeinfo</literal> 属性&mdash;该属性用于跟踪合
        并信息&mdash;的变化会以一种更适合人类阅读的方式呈现出来, 这对于那些
        需要阅读合并信息的用户来说特别有帮助. 不过, 补丁程序 (包括 <command>
          svn patch</command>) 仍然会忽略与 <literal>svn:mergeinfo</literal>
        相关的补丁. 这样做看起来好像是有问题的, 但事实上并非如此, 因为属性
        <literal>svn:mergeinfo</literal> 由 <command>svn merge</command> 单独
        进行管理, 关于合并跟踪的更多信息, 见 <xref linkend="svn.branchmerge"/>.
      </para>
      </note>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.inheritable">
    <!--
      <title>Inherited Properties</title>
    -->
      <title>继承的属性</title>

    <!--
      <para>Subversion 1.8 introduces the concept of inherited properties.
        There is really nothing special about a property that makes it
        inheritable.  In fact, all versioned properties are inheritable!
        The main difference between versioned properties before 1.8 and
        after is that the latter provides a mechanism to find the
        properties set on a target path's <emphasis>parents</emphasis>,
        even if those parents are not found within the working copy.
        </para>
    -->
        <para>Subversion 1.8 引入了继承属性这个概念. 将一个属性设置成可继承的
          并没有什么很特别的地方, 实际上, 所有版本化的属性都是可继承的! 1.8 前
          的版本化属性和 1.8 后的版本化属性的主要区别是后者支持在一个目标路径
          的 <emphasis>父路径</emphasis> (<emphasis>parents</emphasis>) 上搜索
          属性, 即使这些父路径在工作副本里不存在.</para>

    <!--
      <para>Generic property inheritance manifests itself in a few
        commands.  First, the <command>svn proplist</command> and <command>
        svn propget</command> subcommands can retrieve all the properties
        on a URL's or a working copy path's parents by using the <option>
        - -show-inherited-props</option> option.  You might think of this
        as the opposite of a <option>- -recursive</option> subcommand
        operation&mdash;instead of recursing "down" into a target's
        subdirectories, subcommands with the <option>- -show-inherited-props
        </option> option look "up" into the target's parent directories.
        The <command>svnlook propget</command> and <command>svnlook
        proplist </command> subcommands also use the <option>
        - -show-inherited-props</option> option in a similar fashion.</para>
    -->
    <para>有些命令可以显示出一般的属性继承, 首先 <command>svn proplist</command>
      和 <command>svn propget</command> 可以检索 URL 的或工作副本路径的父路径
      上的所有属性, 方法是带上选项 <option>--show-inherited-props</option>.
      读者可能会觉得这是选项 <option>--recursive</option> 的反面&mdash;选项
      <option>--recursive</option> 向 <quote>下</quote> 递归到目标的子目录里,
      而 <option>--show-inherited-props</option> 是向 <quote>上</quote> 看
      目标的父目录. 命令 <command>svnlook propget</command> 和
      <command>svnlook proplist</command> 按照类似的方法使用选项
      <option>--show-inherited-props</option>.</para>

    <!--
      <para>Let's look at an example of how this works. The following
        recursive propget on the root of our working copy finds that the
        <literal>svn:auto-props</literal> property is set on both the target
        of the subcommand and one of its subdirectories <filename>site
        </filename>:</para>
    -->
        <para>举个例子, 在工作副本的根目录递归地调用 <command>propget
            </command>, 发现子命令的目标路径及其中的一个子目录 <filename>site
        </filename> 都设置了属性 <literal>svn:auto-props</literal>:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose -R .
Properties on '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Properties on 'site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

    <!--
      <para>If we were to instead make the target of the subcommand the
        subdirectory <filename>site</filename>, then using the <option>
        - -show-inherited-props</option> option, we find that the <literal>
        svn:auto-props</literal> property is set on the target <emphasis>
        and</emphasis> its parent.  The parent's properties are called out
        as "inherited":</para>
    -->
      <para>如果我们把子目录 <filename>site</filename> 作为子命令的目标路径,
        然后使用选项 <option>--show-inherited-props</option>, 我们将会看到属性
        <literal>svn:auto-props</literal> 存在于目标路径 <emphasis>和</emphasis>
        它的父路径上, 父路径的属性是 <quote>被继承的</quote>:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose --show-inherited-props site
Inherited properties on 'site',
from '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Properties on 'site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

    <!--
      <para>In the prior examples the root of the working copy
        corresponds to the root of the repository, but properties can
        also be inherited from outside the working copy when this is
        not the case.  Let's checkout the <filename>site</filename>
        directory from the prior example, making it the root of our
        working copy:</para>
    -->
      <para>在上一个例子里, 工作副本的根目录对应仓库的根目录, 但即使没有这种
        对应, 属性也可以从工作副本的外面继承. 现在检出上一个例子的
        <filename>site</filename> 目录, 使它成为工作副本的根目录:</para>

        <informalexample>
          <screen>
$ svn co http://svn.example.com/repos site-wc
A    site-wc/publish
A    site-wc/publish/ch2.html
A    site-wc/publish/news.html
A    site-wc/publish/ch3.html
A    site-wc/publish/faq.html
A    site-wc/publish/index.html
A    site-wc/publish/ch1.html
 U   site-wc
Checked out revision 19.

$ cd site-wc
</screen>
        </informalexample>

    <!--
      <para>Now when we check for inherited properties on a working copy
        path we can see that one property is inherited from a working
        copy parent and one from a repository parent representing a
        location "above" the root of the working copy:</para>
    -->
      <para>当我们在一条工作副本路径上检查继承的属性时将会看到, 一个属性继承
        自工作副本里的父目录, 一个属性继承自仓库里的父路径, 该路径在工作副本
        的根目录的 <quote>上层</quote>:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose --show-inherited-props publish
Inherited properties on 'publish',
from 'http://svn.example.com/repos':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Inherited properties on 'publish',
from '.':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

        <warning>
    <!--
          <para>You can only inherit properties from repository paths
            which you have read authorization to&mdash;see
            <xref linkend="svn.serverconfig.svnserve.auth" /> and
            <xref linkend="svn.serverconfig.httpd.authz" />.  If you
            don't have read authorization to a parent path then it will
            appear as if the parent has no properties set on it.
          </para>
    -->
          <para>用户只能从他拥有读权限的仓库路径上继承属性&mdash;见
            <xref linkend="svn.serverconfig.svnserve.auth"/> 和
            <xref linkend="svn.serverconfig.httpd.authz"/>. 如果用户对某条
            父路径没有读权限, 看起来的效果就像是父路径上没有设置属性.</para>
        </warning>

    <!--
      <para>As mentioned above, the <command>svnlook proplist</command>
        and <command>svnlook propget</command> commands also support the
        <option>- -show-inherited-props</option> option, but instead of
        reporting the inherited props by working copy path or URL, they
        are listed by repository paths:</para>
    -->
      <para>前面已经说过, <command>svnlook proplist</command> 和
        <command>svnlook propget</command> 也支持选项
        <option>--show-inherited-props</option>, 但它们不是以工作副本路径或
        URL 作为目标路径, 而是以仓库的路径作为目标路径:</para>

        <informalexample>
          <screen>
$ svnlook pg repos svn:auto-props /site/publish --show-inherited-props -v
Inherited properties on '/site/publish',
from '/':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Inherited properties on '/site/publish',
from '/site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

    <!--
      <para>Properties inherited from above the root of the working copy
        are cached in the working copy's administrative database when the
        working copy is initially checked out and then refreshed whenever
        the working copy is updated.  This means that you don't need
        access to your repository to view inherited properties.  This
        allows Subversion subcommands that have traditionally not
        required access to the repository (e.g. <command>svn add</command>
        ) to remain "disconnected" while still accessing properties
        inherited from paths not found in the working copy.  However it
        also means that inherited properties from above the root of the
        working copy may have changed since your most recent update,
        causing your local cache to become out of date.  So if you require
        the absolute latest value of some inherited property, it's always
        safest to update your working copy first or query the repository
        directly.</para>
    -->
      <para>当工作副本被首次检出或者更新时, 从工作副本根目录上层继承而来的属性
        会被缓存在工作副本的管理数据库里, 这样的话在查看继承的属性时就不用再
        访问仓库了, 同时也允许那些不要求访问仓库的子命令 (例如 <command>svn add
        </command>) 在保持 <quote>无连接</quote> 的同时, 仍然可以访问到从工作
        副本之外的路径继承而来的属性. 但同时也意味着在最近一次更新之后, 来自工
        作副本根目录上层的继承属性可能已经发生了变化, 使得本地缓存变成过时了的.
        所以如果用户要求继承的属性始终是最新的, 最好更新一下工作副本或直接询问
        仓库.</para>

    <!--
      <para>At this point you might be thinking, "nice trick, but what
        good is it?"  By itself property inheritance isn't very useful.
        Before 1.8, all of Subversion's own reserved <literal>svn:*
        </literal> properties (and likely all of your own custom user
        properties) applied only to the path on which they were set or
        at most, the path's immediate children<footnote><para>The one
        noteable exception to this being the <literal>svn:mergeinfo
        </literal> property, which is inheritable&mdash;see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo" />
        </para></footnote>  Rather, inheritable properties are a tool
        that Subversion uses to do other more interesting things, like
        setting automatic properties with the <literal>svn:auto-props
        </literal> property or repository-wide ignores with the <literal>
        svn:global-ignores</literal> property&mdash;see
        <xref linkend="svn.advanced.props.auto" /> and
        <xref linkend="svn.advanced.props.special.ignore" /> for more
        information about these special properties and how to use them.
        </para>
    -->
        <para>到这里读者可能会想 <quote>看起来挺有趣的, 但这有什么好处呢?
          </quote> 对于属性继承本身来说是没多大用处, 在 1.8 之前, Subversion
          所有的保留属性 <literal>svn:*</literal> (还可能包括所有的用户自定
          义属性) 都只能应用到它们所在的路径上, 至多再加上直接子路径
          <footnote><para>有一个例外是 <literal>svn:mergeinfo</literal> 属性,
              它是可继承的&mdash;见
              <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/></para>
          </footnote>. Subversion 使用继承属性完成另一些更有趣的事情, 比如说用
          属性 <literal>svn:auto-props</literal> 设置自动属性, 用属性
          <literal>svn:global-ignores</literal> 实现全局的忽略模式&mdash;
          关于这些特殊属性的更多信息和使用方法, 见
        <xref linkend="svn.advanced.props.auto" /> 和
        <xref linkend="svn.advanced.props.special.ignore" />.</para>

        <tip>
    <!--
          <para>Currently inheritable properties are primarily useful only
            as regards the <literal>svn:auto-props</literal> and <literal>
            svn:global-ignores</literal> properties but that doesn't mean
            those two properties are the end of the story.  Look for more
            features to be built with inherited properties in future
            releases of Subversion&mdash;a log message templating mechanism
            comes to mind.  In the meantime feel free to use the feature
            however you'd like.  Any piece of versioned metadata you want
            to apply to your whole repository (or large subsections
            thereof) can easily be stored in a property on the root of
            your repository (or the appropriate subtree).  We suspect that
            some users and administrators will come up with clever ways to
            use inheritable properties which we never considered.</para>
    -->
          <para>目前可继承的属性中起主要作用的是 <literal>svn:auto-props
            </literal> 和 <literal>svn:global-ignores</literal>, 但这并不意味
            着故事就此结束. 在 Subversion 未来的版本里, 我们期待继承属性能加
            入更多的特性, 例如日志消息模版, 与此同时, 请尽情按照你自己的喜好
            去使用继续属性. 用户想要应用到整个仓库的任意一段
            版本化元数据 (或仓库中的某个较大的部分) 都可以轻易地存放到仓库的
            根目录 (或适当的子目录) 的属性上. 我们相信某些用户和管理员使用
            继承属性的方式可能连我们都未必想像得到.</para>
        </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
    <!--
      <title>Automatic Property Setting</title>
    -->
      <title>自动属性设置</title>

    <!--
      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters&mdash;textual diff and merge
        support, keyword substitution, newline translation, and so on.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that
        step can be easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        few simple but useful features.</para>
    -->
      <para>属性是 Subversion 最强大的特性之一, 它是本章和其他章节介绍的众多
        Subversion 特性&mdash;文本差异比较, 合并支持, 关键字替换和换行符转换
        等&mdash;的关键基础. 为了充分发挥属性的作用, 它们必须被设置到正确的
        文件和目录上, 不幸的是, 这个步骤在日常工作中常常被人遗忘, 尤其是因为
        即使属性设置不当通常也不会造成很明显的错误 (至少和文件添加失败比起
        来, 不是很明显). 为了帮助用户更好地使用属性, Subversion 提供了几个
        简单但很有用的特性.</para>

    <!--
      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion tries to assist by setting some common
        file properties automatically.  First, on operating systems
        whose filesystems support an execute permission bit,
        Subversion will automatically set the
        <literal>svn:executable</literal> property on newly added or
        imported files whose execute bit is enabled.  (See <xref
        linkend="svn.advanced.props.special.executable" /> later in
        this chapter for more about this property.)</para>
    -->
      <para>每当用户使用 <command>svn add</command> 和 <command>svn import
        </command> 向仓库添加文件时, Subversion 自动地在文件上设置一些常见的
        属性. 首先, 如果操作系统的文件系统支持可执行权限位并且文件具有可执行
        权限, Subversion 就自动在文件上设置 <literal>svn:executable</literal>
        属性 (关于这个属性的更多信息, 见
        <xref linkend="svn.advanced.props.special.executable"/>).</para>

    <!--
      <para>Second, Subversion tries to determine the file's MIME
        type.  If you've configured a
        <literal>mime-types-files</literal> runtime configuration
        parameter, Subversion will try to find a MIME type mapping in
        that file for your file's extension.  If it finds such a
        mapping, it will set your file's
        <literal>svn:mime-type</literal> property to the MIME type it
        found.  If no mapping file is configured, or no mapping for
        your file's extension could be found, Subversion will fall
        back to heuristic algorithms to determine the file's MIME
        type.  Depending on how it is built, Subversion 1.7 can make
        use of file scanning libraries<footnote><para>Currently,
        libmagic is the support library used to accomplish
        this.</para></footnote> to detect a file's type based on its
        content.  Failing all else, Subversion will employ its own
        very basic heuristic to determine whether the file contains
        nontextual content.  If so, it automatically sets the
        <literal>svn:mime-type</literal> property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise&mdash;perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal>&mdash;you can
        always remove or edit that property.  (For more on
        Subversion's use of MIME types, see <xref
        linkend="svn.advanced.props.special.mime-type" /> later in
        this chapter.)</para>
    -->
      <para>然后, Subversion 会试图判断文件的 MIME 类型. 如果用户为
        <literal>mime-types-files</literal> 设置了一个运行时配置参数, Subversion
        就会尝试根据文件的后缀名为文件搜索一个对应的 MIME 类型映射, 若找到的话,
        它就把文件的 <literal>svn:mime-type</literal> 属性设置成找到的 MIME
        类型. 如果用户没有为 <literal>mime-types-files</literal> 设置运行时
        配置参数, 或者根据后缀名没有找到对应的类型映射, Subversion 就使用启发
        式的算法来判断文件的 MIME 类型. 取决于编译时的配置, Subversion 1.7
        可以利用文件扫描函数库<footnote><para>当前比较常用的函数库是 libmagic
        </para></footnote> 检测文件的类型. 如果前面的都失败了, Subversion 就
        使用它非常基本的启发式算法来判断文件是否包含非文本数据, 如果是, 就自动
        地把文件的 <literal>svn:mime-type</literal> 属性设置成
        <literal>application/octet-stream</literal> (最一般的 MIME 类型, 表示
        <quote>这是字节的集合</quote>). 当然, 如果 Subversion 的判断不正确,
        又或者是用户想把 <literal>svn:mime-type</literal> 设置成更精确的值
        &mdash;比如 <literal>image/png</literal> 或 <literal>
          application/x-shockwave-flash</literal>&mdash;可以自由地修改或删除
        属性 <literal>svn:mime-type</literal> (关于 Subversion 如何使用 MIME
        类型的更多信息, 见本章后面的
        <xref linkend="svn.advanced.props.special.mime-type" />).</para>

      <note>
    <!--
        <para>UTF-16 is commonly used to encode files whose semantic
          content is textual in nature, but the encoding itself makes
          heavy use of bytes which are outside the typical ASCII
          character byte range.  As such, Subversion will tend to
          classify such files as binary files, much to the chagrin of
          users who desire line-based differencing and merging,
          keyword substitution, and other behaviors for those
          files.</para>
    -->
        <para>有很多文件使用的是 UTF-16 编码, 虽然在语义上文件的内容是纯文本
          的, 但是 UTF-16 使用的字节在 ASCII 字符的范围之外, 因此 Subversion
          更倾向于把它们归类为二进制文件, 用户在给这些文件进行差异比较, 合并
          和关键字替换时也会因此遇到一些小麻烦.</para>
      </note>

    <!--
      <para>Subversion also provides, via its runtime configuration
        system (see <xref linkend="svn.advanced.confarea" />), a more
        flexible automatic property setting feature that allows you
        to create mappings of filename patterns to property names and
        values.  Once again, these mappings affect adds and imports,
        and can not only override the default MIME type decision made
        by Subversion during those operations, but can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that anytime you add
        JPEG files&mdash;ones whose names match the pattern
        <literal>*.jpg</literal>&mdash;Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  For more details on automatic
        property support in the runtime configuration see <xref
        linkend="svn.advanced.confarea.opts.config"/>.</para>
    -->
    <para>借助运行时配置系统 (见 <xref linkend="svn.advanced.confarea"/>),
      Subversion 提供了一种更加灵活的自动属性设置功能, 它允许用户创建文件名
      模式到属性名和值的映射. 再说一次, 这些映射会影响
      <command>svn add</command> 和 <command>svn import</command>, 除了会
      覆盖由 Subversion 判断出的默认 MIME 类型, 还可能添加额外的属性或自定义
      属性. 例如, 用户想创建一个映射, 这个映射是说每次添加一个 JPEG 文件时
      &mdash;文件的名字符合模式 <literal>*.jpg</literal>&mdash;Subversion
      都应该自动地把这个文件的 <literal>svn:mime-type</literal> 属性设置为
      <literal>image/jpeg</literal>. 又或者说匹配模式 <literal>*.cpp</literal>
      的文件都应该把 <literal>svn:eol-style</literal> 设置成 <literal>native
        </literal>, 把 <literal>svn:keywords</literal> 设置成 <literal>Id
      </literal>. 关于运行时配置如何支持自动属性的更多细节, 见
      <xref linkend="svn.advanced.confarea.opts.config"/>.</para>


      <!--
      <para>While automatic property support via the runtime
        configuration system is certainly handy, Subversion
        administrators might prefer a set of property definitions
        which all connecting clients automatically consider when
        operating on working copies checked out from a given server.
        Subversion 1.8 and newer clients support such functionality
        through the <literal>svn:auto-props</literal> inheritable
        property.</para>
      -->
      <para>虽然借助运行时配置系统来支持自动属性设置非常方便, 但 Subversion
        管理员可能更希望当客户端工具在一个从特定服务器检出的工作副本上工作
        时, 可以考虑到那些自动连接到客户端的属性集合. Subversion 1.8 及其
        之后的客户端版本通过可继承属性 <literal>svn:auto-props</literal>
        实现这个功能.</para>

    <!--
      <para>The <literal>svn:auto-props</literal> property works like
        the runtime configuration to automatically set properties on
        files when they are added or imported.  The value of the
        <literal>svn:auto-props</literal> property is expected to be
        the same as the <literal>auto-props</literal> runtime
        configuration option (i.e. Any number of key-value pairs in
        the format FILE_PATTERN = PROPNAME=VALUE[;PROPNAME=VALUE ...])
        Like the <literal>auto-props</literal> runtime option, the
        <literal>svn:auto-props</literal> property can be disregarded
        when using the <option>- -no-auto-props</option> option, but unlike
        the config option, the <literal>svn:auto-props</literal> property
        is <emphasis>not</emphasis> disabled when the
        <literal>enable-auto-props</literal> configuration option is set
        to <literal>no</literal>.
        </para>
    -->
        <para>属性 <literal>svn:auto-props</literal> 可以像运行时配置系统那样,
          自动地为新增的文件设置属性, 属性 <literal>svn:auto-props</literal>
          的值应该和运行时配置选项 <literal>auto-props</literal> 的值相同 (也
          就是任意数量的键值对, 格式是
          FILE_PATTERN = PROPNAME=VALUE[;PROPNAME=VALUE ...]). 和运行时选项
          <literal>auto-props</literal> 一样, 如果使用了选项 <option>
            --no-auto-props</option>, 属性 <literal>svn:auto-props</literal>
          就会被忽略, 但是有所不同的是, 即使配置选项
          <literal>enable-auto-props</literal> 被设置为 <literal>no</literal>,
          属性 <literal>svn:auto-props</literal> 也不会被禁止.</para>

    <!--
      <para>For example, say you have checked out a working copy of your
        <filename>trunk</filename> branch and need to add a new file
        (let's assume that automatic properties in your runtime
        configuration are disabled):</para>
    -->
      <para>举例来说, 你检出了主干的工作副本, 想在其中添加一个新文件 (假设
        运行时配置系统禁止了自动属性):</para>

    <informalexample>
      <screen>
$ svn st
?       calc/data.c

$ svn add calc/data.c
A         calc/data.c

$ svn proplist -v calc/data.c
Properties on 'calc/data.c':
  svn:eol-style
    native
</screen>
    </informalexample>

    <!--
      <para>Notice that after you place the unversioned file
        <filename>data.c</filename> under version control the
        <literal>svn:eol-style</literal> property was automatically set
        on it.  Since we assumed that the <literal>auto-props</literal>
        runtime configuration option is disabled, we know
        that the <literal>svn:auto-props</literal> property must be set
        on some parent path of <filename>data.c</filename>.  Using the
        <command>svn propget</command> subcommand with the
        <option>- -show-inherited-props</option> option we see that this
        is indeed the case:</para>
    -->
      <para>可以看到, 当 <filename>data.c</filename> 被版本控制后, 文件自动
        设置了属性 <literal>svn:eol-style</literal>. 因为运行时配置选项
        <literal>auto-props</literal> 是禁止了的, 所以属性 <literal>
          svn:auto-props</literal> 肯定来自 <filename>data.c</filename> 的
        父路径. 执行带上选项 <option>--show-inherited-props</option> 的命令
        <command>svn propget</command> 可以看到, 事实的确是如我们所想的那样:
      </para>

    <informalexample>
      <screen>
$ svn propget svn:auto-props --show-inherited-props -v calc
Inherited properties on 'calc',
from 'http://svn.example.com/repos':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
</screen>
    </informalexample>

    <!--
      <para>Unlike the <literal>svn:global-ignores</literal> property and
        its analogous runtime configuration
        <literal>global-ignores</literal>, which are combined, the
        <literal>svn:auto-props</literal> property
        <emphasis>overrides</emphasis> the <literal>auto-props</literal>
        runtime configuration if it defines an auto-prop for the
        <emphasis>same</emphasis> pattern as the runtime configuration.
        Automatic properties inherited<footnote><para>Remember that users
        can only inherit properties from paths for which they have read
        access.  So if an administrator sets
        <literal>svn:auto-props</literal> on some high-level parent
        path (e.g. the repository root), they need to be sure all users
        have read access to that path or the desired automatic property
        setting won't kick in.</para></footnote> from one path can also
        override the <emphasis>identical</emphasis> pattern inherited from
        a different path.  The hierarchy of these overrides works as
        follows:</para>
    -->
      <para>属性 <literal>svn:global-ignores</literal> 及其对应的运行时配置
        选项 <literal>global-ignores</literal> 是一起起作用, 但属性
        <literal>svn:auto-props</literal> 和运行时选项
        <literal>auto-props</literal> 的关系就不这样, 如果运行时选项
        <literal>auto-props</literal> 在一个模式上设置了一个自动属性, 而
        属性 <literal>svn:auto-props</literal> 也在 <emphasis>同一个</emphasis>
        模式上设置了自动属性, 那么属性的设置就会覆盖运行时配置选项的设置.
        从一个路径继承而来的自动属性 <footnote><para>用户只能从他拥有读权限
            路径上继承属性, 所以说如果管理员在较高层的父路径上 (例如仓库的
            根目录) 设置了属性 <literal>svn:auto-props</literal>, 他就应该
            确保所有用户都能读取该路径或者期望的自动属性设置不会失效.</para>
        </footnote>也只会覆盖从其他路径继承的 <emphasis>同一个</emphasis> 模式.
        覆盖的先后顺序是:</para>

      <itemizedlist>
        <listitem>
    <!--
          <para>An auto-prop, for a given pattern, defined in
            <literal>svn:auto-props</literal> overrides the same auto-prop
            for the identical pattern in the <literal>auto-props</literal>
            runtime configuration.</para>
    -->
          <para>在 <literal>svn:auto-props</literal> 上定义的, 针对某一模式的
            自动属性会覆盖运行时配置选项 <literal>auto-props</literal> 上设置
            的同一模式的自动属性.</para>
        </listitem>
        <listitem>
    <!--
          <para>If an auto-prop, for a given pattern, is inherited from
            more than one parents' <literal>svn:auto-props</literal>
            property, the nearer path-wise parent overrides the more
            distant parents.</para>
    -->
          <para>对于一个给定的模式而言, 如果它的自动属性继承自多个父路径的
            <literal>svn:auto-props</literal> 属性, 那么在路径上最近的父路径
            的自动属性会覆盖其中父路径.</para>
        </listitem>
        <listitem>
    <!--
          <para>An auto-prop, for a given pattern, defined in a
            <literal>svn:auto-props</literal> property explicitly set on
            a path overrides the same auto-prop(s) for the identical
            pattern inherited from any parents.</para>
    -->
          <para>对一个给定的模式而言, 如果在路径的 <literal>svn:auto-props
            </literal> 属性上显式地设置了一个自动属性, 那它就会覆盖从其他路径
            继承而来的相同模式上的自动属性.</para>
        </listitem>
      </itemizedlist>

    <!--
      <para>Let's look at an example.  Suppose you have this runtime
        configuration:</para>
    -->
      <para>举例来说, 假设你有一个如下所示的运行时配置:</para>

    <informalexample>
      <screen>
[miscellany]
enable-auto-props = yes
[auto-props]
*.py  = svn:eol-style=CR
*.c   = svn:eol-style=CR
*.h   = svn:eol-style=CR
*.cpp = svn:eol-style=CR
</screen>
    </informalexample>

    <!--
      <para>And you want to add three files in the <filename>calc</filename>
        directory of your working copy:</para>
    -->
      <para>你想添加 <filename>calc</filename> 目录中的三个文件:</para>

    <informalexample>
      <screen>
$ svn st
?       calc/data-binding.cpp
?       calc/data.c
?       calc/editor.py
</screen>
    </informalexample>

    <!--
      <para>Let's check what <literal>svn:auto-props</literal> apply to
        <filename>calc</filename>:</para>
    -->
      <para>先看一下 <filename>calc</filename> 的 <literal>svn:auto-props
      </literal> 属性:</para>

    <informalexample>
      <screen>
$ svn propget svn:auto-props -v --show-inherited-props calc
Inherited properties on 'calc',
from 'http://svn.example.com/repos':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Inherited properties on 'calc',
from '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:keywords=Author Date Id Rev URL
</screen>
    </informalexample>

    <!--
      <para>When we add these three files what auto-props do we expect?
        We add the trio to version control and then check:</para>
    -->
      <para>添加这三个文件, 然后检查它们的自动属性:</para>

    <informalexample>
      <screen>
$ svn add calc --force
A         calc/data-binding.cpp
A         calc/data.c
A         calc/editor.py
</screen>
    </informalexample>

    <!--
      <para>The file <filename>data-binding.cpp</filename> has only one
        matching pattern, <literal>*.cpp = svn:eol-style=CR</literal>
        in the runtime configuration, so obviously the
        <literal>svn:eol-style</literal> property is set to
        <literal>CR</literal>:</para>
    -->
      <para>文件 <filename>data-binding.cpp</filename> 只有一个匹配的模式,
        也就是运行时配置选项里的 <literal>*.cpp = svn:eol-style=CR</literal>,
        显然文件的属性 <literal>svn:eol-style</literal> 被设置为 <literal>CR
      </literal>:</para>

    <informalexample>
      <screen>
$ svn proplist -v calc/data-binding.cpp
Properties on 'calc/data-binding.cpp':
  svn:eol-style
    CR
</screen>
    </informalexample>

    <!--
      <para>The file <filename>editor.py</filename> matches a single
        pattern in runtime config and both of the
        <literal>svn:auto-props</literal> properties, but by the hierarchy
        described above, the property explicitly set on
        <filename>calc</filename>,
        <literal>*.py = svn:eol-style=native</literal>, takes precedence.
        So the <literal>svn:eol-style</literal> property is set to
        <literal>native:</literal>:</para>
    -->
      <para>文件 <filename>editor.py</filename> 既匹配运行时配置选项里的一
        条模式, 也匹配属性 <literal>svn:auto-props</literal> 里的模式, 根据前
        面介绍的覆盖顺序, 显式设置在 <filename>calc</filename> 上的属性值
        (<literal>*.py = svn:eol-style=native</literal>) 的优先级较高, 所以
        属性 <literal>svn:eol-style</literal> 被设置为 <literal>native</literal>
        :</para>

    <informalexample>
      <screen>
$ svn proplist -v calc/editor.py
Properties on 'calc/editor.py':
  svn:eol-style
    native
</screen>
    </informalexample>

    <!--
      <para>The file <filename>data.c</filename> also matches patterns
        in the runtime config and both of the inherited
        <literal>svn:auto-props</literal> properties.  The
        <literal>svn:keywords</literal> auto-prop is only defined once,
        on <filename>calc</filename>, so <filename>data.c</filename>
        automatically gets that property.  The
        <literal>svn:auto-props</literal> on <filename>calc</filename>
        don't define a <literal>svn:eol-style</literal> value however, so
        the nearest inherited parent,
        <literal>http://svn.example.com/repos</literal>,
        provides that value:</para>
    -->
      <para>文件 <filename>data.c</filename> 同时匹配运行时配置选项和继承属性
        <literal>svn:auto-props</literal> 的模式. 自动属性 <literal>
          svn:keywords</literal> 只被定义了一次, 在 <filename>calc</filename>
        上定义, 所以 <filename>data.c</filename> 自动获取了该属性.
        <filename>calc</filename> 上的 <literal>svn:auto-props</literal> 没有
        为 <literal>svn:eol-style</literal> 定义值, 所以最近的父路径
        <literal>http://svn.example.com/repos</literal> 提供了这个值:</para>

    <informalexample>
      <screen>
$ svn proplist -v calc/data.c
Properties on 'calc/data.c':
  svn:eol-style
    native
  svn:keywords
    Author Date Id Rev URL
</screen>
    </informalexample>

      <warning>
    <!--
        <para>Overriding auto-props only applies for
          <emphasis>identical</emphasis> patterns.  If a file to be added
          or imported matches more than one pattern, then there is no
          guarantee which pattern's auto-props will be applied.  For
          example, say you want to add the file
          <filename>foo.cpp</filename> in the directory
          <filename>bar</filename>.  Further, suppose the
          <literal>svn:auto-props</literal> property is set on
          <filename>bar</filename> with the value:</para>
    -->
        <para>自动属性的覆盖只发生在 <emphasis>相同的</emphasis> 模式上, 如果
          新增的文件同时匹配多个模式, 那就无法确定最终应用的是哪一个自动属性.
          比如说用户想把文件 <filename>foo.cpp</filename> 添加到目录
          <filename>bar</filename>, 而 <filename>bar</filename> 的属性
          <literal>svn:auto-props</literal> 的值是:</para>

    <informalexample>
      <screen>
*.c*  = svn:eol-style=native
*.cpp = svn:eol-style=native;svn:keywords=Author Date Id Rev URL
</screen>
    </informalexample>

    <!--
        <para>Since <filename>foo.cpp</filename> matches both patterns,
          there is no way to know if the <literal>svn:keywords</literal>
          property will be set on <filename>foo.cpp</filename> when it
          is added.</para>
    -->
        <para>因为 <filename>foo.cpp</filename> 同时匹配两个不同的模式, 所以
          我们没办法事先确定属性 <literal>svn:keywords</literal> 是否被设置到
          <filename>foo.cpp</filename> 上.</para>
      </warning>

    <!--
      <para>A final note on <literal>svn:auto-props</literal>.  This
        property (along with the similar
        <literal>svn:global-ignores</literal>, see
        <xref linkend="svn.advanced.props.special.ignore"/>)
        only provides a <emphasis>recommendation</emphasis> to clients
        that understand the meaning of the property.  Older clients will
        ignore these properties, the <option>- -no-auto-props</option>
        option will disregard them, a user might manually change or remove
        automatic properties after they have been set&mdash;there are
        numerous ways in which the recommended properties contained in
        <literal>svn:auto-props</literal> can be by-passed.  Given
        this, administrators will still need to use hook scripts to
        validate that the properties added to and modified on files
        and directories match the administrator's preferred policies,
        rejecting commits which are non-compliant in this fashion.
        (See <xref linkend="svn.reposadmin.hooks"/> for more about
        hook scripts.)</para>
    -->
      <para><literal>svn:auto-props</literal> 最后一个需要注意的地方是它 (以
        及类似的 <literal>svn:global-ignores</literal>, 见
        <xref linkend="svn.advanced.props.special.ignore"/>) 只是向理解属性
        的客户端工具提供了一个建议, 较老的客户端会忽略这些属性, 选项
        <option>--no-auto-props</option> 会忽略它们, 用户可能会选择手动地修改
        或删除自动属性&mdash;有很多方法可以旁路掉包含在 <literal>svn:auto-props
        </literal> 里的推荐属性. 因此, 管理员仍然需要使用钩子脚本验证文件和
        目录上的属性是否符合管理员的策略, 并拒绝与策略不兼容的提交 (钩子脚本见
        <xref linkend="svn.advanced.props.special.ignore"/>).</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.ref">
    <!--
      <title>Subversion's Reserved Properties</title>
    -->
      <title>Subversion 的保留属性</title>

    <!--
      <para>In this section, we'll briefly summarize all the
        properties which Subversion reserves for its own use.  We'll
        look at both types of properties&mdash;those which are
        associated with individual versioned files and directories,
        and those which are associated with revisions.</para>
    -->
      <para>本节将对 Subversion 所有的保留属性做一个简单的总结, 包括版本化的
        的属性 (和文件, 目录关联) 与非版本化的属性 (和版本号关联).</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.props.ref.versioned">
    <!--
        <title>Versioned properties</title>
    -->
        <title>版本化的属性</title>

    <!--
        <para>These are the versioned (or node) properties that
          Subversion reserves for its own use:</para>
    -->
        <para>这些是 Subversion 保留给自己用的版本化属性:</para>

        <variablelist>
  
          <varlistentry>
            <term><literal>svn:auto-props</literal></term>
            <listitem>
    <!--
              <para>If present on a directory, the value is a set of
                automatic property definitions which apply to all files
                under the directory, See
                <xref linkend="svn.advanced.props.auto" />.</para>
    -->
              <para>该属性包含了一系列的自动属性定义, 如果被设置在一个目录上,
                那么自动属性定义会应用到目录内的所有文件, 见
                <xref linkend="svn.advanced.props.auto"/>.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:executable</literal></term>
            <listitem>
    <!--
              <para>If present on a file, the client will make the file
                executable in Unix-hosted working copies.  See
                <xref linkend="svn.advanced.props.special.executable"
                />.</para>
    -->
            <para>如果该属性被设置到一个文件上, 那客户端就会给 Unix 工作副本里
              的文件设置上可执行权限, 见
              <xref linkend="svn.advanced.props.special.executable"/>.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:mime-type</literal></term>
            <listitem>
    <!--
              <para>If present on a file, the value indicates the file's
                MIME type.  This allows the client to decide whether
                line-based contextual merging is safe to perform during
                updates, and can also affect how the file behaves when
                fetched via a web browser.  See
                <xref linkend="svn.advanced.props.special.mime-type"
                />.</para>
    -->
            <para>如果属性出现在一个文件上, 那么属性值指出了文件的 MIME 类型,
              当更新时, 属性可以帮助客户端判断是否可以安全地对文件进行基于行
              的合并操作. 另外, 当用户通过网页浏览器获取文件时, 该属性还会影
              响文件的具体行为. 更多的信息参考
              <xref linkend="svn.advanced.props.special.mime-type"/>.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:ignore</literal></term>
            <listitem>
    <!--
              <para>If present on a directory, the value is a list of
                <emphasis>unversioned</emphasis> file patterns to be
                ignored by <command>svn status</command> and other
                subcommands.  See
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
    -->
            <para>如果该属性出现在一个目录上, 属性值是一个未被版本化的文件
              模式列表, 符合模式的文件会被 <command>svn status</command> 和
              其他子命令忽略, 见
              <xref linkend="svn.advanced.props.special.ignore"/>.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:global-ignores</literal></term>
            <listitem>
    <!--
              <para>If present on a directory, the value is a list of
                <emphasis>unversioned</emphasis> file patterns to be
                ignored by <command>svn status</command> and other
                subcommands.  Unlike <literal>svn:ignore</literal> these
                patterns apply to <emphasis>all</emphasis> unversioned
                subtrees under the directory, not just the directory's
                immediate file children.  See
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
    -->
            <para>如果该属性出现在一个目录上, 属性值是一个未被版本化的文件
              模式列表, 符合模式的文件会被 <command>svn status</command> 和
              其他子命令忽略, 但是和 <literal>svn:ignore</literal> 不同的是,
              这些模式会应用到目录内 <emphasis>所有的</emphasis> 子目录及其
              子文件, 而不仅仅是目录的直接子文件, 见
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:keywords</literal></term>
            <listitem>
    <!--
              <para>If present on a file, the value tells the client how
                to expand particular keywords within the file.  See
                <xref linkend="svn.advanced.props.special.keywords"
                />.</para>
    -->
            <para>如果该属性出现在一个文件上, 属性的值指出了客户端应该如何
              扩展文件内的特定关键字, 见
                <xref linkend="svn.advanced.props.special.keywords" />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:eol-style</literal></term>
            <listitem>
    <!--
              <para>If present on a file, the value tells the client how
                to manipulate the file's line-endings in the working
                copy and in exported trees.  See
                <xref linkend="svn.advanced.props.special.eol-style" />
                and <xref linkend="svn.ref.svn.c.export" />.</para>
    -->
              <para>如果该属性出现在一个文件上, 则属性的值指出了客户端应该如何
                处理工作副本和导出目录里的文件的行终止符, 见
                <xref linkend="svn.advanced.props.special.eol-style" />
                和 <xref linkend="svn.ref.svn.c.export" />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:externals</literal></term>
            <listitem>
    <!--
              <para>If present on a directory, the value is a multiline
                list of other paths and URLs the client should check
                out.  See <xref linkend="svn.advanced.externals"
                />.</para>
    -->
            <para>如果该属性出现在一个目录上, 则属性的值是一个包含了多个路径
              和 URL 的列表, 这些路径和 URL 都是客户端需要检出的内容, 见
              <xref linkend="svn.advanced.externals"/>.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:special</literal></term>
            <listitem>
    <!--
              <para>If present on a file, indicates that the file is not
                an ordinary file, but a symbolic link or other special
                object.<footnote><para>As of this writing, symbolic
                links are indeed the only <quote>special</quote>
                objects.  But there might be more in future releases of
                Subversion.</para></footnote></para>
    -->
          <para>如果该属性出现在一个文件上, 则表示该文件不是一个普通的文件,
            可能是一个符号链接或其他特殊的对象<footnote><para>在写到这里时,
                符号链接是已知的唯一一个 <quote>特殊</quote> 对象, 在以后
                的版本里可能会出现更多种类的特殊对象.</para></footnote></para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:needs-lock</literal></term>
            <listitem>
    <!--
              <para>If present on a file, tells the client to make the
                file read-only in the working copy, as a reminder that
                the file should be locked before editing begins.  See
                <xref linkend="svn.advanced.locking.lock-communication"
                />.</para>
    -->
            <para>如果该属性出现在一个文件上, 客户端就会把工作副本里的这个
              文件设置成只读, 也就是提醒用户在编辑文件之前需要加锁, 见
                <xref linkend="svn.advanced.locking.lock-communication"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:mergeinfo</literal></term>
            <listitem>
    <!--
              <para>Used by Subversion to track merge data.  See
                <xref linkend="svn.branchmerge.basicmerging.mergeinfo"
                /> for details, but you should never edit this property
                unless you <emphasis>really</emphasis> know what you're
                doing.</para>
    -->
              <para>Subversion 使用该属性跟踪合并信息, 更多的细节见
                <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>,
                除非你 <emphasis>真得</emphasis> 知道自己在做什么, 否则不要
                编辑该属性.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.props.ref.unversioned">
    <!--
        <title>Unversioned properties</title>
    -->
        <title>未版本化的属性</title>

    <!--
        <para>The following are the unversioned (or revision) properties
          that Subversion reserves for its own use.  Most of these
          appear on every revision in the repository, carrying important
          information about the origin and nature of the changes made in
          that revision.</para>
    -->
        <para>下面是保留给 Subversion 私用的版本化的 (或版本号) 属性, 它们中
          的大部分都会出现在仓库的每个版本号上, 属性携带了关于修改的起因与
          本质.</para>
  
        <variablelist>
  
          <varlistentry>
            <term><literal>svn:author</literal></term>
            <listitem>
    <!--
              <para>If present, contains the authenticated username of
                the person who created the revision.  (If not present,
                the revision was committed anonymously.)</para>
    -->
              <para>如果设置了该属性, 则属性包含了创建此版本号用户名,
                如果没有该属性, 那么版本号是匿名提交的.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:autoversioned</literal></term>
            <listitem>
    <!--
              <para>If present, the revision was created via the
                autoversioning feature.  See
                <xref linkend="svn.webdav.autoversioning" />.</para>
    -->
              <para>如果设置了该属性, 则说明版本号是通过自动版本化特性创建的,
                见 <xref linkend="svn.webdav.autoversioning" />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:date</literal></term>
            <listitem>
    <!--
              <para>Contains the UTC time the revision was created, in
                ISO 8601 format.  The value comes from the
                <emphasis>server</emphasis> machine's clock, not the
                client's.</para>
    -->
              <para>包含了版本号创建时的 UTC 时间, 使用 ISO 8601 格式,
                时间来自 <emphasis>服务器</emphasis> 的机器时钟, 而不是客户
                端的时钟.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:log</literal></term>
            <listitem>
    <!--
              <para>Contains the log message describing the
                revision.</para>
    -->
              <para>包含了描述版本号的日志消息.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>
  
    <!--
        <para>Certain auxiliary tools in the Subversion
          toolchain&mdash;namely, <command>svnrdump</command>
          and <command>svnsync</command>&mdash;also use unversioned
          properties for their own accounting purposes.  These
          properties are found only on revision 0 of repositories on
          which these tools are operating.  For more about
          <command>svnrdump</command> and <command>svnsync</command> and
          the functionality they offer, see
          <xref linkend="svn.reposadmin" />.  The following are the
          properties created and managed by these tools.</para>
    -->
        <para>Subversion 的某些辅助工具&mdash;<command>svnrdump</command> 和
          <command>svnsync</command>&mdash;也会使用未版本化的属性完成记帐工作,
          这些属性只会出现在仓库的版本号 0 上, 关于 <command>svnrdump</command>
          和 <command>svnsync</command> 的更多信息, 见
          <xref linkend="svn.reposadmin"/>. 下面是由 <command>svnrdump</command>
          和 <command>svnsync</command> 创建并管理的属性.</para>
  
        <variablelist>
  
          <varlistentry>
            <term><literal>svn:rdump-lock</literal></term>
            <listitem>
    <!--
              <para>Used to temporarily enforce mutually exclusive
                access to the repository by <command>svnrdump
                load</command>.  This property is generally only
                observed when such an operation is active&mdash;or when
                an <command>svnrdump</command> command failed to cleanly
                disconnect from the repository.  (This property is only
                relevant when it appears on revision 0.)</para>
    -->
              <para>为 <command>svnrdump load</command> 访问仓库临时施加互斥
                性, 通常只有在 <command>svnrdump load</command> 活动时&mdash;
                或者在 <command>svnrdump</command> 不能干净地与仓库断开连接时
                &mdash;该属性才会被观察到 (只有当这个属性出现在版本号 0 上时,
                它才是有意义的).</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-currently-copying</literal></term>
            <listitem>
    <!--
              <para>Contains the revision number from the source
                repository which is currently being mirrored to this one
                by the <command>svnsync</command> tool.  (This property
                is only relevant when it appears on revision 0.)</para>
    -->
              <para>包含了源仓库中已经被 <command>svnsync</command> 镜像备份
                的版本号 (只有当这个属性出现在版本号 0 上时, 它才是有意义的).
              </para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-from-uuid</literal></term>
            <listitem>
    <!--
              <para>Contains the UUID of the repository of which this
                repository has been initialized as a mirror by
                the <command>svnsync</command> tool.  (This property is
                only relevant when it appears on revision 0.)</para>
    -->
              <para>包含了由 <command>svnsync</command> 创建的镜像的源仓库的
                UUID (只有当这个属性出现在版本号 0 上时, 它才是有意义的).
              </para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-from-url</literal></term>
            <listitem>
    <!--
              <para>Contains the URL of the repository directory of
                which this repository has been initialized as a mirror
                by the <command>svnsync</command> tool.  (This property
                is only relevant when it appears on revision 0.)</para>
    -->
              <para>包含了由 <command>svnsync</command> 创建的镜像的源仓库目录
                的 URL (只有当这个属性出现在版本号 0 上时, 它才是有意义的).
              </para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-last-merged-rev</literal></term>
            <listitem>
    <!--
              <para>Contains the revision of the source repository which
                was most recently and successfully mirrored to this one.
                (This property is only relevant when it appears on
                revision 0.)</para>
    -->
              <para>包含了最近一次被成功地镜像备份的源仓库的版本号 (只有当这
                个属性出现在版本号 0 上时, 它才是有意义的).</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-lock</literal></term>
            <listitem>
    <!--
              <para>Used to temporarily enforce mutually exclusive
                access to the repository by <command>svnsync</command>
                mirroring operations.  This property is generally only
                observed when such an operation is active&mdash;or when
                an <command>svnsync</command> command failed to cleanly
                disconnect from the repository.  (This property is
                only relevant when it appears on revision 0.)</para>
    -->
              <para>为 <command>svnsync</command> 的镜像操作临时添加仓库访问
                的互斥性, 通常只有在 <command>svnsync</command> 活动时&mdash;
                或者在 <command>svnsync</command> 不能干净地与仓库断开连接时,
                只有当这个属性出现在版本号 0 上时, 它才是有意义的).</para>
            </listitem>
          </varlistentry>
  
        </variablelist>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.file-portability">
    <!--
    <title>File Portability</title>
    -->
    <title>文件的可移植性</title>

    <!--
    <para>Fortunately for Subversion users who routinely find
      themselves on different computers with different operating
      systems, Subversion's command-line program behaves almost
      identically on all those systems.  If you know how to wield
      <command>svn</command> on one platform, you know how to wield it
      everywhere.</para>
    -->
    <para>对于经常需要在不同的操作系统中工作的用户来说, 比较幸运的一点是
      Subversion 命令行工具在所有系统中的表现几乎都是相同的, 如果用户已经知道
      了如何在一种系统中使用 <command>svn</command>, 那他也就知道了如何在其他
      系统中使用 <command>svn</command>.</para>

    <!--
    <para>However, the same is not always true of other general classes
      of software or of the actual files you keep in Subversion.  For
      example, on a Windows machine, the definition of a <quote>text
      file</quote> would be similar to that used on a Linux box, but
      with a key difference&mdash;the character sequences used to mark
      the ends of the lines of those files.  There are other
      differences, too.  Unix platforms have (and Subversion supports)
      symbolic links; Windows does not.  Unix platforms use filesystem
      permission to determine executability; Windows uses filename
      extensions.</para>
    -->
    <para>然而, 其他软件或存放在 Subversion 仓库里的文件并不都是这样. 比如说
      在一台 Windows 机器上, 对于 <quote>文本文件</quote> 定义和 Linux 机器类
      似, 除了一点&mdash;标记一行结束的字符序列不同. 除此之外, Unix 平台 (和
      Subversion) 支持符号链接, 而 Windows 不支持; Unix 平台根据文件系统权限
      来判断文件的可执行性, 而 Windows 是根据文件的扩展名.</para>

    <!--
    <para>Because Subversion is in no position to unite the whole
      world in common definitions and implementations of all of these
      things, the best it can do is to try to help make your life
      simpler when you need to work with your versioned files and
      directories on multiple computers and operating systems.  This
      section describes some of the ways Subversion does this.</para>
    -->
    <para>Subversion 并不想把整个世界都统一到公共的定义和实现上, 当用户要在多
      种不同的操作系统中管理文件与目录时, 它所能做的只是尽量减少用户的麻烦.
      本节介绍 Subversion 如何帮助用户在多种不同的平台中使用 Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.mime-type">
    <!--
      <title>File Content Type</title>
    -->
      <title>文件内容类型</title>
      
    <!--
      <para>Subversion joins the ranks of the many applications that
        recognize and make use of Multipurpose Internet Mail
        Extensions (MIME) content types.  Besides being a
        general-purpose storage location for a file's content type,
        the value of the <literal>svn:mime-type</literal> file
        property determines some behavioral characteristics of
        Subversion itself.</para>
    -->
      <para>和许多应用程序一样, Subversion 也会使用 MIME (多用途互联网邮件扩展
        类型, Multipurpose Internet Mail Extensions) 内容类型. 属性
        <literal>svn:mime-type</literal> 除了可以作为文件内容类型的存放位置,
        它的值还决定了 Subversion 的某些行为特征.</para>

      <sidebar>
    <!--
        <title>Identifying File Types</title>
    -->
        <title>识别文件类型</title>
    
    <!--
        <para>Various programs on most modern operating systems make
          assumptions about the type and format of the contents of a
          file by the file's name, specifically its file extension.
          For example, files whose names end in
          <filename>.txt</filename> are generally assumed to be
          human-readable; that is, able to be understood by simple perusal
          rather than requiring complex processing to decipher.  Files
          whose names end in <filename>.png</filename>, on the other
          hand, are assumed to be of the Portable Network Graphics
          type&mdash;not human-readable at all, and sensible only when
          interpreted by software that understands the PNG format and
          can render the information in that format as a raster
          image.</para>
    -->
        <para>很多程序都会根据文件的名字&mdash;尤其是扩展名&mdash;对文件内容
          的类型和格式作出一些假定, 比如说文件名以 <filename>.txt</filename> 结
          尾的文件通常被认为是人类可读的, 也就是说用户可以通过简单的阅读来理解
          文件的内容, 而不需要经过复杂的译解过程. 另一方面, 文件名以 <filename>
            .png</filename> 结尾的文件通常会被当作可移植网络图像 (Portable
          Network Graphics, PNG) 格式&mdash;它们不是人类可读的类型, 只有理解
          PNG 格式的软件才能把文件内容以适当的形式展现出来.</para>

    <!--
        <para>Unfortunately, some of those extensions have changed
          their meanings over time.  When personal computers first appeared,
          a file named <filename>README.DOC</filename> would have
          almost certainly been a plain-text file, just like today's
          <filename>.txt</filename> files.  But by the mid-1990s, you
          could almost bet that a file of that name would not be a
          plain-text file at all, but instead a Microsoft Word
          document in a proprietary, non-human-readable format.  But
          this change didn't occur overnight&mdash;there was certainly
          a period of confusion for computer users over what exactly
          they had in hand when they saw a <filename>.DOC</filename>
          file.<footnote><para>You think that was rough?  During that
          same era, WordPerfect also used <filename>.DOC</filename>
          for their proprietary file format's preferred
          extension!</para></footnote></para>
    -->
    <para>不幸的是, 有些扩展名的意义会随着时间而发生变化. 当个人计算机首次出
      现时, 如果有一个名为 <filename>README.DOC</filename> 的文件, 那就几乎可
      以确定它是个纯文本文件, 就像现在的 <filename>.txt</filename> 文件, 但是
      在 90 年代中期, 同样名字的文件很可能是一个 Microsoft Word 文档, 它采用
      了一种私有的, 人类不可读的文件格式. 不过这种变化并非一蹴而就&mdash;曾经
      有一段时间, 当计算机用户看到一个 <filename>.DOC</filename> 文件时, 常常
      想不清楚文件的格式到底是什么类型.<footnote><para>雪上加霜的是, 当时还
          有一款叫作 WordPerfect 的软件也使用 <filename>.DOC</filename>
          作为他们的私有文件格式的扩展名!</para></footnote></para>

    <!--
        <para>The popularity of computer networking cast still more
          doubt on the mapping between a file's name and its content.
          With information being served across networks and generated
          dynamically by server-side scripts, there was often no real
          file per se, and therefore no filename.  Web
          servers, for example, needed some other way to tell browsers
          what they were downloading so that the browser could do something
          intelligent with that information, whether that was to
          display the data using a program registered to handle that
          datatype or to prompt the user for where on the client
          machine to store the downloaded data.</para>
    -->
        <para>计算机网络在文件名与文件类型的关系上更加疑惑. 信息跨网络地传输,
          并且由服务器端的脚本动态生成, 本质上不能算作真正的文件, 也就不存在
          文件名. 比如说, 网页服务器需要通过其他途径告诉浏览器它们正在下载的
          文件是什么类型, 这样的话针对文件, 浏览器可以采取更加智能的做法, 比
          如用一个对应的程序打开文件, 或提示用户应该把下载的文件放到哪个目录
          下.</para>

    <!--
        <para>Eventually, a standard emerged for, among other things,
          describing the contents of a data stream.  In 1996, RFC 2045
          was published.  It was the first of five RFCs describing
          MIME.  It describes the concept of media types and subtypes
          and recommends a syntax for the representation of those
          types.  Today, MIME media types&mdash;or <quote>MIME
          types</quote>&mdash;are used almost universally across
          email applications, web servers, and other software as the
          de facto mechanism for clearing up the file content
          confusion.</para>
    -->
        <para>最终总算有一个描述数据流内容的标准出现了. 1996 年, RFC 2045
          发布, 它是描述 MIME 的 5 篇 RFC 文档的第一篇. 文档介绍的概念包括
          媒体类型及其子类型, 并推荐了一种表示这些类型的语法. 如今, MIME 媒体
          类型&mdash;或 <quote>MIME 类型</quote>&mdash;被广泛地应用在邮件程序,
          网页服务器等软件中, 作为一种解决文件内容格式混乱的事实标准.</para>

      </sidebar>
    
    <!--
      <para>For example, one of the benefits that Subversion typically
        provides is contextual, line-based merging of changes received
        from the server during an update into your working file.  But
        for files containing nontextual data, there is often no
        concept of a <quote>line.</quote>  So, for versioned files
        whose <literal>svn:mime-type</literal> property is set to a
        nontextual MIME type (generally, something that doesn't begin
        with <literal>text/</literal>, though there are exceptions),
        Subversion does not attempt to perform contextual merges
        during updates.  Instead, any time you have locally modified a
        binary working copy file that is also being updated, your file
        is left untouched and Subversion creates two new files.  One
        file has a <filename>.oldrev</filename> extension and contains
        the BASE revision of the file.  The other file has a
        <filename>.newrev</filename> extension and contains the
        contents of the updated revision of the file.  This behavior
        is really for the protection of the user against failed
        attempts at performing contextual merges on files that simply
        cannot be contextually merged.</para>
    -->
      <para>比如说, Subversion 提供的一项特性是在更新工作副本时, 支持基于行
        的文件内容合并, 但是二进制文件没有 <quote>行</quote> 的概念, 于是,
        如果文件的 <literal>svn:mime-type</literal> 属性被设置成非文本 MIME
        类型 (非文本的 MIME 类型通常不以 <literal>text/</literal> 开始, 但是也有
        例外), Subversion 就不会对文件执行合并操作. 作为替代, 如果被更新的二
        进制文件含有本地修改, 那文件就不会被更新, Subversion 会另外创建两个
        新的文件, 其中一个的扩展名是 <filename>.oldrev</filename>, 对应文件的
        BASE 版本号; 另一个的扩展名是 <filename>.newrev</filename>, 对应更新
        后的版本号. 这样做是为了避免对不支持合并的文件进行合并而带来的错误.
      </para>

    <!--
      <para>Additionally, since the acts of displaying line-based
        differences and line-based change attribution are, rather
        obviously, dependent on there being a meaningful definition
        of <quote>line</quote> for a given file, files with nontextual
        MIME types will by default trigger errors when used as the
        targets of <command>svn diff</command> and <command>svn
        annotate</command> operations.  This can be especially
        frustrating for users with XML files whose
        <literal>svn:mime-type</literal> property is set to something
        such as <literal>application/xml</literal> which is not
        unambiguously human-readable and as such is treated as
        nontextual by Subversion.  Fortunately, those subcommands
        offer a <option>- -force</option> option for forcing
        Subversion to attempt the operations in spite of the apparent
        non-human-readability of the files.</para>
    -->
      <para>另外, 为了能够以行为单位显示修改, 文件必须能被划分成
        <quote>行</quote>, 如果 <command>svn diff</command> 和
        <command>svn annotate</command> 的目标文件的 MIME 类型是非文本的, 这
        两个命令默认会报错. 如果用户的文件是 XML 文件, 它们的 <literal>
          svn:mime-type</literal> 被设置成 <literal>application/xml</literal>,
        虽然它们是人类可读的文本文件, 但 Subversion 仍然会把它们看成是非文本
        文件, 幸好, 为命令添加选项 <option>--force</option> 可以强制 Subversion
        不管文件的 MIME 类型, 直接执行操作.</para>

      <warning>
    <!--
        <para>The <literal>svn:mime-type</literal> property, when set
          to a value that does not indicate textual file contents, can
          cause some unexpected behaviors with respect to other
          properties.  For example, since the idea of line endings
          (and therefore, line-ending conversion) makes no sense when
          applied to nontextual files, Subversion will prevent you
          from setting the <literal>svn:eol-style</literal> property
          on such files.  This is obvious when attempted on a single
          file target&mdash;<command>svn propset</command> will error
          out.  But it might not be as clear if you perform a
          recursive property set, where Subversion will silently skip
          over files that it deems unsuitable for a given
          property.</para>
    -->
        <para>如果属性 <literal>svn:mime-type</literal> 的值不能说明文件内容
          是文本的, 这将会给其他属性造成意想不到的影响. 例如, 二进制文件没有
          行的概念, 所以 Subversion 不允许为二进制文件设置属性 <literal>
            svn:eol-style</literal>. 如果命令的目标是单一的文件, 那么就很
          容易看出来&mdash;<command>svn propset</command> 会报错退出, 但是,
          如果用户递归地执行属性设置命令, 可能就没那么明显了: 如果 Subversion
          觉得某个文件不适合设置给定的属性, 它就会悄无声息地跳过该文件.
        </para>
      </warning>

    <!--
      <para>Subversion provides a number of mechanisms by which to
        automatically set the <literal>svn:mime-type</literal>
        property on a versioned file.  See
        <xref linkend="svn.advanced.props.auto" /> for details.</para>
    -->
      <para>Subversion 提供了多种用于自动设置属性 <literal>svn:mime-type
        </literal> 的机制, 详细的介绍见 
        <xref linkend="svn.advanced.props.auto" />.</para>

    <!--
      <para>Also, if the <literal>svn:mime-type</literal> property is
        set, then the Subversion Apache module will use its value to
        populate the <literal>Content-type:</literal> HTTP header when
        responding to GET requests.  This gives your web browser a
        crucial clue about how to display a file when you use it to
        peruse your Subversion repository's contents.</para>
    -->
      <para>另外, 如果文件设置了属性 <literal>svn:mime-type</literal>, 响应
        GET 请求时, Subversion Apache 模块将会使用属性的值填充 HTTP 头部的
        <literal>Content-type</literal> 字段. 如果用户使用浏览器查看仓库的内容,
        这可以提示浏览器应该如何显示文件.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.executable">
    <!--
      <title>File Executability</title>
    -->
      <title>文件的可执行性</title>
 
    <!--
      <para>On many operating systems, the ability to execute a file
        as a command is governed by the presence of an execute
        permission bit.  This bit usually defaults to being disabled,
        and must be explicitly enabled by the user for each file that
        needs it.  But it would be a monumental hassle to have to
        remember exactly which files in a freshly checked-out working
        copy were supposed to have their executable bits toggled on,
        and then to have to do that toggling.  So, Subversion provides
        the <literal>svn:executable</literal> property as a way to
        specify that the executable bit for the file on which that
        property is set should be enabled, and Subversion honors that
        request when populating working copies with such files.</para>
    -->
      <para>在很多操作系统里, 一个文件是否可以执行取决于该文件是否设置了
        可执行权限位. 该位默认是不开启的, 如果用户需要可执行权限, 必须显式地
        开启它. 但是记住应该为哪些检出的文件设置可执行位是一件很麻烦的事情,
        所以 Subversion 提供了属性 <literal>svn:executable</literal>, 如果文件
        设置了该属性, Subversion 就会在工作副本里打开文件的可执行位.</para>

    <!--
      <para>This property has no effect on filesystems that have no
        concept of an executable permission bit, such as FAT32 and
        NTFS.<footnote><para>The Windows filesystems use file
        extensions (such
        as <filename>.EXE</filename>, <filename>.BAT</filename>, and
        <filename>.COM</filename>) to denote executable
        files.</para></footnote>  Also, although it has no defined
        values, Subversion will force its value
        to <literal>*</literal> when setting this property.  Finally,
        this property is valid only on files, not on
        directories.</para>
    -->
      <para>该属性对不支持可执行位的文件系统是没有效果的, 比如 FAT32 和 NTFS.
        <footnote><para>Windows 的文件系统使用文件的扩展名 (比如 <filename>
              .EXE</filename>, <filename>.BAT</filename> 和 <filename>.COM
        </filename>) 表示文件是可执行的.</para></footnote> 另外, 尽管该属性
        没有预定义的值, 在设置属性时, Subversion 强制把它的值设置为
        <literal>*</literal>. 最后, 该属性只对文件有效, 对目录不起作用.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.eol-style">
    <!--
      <title>End-of-Line Character Sequences</title>
    -->
      <title>行结束标记</title>

    <!--
      <para>Unless otherwise noted using a versioned file's
        <literal>svn:mime-type</literal> property, Subversion
        assumes the file contains human-readable data.  Generally
        speaking, Subversion uses this knowledge only to determine
        whether contextual difference reports for that file are
        possible.  Otherwise, to Subversion, bytes are bytes.</para>
    -->
      <para>除非属性 <literal>svn:mime-type</literal> 进行了额外说明, 否则
        Subversion 总是假设文件的内容是人类可读的. 一般来说, Subversion 会根据
        自己的知识来判断是否可以对文件进行基于上下文的差异比较, 如果不能的话, 就
        按字节比较差异.</para>
      
      <para>
        <indexterm>
          <primary>line endings (行结束标记)</primary>
        </indexterm>
        <indexterm>
          <primary>end-of-line (EOL) markers (EOL 标记)</primary>
          <see>line endings (行结束标记)</see>
    <!--
        </indexterm>This means that by default, Subversion doesn't pay
        any attention to the type of <firstterm>end-of-line (EOL)
        markers</firstterm> used in your files.  Unfortunately,
        different operating systems have different conventions about
        which character sequences represent the end of a line of text
        in a file.  For example, the usual line-ending token used by
        software on the Windows platform is a pair of ASCII control
        characters&mdash;a carriage return (<literal>CR</literal>)
        followed by a line feed (<literal>LF</literal>).  Unix
        software, however, just uses the <literal>LF</literal>
        character to denote the end of a line.</para>
    -->
        </indexterm>Subversion 默认情况下并不关心文件的 <firstterm>
        行结束 (EOL) 标记</firstterm> (<firstterm>end-of-line (EOL) markers
      </firstterm>) 类型. 不幸的是, 如何结束一行, 不同的操作系统有着不同的约
      定. 比如说, Windows 软件使用一对 ASCII 控制字符表示一行的结束&mdash;
      一个回车符 (<literal>CR</literal>) 后面再跟一个换行符 (<literal>LF
        </literal>); 而 Unix 系统中的软件只用单一的换行符 (<literal>LF
      </literal>) 表示一行的结束.</para>

      <para>
        <indexterm>
          <primary>line endings (行结束标记)</primary>
          <secondary>native (本地的)</secondary>
    <!--
        </indexterm>Not all of the various tools on these operating
        systems understand files that contain line endings in a format
        that differs from the <firstterm>native line-ending
        style</firstterm> of the operating system on which they are
        running.  So, typically, Unix programs treat the
        <literal>CR</literal> character present in Windows files as a
        regular character (usually rendered as <literal>^M</literal>),
        and Windows programs combine all of the lines of a Unix file
        into one giant line because no <literal>CR</literal>
        characters are found to denote the ends of the lines.</para>
    -->
      </indexterm>如果文件的行结束标记与操作系统的 <firstterm>本地的行结束风格
        </firstterm> 不同, 有些软件可能无法正确地处理这种文件. 所以在典型情况
        下, Unix 程序把来自 Windows 的文件里的回车符 (<literal>CR</literal>) 当
        成一个普通字符 (通常显示成 <literal>^M</literal>), 而 Windows 程序会
        把来自 Unix 系统的文件显示成一段很长的行, 因为它们找不到用来结束一行
        的回车符 (<literal>CR</literal>).</para>

    <!--
      <para>This sensitivity to foreign EOL markers can be
        frustrating for folks who share a file across different
        operating systems.  For example, consider a source code
        file, and developers who edit this file on both Windows and
        Unix systems.  If all the developers always use tools that
        preserve the line-ending style of the file, no problems
        occur.</para>
    -->
      <para>如果用户要在不同的操作系统之间分享文件, 如此敏感的 EOL 标记可不
        是什么好事. 比如说有一个源代码文件, 开发人员可能会同时在 Unix 和
        Windows 系统中编辑它, 如果所有开发人员使用的工具都能保留文件原来的行
        结束风格, 那就不会产生什么问题.</para>

    <!--
      <para>But in practice, many common tools either fail to
        properly read a file with foreign EOL markers, or
        convert the file's line endings to the native style when the
        file is saved.  If the former is true for a developer, he
        has to use an external conversion utility (such as
        <command>dos2unix</command> or its companion,
        <command>unix2dos</command>) to prepare the file for
        editing.  The latter case requires no extra preparation.
        But both cases result in a file that differs from the
        original quite literally on every line!  Prior to committing
        his changes, the user has two choices.  Either he can use a
        conversion utility to restore the modified file to the same
        line-ending style that it was in before his edits were made,
        or he can simply commit the file&mdash;new EOL markers and
        all.</para>
    -->
      <para>可惜的是, 如果文件的行结束标记和本地不同, 很多程序要么不能正确地读
        取并显示文件, 要么在保存时, 把文件的行结束标记转换成本地风格. 如果是前
        一种情况, 开发人员在开始编辑文件之前, 需要使用一种格式转换工具 (比如
        <command>dos2unix</command> 及其伙伴 <command>unix2dos</command>) 把
        文件的行结束标记转换成本地风格. 如果是后一种情况就不用在编辑之前转换文件
        格式. 但是两种情况都会导致文件的每一行都发生变化! 在提交修改之前, 用户
        有两种选择, 一是使用格式转换工具把文件的行结束标记转换成与原来一样的
        风格, 二是直接提交&mdash;使用新的行结束标记.</para>

    <!--
      <para>The result of scenarios like these include wasted time
        and unnecessary modifications to committed files.  Wasted
        time is painful enough.  But when commits change every line
        in a file, this complicates the job of determining which of
        those lines were changed in a nontrivial way.  Where was
        that bug really fixed?  On what line was a syntax error
        introduced?</para>
    -->
      <para>这种情况的结果是既浪费了时间, 也提交了很多没必要的修改. 浪费时间
        已经足够烦人了, 更糟糕的是一次提交修改了文件的每一行, 这会给后面的历史
        查询带来很大的麻烦&mdash;是哪几行修改解决了问题, 或者是哪一行修改引入
        了语法错误.</para>

    <!--
      <para>The solution to this problem is the
        <literal>svn:eol-style</literal> property.  When this
        property is set to a valid value, Subversion uses it to
        determine what special processing to perform on the file so
        that the file's line-ending style isn't flip-flopping with
        every commit that comes from a different operating
        system.  The valid values are:</para>
    -->
      <para>问题的解决办法是使用属性 <literal>svn:eol-style</literal>. 如果属
        性的值是有效的, Subversion 将根据属性值对文件进行特殊的处理, 这样文件
        的行结束风格就不会随着操作系统的变化而变化. 属性的有效值包括:</para>

      <variablelist>
        <varlistentry>
          <term><literal>native</literal></term>
          <listitem>
    <!--
            <para>This causes the file to contain the EOL markers
              that are native to the operating system on which
              Subversion was run.  In other words, if a user on a
              Windows machine checks out a working copy that
              contains a file with an
              <literal>svn:eol-style</literal> property set to
              <literal>native</literal>, that file will contain
              <literal>CRLF</literal> EOL markers.  A Unix user
              checking out a working copy that contains the same
              file will see <literal>LF</literal> EOL markers in his
              copy of the file.</para>
    -->
            <para>文件的行结束标记是操作系统的本地风格, 换句话说, 如果一个用户
              在 Windows 操作系统上检出了工作副本, 文件的 <literal>
                svn:eol-style</literal> 被设置成 <literal>native</literal>,
              则文件将使用 <literal>CRLF</literal> 作为行结束标记. 而 Unix 用户
              检出的文件的行结束标记是 <literal>LF</literal>.</para>

    <!--
            <para>Note that Subversion will actually store the file
              in the repository using normalized
              <literal>LF</literal> EOL markers regardless of the
              operating system.  This is basically transparent to
              the user, though.</para>
    -->
            <para>注意, 不管操作系统是什么类型, Subversion 仓库中存放的文件
              的行结束标记总是 <literal>LF</literal>, 这对用户来说是透明的.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CRLF</literal></term>
          <listitem>
    <!--
            <para>This causes the file to contain
              <literal>CRLF</literal> sequences for EOL markers,
              regardless of the operating system in use.</para>
    -->
            <para>无论是什么操作系统, 文件总是使用 <literal>CRLF</literal>
              作为行结束标记.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>LF</literal></term>
          <listitem>
    <!--
            <para>This causes the file to contain
              <literal>LF</literal> characters for EOL markers,
              regardless of the operating system in use.</para>
    -->
            <para>无论是什么操作系统, 文件总是使用 <literal>LF</literal> 作为
              行结束标记.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CR</literal></term>
          <listitem>
    <!--
            <para>This causes the file to contain
              <literal>CR</literal> characters for EOL markers,
              regardless of the operating system in use.  This
              line-ending style is not very common.</para>
    -->
            <para>无论是什么操作系统, 文件总是使用 <literal>CR</literal>
              作为行结束标记. 这种行结束标记用得很少.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.ignore">
    <!--
    <title>Ignoring Unversioned Items</title>
    -->
    <title>忽略未被版本控制的项目</title>

    <!--
    <para>In any given working copy, there is a good chance that
      alongside all those versioned files and directories are other
      files and directories that are neither versioned nor intended
      to be.  Text editors litter directories with backup files.
      Software compilers generate intermediate&mdash;or even
      final&mdash;files that you typically wouldn't bother to
      version.  And users themselves drop various other files and
      directories wherever they see fit, often in version control
      working copies.</para>
    -->
    <para>在一个长时间使用的工作副本里, 除了被版本控制的文件和目录外, 常常
      还有很多未被版本控制的文件与目录, 而且它们将来也不会被添加到仓库里, 这
      些文件可能是文本编辑器的备份文件, 或编译器产生的目标文件, 对它们进行版
      本控制是没有意义的, 用户随时都有可能把它们删除.</para>

    <!--
    <para>It's ludicrous to expect Subversion working copies to be
      somehow impervious to this kind of clutter and impurity.  In
      fact, Subversion counts it as a <emphasis>feature</emphasis>
      that its working copies are just typical directories, just like
      unversioned trees.  But these not-to-be-versioned files and
      directories can cause some annoyance for Subversion users.  For
      example, because the <command>svn add</command> and <command>svn
      import</command> commands act recursively by default and don't
      know which files in a given tree you do and don't wish to
      version, it's easy to accidentally add stuff to version control
      that you didn't mean to.  And because <command>svn
      status</command> reports, by default, every item of interest in
      a working copy&mdash;including unversioned files and
      directories&mdash;its output can get quite noisy where many of
      these things exist.</para>
    -->
    <para>希望工作副本不受这些杂质影响是不可能的. 实际上这是 Subversion 的一个
      特性, 那就是对操作系统来说工作副本就是一个普通的目录, 与未被版本化的
      目录相比并没有本质上的区别. 不过工作副本里的未被版本化的文件和目录会给
      用户产生一定的困扰. 比如说, 命令 <command>svn add</command> 和
      <command>svn import</command> 默认会递归地执行, 命令并不知道目录中的哪些
      文件是用户想要的, 哪些是不想要的. 命令 <command>svn status</command>
      默认报告工作副本里的每一个项目的状态&mdash;包括未被版本控制的文件与目
      录&mdash;如果未被版本控制的项目很多, 命令的输出就比较扰人.</para>

    <para>
      <indexterm>
        <primary>file patterns (文件名模式)</primary>
      </indexterm>
      <indexterm>
        <primary>globs </primary>
        <see>file patterns (文件名模式)</see>
      </indexterm>
      <indexterm>
        <primary>shell wildcard patterns (shell 通配符模式)</primary>
        <see>file patterns (文件名模式)</see>
      </indexterm>
      于是, Subversion 提供了几种方式告诉 Subversion 哪些文件是可以忽略的.
      其中一种要用到 Subversion 的运行时配置系统 (见
      <xref linkend="svn.advanced.confarea"/>), 会受到配置影响的通常是在特定
      计算机上执行的 Subversion 操作, 或计算机上的某些特定用户. 另外两种方式
      用到了 Subversion 的目录属性, 与版本化目录的联系更为紧密, 因此它会影响
      到版本化目录的所有工作副本. 上面说的两种机制都会用到
      <firstterm>文件模式</firstterm> (<firstterm>file patterns</firstterm>)
      (用于匹配文件名的字符串, 包含了字面字符与通配符) 来决定应该忽略哪些
      文件.</para>
    <!--
      So Subversion provides several ways for telling it
      which files you would prefer that it simply disregard.  One of
      the ways involves the use of Subversion's runtime configuration
      system (see <xref linkend="svn.advanced.confarea" />), and
      therefore applies to all the Subversion operations that make use
      of that runtime configuration&mdash;generally those performed on
      a particular computer or by a particular user of a computer.
      Two other methods make use of Subversion's directory property
      support and are more tightly bound to the versioned tree itself,
      and therefore affects everyone who has a working copy of that
      tree.  All of these mechanisms use <firstterm>file
      patterns</firstterm> (strings of literal and special wildcard
      characters used to match against filenames) to decide which
      files to ignore.</para>
    -->

    <!--
    <para>The Subversion runtime configuration system provides an
      option, <literal>global-ignores</literal>, whose value is a
      whitespace-delimited collection of file patterns.  The
      Subversion client checks these patterns against the names of the
      files that are candidates for addition to version control, as
      well as to unversioned files that the <command>svn
      status</command> command notices.  If any file's name matches
      one of the patterns, Subversion will basically act as if the
      file didn't exist at all.  This is really useful for the kinds
      of files that you almost never want to version, such as editor
      backup files such as Emacs' <literal>*~</literal> and
      <literal>.*~</literal> files.</para>
    -->
    <para>Subversion 运行时配置系统提供了一个选项&mdash; <literal>global-ignores
      </literal>&mdash;选项的值是空白符分隔的文件名模式集. 如果文件的名字
      与集合中的某个模式匹配, 那这个文件对 Subversion 来说相当于是不存在的,
      命令 <command>svn add</command>, <command>svn import</command> 和
      <command>svn status</command> 就会忽略它. 如果工作副本里有永远不会
      被版本控制的文件 (比如 Emacs 的备份文件 <literal>*~</literal> 和
      <literal>.*~</literal>), 这个特性就会非常有用.</para>

    <sidebar>
    <!--
      <title>File Patterns in Subversion</title>
    -->
      <title>Subversion 的文件名模式</title>

    <!--
      <para>File patterns (also called <firstterm>globs</firstterm> or
        <firstterm>shell wildcard patterns</firstterm>) are strings of
        characters that are intended to be matched against filenames,
        typically for the purpose of quickly selecting some subset of
        similar files from a larger grouping without having to
        explicitly name each file.  The patterns contain two types of
        characters:  regular characters, which are compared explicitly
        against potential matches, and special wildcard characters,
        which are interpreted differently for matching
        purposes.</para>
    -->
      <para>文件名模式 (也叫作 <firstterm>globs</firstterm> 或 <firstterm>
          shell 通配符模式</firstterm> (<firstterm>shell wildcard patterns
        </firstterm>)) 是一个字符串, 这个字符串用于匹配一个文件名, 比较常见的
        用法是从一大堆文件中, 选出具有类似性质的子集, 而不用列出每个文件名字.
        模式中的字符分为两种: 普通字符&mdash;按照字面值进行匹配, 例如字母
        <literal>a</literal> 就是匹配字母 <literal>a</literal>; 通配符&mdash;
        在匹配时被解释成和字面值不同的含义.</para>

    <!--
      <para>There are different types of file pattern syntaxes, but
        Subversion uses the one most commonly found in Unix systems
        implemented as the <function>fnmatch</function> system
        function.  It supports the following wildcards, described here
        simply for your convenience:</para>
    -->
      <para>文件名模式的语法有很多种, Subversion 用的是 Unix 系统中最常见的一
        种语法, 这种语法被实现成系统函数 <function>fnmatch</function>. 下面简
        单介绍该语法支持的通配符:</para>

      <variablelist>
        <varlistentry>
          <term><literal>?</literal></term>
          <listitem>
    <!--
            <para>Matches any single character</para>
    -->
            <para>匹配任意 <emphasis>一个</emphasis> 字符</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>*</literal></term>
          <listitem>
    <!--
            <para>Matches any string of characters, including the
              empty string</para>
    -->
            <para>匹配 0 个或多个字符组成的字符串</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>[</literal></term>
          <listitem>
    <!--
            <para>Begins a character class definition terminated by
              <literal>]</literal>, used for matching a subset of
              characters</para>
    -->
            <para>开始定义一个字符类, <literal>]</literal> 表示定义结束, 字
              符类可以匹配任意一个类中的字符</para>
          </listitem>
        </varlistentry>
      </variablelist>

    <!--
      <para>You can see this same pattern matching behavior at a Unix
        shell prompt.  The following are some examples of patterns
        being used for various things:</para>
    -->
      <para>Unix shell 支持相同的文件名模式语法, 下面是 shell 的一些使用例子:
      </para>

      <informalexample>
        <screen>
$ ls   ### the book sources
appa-quickstart.xml             ch06-server-configuration.xml
appb-svn-for-cvs-users.xml      ch07-customizing-svn.xml
appc-webdav.xml                 ch08-embedding-svn.xml
book.xml                        ch09-reference.xml
ch00-preface.xml                ch10-world-peace-thru-svn.xml
ch01-fundamental-concepts.xml   copyright.xml
ch02-basic-usage.xml            foreword.xml
ch03-advanced-topics.xml        images/
ch04-branching-and-merging.xml  index.xml
ch05-repository-admin.xml       styles.css
$ ls ch*   ### the book chapters
ch00-preface.xml                ch06-server-configuration.xml
ch01-fundamental-concepts.xml   ch07-customizing-svn.xml
ch02-basic-usage.xml            ch08-embedding-svn.xml
ch03-advanced-topics.xml        ch09-reference.xml
ch04-branching-and-merging.xml  ch10-world-peace-thru-svn.xml
ch05-repository-admin.xml
$ ls ch?0-*   ### the book chapters whose numbers end in zero
ch00-preface.xml  ch10-world-peace-thru-svn.xml
$ ls ch0[3578]-*   ### the book chapters that Mike is responsible for
ch03-advanced-topics.xml   ch07-customizing-svn.xml
ch05-repository-admin.xml  ch08-embedding-svn.xml
$
</screen>
      </informalexample>

    <!--
      <para>File pattern matching is a bit more complex than what
        we've described here, but this basic usage level tends to suit
        the majority of Subversion users.</para>
    -->
      <para>完整的文件名模式比我们这里介绍的要更加复杂, 但是对大多数 Subversion
        用户来说, 这里介绍的基本用法已经足够了.</para>

    </sidebar>

    <!--
    <para>When found on a versioned directory, the
      <literal>svn:ignore</literal> property is expected to contain a
      list of newline-delimited file patterns that Subversion should
      use to determine ignorable objects in that
      <emphasis>same</emphasis> directory.
      These patterns do not override those found in the
      <literal>global-ignores</literal> runtime configuration option,
      but are instead appended to that list.  And it's worth noting
      again that, unlike the <literal>global-ignores</literal> option,
      the patterns found in the <literal>svn:ignore</literal>
      property apply only to the directory on which that property is
      set, and not to any of its subdirectories.  The
      <literal>svn:ignore</literal> property is a good way to tell
      Subversion to ignore files that are likely to be present in
      every user's working copy of that directory, such as compiler
      output or&mdash;to use an example more appropriate to this
      book&mdash;the HTML, PDF, or PostScript files generated as the
      result of a conversion of some source DocBook XML files to a
      more legible output format.</para>
    -->
    <para>如果被版本控制的目录上设置了属性 <literal>svn:ignore</literal>,
      属性值应该是一个文件名模式列表, 各项之间用换行符分开, Subversion 根据
      文件名模式列表判断 <emphasis>相同</emphasis> 目录内的哪些文件是可以忽略
      的. 属性 <literal>svn:ignore</literal> 不会覆盖运行时配置选项 <literal>
        global-ignores</literal> 的值, 而是作为一种补充. 与 <literal>
        global-ignores</literal> 不同的是, 属性 <literal>svn:ignore</literal>
      里的模式只能作用在该属性所在的目录上, 不会递归作用到子目录上. 属性
      <literal>svn:ignore</literal> 的一个常用目的是告诉 Subversion 去忽略每个
      用户的工作副本中可能都会有的文件, 例如编译器的输出文件&mdash;对于本书而
      言, 就是 HTML, PDF, PostScript 文件, 或其他 DocBook XML 转换过程中产生
      的临时文件和输出文件.</para>

    <!--
    <para>Subversion 1.8 provides a more powerful version of the
      <literal>svn:ignore</literal> property, the
      <literal>svn:global-ignores</literal> property.  Like the
      <literal>svn:ignore</literal> property,
      <literal>svn:global-ignores</literal> can only be set
      on a directory and contains file patterns Subversion uses to
      determine ignorable objects.<footnote><para>The ignore patterns
      in the <literal>svn:global-ignores</literal> property may be
      delimited with any whitespace (similar to the
      <literal>global-ignores</literal> runtime configuration option),
      not just newlines (as with the <literal>svn:ignore</literal>
      property).</para></footnote> These ignore patterns are also
      appended to any patterns defined in the
      <literal>global-ignores</literal> runtime configuration option
      together with any <literal>svn:ignore</literal> defined patterns.
      Unlike <literal>svn:ignore</literal> however, the
      <literal>svn:global-ignores</literal> property is inheritable
      <footnote><para>Of course only a 1.8 or newer Subversion client
      will recognize the inheritability and special meaning of the
      <literal>svn:global-ignores</literal> property!</para></footnote>
      and applies to <emphasis>all</emphasis> paths under the directory on
      which the property is set, not just the immediate children of the
      directory.</para>
    -->
    <para>Subversion 1.8 提供了一个比 <literal>svn:ignore</literal> 更强大的
      属性&mdash;<literal>svn:global-ignores</literal>. 和 <literal>
        svn:ignore</literal> 相同的是, <literal>svn:global-ignores</literal>
      只能设置到目录上, 属性值是文件名模式集合.<footnote><para><literal>
            svn:global-ignores</literal> 的各个文件名模式之间可能用空白符
          分隔 (就像运行时配置选项 <literal>global-ignores</literal>), 而不仅
          仅是换行符 (属性 <literal>svn:ignore</literal> 的各个文件名模式之间
          只能用换行符分隔).</para></footnote> <literal>svn:global-ignores
        </literal> 定义的文件名模式会添加到运行时配置选项
        <literal>global-ignores</literal> 与 属性 <literal>svn:ignore</literal>
        定义的模式上. 与 <literal>svn:ignore</literal> 不同的是, <literal>
          svn:global-ignores</literal> 是可继承的 <footnote><para>当然, 只
            有 1.8 或更新版本的 Subversion 客户端才能认识
            <literal>svn:global-ignores</literal> 的意义与可继承性</para>
        </footnote>, 它会递归地作用到目录内的 <emphasis>所有</emphasis> 路径上,
        而不仅仅是目录的直接子文件.</para>

    <note>
    <!--
      <para>Subversion's support for ignorable file patterns extends
        only to the one-time process of adding unversioned
        files and directories to version control.  Once an object is
        under Subversion's control, the ignore pattern mechanisms no
        longer apply to it.  In other words, don't expect Subversion
        to avoid committing changes you've made to a versioned file
        simply because that file's name matches an ignore
        pattern&mdash;Subversion <emphasis>always</emphasis> notices
        all of its versioned objects.</para>
    -->
      <para>Subversion 的忽略文件名模式只对未被版本控制的文件和目录起作用, 一旦
        文件和目录被版本控制了, 忽略文件名模式就不会对它们产生影响. 也就是说,
        不要以为某个被版本控制的文件名符合忽略模式, 在你提交时, Subversion 就
        会忽略它的修改&mdash;Subversion <emphasis>总是</emphasis> 会注意到所有
        被版本控制的对象.</para>
    </note>

    <sidebar>
    <!--
      <title>Ignore Patterns for CVS Users</title>
    -->
      <title>CVS 用户的忽略模式</title>
    
    <!--
      <para>The Subversion <literal>svn:ignore</literal> property is
        very similar in syntax and function to the CVS
        <filename>.cvsignore</filename> file.  In fact, if you are
        migrating a CVS working copy to Subversion, you can directly
        migrate the ignore patterns by using the
        <filename>.cvsignore</filename> file as input to the
        <command>svn propset</command> command:</para>
    -->
      <para>Subversion 的 <literal>svn:ignore</literal> 属性的语法和功能非常
        像 CVS <filename>.cvsignore</filename> 文件. 实际上, 如果用户想从 CVS
        的工作副本迁移到 Subversion 的工作副本中, 为了迁移忽略模式, 可以把
        <filename>.cvsignore</filename> 作为命令 <command>svn propset</command>
        的输入:</para>
   
      <informalexample>
        <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>
      </informalexample>
    
    <!--
      <para>There are, however, some differences in the ways that CVS
        and Subversion handle ignore patterns.  The two systems use
        the ignore patterns at some different times, and there are
        slight discrepancies in what the ignore patterns apply to.
        Also, Subversion does not recognize the use of the
        <literal>!</literal> pattern as a reset back to having no
        ignore patterns at all.</para>
    -->
      <para>但是, CVS 和 Subversion 在忽略模式的使用方式上有所区别. 两个系统
        使用忽略模式的时机不同, 在忽略模式的作用目标上也有细微的差别, 另外,
        Subversion 无法识别 <literal>!</literal> 的特殊意义, 对 CVS 来说,
        <literal>!</literal> 表示不要忽略这种模式.</para>

    </sidebar>

    <!--
    <para>The ignore patterns in the <literal>global-ignores</literal>
      runtime configuration option tend to be more a
      matter of personal taste<footnote><para>Despite being a matter
      of personal taste, if you don't explicitly set the
      <literal>global-ignores</literal> runtime
      configuration option&mdash;either to your preferred set of
      patterns or to an empty string&mdash;Subversion uses a default
      value.  See the <literal>global-ignores</literal> entry in
      <xref linkend="svn.advanced.confarea.opts.config"/></para>
      </footnote> and ties more closely to a user's particular tool
      chain than to the details of any particular working copy's needs.
      So, the rest of this section will focus
      on the <literal>svn:ignore</literal> and
      <literal>svn:global-ignores</literal> properies and their
      uses.</para>
    -->
    <para>运行时配置选项 <literal>global-ignores</literal> 里的忽略模式更
      倾向于个人化 <footnote><para>抛开个人化不说, 如果用户没有显式地设置
          <literal>global-ignores</literal>, Subversion 就会使用默认值,
          见 <xref linkend="svn.advanced.confarea.opts.config"/></para>
      </footnote>, 并且和工作副本相比, 更贴近用户的个人需求. 所以, 本节的余
      下部分主要关注 <literal>svn:ignore</literal>, <literal>
        svn:global-ignores</literal> 及如何使用它们.</para>

    <!--
    <para>Say you have the following output from <command>svn
      status</command>:</para>
    -->
  <para>假设某个工作副本的 <command>svn status</command> 输出是:</para>

    <informalexample>
      <screen>
$ svn status calc
 M      calc/button.c
?       calc/calculator
?       calc/data.c
?       calc/debug_log
?       calc/debug_log.1
?       calc/debug_log.2.gz
?       calc/debug_log.3.gz
</screen>
    </informalexample>
    
    <!--
    <para>In this example, you have made some property modifications
      to <filename>button.c</filename>, but in your working copy, you
      also have some unversioned files: the latest
      <filename>calculator</filename> program that you've compiled
      from your source code, a source file named
      <filename>data.c</filename>, and a set of debugging output
      logfiles.  Now, you know that your build system always results
      in the <filename>calculator</filename> program being
      generated.<footnote><para>Isn't that the whole point of a build
      system?</para></footnote>  And you know that your test suite
      always leaves those debugging logfiles lying around.  These
      facts are true for all working copies of this project, not just
      your own.  And you know that you aren't interested in seeing
      those things every time you run
      <command>svn status</command>, and you are pretty sure that
      nobody else is interested in them either.  So you use
      <userinput>svn propedit svn:ignore calc</userinput> to add some
      ignore patterns to the <filename>calc</filename>
      directory.</para>
    -->
    <para>在上面的例子里, 用户已经修改了 <filename>button.c</filename>, 但是
      工作副本里还有一些未被版本控制的项目: 刚从源代码编译出的 <filename>
        calculator</filename> 程序, 一个叫做 <filename>data.c</filename> 的
      源代码文件, 还有几个用于调试的日志文件. 假设用户已经知道编译系统总是会
      输出一个目标文件 <filename>calculator</filename>
      <footnote><para>这不就是构建系统存在的意义吗?</para></footnote>,
      而且测试程序总是会留下一些
      调试日志文件, 除了用户自己的工作副本, 该项目所有的工作副本都有可能出现
      这些文件. 用户非常清楚地知道, 当他执行 <command>svn status</command> 时,
      并不想看到这些他不感兴趣的文件, 而且他也相信其他人也对它们不感兴趣. 于是,
      用户决定为目录 <filename>calc</filename> 设置属性 <literal>svn:ignore
    </literal>:</para>

    <informalexample>
      <screen>
$ svn propget svn:ignore calc
calculator
debug_log*
$
</screen>
    </informalexample>
    
    <!--
    <para>After you've added this property, you will now have a local
      property modification on the <filename>calc</filename>
      directory.  But notice what else is different about your
      <command>svn status</command> output:</para>
    -->
    <para>属性设置完毕后, 目录 <filename>calc</filename> 包含了未被提交的本地
      修改. 注意看 <command>svn status</command> 的输出发生了什么变化:</para>

    <informalexample>
      <screen>
$ svn status
 M      calc
 M      calc/button.c
?       calc/data.c
</screen>
    </informalexample>
    
    <!--
    <para>Now, all that cruft is missing from the output!  Your
      <filename>calculator</filename> compiled program and all those
      logfiles are still in your working copy; Subversion just isn't
      constantly reminding you that they are present and unversioned.
      And now with all the uninteresting noise removed from the
      display, you are left with more intriguing items&mdash;such as
      that source code file <filename>data.c</filename> that you
      probably forgot to add to version control.</para>
    -->
    <para>现在, 命令的输出变得干净多了! 编辑器产生的目标文件 <filename>
        calculator</filename> 和日志文件仍然留在工作副本里, Subversion 只是不
      再提醒用户这些文件的存在. 输出变干净后, 用户就能更容易地关注到更重要的
      事情上&mdash;例如用户可能忘记把源代码文件 <filename>data.c</filename>
      添加到仓库里.</para>

    <!--
    <para>Of course, this less-verbose report of your working copy
      status isn't the only one available.  If you actually want to
      see the ignored files as part of the status report, you can pass
      the <option>- -no-ignore</option> option to Subversion:</para>
    -->
    <para>当然, 减少垃圾信息只是一个选择, 如果用户确实想看到所有的文件, 包括
      正常情况下会被忽略的文件, 可以给 <command>svn status</command> 加上选项
      <option>--no-ignore</option>:</para>

    <informalexample>
      <screen>
$ svn status --no-ignore
 M      calc
 M      calc/button.c
I       calc/calculator
?       calc/data.c
I       calc/debug_log
I       calc/debug_log.1
I       calc/debug_log.2.gz
I       calc/debug_log.3.gz
I       calc/wip.1.diff
</screen>
    </informalexample>

    <!--
    <para>All of your previously hidden unversioned paths are once
      again shown, but now with the <literal>'I' Ignored</literal>
      status.  But wait, what about <filename>wip.1.diff</filename>?
      The <literal>svn:ignore</literal> property on
      <filename>calc</filename> doesn't include any pattern that
      matches that filename, so why is it ignored?<footnote><para>
      Let's assume that you don't have a matching pattern anywhere
      in your <literal>global-ignores</literal> runtime configuration.
      </para></footnote>  The answer lies in the third method by which
      Subversion can disregard unversioned paths, the inheritable
      <literal>svn:global-ignores</literal> property.  Using the
      <command>svn propget</command> subcommand with the
      <option>- -show-inherited-props</option> option, you see that
      the <literal>svn:global-ignores</literal> property is set on the
      root of your working copy, and sure enough, it defines a
      matching ignore pattern:</para>
    -->
    <para>被隐藏的未被版本控制的项目再度显示出来, 但是在项目的左边加上了字母
      <literal>I</literal> (Ignored). 请等一下, 为什么 <filename>wip.1.diff
      </filename> 也有 <literal>I</literal>? <filename>calc</filename> 的属性
      <literal>svn:ignore</literal> 里并没有匹配 <filename>wip.1.diff</filename>
      的模式, 那么它为什么会被忽略?<footnote><para>假设用户的运行时配置选项
          <literal>global-ignores</literal> 里也没有匹配的模式</para></footnote>
      答案是继承的属性 <literal>svn:global-ignores</literal>. 执行带上选项
      <option>--show-inherited-props</option> 的命令 <command>svn propget
      </command>, 就可以看到属性 <literal>svn:global-ignores</literal> 被设置
      在了工作副本的根目录上, 果然在这个属性里找到了匹配 <filename>wip.1.diff
    </filename> 的模式:</para>

    <informalexample>
      <screen>
$ svn pg svn:global-ignores calc -v --show-inherited-props
Inherited properties on 'calc',
from '.':
  svn:global-ignores
    *.diff
    *.patch
</screen>
    </informalexample>
    
    <!--
    <para>As mentioned earlier, the list of file patterns to ignore is
      also used by <command>svn add</command> and <command>svn
      import</command>.  Both of these operations involve asking
      Subversion to begin managing some set of files and directories.
      Rather than force the user to pick and choose which files in a
      tree she wishes to start versioning, Subversion uses the ignore
      patterns&mdash;the global, per-directory, and inherited
      lists&mdash;to determine which files should not be swept into
      the version control system as part of a larger recursive
      addition or import operation.  And here again, you can use the
      <option>- -no-ignore</option> option to tell Subversion to disregard
      its ignores list and operate on all the files and directories
      present.</para>
    -->
    <para>之前提过, <command>svn add</command> 和 <command>svn import</command>
      也会用到忽略模式列表, 这两个操作都会要求 Subversion 开始管理文件与目录.
      在递归的添加操作或导入操作中, Subversion 不会要求用户去选择目录
      中的哪些文件应该被版本控制, 而是使用忽略模式&mdash;包括全局的, 每个目录
      与继承的&mdash;来决定哪些文件应该被忽略. 同样, 用户也可以用选项
      <option>--no-ignore</option> 告诉 Subversion 不会忽略任意一个文件.</para>

    <tip>
      <!--
      <para>Even if <literal>svn:ignore</literal> or
        <literal>svn:global-ignores</literal> is set, you may run
        into problems if you use shell wildcards in a command.  Shell
        wildcards are expanded into an explicit list of targets before
        Subversion operates on them, so running <userinput>svn
        <replaceable>SUBCOMMAND</replaceable> *</userinput> is just like
        running <userinput>svn <replaceable>SUBCOMMAND</replaceable>
        file1 file2 file3 &hellip;</userinput>.  In the case of the
        <command>svn add</command> command, this has an effect similar
        to passing the <option>- -no-ignore</option> option.  So
        instead of using a wildcard, use <userinput>svn add - -force
        .</userinput> to do a bulk scheduling of unversioned things for
        addition.  The explicit target will ensure that the current
        directory isn't overlooked because of being already under
        version control, and the <option>- -force</option> option will
        cause Subversion to crawl through that directory, adding
        unversioned files while still honoring the
        <literal>svn:ignore</literal> and
        <literal>svn:global-ignores</literal> properties and the
        <literal>global-ignores</literal> runtime configuration
        variable.  Be sure to also provide the <option>- -depth
        files</option> option to the <command>svn add</command>
        command if you don't want a fully recursive crawl for things
        to add.</para>
      -->
      <para>即使已经设置了属性 <literal>svn:ignore</literal> 和 <literal>
          svn:global-ignores</literal>, 使用 shell 的通配符可能还是会产生一些
        问题. 在 Subversion 接收到参数之前, shell 会把通配符扩展成显式的文件
        名列表, 所以执行 <userinput>svn <replaceable>SUBCOMMAND</replaceable> *
            </userinput> 相当于执行 <userinput>svn <replaceable>SUBCOMMAND
          </replaceable> file1 file2 file3 &hellip;</userinput>. 如果是
          <command>svn add</command>, 效果就像是给命令带上选项 <option>
            --no-ignore</option>, 所以最好使用 <userinput>svn add --force .
          </userinput> 完成文件的批量添加. 显式地指定目标文件确保了当前目录不
          会因为已经处于版本控制之下而被忽略, 选项 <option>--force</option>
          使得 Subversion 在遍历目录, 添加未被版本控制的文件时, 仍然遵循属性
          <literal>svn:ignore</literal>, <literal>svn:global-ignores</literal>
          和运行时配置选项 <literal>global-ignores</literal> 的值. 如果你不想
          递归地添加所有项目, 别忘了给命令 <command>svn add</command> 加上选项
          <option>--depth files</option>.</para>

      </tip>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.keywords">
    <!--
    <title>Keyword Substitution</title>
    -->
    <title>关键字替换</title>

    <para>
      <indexterm>
        <primary>keywords (关键字)</primary>
      </indexterm>
      Subversion 支持把 <firstterm>关键字</firstterm> (<firstterm>keywords
      </firstterm>)&mdash;跟文件有关的一段有用的动态信息&mdash;替换成文件
      的内容. 关键字提供了与文件最后一次修改有关的信息, 但是每次文件被修改时,
      这个信息都会发生变化, 更重要的是, 文件刚被修改后, 除了版本控制系统, 对
      任何一个企图保持数据最新的过程都是一场混乱, 如果把工作交给用户, 就很容易
      造成信息过时.</para>
    <!--
      Subversion has the ability to substitute
      <firstterm>keywords</firstterm>&mdash;pieces of useful,
      dynamic information about a versioned file&mdash;into the
      contents of the file itself.  Keywords generally provide
      information about the last modification made to the file.
      Because this information changes each time the
      file changes, and more importantly, just
      <emphasis>after</emphasis> the file changes, it is a hassle
      for any process except the version control system to keep
      the data completely up to date.  Left to human authors, the
      information would inevitably grow stale.</para>
    -->

    <!--
    <para>For example, say you have a document in which you would
      like to display the last date on which it was modified.  You
      could burden every author of that document to, just before
      committing their changes, also tweak the part of the
      document that describes when it was last changed.  But
      sooner or later, someone would forget to do that.  Instead,
      simply ask Subversion to perform keyword substitution on the
      <literal>LastChangedDate</literal> keyword.  You control
      where the keyword is inserted into your document by placing
      a <firstterm>keyword anchor</firstterm> at the desired
      location in the file.  This anchor is just a string of text
      formatted as
      <literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>.</para>
    -->
    <para>比如说用户有一个文档, 他想显示文档最后一次被修改的日期. 他可以要求
      文档的每一个作者在他们提交修改之前, 在文档中记录一下本次修改的日期. 但
      是很快就会出现, 总有人会忘记记录修改日期. 更好的做法是让 Subversion 去
      完成记录时间的操作, 比如说在每次提交时, 把文档中的关键字 <literal>
        LastChangedDate</literal> 替换成当时的日期. 通过在文档中放置一个
      <firstterm>关键字锚点</firstterm> (<firstterm>keyword anchor</firstterm>),
      用户可以控制关键字的插入位置. 锚点就是一段简单的文本, 格式是
      <literal>$</literal><replaceable>KeywordName</replaceable><literal>$
    </literal>.</para>

    <!--
    <para>Adding keyword anchor text alone to your file does nothing
      special.  Subversion will never attempt to perform textual
      substitutions on your file contents unless explicitly asked to
      do so.  After all, you might be writing a
      document<footnote><para>&hellip; or maybe even a section of a
      book &hellip;</para></footnote> about how to use keywords, and
      you don't want Subversion to substitute your beautiful examples
      of unsubstituted keyword anchors!</para>
    -->
    <para>如果只想单纯地往文件中添加关键字锚点并不会产生什么特别的效果, 除非
      用户显式要求 Subversion, 否则的话它决不会执行文本替换操作, 毕竟用户有可
      能只是想写一篇介绍如何使用关键字的文档<footnote><para>&hellip;或者是书中
          的一节&hellip;</para></footnote>, 此时用户当然不希望 Subversion 把
      示例中的关键字锚点都替换掉.</para>

    <!--
    <para>To tell Subversion whether to substitute keywords
      on a particular file, we again turn to the property-related
      subcommands.  The <literal>svn:keywords</literal> property,
      when set on a versioned file, controls which keywords will
      be substituted on that file.  The value is a space-delimited
      list of keyword names or aliases.</para>
    -->
    <para>为了告诉 Subversion 是否要替换某个文件中的关键字, 我们要再次使用
      与属性有关的子命令. 设置在文件上的属性 <literal>svn:keywords</literal>
      决定了文件中的哪些关键词将会被替换, 属性值是空格分隔的关键字名或别名列表.
    </para>

      <!--
    <para>For example, say you have a versioned file named
      <filename>weather.txt</filename> that looks like
      this:</para>
      -->
    <para>举个例子, 假设用户一个叫作 <filename>weather.txt</filename> 的文件,
      文件的内容是:</para>

    <informalexample>
      <programlisting>
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
    </informalexample>
        
    <!--
    <para>With no <literal>svn:keywords</literal> property set on
      that file, Subversion will do nothing special.  Now, let's
      enable substitution of the
      <literal>LastChangedDate</literal> keyword.</para>
    -->
    <para>如果文件上没有设置属性 <literal>svn:keywords</literal>, Subversion
      就不会对文件做什么特别的操作. 现在开启关键字 <literal>LastChangedDate
    </literal> 的替换.</para>

    <informalexample>
      <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>
    </informalexample>
    
    <!--
    <para>Now you have made a local property modification on the
      <filename>weather.txt</filename> file.  You will see no
      changes to the file's contents (unless you made some of your
      own prior to setting the property).  Notice that the file
      contained a keyword anchor for the <literal>Rev</literal>
      keyword, yet we did not include that keyword in the property
      value we set.  Subversion will happily ignore requests to
      substitute keywords that are not present in the file and
      will not substitute keywords that are not present in the
      <literal>svn:keywords</literal> property value.</para>
    -->
    <para>文件 <filename>weather.txt</filename> 此时含有未被提交的属性修改,
      但文件的内容并没有发生变化 (除非用户在设置属性之前又修改了文件). 注意
      文件还包含了关键字 <literal>Rev</literal> 的锚点, 但
      <literal>svn:keywords</literal> 的属性值并没有包含关键字 <literal>Rev
      </literal>. 如果文件中没有要被替换的关键字, 或者关键字没有出现在
      <literal>svn:keywords</literal> 的属性值里, Subversion 就不会真正地替换
      关键字.</para>

    <!--
    <para>Immediately after you commit this property change,
      Subversion will update your working file with the new
      substitute text.  Instead of seeing your keyword anchor
      <literal>$LastChangedDate$</literal>, you'll see its
      substituted result.  That result also contains the name of
      the keyword and continues to be delimited by the dollar sign
      (<literal>$</literal>) characters.  And as we predicted, the
      <literal>Rev</literal> keyword was not substituted because
      we didn't ask for it to be.</para>
    -->
    <para>属性修改提交后, Subversion 会立刻更新工作副本里的文件, 将其中的关键
      字替换成对应的文本. 关键字锚点将会出现替换后的文本, 替换的结果仍然包含
      关键字的名字以及两边的美元符 (<literal>$</literal>). 因为 <literal>
        svn:keywords</literal> 的属性值里没有包含对应的关键字, 所以 <literal>
        Rev</literal> 没有被替换.</para>

    <!--
    <para>Note also that we set the <literal>svn:keywords</literal>
      property to <literal>Date Author</literal>, yet the keyword
      anchor used the alias <literal>$LastChangedDate$</literal>
      and still expanded correctly:</para>
    -->
    <para>注意我们把属性 <literal>svn:keywords</literal> 设置成 <literal>
        Date Author</literal>, 而关键字锚点则写成了 <literal>
        $LastChangedDate$</literal>, 但仍然得到了正确的结果, 这是因为
      <literal>LastChangedDate</literal> 是 <literal>Date</literal> 的别名.
    </para>

    <informalexample>
      <programlisting>
Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
    </informalexample>
        
    <!--
    <para>If someone else now commits a change to
      <filename>weather.txt</filename>, your copy of that file
      will continue to display the same substituted keyword value
      as before&mdash;until you update your working copy.  At that
      time, the keywords in your <filename>weather.txt</filename>
      file will be resubstituted with information that
      reflects the most recent known commit to that file.</para>
    -->
    <para>如果其他人向 <filename>weather.txt</filename> 提交了新的修改, 自己
      工作副本里的文件不会自动更新&mdash;直到用户显式地更新了工作副本, 此时,
      <filename>weather.txt</filename> 的关键字会被重新替换, 以反应最新的修改
      时间.</para>

    <!--
    <para>All keywords are case-sensitive where they appear as
      anchors in files: you must use the correct capitalization
      for the keyword to be expanded.  You should consider the
      value of the <literal>svn:keywords</literal> property to be
      case-sensitive, too&mdash;for the sake of backward
      compatibility, certain keyword names will be recognized
      regardless of case, but this behavior is deprecated.</para>
    -->
    <para>作为锚点出现在文件里的关键字都区分大小写: 用户必须使用大小写正确的
      关键字. 同样也要注意属性 <literal>svn:keywords</literal> 的值也区分大
      小写. 为了保持向后兼容, 某几个关键词是不区分大小写的, 但不建议用户使用
      这个特性.</para>

    <!--
    <para>Subversion defines the list of keywords available for
      substitution.  That list contains the following keywords, 
      some of which have aliases that you can also use:</para>
    -->
    <para>Subversion 定义了几个支持替换的关键字, 下面列出这些关键字, 其中一些
      关键字拥有别名:</para>

    <variablelist>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>Date</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>LastChangedDate</secondary>
        <see>keywords (关键字), Date</see>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>Revision</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>LastChangedRevision</secondary>
        <see>keywords (关键字), Revision</see>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>Rev</secondary>
        <see>keywords (关键字), Revision</see>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>Author</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>LastChangedBy</secondary>
        <see>keywords (关键字), Author</see>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>HeadURL</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>URL</secondary>
        <see>keywords (关键字), HeadURL</see>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>Id</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords (关键字)</primary>
        <secondary>Header</secondary>
      </indexterm>

      <varlistentry>
        <term><literal>Date</literal></term>
        <listitem>
    <!--
          <para>This keyword describes the last time the file was
            known to have been changed in the repository, and is of
            the form <literal>$Date: 2006-07-22 21:42:37 -0700 (Sat,
            22 Jul 2006) $</literal>.  It may also be specified as
            <literal>LastChangedDate</literal>.  Unlike the
            <literal>Id</literal> keyword, which uses UTC, the
            <literal>Date</literal> keyword displays dates using the
            local time zone.</para>
    -->
          <para>这个关键字描述了仓库中的文件已知的最后一次被修改的时间, 格式类似
            于 <literal>$Date: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
            </literal>. 它的别名是 <literal>LastChangedDate</literal>. 和关
            键字 <literal>Id</literal> 不同 (<literal>Id</literal> 使用 UTC
            时间), <literal>Date</literal> 会按照本地时区显示日期.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Revision</literal></term>
        <listitem>
    <!--
          <para>This keyword describes the last known revision in
            which this file changed in the repository, and looks
            something like <literal>$Revision: 144 $</literal>.  
            It may also be specified as
            <literal>LastChangedRevision</literal> or
            <literal>Rev</literal>.</para>
    -->
          <para>这个关键字描述了仓库中的文件已知的最后一次被修改的版本号, 显
            示格式
            类似于 <literal>$Revision: 144 $</literal>, 它的别名有 <literal>
              LastChangedRevision</literal> 和 <literal>Rev</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Author</literal></term>
        <listitem>
    <!--
          <para>This keyword describes the last known user to
            change this file in the repository, and looks
            something like <literal>$Author: harry $</literal>.  
            It may also be specified as 
            <literal>LastChangedBy</literal>.</para>
    -->
          <para>这个关键字描述了仓库中的文件已知的最后一次是被谁修改的, 显示
            格式类似
            于 <literal>$Author: harry $</literal>, 它的别名是 <literal>
              LastChangedBy</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>HeadURL</literal></term>
        <listitem>
    <!--
          <para>This keyword describes the full URL to the latest
            version of the file in the repository, and looks
            something like <literal>$HeadURL:
            http://svn.example.com/repos/trunk/calc.c $</literal>.
            It may be abbreviated as
            <literal>URL</literal>.</para>
    -->
          <para>这个关键字描述了仓库中的文件的最新版本的完整 URL 路径, 显示格式
            类似于 <literal>$HeadURL:
            http://svn.example.com/repos/trunk/calc.c $</literal>, 它的别名是
          <literal>URL</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Id</literal></term>
        <listitem>
    <!--
          <para>This keyword is a compressed combination of the other
            keywords.  Its substitution looks something like
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, and is interpreted to mean that the file
            <filename>calc.c</filename> was last changed in revision
            148 on the evening of July 28, 2006 by the user
            <literal>sally</literal>.  The date displayed by this
            keyword is in UTC, unlike that of the
            <literal>Date</literal> keyword (which uses the local time
            zone).</para>
    -->
          <para>这个关键字是几个关键字的组合, 它显示的内容类似于
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally $</literal>,
            例子的意思是文件 <filename>calc.c</filename> 最后一次修改是在
            2006 年 7 月 28 日, 版本号 148, 作者是 <literal>sally</literal>.
            <literal>Id</literal> 使用 UTC 时间, 而 <literal>Date</literal>
            使用本地时区.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Header</literal></term>
        <listitem>
    <!--
          <para>This keyword is similar to the <literal>Id</literal>
            keyword but contains the full URL of the latest revision
            of the item, identical to <literal>HeadURL</literal>. 
            Its substitution looks something like <literal>$Header: 
            http://svn.example.com/repos/trunk/calc.c 
            148 2006-07-28 21:30:43Z sally $</literal>.</para>
    -->
        <para>这个关键字和 <literal>Id</literal> 类似, 但是增加了 <literal>
            HeadURL</literal> 的内容, 看起来就像 <literal>$Header:
            http://svn.example.com/repos/trunk/calc.c 
            148 2006-07-28 21:30:43Z sally $</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <!--
    <para>Several of the preceding descriptions use the phrase
      <quote>last known</quote> or similar wording.  Keep in mind that
      keyword expansion is a client-side operation, and your client
      <quote>knows</quote> only about changes that have occurred in
      the repository when you update your working copy to include
      those changes.  If you never update your working copy, your
      keywords will never expand to different values even if those
      versioned files are being changed regularly in the
      repository.</para>
    -->
    <para>在介绍关键字时, (隐式的或显式的) 用到了形容词 <quote>已知的</quote>,
      这是因为关键字替换是一个客户端操作, 客户端只能知道最近一次更新工作副本
      时从仓库中获取的信息. 如果工作副本一直得不到更新, 即使仓库中的文件已经
      修改了, 工作副本里的关键字也不会被替换成更新的信息.</para>

    <sidebar>
    <!--
      <title>Where's $GlobalRev$?</title>
    -->
      <title>$GlobalRev$ 在哪儿?</title>

    <!--
      <para>New users are often confused by how the
        <literal>$Rev$</literal> keyword works.  Since the repository
        has a single, globally increasing revision number, many people
        assume that it is this number that is reflected by the
        <literal>$Rev$</literal> keyword's value.  But
        <literal>$Rev$</literal> expands to show the last revision in
        which the file <emphasis>changed</emphasis>, not the last
        revision to which it was updated.  Understanding this clears
        the confusion, but frustration often remains&mdash;without the
        support of a Subversion keyword to do so, how can you
        automatically get the global revision number into your
        files?</para>
    -->
      <para>新手常常弄不清楚 <literal>$Rev$</literal> 的工作方式. 因为
        Subversion 有一个全局增长的版本号, 很多新用户以为 <literal>
          $Rev$</literal> 显示的是版本号的全局最大值. 但实际上 <literal>
          $Rev$</literal> 被替换成文件最后一次被 <emphasis>修改</emphasis>
        时的版本号, 只要理解了这点就不会再有疑惑. 但是还有一个问题没有解决
        &mdash;缺少了关键字的支持, 用户应该如何在文件中自动获取全局最新的版本
        号?</para>

    <!--
      <para>To do this, you need external processing.  Subversion
        ships with a tool called <command>svnversion</command>, which
        was designed for just this purpose.  It crawls your working
        copy and generates as output the revision(s) it finds.  You
        can use this program, plus some additional tooling, to embed
        that revision information into your files.  For more
        information on <command>svnversion</command>, see <xref
        linkend="svn.ref.svnversion"/>.</para>
    -->
    <para>完成这项工作需要借助另一个工具, <command>svnversion</command>.
      <command>svnversion</command> 遍历工作副本, 然后输出最新的版本号. 利用
      这个命令, 再加上一些额外的工具, 用户就可以把版本号信息插入到文件中,
      关于 <command>svnversion</command> 的更多信息, 见
      <xref linkend="svn.ref.svnversion"/>.</para>

    </sidebar>

    <!--
    <para>In addition to previous set of stock keyword definitions and
      aliases, Subversion 1.8 allows you the freedom to define and use
      custom keywords.  To define a custom keyword, add a token to the
      value of the <literal>svn:keywords</literal> property which is
      of the form
      <userinput><replaceable>MyKeyword</replaceable>=<replaceable>FORMAT</replaceable></userinput>,
      where <replaceable>MyKeyword</replaceable> is the keyword name
      (which you'll use in the keyword anchor)
      and <replaceable>FORMAT</replaceable> is a format string into
      which information will be substituted when your keyword is
      expanded inside your file.</para>
    -->
    <para>除了前面几个预定义的关键字, Subversion 1.8 允许用户定义新的关键字.
      为了定义一个关键字, 给属性 <literal>svn:keywords</literal> 的值添加
      新的记号,
      记号的格式是 <userinput><replaceable>MyKeyword</replaceable>=
        <replaceable>FORMAT</replaceable></userinput>, 其中 <replaceable>
        MyKeyword</replaceable> 是关键字的名字 (关键字锚点需要),
      <replaceable>FORMAT</replaceable> 是一个格式化的字符串, 替换文件中的关
      键字时会根据格式字符进行替换.</para>

    <!--
    <para>The format string syntax used for custom keywords supports
      the following format codes:</para>
    -->
    <para>格式化字符串支持的格式控制符有以下这些:</para>

    <variablelist>
      <varlistentry>
        <term><literal>%a</literal></term>
        <listitem>
    <!--
          <para>The author of the revision given
            by <literal>%r</literal>.</para>
    -->
          <para>由 <literal>%r</literal> 指定的版本号的作者.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%b</literal></term>
        <listitem>
    <!--
          <para>The basename of the URL of the file.</para>
    -->
          <para>文件的 URL 的基本名 (basename).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%d</literal></term>
        <listitem>
    <!--
          <para>Short format of the date of the revision given by
            <literal>%r</literal>.</para>
    -->
          <para>由 <literal>%r</literal> 指定的版本号的日期的短格式.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%D</literal></term>
        <listitem>
    <!--
          <para>Long format of the date of the revision given by
            <literal>%r</literal>.</para>
    -->
          <para>由 <literal>%r</literal> 指定的版本号的日期的长格式.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%P</literal></term>
        <listitem>
    <!--
          <para>The file's path, relative to the repository
            root.</para>
    -->
          <para>文件相对于仓库根目录的路径.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%r</literal></term>
        <listitem>
    <!--
          <para>The last known revision in which this file changed in
          the repository.  (This is the same revision which would be
          substituted for the <literal>Revision</literal>
          keyword.)</para>
    -->
        <para>已知的文件最后一次被修改时的版本号 (和用来替换 <literal>Revision
        </literal> 的版本号相同).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%R</literal></term>
        <listitem>
    <!--
          <para>The URL to the root of the repository.</para>
    -->
          <para>仓库根目录的 URL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%u</literal></term>
        <listitem>
    <!--
          <para>The URL of the file.</para>
    -->
          <para>文件的 URL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%_</literal></term>
        <listitem>
    <!--
          <para>A space character. (Keyword definitions cannot contain
            a literal space character.)</para>
    -->
          <para>一个空格符 (定义关键字的字符串中不能包含字面空格).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%%</literal></term>
        <listitem>
    <!--
          <para>A literal percent sign ('<literal>%</literal>').</para>
    -->
          <para>一个百分号 (<literal>%</literal>).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%H</literal></term>
        <listitem>
    <!--
          <para>Equivalent to <literal>%P%_%r%_%d%_%a</literal>.</para>
    -->
          <para>等价于 <literal>%P%_%r%_%d%_%a</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%I</literal></term>
        <listitem>
    <!--
          <para>Equivalent to <literal>%b%_%r%_%d%_%a</literal>.</para>
    -->
          <para>等价于 <literal>%b%_%r%_%d%_%a</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <!--
    <para>As you can see, many of the individual format codes serve as
      placeholders for the same information available through the
      stock keywords.  But of course, the custom keyword format allows
      you to more flexibly string together multiple bits of
      information.  For example, you might wish to have a single
      keyword in your files which reports the repository relative path
      of the file and last-changed revision, formatted in a pleasant,
      human-readable way.  To do so, you'd first define your custom
      keyword:</para>
    -->
    <para>可以看到, 很多单独的格式控制字符所表示的信息与预定义的关键字所表示
      的信息相同, 但是自定义关键字允许用户得到更灵活和更丰富的信息. 比如说,
      用户希望有一个关键字能被替换成文件在仓库里的相对路径, 以及最后一次修改
      文件的版本号, 此时就需要自定义一个关键字:</para>

    <informalexample>
      <screen>
$ svn pset svn:keywords "PathRev=%P,%_r%r" calc/button.c
property 'svn:keywords' set on 'button.c'
$
</screen>
    </informalexample>

    <!--
    <para>Next, you'd edit the file's contents to add the keyword
      anchor for your custom keyword, which in this case
      is <literal>$PathRev$</literal>.  After committing these
      changes, an examination of your file's contents will show that
      your custom keyword was substituted as you would
      expect&mdash;where previously the file
      contained <literal>$PathRev$</literal>, it now reads
      <literal>$PathRev: trunk/calc/button.c, r23 $</literal>.</para>
    -->
    <para>接下来用户要把关键字锚点插入到文档的适当位置, 在这个例子里, 关键字
      锚点要写成 <literal>$PathRev$</literal>. 提交修改后, 文件中原来显示
      <literal>$PathRev$</literal> 的文本, 变成了
      <literal>$PathRev: trunk/calc/button.c, r23 $</literal>.</para>

    <note>
    <!--
      <para>Subversion will automatically truncate any keyword
        expansions which exceed 255 bytes in length.  Also custom
        keywords defined with names that exceed 255 bytes will be
        ignored altogether.</para>
    -->
      <para>如果关键字替换后的内容超过了 255 个字符, Subversion 会自动截断过
        长的部分. 自定义关键字的名字如果超过了 255 个字符, Subversion 会自动
        忽略超出的部分.</para>
    </note>

    <!--
    <para>You can also instruct Subversion to maintain a fixed length
      (in terms of the number of bytes consumed) for the substituted
      keyword.  By using a double colon (<literal>::</literal>) after
      the keyword name, followed by a number of space characters, you
      define that fixed width.  When Subversion goes to substitute
      your keyword for the keyword and its value, it will essentially
      replace only those space characters, leaving the overall width
      of the keyword field unchanged.  If the substituted value is
      shorter than the defined field width, there will be extra
      padding characters (spaces) at the end of the substituted field;
      if it is too long, it is truncated with a special hash
      (<literal>#</literal>) character just before the final dollar
      sign terminator.</para>
    -->
    <para>用户还可以为替换后的字符串指定一个固定的长度. 在关键字名字后面加
      两个冒号 (<literal>::</literal>), 然后是一定个数的空格, 这样就指定了
      一个固定长度. 当 Subversion 准备替换关键字时, 如果发现锚点指定了一个固
      定长度, Subversion 就只会替换空格部分. 如果替换后的字符串不够长, 不足
      的部分就会用空格填充; 如果替换后的字符串不过长, 字符串就会被截断, 并在
      截断的地方放置一个 <literal>#</literal> 字符.</para>

    <!--
    <para>For example, say you have a document in which you have
      some section of tabular data reflecting the document's
      Subversion keywords.  Using the original Subversion keyword
      substitution syntax, your file might look something
      like:</para>
    -->
    <para>比如说, 你有一个文档, 文档把 Subversion 的关键字按照表格的样式进行
      排版, 如果使用原来形式的关键字替换语法, 替换前的文件内容看起来就像:
    </para>

    <informalexample>
      <programlisting>
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</programlisting>
    </informalexample>
    
    <!--
    <para>Now, that looks nice and tabular at the start of things.
      But when you then commit that file (with keyword substitution
      enabled, of course), you see:</para>
    -->
    <para>现在看起来表格的格式还挺工整的, 但是提交后 (开启了关键字替换功能),
      文件的内容就变成了:</para>

    <informalexample>
      <programlisting>
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</programlisting>
    </informalexample>
    
    <!--
    <para>The result is not so beautiful.  And you might be
      tempted to then adjust the file after the substitution so
      that it again looks tabular.  But that holds only as long as
      the keyword values are the same width.  If the last
      committed revision rolls into a new place value (say, from
      99 to 100), or if another person with a longer username
      commits the file, stuff gets all crooked again.  However, if
      you are using Subversion 1.2 or later, you can use the new
      fixed-length keyword syntax and define some field widths that
      seem sane, so your file might look like this:</para>
    -->
    <para>替换后的效果令人感到失望, 用户可能会忍不住手工地调整每一行没对齐的
      文本, 但是实际上只要关键字的值占用相同的宽度, 格式就不会被打乱. 如果版本
      号增长到比较长的位数 (例如从 99 增长到 100), 或者有一个名字很长的用户提
      交了修改, 文件的版式就得重新调整. 如果用户使用的 Subversion 版本大于等于
      1.2, 就可以使用具有固定长度的关键字语法, 为了使用这种关键字语法, 把文件
      的内容改成:</para>

    <informalexample>
      <programlisting>
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</programlisting>
    </informalexample>
    
    <!--
    <para>You commit this change to your file.  This time,
      Subversion notices the new fixed-length keyword syntax and
      maintains the width of the fields as defined by the padding
      you placed between the double colon and the trailing dollar
      sign.  After substitution, the width of the fields is
      completely unchanged&mdash;the short values for
      <literal>Rev</literal> and <literal>Author</literal> are
      padded with spaces, and the long <literal>Date</literal>
      field is truncated by a hash character:</para>
    -->
    <para>提交修改, 这次 Subversion 会注意到文件中使用了具有固定长度的关键字语
      法, 替换后, 字段的长度保持不变&mdash;较短的 <literal>Rev</literal> 和
      <literal>Author</literal> 使用空格填充不足的部分, 较长的 <literal>Date
    </literal> 被井字符截断:</para>

    <informalexample>
      <programlisting>
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</programlisting>
    </informalexample>

      <!--
    <para>The use of fixed-length keywords is especially handy when
      performing substitutions into complex file formats that
      themselves use fixed-length fields for data, or for which the
      stored size of a given data field is overbearingly difficult to
      modify from outside the format's native application.  Of course,
      where binary file formats are concerned, you must always take great
      care that any keyword substitution you introduce&mdash;fixed-length
      or otherwise&mdash;does not violate the integrity of that format.
      While it might sound easy enough, this can be an astonishingly
      difficult task for most of the popular binary file formats in use
      today, and <emphasis>not</emphasis> something to be undertaken by
      the faint of heart!</para>
      -->
    <para>固定长度的关键字替换在以下场景非常方便: (1) 文件把数据放在长度固定
      的字段里; (2) 除了格式的本地应用程序外, 其他程序难以修改某些数据字段
      的存放大小. 当然, 如果涉及到二进制文件格式, 用户必须非常小心, 关键字替换
      (无论是长度是否固定) 不能破坏格式的完整性. 虽然这听起来很容易, 但是对于
      现在流行的大多数二进制格式而言, 实际做起来可能会非常困难, 绝不是稍微用
      点心就能对付过去的.</para>

    <warning>
    <!--
      <para>Be aware that because the width of a keyword field is
        measured in bytes, the potential for corruption of
        multibyte values exists.  For example, a username that
        contains some multibyte UTF-8 characters might suffer
        truncation in the middle of the string of bytes that make
        up one of those characters.  The result will be a mere
        truncation when viewed at the byte level, but will likely
        appear as a string with an incorrect or garbled final
        character when viewed as UTF-8 text.  It is conceivable
        that certain applications, when asked to load the file,
        would notice the broken UTF-8 text and deem the entire
        file corrupt, refusing to operate on the file
        altogether.  So, when limiting keywords to a fixed size,
        choose a size that allows for this type of byte-wise
        expansion.</para> 
    -->
      <para>注意关键字字段的长度以字节为单位, 在处理多字节字符时可能会出问题.
        比如说, 用户名如果包含 UTF-8 字符, 截断可能会发生在组成一个字符的多个
        字节之间. 从字节来看这可能只是一个非常普通的截断, 但是在解释成 UTF-8
        字符就会产生错误, 很可能会产生乱码. 有些应用程序在打开这种含有错误编
        码的文件时会认为整个文件已经损坏, 拒绝对文件进行进一步操作. 所以在限
        制关键字的长度时, 注意避免在字符当中发生截断.</para>
    </warning>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.sparsedirs">
    <!--
    <title>Sparse Directories</title>
    -->
    <title>稀疏目录</title>

    <para>
      <indexterm>
        <primary>sparse directories (稀疏目录)</primary>
      </indexterm>
      <indexterm>
        <primary>checkouts (检出)</primary>
        <secondary>shallow (浅检出)</secondary>
        <see>sparse directories (稀疏目录)</see>
      </indexterm>
      默认情况下, 大多数 Subversion 操作在处理目录时会采用递归的方式, 比如说,
      <command>svn checkout</command> 会检出仓库指定区域内的所有文件与目录.
      Subversion 1.5 引入了一个新特性: <firstterm>稀疏目录</firstterm>
      (<firstterm>sparse directories</firstterm>, 或 <firstterm>浅检出
      </firstterm> (<firstterm>shallow checkouts</firstterm>)). 和完整的递归
      操作相比, 新特性允许用户更加轻浅地检出工作副本&mdash;或工作副本的一部分,
      以后仍然还能访问到原来未被检出的文件与子目录.</para>
    <!--
      By default, most Subversion operations on
      directories act in a recursive manner.  For
      example, <command>svn checkout</command> creates a working copy
      with every file and directory in the specified area of the
      repository, descending recursively through the repository tree
      until the entire structure is copied to your local disk.
      Subversion 1.5 introduces a feature called <firstterm>sparse
      directories</firstterm> (or <firstterm>shallow
      checkouts</firstterm>) that allows you to easily check out a
      working copy&mdash;or a portion of a working copy&mdash;more
      shallowly than full recursion, with the freedom to bring in
      previously ignored files and subdirectories at a later
      time.</para>
    -->

    <!--
    <para>For example, say we have a repository with a tree of files
      and directories with names of the members of a human family with
      pets.  (It's an odd example, to be sure, but bear with us.)  A
      regular <command>svn checkout</command> operation will give us a
      working copy of the whole tree:</para>
    -->
    <para>举个例子, 假设我们有一个仓库, 仓库中存放的是拥有宠物的家庭成员 (这个
      例子确实有点奇怪), 普通的 <command>svn checkout</command> 操作会得到
      一整棵目录树的工作副本:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos mom
A    mom/son
A    mom/son/grandson
A    mom/daughter
A    mom/daughter/granddaughter1
A    mom/daughter/granddaughter1/bunny1.txt
A    mom/daughter/granddaughter1/bunny2.txt
A    mom/daughter/granddaughter2
A    mom/daughter/fishie.txt
A    mom/kitty1.txt
A    mom/doggie1.txt
Checked out revision 1.
$
</screen>
    </informalexample>

    <!--
    <para>Now, let's check out the same tree again, but this time
      we'll ask Subversion to give us only the topmost directory
      with none of its children at all:</para>
    -->
    <para>现在我们再次执行检出操作, 不过这次要求 Subversion 只检出最上层的目
      录, 不包括其中的文件与子目录:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1
$
</screen>
    </informalexample>
 
    <!--
    <para>Notice that we added to our original <command>svn
      checkout</command> command line a new <option>- -depth</option>
      option.  This option is present on many of Subversion's
      subcommands and is similar to the
      <option>- -non-recursive</option> (<option>-N</option>) and
      <option>- -recursive</option> (<option>-R</option>) options.  In
      fact, it combines, improves upon, supercedes, and ultimately
      obsoletes these two older options.  For starters, it expands the
      supported degrees of depth specification available to users,
      adding some previously unsupported (or inconsistently supported)
      depths.  Here are the depth values that you can request for a
      given Subversion operation:</para>
    -->
    <para>注意我们这次给命令 <command>svn checkout</command> 加了一个选项
      <option>--depth</option>. 很多子命令都支持这个选项, 选项的意义类似于
      <option>--non-recursive</option> (<option>-N</option>) 和
      <option>--recursive</option> (<option>-R</option>). 实际上, Subversion
      希望选项 <option>--depth</option> 最终能超过并替换掉这两个旧选项. 对
      新手来说, <option>--depth</option> 拓宽了用户能够指定的操作深度, 增加了
      一些原来不支持 (或支持地不一致) 的深度. 下面是用户可以使用的几种深度值:
    </para>

    <variablelist>

      <indexterm>
        <primary>depth (深度)</primary>
        <secondary>empty</secondary>
      </indexterm>
      <indexterm>
        <primary>depth (深度)</primary>
        <secondary>files</secondary>
      </indexterm>
      <indexterm>
        <primary>depth (深度)</primary>
        <secondary>immediates</secondary>
      </indexterm>
      <indexterm>
        <primary>depth (深度)</primary>
        <secondary>infinity</secondary>
      </indexterm>

      <varlistentry>
        <term><literal>--depth empty</literal></term>
        <listitem>
    <!--
          <para>Include only the immediate target of the operation,
            not any of its file or directory children.</para>
    -->
          <para>只包含操作的直接目标, 不包括其中的文件或子目录.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth files</literal></term>
        <listitem>
    <!--
          <para>Include the immediate target of the operation and any
            of its immediate file children.</para>
    -->
          <para>只包含操作的直接目标及其中的直接子文件.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth immediates</literal></term>
        <listitem>
    <!--
          <para>Include the immediate target of the operation and any
            of its immediate file or directory children.  The directory
            children will themselves be empty.</para>
    -->
          <para>包括操作的目标自身, 及它的直接子文件与直接子目录, 子目录为空.
          </para>
        </listitem>
      </varlistentry>
      
      <varlistentry>
        <term><literal>--depth infinity</literal></term>
        <listitem>
    <!--
          <para>Include the immediate target, its file and directory
            children, its children's children, and so on to full
            recursion.</para>
    -->
          <para>包括目标自身, 及它的所有子文件与子目录, 子目录的子文件与
            子目录, 等等.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>
      <indexterm>
        <primary>depth (深度)</primary>
        <secondary>ambient</secondary>
      </indexterm>
      当然, 如果仅仅是把两个选项合并成一个选项, 那就没必要花费整整一节的笔墨
      介绍它, 幸运的是远不止选项合并这么简单. 深度的概念不仅延伸到 Subversion
      客户端执行的操作, 同时还描述了工作副本的 <firstterm>周围深度</firstterm>
      (<firstterm>ambient depth</firstterm>), 它是工作副本为项目记录的深度.
      深度的关键之处在于它是 <quote>粘着</quote> (sticky) 的, 工作副本记住了用户为每一个项目
      指定的深度, 在用户显式地修改之前, 项目的深度不会发生变化. 默认情况下,
      不管文件的深度设置是什么样的, Subversion 的命令只会操作工作副本中已有
      的项目.</para>
    <!--
      Of course, merely combining two existing options into one
      hardly constitutes a new feature worthy of a whole section in
      our book.  Fortunately, there is more to this story.  This idea
      of depth extends not just to the operations you perform with
      your Subversion client, but also as a description of a working
      copy citizen's <firstterm>ambient depth</firstterm>, which is
      the depth persistently recorded by the working copy for that
      item.  Its key strength is this very persistence&mdash;the fact
      that it is <quote>sticky</quote>.  The working copy remembers
      the depth you've selected for each item in it until you later
      change that depth selection; by default, Subversion commands
      operate on the working copy citizens present, regardless of
      their selected depth settings.</para>
    -->

    <tip>
    <!--
      <para>You can check the recorded ambient depth of a working copy
        using the <command>svn info</command> command.  If the ambient
        depth is anything other than infinite recursion, <command>svn
        info</command> will display a line describing that depth
        value:</para>
    -->
      <para>可以用命令 <command>svn info</command> 查看工作副本的周围深度,
        如果周围深度是除了无限递归外的其他内容, <command>svn info</command>
        就会显示一行描述深度值的信息:</para>

      <informalexample>
        <screen>
$ svn info mom-immediates | grep "^Depth:"
Depth: immediates
$
</screen>
      </informalexample>
    </tip>

    <!--
    <para>Our previous examples demonstrated checkouts of infinite
      depth (the default for <command>svn checkout</command>) and
      empty depth.  Let's look now at examples of the other depth
      values:</para>
    -->
    <para>前面的两个例子演示的深度值 <literal>infinity</literal> (<command>
        svn checkout</command> 的默认行为) 和 <literal>empty</literal> 的效果,
      现在看一下其他深度的例子:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos mom-files --depth files
A    mom-files/kitty1.txt
A    mom-files/doggie1.txt
Checked out revision 1.
$ svn checkout file:///var/svn/repos mom-immediates --depth immediates
A    mom-immediates/son
A    mom-immediates/daughter
A    mom-immediates/kitty1.txt
A    mom-immediates/doggie1.txt
Checked out revision 1.
$
</screen>
    </informalexample>

    <!--
    <para>As described, each of these depths is something more than
      only the target, but something less than full recursion.</para>
    -->
    <para>和 <literal>empty</literal> 相比, 这些深度会得到更多的内容, 但和
      <literal>infinity</literal> 相比, 会得到更少的内容.</para>

    <!--
    <para>We've used <command>svn checkout</command> as an example
      here, but you'll find the <option>- -depth</option> option
      present on many other Subversion commands, too.  In those other
      commands, depth specification is a way to limit the scope of an
      operation to some depth, much like the way the older
      <option>- -non-recursive</option> (<option>-N</option>) and
      <option>- -recursive</option> (<option>-R</option>) options
      behave.  This means that when operating on a working copy of
      some depth, while requesting an operation of a shallower depth,
      the operation is limited to that shallower depth.  In fact, we
      can make an even more general statement: given a working copy of
      any arbitrary&mdash;even mixed&mdash;ambient depth, and a
      Subversion command with some requested operational depth, the
      command will maintain the ambient depth of the working copy
      members while still limiting the scope of the operation to the
      requested (or default) operational depth.</para>
    -->
    <para>我们已经介绍了 <command>svn checkout</command> 如何利用选项
      <option>--depth</option>, 但读者会看到除了 <command>checkout</command>,
      还有很多子命令也支持 <option>--depth</option>. 在这些命令中, 指定深度
      将操作的作用域限制在某一层次上, 非常类似老选项 <option>--non-recursive
      </option> 和 <option>--recursive</option> 的行为. 这就意味着当我们操作
      一个处在某个深度上的工作副本时, 可以执行一个深度更浅的操作. 实际上, 我
      们可以更一般地说: 对于一个给定的, 处于任意周围深度 (深度可以是混合的)
      的工作副本, 和一个指定了操作深度 (或使用默认值) 的 Subversion 命令, 命令
      将保持工作副本的周围深度不变, 同时将操作的作用域限制在所给定 (或默认的)
      的操作深度上.</para>

    <!--
    <para>In addition to the <option>- -depth</option> option, the
      <command>svn update</command> and <command>svn switch</command>
      subcommands also accept a second depth-related option:
      <option>- -set-depth</option>.  It is with this option that you
      can change the sticky depth of a working copy item.  Watch what
      happens as we take our empty-depth checkout and gradually
      telescope it deeper using <userinput>svn update
      - -set-depth <replaceable>NEW-DEPTH</replaceable> <replaceable>TARGET</replaceable></userinput>:</para>
    -->
    <para>除了选项 <option>--depth</option>, 命令 <command>svn update</command>
      和 <command>svn switch</command> 还支持第二种与深度有关的选项 <option>
      --set-depth</option>, 它可以修改工作副本中项目的粘着深度. 现在看
      一下如何使用 <userinput>svn update --set-depth <replaceable>
      NEW-DEPTH</replaceable> <replaceable>TARGET</replaceable></userinput>,
      把原来深度为 <literal>empty</literal> 的工作副本逐渐加深:</para>

    <informalexample>
      <screen>
$ svn update --set-depth files mom-empty
Updating 'mom-empty':
A    mom-empty/kittie1.txt
A    mom-empty/doggie1.txt
Updated to revision 1.
$ svn update --set-depth immediates mom-empty
Updating 'mom-empty':
A    mom-empty/son
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty
Updating 'mom-empty':
A    mom-empty/son/grandson
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
A    mom-empty/daughter/granddaughter2
A    mom-empty/daughter/fishie1.txt
Updated to revision 1.
$
</screen>
    </informalexample>

    <!--
    <para>As we gradually increased our depth selection, the
      repository gave us more pieces of our tree.</para>
    -->
    <para>随着深度的不断加深, 每次更新, 仓库都会给我们传来更多的数据.</para>

    <!--
    <para>In our example, we operated only on the root of our working
      copy, changing its ambient depth value.  But we can
      independently change the ambient depth value of
      <emphasis>any</emphasis> subdirectory inside the working copy,
      too.  Careful use of this ability allows us to flesh out only
      certain portions of the working copy tree, leaving other
      portions absent altogether (hence the <quote>sparse</quote> bit
      of the feature's name).  Here's an example of how we might build
      out a portion of one branch of our family's tree, enable full
      recursion on another branch, and keep still other pieces pruned
      (absent from disk).</para>
    -->
    <para>在上面的例子里, 我们都是在工作副本的根目录执行操作, 改变周围深度, 其
      实我们可以独立地修改工作副本的 <emphasis>任意</emphasis> 子目录的周围
      深度. 认真使用这项特性就可以在工作副本中只保留感兴趣的部分, 而忽略那些
      不重要的部分 (所以称为 <quote>稀疏</quote> 目录), 下面的例子展示了典型
      的用法:</para>

    <informalexample>
      <screen>
$ rm -rf mom-empty
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1.
$ svn update --set-depth empty mom-empty/son
Updating 'mom-empty/son':
A    mom-empty/son
Updated to revision 1.
$ svn update --set-depth empty mom-empty/daughter
Updating 'mom-empty/daughter':
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty/daughter/granddaughter1
Updating 'mom-empty/daughter/granddaughter1':
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
Updated to revision 1.
$
</screen>
    </informalexample>

    <!--
    <para>Fortunately, having a complex collection of ambient depths
      in a single working copy doesn't complicate the way you interact
      with that working copy.  You can still make, revert, display,
      and commit local modifications in your working copy without
      providing any new options (including <option>- -depth</option> and
      <option>- -set-depth</option>) to the relevant subcommands.  Even
      <command>svn update</command> works as it does elsewhere when no
      specific depth is provided&mdash;it updates the working copy
      targets that are present while honoring their sticky
      depths.</para>
    -->
    <para>幸运的是, 在一个工作副本里出现如此复杂的周围深度并不会使用户与工作
      副本的交互也变得复杂. 用户仍然可以像以往那样修改文件, 显示修改, 撤消或
      提交修改, 而不用给相关命令提供新的选项 (包括 <option>--depth</option>
      和 <option>--set-depth</option>). 当没有指定深度时, <command>svn update
      </command> 也能正常工作&mdash;命令根据各个项目的粒着深度更新工作副本里
      已有的文件和目录.</para>

    <!--
    <para>You might at this point be wondering, <quote>So what?  When
      would I use this?</quote>  One scenario where this feature
      finds utility is tied to a particular repository layout,
      specifically where you have many related or codependent
      projects or software modules living as siblings in a single
      repository location (<filename>trunk/project1</filename>,
      <filename>trunk/project2</filename>,
      <filename>trunk/project3</filename>, etc.).  In such
      scenarios, it might be the case that you personally care 
      about only a handful of those projects&mdash;maybe some primary
      project and a few other modules on which it depends.  You can
      check out individual working copies of all of these things, but
      those working copies are disjoint and, as a result, it can be
      cumbersome to perform operations across several or all of them
      at the same time.  The alternative is to use the sparse
      directories feature, building out a single working copy that
      contains only the modules you care about.  You'd start with an
      empty-depth checkout of the common parent directory of the
      projects, and then update with infinite depth only the items you
      wish to have, like we demonstrated in the previous example.
      TODO
      Think of it like an opt-in system for working copy
      citizens.</para>
    -->
    <para>读者心里可能在想 <quote>那么, 我什么时候会用到稀疏目录呢?</quote> 
      用到稀疏目录的一种场景是仓库的布局比较特殊, 尤其是许多相关的项目模块都
      在同一个仓库中分别占据一个单独的目录 (例如 <filename>trunk/project1
        </filename>, <filename>trunk/project2</filename>, <filename>
        trunk/project3</filename> 等), 但是用户可能只关心其中的部分模块&mdash;
      比如说项目的主要模块及其依赖模块. 用户可以分别检出他所关心的各个模块的
      工作副本, 但是这些工作副本之间是分离的, 如果想同时对它们执行同一个操作
      就会很麻烦, 必须多次切换目录. 另一种选择是利用稀疏目录特性, 检出一个只
      包含了感兴趣的模块的工作副本. 首先为模块的公共父目录检出一个深度为
      <literal>empty</literal> 的工作副本, 然后按照深度 <literal>infinity
    </literal> 更新感兴趣的模块目录, 就像我们在上一个例子中展示的那样.
    可以把稀疏目录看成是工作副本中项目的选入系统.</para>

    <!--
    <para>The original (Subversion 1.5) implementation of shallow
      checkouts was good, but didn't support de-telescoping of working
      copy items.  Subversion 1.6 remedied this problem.  For example,
      running <userinput>svn update - -set-depth empty</userinput> in
      an infinite-depth working copy will discard everything but the
      topmost directory.<footnote><para>Safely, of course.  As in
      other situations, Subversion will leave on disk any files you've
      modified or which aren't versioned.</para></footnote>  Subversion
      1.6 also introduced another supported value for
      the <option>- -set-depth</option>
      option: <literal>exclude</literal>.  Using <option>- -set-depth
      exclude</option> with <command>svn update</command> will cause
      the update target to be removed from the working copy
      entirely&mdash;a directory target won't even be left
      present-but-empty.  This is especially handy when there are more
      things that you'd like to keep in a working copy than things
      you'd like to <emphasis>not</emphasis> keep.</para>
    -->
    <para>浅检出的原始实现 (Subversion 1.5) 就已经很不错了, 但是它不能缩减
      工作副本项目的深度, Subversion 1.6 解决了这个问题. 比如说在一个深度
      原来是 <literal>infinity</literal> 的工作副本里执行 <command>
        svn update --set-depth empty</command>, 工作副本就会删除除了顶层目录
      外的所有文件与目录 <footnote><para>删除操作是安全的, Subversion 会保留
          修改过的或未被版本控制的项目.</para></footnote> Subversion 1.6 还
      为选项 <option>--set-depth</option> 引入的一个新的值: <literal>exclude
      </literal>. 如果给命令 <command>svn update</command> 带上选项
      <option>--set-depth exclude</option> 会造成被更新的目标从工作副本中完全
      删除&mdash;如果目标是一个目录, 那么目录也会被完全删除, 而不是留下一个
      空目录. 如果工作副本中用户想保留的东西要比不想保留的东西多, 那
      <literal>--set-depth exclude</literal> 就能提供很大的方便.</para>

    <!--
    <para>Consider a directory with hundreds of subdirectories, one of
      which you would like to omit from your working copy.  Using
      an <quote>additive</quote> approach to sparse directories, you
      might check out the directory with an empty depth, then
      explicitly telescope (using <userinput>svn update - -set-depth
      infinity</userinput>) each and every subdirectory of the
      directory except the one you don't care about.</para>
    -->
    <para>考虑一个包含了几百个子目录的目录, 用户想要从工作副本中忽略其中一个
      子目录, 如果是用 <quote>增量</quote> 的方法得到稀疏目录, 首先先检出一
      个深度为 <literal>empty</literal> 的工作副本, 然后显式地把每一个子目录
      的深度设置成 <literal>infinity</literal> (使用
      <userinput>svn update --set-depth infinity</userinput>), 除了那个用户
      不感兴趣的子目录.</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/repos/many-dirs --depth empty
&hellip;
$ svn update --set-depth infinity many-dirs/wanted-dir-1
&hellip;
$ svn update --set-depth infinity many-dirs/wanted-dir-2
&hellip;
$ svn update --set-depth infinity many-dirs/wanted-dir-3
&hellip;
### and so on, and so on, ...
</screen>
    </informalexample>

    <!--
    <para>This could be quite tedious, especially since you don't even
      have stubs of these directories in your working copy to deal
      with.  Such a working copy would also have another
      characteristic that you might not expect or desire: if someone
      else creates any new subdirectories in this top-level directory,
      you won't receive those when you update your working
      copy.</para>
    -->
    <para>这可能会非常枯燥, 尤其是工作副本中还不存在存根目录供用户处理.
      另一个问题是如果有人在顶层目录下创建了一个新的子目录, 当用户更新
      工作副本时将看不到这个新的子目录, 这应该不是你想要的效果.</para>

    <!--
    <para>Beginning with Subversion 1.6, you can take a different
      approach.  First, check out the directory in full.  Then
      run <userinput>svn update - -set-depth exclude</userinput> on the
      one subdirectory you don't care about.</para>
    -->
    <para>从 Subversion 1.6 开始, 你有了另一种选择. 首先检出一个完整的目录,
      然后在不兴趣的目录上执行 <userinput>svn update --set-depth exclude
    </userinput></para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/repos/many-dirs
&hellip;
$ svn update --set-depth exclude many-dirs/unwanted-dir
D         many-dirs/unwanted-dir
$
</screen>
    </informalexample>

    <!--
    <para>This approach leaves your working copy with the same stuff
      as in the first approach, but any new subdirectories which
      appear in the top-level directory would also show up when you
      update your working copy.  The downside of this approach is that
      you have to actually check out that whole subdirectory that you
      don't even want just so you can tell Subversion that you don't
      want it.  This might not even be possible if that subdirectory
      is too large to fit on your disk (which might, after all, be the
      very reason you don't want it in your working copy).</para>
    -->
    <para>和第一种方法相比, 使用第二种方法后在工作副本里留下的数据是相同的,
      但是如果有新的子目录被提交到仓库中, 更新工作副本时仍然可以看到. 第二种
      方法的缺点是一开始要检出后来不用的子目录, 如果子目录过于庞大, 大到磁盘
      无法容纳 (可能这就是用户不想把它检出到工作副本里的原因).</para>

    <note>
    <!--
      <para>While the functionality for excluding an existing item
        from a working copy was hung off of the <command>svn
        update</command> command, you might have noticed that the
        output from <userinput>svn update - -set-depth
        exclude</userinput> differs from that of a normal update
        operation.  This output betrays the fact that, under the hood,
        exclusion is a completely client-side operation, very much
        unlike a typical update.</para>
    -->
      <para>虽然这个功能&mdash;从工作副本中排除已有的项目&mdash;由 <command>
          svn update</command> 完成, 但读者可能已经注意到 <userinput>
          svn update --set-depth exclude</userinput> 的输出和通常的
        <command>svn update</command> 的不太一样. 排除是一个完全客户端的操作,
        但命令的输出却不太符合这个事实.</para>
    </note>

    <!--
    <para>In such a situation, you might consider a compromise
      approach.  First, check out the top-level directory
      with <option>- -depth immediates</option>.  Then, exclude the
      directory you don't want using <userinput>svn update - -set-depth
      exclude</userinput>.  Finally, telescope all the items that
      remain to infinite depth, which should be fairly easy to do
      because they are all addressable in your shell.</para>
    -->
    <para>如果出现这种情况, 你可能需要一个折衷的方法. 首先, 使用 <literal>
        --depth immediates</literal> 检出顶层目录, 然后用 <literal>
        svn update --set-depth exclude</literal> 排除不感兴趣的子目录, 最后,
      把剩下的子目录的深度设置成 <literal>infinity</literal>, 因为子目录都已
      经出现在本地了, 所以应该会容易一点.</para>

    <informalexample>
    <screen>
$ svn checkout http://svn.example.com/repos/many-dirs --depth immediates
&hellip;
$ svn update --set-depth exclude many-dirs/unwanted-dir
D         many-dirs/unwanted-dir
$ svn update --set-depth infinity many-dirs/*
&hellip;
$
</screen>
    </informalexample>

    <!--
    <para>Once again, your working copy will have the same stuff as in
      the previous two scenarios.  But now, any time a new file or
      subdirectory is committed to the top-level directory, you'll
      receive it&mdash;at an empty depth&mdash;when you update your
      working copy.  You can now decide what to do with such newly
      appearing working copy items: expand them into infinite depth,
      or exclude them altogether.</para>
    -->
    <para>再说一次, 这种方法得到的工作副本里的数据和前两种方法完全相同, 当有
      新的文件或目录提交到顶层目录时, 更新操作按深度 <literal>empty</literal>
      把文件或目录更新到本地, 接下来你可以决定针对新出现的项目应该采取什么
      操作: 是把深度扩展到 <literal>infinity</literal>, 还是把它排除.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
    <!--
    <title>Locking</title>
    -->
    <title>锁</title>

    <!--
    <para>Subversion's copy-modify-merge version control model lives
      and dies on its data merging algorithms&mdash;specifically on
      how well those algorithms perform when trying to resolve
      conflicts caused by multiple users modifying the same file
      concurrently.  Subversion itself provides only one such
      algorithm: a three-way differencing algorithm that is smart
      enough to handle data at a granularity of a single line of text.
      Subversion also allows you to supplement its content merge
      processing with external differencing utilities (as described in
      <xref linkend="svn.advanced.externaldifftools.diff3" /> and
      <xref linkend="svn.advanced.externaldifftools.merge" />), some
      of which may do an even better job, perhaps providing
      granularity of a word or a single character of text.  But common
      among those algorithms is that they generally work only on text
      files.  The landscape starts to look pretty grim when you start
      talking about content merges of nontextual file formats.  And
      when you can't find a tool that can handle that type of merging,
      you begin to run into problems with the copy-modify-merge
      model.</para>
    -->
    <para>Subversion 的数据合并算法与 复制-修改-合并 模型之间的关系就像水和
      船: 水能载舟, 亦能覆舟&mdash;尤其是当 Subversion 尝试解决冲突时, 合并
      算法的表现至关重要. Subversion 自身只提供了一种合并算法: 三路差异比较算
      法的智能足够在行的级别上处理数据. 作为补充, Subversion 允许用户指定外部
      的差异比较工具 (在 
      <xref linkend="svn.advanced.externaldifftools.diff3" /> 和
      <xref linkend="svn.advanced.externaldifftools.merge" /> 介绍), 这些外
      部工具可能比 Subversion 工作得更好, 比如在单词或字符的级别上比较差异.
      但是这些工具和 Subversion 的算法通常只能处理文本文件, 在面对非文本文件
      时, 现实就残酷多了. 如果用户无法找到支持非文本文件合并的工具,
      复制-修改-合并 模型就不再适用.</para>

    <!--
    <para>Let's look at a real-life example of where this model runs
      aground.  Harry and Sally are both graphic designers working on
      the same project, a bit of marketing collateral for an
      automobile mechanic.  Central to the design of a particular
      poster is an image of a car in need of some bodywork, stored in
      a file using the PNG image format.  The poster's layout is
      almost finished, and both Harry and Sally are pleased with the
      particular photo they chose for their damaged car&mdash;a baby
      blue 1967 Ford Mustang with an unfortunate bit of crumpling on
      the left front fender.</para>
    -->
    <para>介绍一个现实生活中可能会遇到的例子. Harry 和 Sally 是同一个项目的
      图片设计师, 为汽车保险部门设计一款海报. 海报的中心是一辆汽车, 海报的格式
      是 PNG. 海报的布局已经基本确定, Harry 和 Sally 将一辆 1967 年淡蓝色
      Ford Mustang 照片放在海报中央, 车的左前侧保险杠有一点凹陷.</para>

    <!--
    <para>Now, as is common in graphic design work, there's a change
      in plans, which causes the car's color to be a concern.  So Sally
      updates her working copy to <literal>HEAD</literal>, fires up
      her photo-editing software, and sets about tweaking the image so
      that the car is now cherry red.  Meanwhile, Harry, feeling
      particularly inspired that day, decides that the image would
      have greater impact if the car also appears to have suffered
      greater impact.  He, too, updates to <literal>HEAD</literal>,
      and then draws some cracks on the vehicle's windshield.  He
      manages to finish his work before Sally finishes hers, and after
      admiring the fruits of his undeniable talent, he commits the
      modified image.  Shortly thereafter, Sally is finished with the
      car's new finish and tries to commit her changes.  But, as
      expected, Subversion fails the commit, informing Sally that
      her version of the image is now out of date.</para>
    -->
    <para>项目计划有所改动, 导致车身的颜色需要修改, 于是 Sally 把工作副本更
      新到 <literal>HEAD</literal>, 打开图片编辑软件, 将车身的颜色改成樱桃红.
      同时, Harry 觉得车的毁坏程度应该更严重一些, 这样效果更好, 于是他也把自己
      的工作副本更新到 <literal>HEAD</literal>, 在车挡风玻璃上增加了一些裂痕.
      就在 Harry 提交修改后, Sally 也提交了自己的修改, 显然, Subversion 会拒绝
      Sally 的提交.</para>

    <!--
    <para>Here's where the difficulty sets in.  If Harry and Sally
      were making changes to a text file, Sally would simply update
      her working copy, receiving Harry's changes in the process.  In
      the worst possible case, they would have modified the same
      region of the file, and Sally would have to work out by hand the
      proper resolution to the conflict.  But these aren't text
      files&mdash;they are binary images.  And while it's a simple
      matter to describe what one would expect the results of this
      content merge to be, there is precious little chance that any
      software exists that is smart enough to examine the common
      baseline image that each of these graphic artists worked
      against, the changes that Harry made, and the changes that Sally
      made, and then spit out an image of a busted-up red Mustang with
      a cracked windshield!</para>
    -->
    <para>现在麻烦来了. 如果 Harry 和 Sally 编辑的是文本文件, 此时 Sally 只
      要更新工作副本, 然后就可以再次尝试提交, 最差的情况不过是两人都修改了文件
      的同一区域, 而 Sally 必须手工地解决冲突. 但海报不是文本文件, 它是二进制
      的图片, 没有哪一款软件可以聪明到能够把两张图片合并成一张, 最终得到一辆
      樱桃红的, 挡风玻璃上有裂痕的汽车.</para>

    <para>
      <indexterm>
        <primary>locks (锁)</primary>
      </indexterm>
      <indexterm>
        <primary>checkouts (检出)</primary>
        <secondary>reserved (保留地)</secondary>
        <see>locking (加锁)</see>
      </indexterm>
      如果 Harry 和 Sally 是串行地修改图片, 那事情就会顺利很多&mdash;比如 Sally
      修改车身颜色并提交后, Harry 再去添加裂痕, 或者是 Sally 等到 Harry 添加裂
      痕后再去修改车身颜色. <xref linkend="svn.basic.vsn-models.copy-merge" />
      已经说过, 如果 Harry 和 Sally 之间进行了充分的沟通, 这种问题大部分都可
      以迎刃而解. 但是版本控制系统也是一种沟通的形式, 由软件来保证工作的串行
      化并不是一件坏事, 反而效果更好, 效率更高. 正是基于这点考虑, Subversion
      实现了 加锁-修改-解锁 模型. Subversion 的 <emphasis>锁定</emphasis>
      特性和其他版本控制系统的 <quote>保留检出</quote> 比较类似.</para>
    <!--
      Of course, things would have gone more smoothly if
      Harry and Sally had serialized their modifications to the
      image&mdash;if, say, Harry had waited to draw his windshield
      cracks on Sally's now-red car, or if Sally had tweaked the color
      of a car whose windshield was already cracked.  As is discussed
      in <xref linkend="svn.basic.vsn-models.copy-merge" />, most of
      these types of problems go away entirely where perfect
      communication between Harry and Sally
      TODO
      exists.<footnote><para>Communication wouldn't have been such bad
      medicine for Harry and Sally's Hollywood namesakes, either, for
      that matter.</para></footnote> But as one's version control
      system is, in fact, one form of communication, it follows that
      having that software facilitate the serialization of
      nonparallelizable editing efforts is no bad thing.  This is
      where Subversion's implementation of the lock-modify-unlock
      model steps into the spotlight.  This is where we talk about
      Subversion's <firstterm>locking</firstterm> feature, which is
      similar to the <quote>reserved checkouts</quote> mechanisms of
      other version control systems.</para>
    -->

    <!--
    <para>Subversion's locking feature exists ultimately to minimize
      wasted time and effort.  By allowing a user to programmatically
      claim the exclusive right to change a file in the repository,
      that user can be reasonably confident that any energy he invests
      on unmergeable changes won't be wasted&mdash;his commit of those
      changes will succeed.  Also, because Subversion communicates to
      other users that serialization is in effect for a particular
      versioned object, those users can reasonably expect that the
      object is about to be changed by someone else.  They, too, can
      then avoid wasting their time and energy on unmergeable changes
      that won't be committable due to eventual
      out-of-dateness.</para>
    -->
    <para>Subversion 的锁定特性是为了最大程度地减少时间和精力的浪费. 允许用户
      独占地修改仓库中的文件, 保证了用户在不支持合并的修改上所花费的精力不会
      被浪费&mdash;他的修改总能提交成功. 并且, Subversion 把对象正在被锁定的
      事实告诉给了其他用户, 其他用户就可以知道该对象正在被修改, 也就不会把时
      间浪费在无法成功提交与合并的修改上.</para>

    <!--
    <para>When referring to Subversion's locking feature, one is
      actually talking about a fairly diverse collection of behaviors,
      which include the ability to lock a versioned
      file<footnote><para>Subversion does not currently allow locks on
      directories.</para></footnote> (claiming the exclusive right to
      modify the file), to unlock that file (yielding that exclusive
      right to modify), to see reports about which files are locked
      and by whom, to annotate files for which locking before editing
      is strongly advised, and so on.  In this section, we'll cover
      all of these facets of the larger locking feature.</para>
    -->
    <para>当我们谈到 Subversion 的锁定特性时, 实际上说的是多种不同行为的集合,
      包括锁定文件的的能力 <footnote><para>Subversion 目前不支持锁定目录.
      </para></footnote> (获得独占修改文件的权利), 解锁一个文件 (放弃独占修改
      文件的权利), 查看哪些文件被哪些用户锁定, 为锁定的文件添加注释 (强烈建议)
      等, 所有的这些都会在本节进行详细介绍.</para>

    <sidebar id="svn.advanced.locking.meanings">
    <!--
      <title>The Many Meanings of <quote>Lock</quote></title>
    -->
      <title><quote>锁</quote> 的多种涵义</title>

    <!--
      <para>In this section, and almost everywhere in this book, the
        words <quote>lock</quote> and <quote>locking</quote> describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits.  Unfortunately, there are other sorts
        of <quote>lock</quote> with which Subversion, and therefore
        this book, sometimes needs to be concerned.</para>
    -->
      <para>本节及书中的其他地方, 单词 <quote>锁 (lock) </quote> 和 <quote>
          加锁 (locking)</quote> 描述一种用于实现用户间互斥的机制, 避免提交
        产生碰撞. 不幸的是, Subversion 还有其他种类的 <quote>锁</quote> 需要
        注意.</para>

      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>administrative (管理锁)</secondary>
          </indexterm>
          <firstterm>管理锁</firstterm> (<firstterm>administrative
            locks</firstterm>), 由 Subversion 内部使用, 用于防止多个客户端在
          操作同一个工作副本时产生碰撞. <command>svn status</command> 输出中
          第三列的 <computeroutput>L</computeroutput> 指的就是管理锁, 命令
          <command>svn cleanup</command> 会删除管理锁, 见
          <xref linkend="svn.tour.cleanup"/>.</para>
    <!--
        </indexterm>Subversion uses <firstterm>administrative
        locks</firstterm> internally to prevent
        clashes between multiple Subversion clients operating on the
        same working copy.  This is the sort of lock indicated by an
        <computeroutput>L</computeroutput> in the third column of
        <command>svn status</command> output, and removed by the
        <command>svn cleanup</command> command, as described in <xref
        linkend="svn.tour.cleanup"/>.</para>
    -->

      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>database (数据库锁)</secondary>
          </indexterm>
          使用老的 Berkeley DB 作为仓库后端的管理员需要了解 <firstterm>数据库锁
          </firstterm>, 它由 Berkeley DB 数据库内部使用, 防止多个程序在访问数
          据库时产生碰撞. 这种类型的锁如果在遭遇错误出现了不应该出现的持久化
          状态, 将导致仓库 <quote>楔形化</quote> (见
          <xref linkend="svn.berkeleydb.maintenance.recovery" />.</para>
    <!--
        </indexterm>Administrators using the older Berkeley DB repository
        backend will need to be familiar with <firstterm>database
        locks</firstterm>, which exist to prevent clashes between multiple
        programs trying to access the database.  This is the sort of lock
        whose unwanted persistence after an error can cause a repository
        to be <quote>wedged,</quote> as described in
        <xref linkend="svn.berkeleydb.maintenance.recovery" />.</para>
    -->

      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>svnsync</secondary>
        </indexterm>
        另外, <firstterm>svnsync 锁</firstterm> 可以让命令
        <command>svnsync</command> 的多个实例在操作仓库的同一个镜像时保持互斥.
        这种锁类型通过版本号的 <literal>svn:sync-lock</literal> 属性实现, 
        <command>svnsync</command> 的介绍见
        <xref linkend="svn.reposadmin.maint.replication.svnsync" />.</para>
      <!--
        Additionally, there are <firstterm>svnsync
        locks</firstterm>, which effect mutual exclusion between multiple
        instances of the <command>svnsync</command> command that write
        to the same mirror of a repository.  This is the sort of lock
        implemented by the <literal>svn:sync-lock</literal> revision
        property, as described in <xref
        linkend="svn.reposadmin.maint.replication.svnsync" />.</para>
      -->

      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>svnrdump</secondary>
        </indexterm>
        最后还有一个 <firstterm>svnrdump 锁</firstterm>. 它和 svnsync 锁非常
        类似, 只是它和命令 <command>svnrdump load</command> 相关, <command>svnrdump
        </command> 的介绍见
        <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />.</para>
      <!--
        Finally, there are <firstterm>svnrdump
        locks</firstterm>.  These are very much like svnsync locks, but
        are associated with the <command>svnrdump load</command> command
        (described in <xref linkend="svn.reposadmin.maint.migrate.svnrdump"
        />) instead of <command>svnsync</command>.</para>
      -->

    <!--
      <para>You can generally forget about these other kinds of locks
        until something goes wrong that requires you to care about
        them.  In this book, <quote>lock</quote> means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</para>
    -->
      <para>除非出现问题, 否则的话用户可以不用考虑后两种锁. 贯穿全书, <quote>
          锁</quote> 都指的是第一种锁, 除非显式地或者从上下文可以明显地推断
        出锁的其他类型.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
    <!--
      <title>Creating Locks</title>
    -->
      <title>创建锁</title>
      
      <para>
        <indexterm>
          <primary>locks (锁)</primary>
        </indexterm>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>lock token (锁令牌)</secondary>
        </indexterm>
        <indexterm>
          <primary>locking (加锁)</primary>
          <secondary>lock owner (锁的持有者)</secondary>
        </indexterm>
        在 Subversion 仓库里, 一个 <firstterm>锁</firstterm> (<firstterm>lock
        </firstterm>) 就是一段元数据, 它赋予了一个用户独占修改文件的权利, 该
        用户被认为是 <firstterm>锁的持有者</firstterm> (<firstterm>lock
          owner</firstterm>). 仓库
        负责管理锁, 具体来说就是锁的创建, 实施和删除. 如果有一个提交试图修改或
        删除被锁定了的文件 (或删除文件的某个父目录), 仓库就会要求客户端提供 2
        项信息&mdash;一是执行提交操作的客户端已被授权为锁的所有者, 二是提供了
        锁令牌, 表明客户端知道它用的是哪一个锁.</para>
    <!--
        In the Subversion repository, a
        <firstterm>lock</firstterm> is a piece of metadata that
        grants exclusive access to one user to change a file.  This
        user is said to be the <firstterm>lock owner</firstterm>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <firstterm>lock
        token</firstterm>.  The repository manages locks, ultimately
        handling their creation, enforcement, and removal.  If any
        commit transaction attempts to modify or delete a locked file
        (or delete one of the parent directories of the file), the
        repository will demand two pieces of information&mdash;that
        the client performing the commit be authenticated as the lock
        owner, and that the lock token has been provided as part of
        the commit process as a form of proof that the client knows which
        lock it is using.</para>
    -->
      
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>lock</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>creation (创建)</secondary>
        </indexterm>
        为了演示锁的创建, 我们再以海报设计作为例子. Harry 决定修改一个 JPEG
        图片, 为了防止其他用户在他完成修改之前向该文件提交修改, 他使用命令
        <command>svn lock</command> 锁定了仓库中的文件:</para>
    <!--
        To demonstrate lock creation, let's refer back to
        our example of multiple graphic designers working on the same
        binary image files.  Harry has decided to change a JPEG image.
        To prevent other people from committing changes to the file
        while he is modifying it (as well as alerting them that he is
        about to change it), he locks the file in the repository using
        the <command>svn lock</command> command.</para>
    -->

      <informalexample>
        <screen>
$ svn lock banana.jpg -m "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.
$
</screen>
      </informalexample>

    <!--
      <para>The preceding example demonstrates a number of new things.
        First, notice that Harry passed the
        <option>- -message</option> (<option>-m</option>) option to
        <command>svn lock</command>.  Similar to <command>svn
        commit</command>, the <command>svn lock</command> command can
        take comments&mdash;via either <option>- -message</option>
        (<option>-m</option>) or <option>- -file</option>
        (<option>-F</option>)&mdash;to describe the reason for locking the
        file.  Unlike <command>svn commit</command>, however,
        <command>svn lock</command> will not demand a message by
        launching your preferred text editor.  Lock comments are
        optional, but still recommended to aid communication.</para>
    -->
      <para>上面的例子展示了一些新东西. 首先, Harry 向命令 <command>svn lock
        </command> 传递了选项 <option>--message</option>
        (<option>-m</option>), 和命令 <command>svn commit</command> 类似,
        <command>svn lock</command> 支持注释&mdash;借助选项 <option>--message
        </option> (<option>-m</option>) 或 <option>--file</option>
        (<option>-F</option>)&mdash;注释描述了锁定文件的原因. 然而, 和
        <command>svn commit</command> 不同的是 <command>svn lock</command> 不
        会通过启动文本编辑器来要求用户输入注释, 注释是可选的, 但是为了更好地
        与其他用户沟通, 建议输入注释.</para>

    <!--
      <para>Second, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out of date, the repository would have rejected the
        request, forcing Harry to <command>svn update</command> and
        reattempt the locking command.  The locking command would also
        have failed if the file had already been locked by someone
        else.</para>
    -->
      <para>第二, 尝试加锁成功了, 这就是说文件之前未被锁定, 而且 Harry 工作副本
        里的文件是最新的. 如果 Harry 工作副本里的文件是过时了的, 仓库将会拒绝
        加锁请求, 要求 Harry 执行 <command>svn update</command> 并重新执行加
        锁命令. 如果文件已经处于加锁状态, 加锁命令也会失败.</para>

    <!--
      <para>As you can see, the <command>svn lock</command> command
        prints confirmation of the successful lock.  At this point,
        the fact that the file is locked becomes apparent in the
        output of the <command>svn status</command> and <command>svn
        info</command> reporting subcommands.</para>
    -->
    <para>如果加锁成功, <command>svn lock</command> 会输出确认信息, 从现在开始,
      文件已经被锁定的事实会体现在 <command>svn status</command> 和
      <command>svn info</command> 的输出信息里.</para>

      <informalexample>
        <screen>
$ svn status
     K  banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
Working Copy Root Path: /home/harry/project
URL: http://svn.example.com/repos/project/banana.jpg
Relative URL: ^/banana.jpg
Repository Root: http://svn.example.com/repos/project
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
Editing file for tomorrow's release.

$
</screen>
      </informalexample>

    <!--
      <para>The fact that the <command>svn info</command> command,
        which does not contact the repository when run against working
        copy paths, can display the lock token reveals an important
        piece of information about those tokens:  they are cached in
        the working copy.  The presence of the lock token is critical.
        It gives the working copy authorization to make use of the
        lock later on.  Also, the <command>svn status</command>
        command shows a <literal>K</literal> next to the file (short
        for locKed), indicating that the lock token is present.</para>
    -->
      <para><command>svn info</command> 在执行时不会与仓库通信, 但是它仍然可
        以显示锁令牌, 说明了一个很重要的信息: 它们被缓存在工作副本里. 锁令牌
        的存在非常重要, 它向工作副本提供了使用锁的授权. 并且, <command>
          svn status</command> 在文件名的旁边显示一个 <literal>K</literal>
        (locKed 的缩写), 表示该文件存在锁令牌.</para>

      <sidebar>
    <!--
        <title>Regarding Lock Tokens</title>
    -->
        <title>关于锁令牌</title>

    <!--
        <para>A lock token isn't an authentication token, so much as
          an <emphasis>authorization</emphasis> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <userinput>svn info
          <replaceable>URL</replaceable></userinput>.  A lock token is
          special only when it lives inside a working copy.  It's
          proof that the lock was created in that particular working
          copy, and not somewhere else by some other client.  Merely
          authenticating as the lock owner isn't enough to prevent
          accidents.</para>
    -->
        <para>锁令牌不是验证令牌 (authentication token), 是 <emphasis>授权
          </emphasis> 令牌 (authorization token). 令牌不是一个受保护的秘密,
          实际上, 任意一个用户都可以用 <userinput>svn info <replaceable>URL
          </replaceable></userinput> 发现锁的一个独一无二的令牌. 只有当一个
          锁令牌处在工作副本里时它才是特殊的, 这说明了锁是在这个特定的工作
          副本里被创建出来的, 仅仅验证锁的所有者并不能完全避免意外.</para>

        <para>
          <indexterm>
            <primary>locks (锁)</primary>
            <secondary>breaking (破坏)</secondary>
          </indexterm>
          比如说, 你在办公室的电脑上锁定了一个文件, 但是还没有提交修改就下
          班回家了, 如果你想在家里完成提交就会失败, 因为仅仅被授权为锁的所有
          者并不能保证提交成功. 换句话说, 锁令牌阻止了一部分的 Subversion 相关
          软件破坏另一部分的工作. (在我们的例子里, 如果你确实需要从另一个工作
          副本提交修改, 就必须先 <emphasis>破坏</emphasis> 锁, 然后重新锁定文
          件).</para>
    <!--
          For example, suppose you lock a file using a
          computer at your office, but leave work for the day before
          you finish your changes to that file.  It should not be
          possible to accidentally commit changes to that same file
          from your home computer later that evening simply because
          you've authenticated as the lock's owner.  In other words,
          the lock token prevents one piece of Subversion-related
          software from undermining the work of another.  (In our
          example, if you really need to change the file from an
          alternative working copy, you would need
          to <firstterm>break</firstterm> the lock and relock the
          file.)</para>
    -->

      </sidebar>

    <!--
      <para>Now that Harry has locked <filename>banana.jpg</filename>,
        Sally is unable to change or delete that file:</para>
    -->
      <para>因为 Harry 已经锁定了文件 <filename>banana.jpg</filename>, 所以
        Sally 不能提交和 <filename>banana.jpg</filename> 有关的修改:</para>

      <informalexample>
        <screen>
$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: E175002: Commit failed (details follow):
svn: E175002: Server sent unexpected return value (423 Locked) in response to 
DELETE request for '/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc
35d/banana.jpg'
$
</screen>
      </informalexample>

    <!--
      <para>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner and also because his working
        copy holds the correct lock token:</para>
    -->
      <para>修改完香蕉的黄色阴影后, Harry 可以向仓库提交修改, 这是因为他被授
        权为锁的拥有者, 而且工作副本包含了正确的锁令牌:</para>

      <informalexample>
        <screen>
$ svn status
M    K  banana.jpg
$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
$ svn status
$
</screen>
      </informalexample>

    <!--
      <para>Notice that after the commit is finished, <command>svn
        status</command> shows that the lock token is no longer
        present in the working copy.  This is the standard behavior of
        <command>svn commit</command>&mdash;it searches the working
        copy (or list of targets, if you provide such a list) for
        local modifications and sends all the lock tokens it
        encounters during this walk to the server as part of the
        commit transaction.  After the commit completes successfully,
        all of the repository locks that were mentioned are
        released&mdash;<emphasis>even on files that weren't
        committed</emphasis>.  This is meant to discourage users from
        being sloppy about locking or from holding locks for too long.
        If Harry haphazardly locks 30 files in a directory named
        <filename>images</filename> because he's unsure of which files
        he needs to change, yet changes only four of those files, when he
        runs <userinput>svn commit images</userinput>, the process will
        still release all 30 locks.</para>
    -->
      <para>注意提交完成后, <command>svn status</command> 显示锁令牌不再出现
        在工作副本里, 这是 <command>svn commit</command> 的标准行为&mdash;
        它搜索工作副本 (如果提供了目标列表, 则搜索该列表) 的本地修改, 并将所
        有遇到的锁令牌作为提交事务的一部分发送给服务器, 如果提交成功, 仓库中
        所有涉及到的锁都会被释放&mdash;<emphasis>即使是未被提交的文件上的锁
        也会被释放</emphasis>. 这是为了防止粗心的用户持锁时间过长. 如果 Harry
      随意地把目录 <filename>images</filename> 下的 30 个文件都锁定了 (因为他
      不确定哪些文件需要修改), 而他只修改了其中 4 个文件, 当他执行完
      <userinput>svn commit images</userinput> 后, 所有 30 个文件的锁都会被
      释放.</para>

    <!--
      <para>This behavior of automatically releasing locks can be
        overridden with the <option>- -no-unlock</option> option to
        <command>svn commit</command>.  This is best used for those
        times when you want to commit changes, but still plan to make
        more changes and thus need to retain existing locks.  You can
        also make this your default behavior by setting the
        <literal>no-unlock</literal> runtime configuration option (see
        <xref linkend="svn.advanced.confarea" />).</para>
    -->
      <para>为 <command>svn commit</command> 添加选项 <option>--no-unlock
        </option> 就不会在提交成功后自动释放锁, 适用选项的场景是用户需要多次
        提交修改. 你可以通过运行时配置选项 <literal>no-unlock</literal> (见
        <xref linkend="svn.advanced.confarea"/>) 把不自动释放锁设置成默认行为.
      </para>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>unlock</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>releasing (释放)</secondary>
        </indexterm>
        当然, 锁定文件后并不要求一定要向该文件提交修改才能释放锁, 用户可以在
        任何时候用命令 <command>svn unlock</command> 释放文件上的锁:</para>
    <!--
        Of course, locking a file doesn't oblige one to
        commit a change to it.  The lock can be released at any time
        with a simple <command>svn unlock</command> command:</para>
    -->

      <informalexample>
        <screen>
$ svn unlock banana.c
'banana.c' unlocked.
</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
    <!--
      <title>Discovering Locks</title>
    -->
      <title>发现锁</title>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>status</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>discovery (发现)</secondary>
        </indexterm>
        如果由于其他用户锁定了文件而导致提交失败, 获取有关锁的信息非常方便,
        最简单的方式是执行 <userinput>svn status -u</userinput>:</para>
    <!--
        When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest way is to run
        <userinput>svn status -u</userinput>:</para>
    -->

      <informalexample>
        <screen>
$ svn status -u
M               23   bar.c
M    O          32   raisin.jpg
        *       72   foo.h
Status against revision:     105
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>info</tertiary>
        </indexterm>
        在这个例子里, Sally 不仅可以看到 <filename>foo.h</filename> 是过时了的,
        而且他打算提交的两个文件中, 有一个在仓库中是被锁定了的. 字符 <literal>
          O</literal> 表示 <quote>其他</quote> (<quote>Other</quote>), 意思是说
        文件被其他用户锁定了, 如果 Sally 试图提交,
        <filename>raisin.jpg</filename> 上的锁会阻止提交成功. Sally 想知道是
        谁, 在什么时候, 因为什么原因锁定了文件, <command>svn info</command> 可以
        回答他的问题:</para>
    <!--
        In this example, Sally can see not only that her copy of
        <filename>foo.h</filename> is out of date, but also that one of the
        two modified files she plans to commit is locked in the
        repository.  The <literal>O</literal> symbol stands for
        <quote>Other,</quote> meaning that a lock exists on the file
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <filename>raisin.jpg</filename> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <command>svn info</command> has the
        answers:</para>
    -->

      <informalexample>
        <screen>
$ svn info ^/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Relative URL: ^/raisin.jpg
Repository Root: http://svn.example.com/repos/project
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Need to make a quick tweak to this image.
$
</screen>
      </informalexample>

    <!--
      <para>Just as you can use <command>svn info</command> to examine
        objects in the working copy, you can also use it to examine
        objects in the repository.  If the main argument to
        <command>svn info</command> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <command>svn info</command> on a working copy
        path will show no lock information at all).  If the main
        argument to <command>svn info</command> is a URL, the
        information reflects the latest version of an object in the
        repository, and any mention of a lock describes the current
        lock on the object.</para>
    -->
      <para><command>svn info</command> 除了可以检查工作副本里的项目外, 也可以
        检查仓库里的项目. 如果传递给 <command>svn info</command> 的参数是一个
        工作副本路径, 那么缓存在工作副本里的所有信息都会显示出来; 只要显示的
        信息中提到了锁, 那就说明工作副本持有一个锁令牌 (如果文件是被其他用户
        或者是在另一个工作副本里锁定的, 那么在一个工作副本路径上执行
        <command>svn info</command> 将不会显示关于锁的任何信息). 如果传递给
        <command>svn info</command> 的是一个 URL, 输出的信息反映了仓库中的
        项目的最新版, 信息中提到关于锁的任何信息都是在描述项目的当前加锁情况.
      </para>

    <!--
      <para>So in this particular example, Sally can see that Harry
        locked the file on February 16 to <quote>make a quick
        tweak.</quote>  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</para>
    -->
      <para>在我们的例子里, Sally 可以看到 Harry 在 2 月 16 日锁定了文件
        <filename>raisin.jpg</filename>, 原因是 <quote>Need to make a quick
          tweak to this image</quote>. 现在已经 6 月了, Sally 怀疑 Harry
        忘记给文件解锁, 她可能会打电话给 Harry, 向他抱怨, 让他马上释放锁. 如
        果联系不到 Harry, 她可能会强行地破坏锁, 或者让管理员来帮她解决.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
    <!--
      <title>Breaking and Stealing Locks</title>
    -->
      <title>破坏与窃取锁</title>

      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>breaking (破坏)</secondary>
        </indexterm>
        锁并非是不可侵犯的&mdash;在 Subversion 的默认配置状态下, 除了创建锁的
        用户可以释放锁之外, 任意一个用户也可以释放锁. 如果释放锁的用户不是锁
        的创建者, 我们把这种行为叫作 <firstterm>破坏锁</firstterm>
        (<firstterm>breaking the lock</firstterm>).</para>
    <!--
        A repository lock isn't sacred&mdash;in Subversion's
        default configuration state, locks can be released not only by
        the person who created them, but by anyone.  When somebody
        other than the original lock creator destroys a lock, we refer
        to this as <firstterm>breaking the lock</firstterm>.</para>
    -->

    <!--
      <para>From the administrator's chair, it's simple to break
        locks.  The <command>svnlook</command>
        and <command>svnadmin</command> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>
    -->
      <para>对于管理员来说, 破坏锁非常简单. 命令 <command>svnlook</command>
        和 <command>svnadmin</command> 可以直接从仓库中显示与移除锁 (关于
        <command>svnlook</command> 和 <command>svnadmin</command> 的更多信息,
        见 <xref linkend="svn.reposadmin.maint.tk"/>).</para>

      <informalexample>
        <screen>
$ svnadmin lslocks /var/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires: 
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires: 
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /var/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
$
</screen>
      </informalexample>

    <!--
      <para>The more interesting option is to allow users to break
        each other's locks over the network.  To do this, Sally simply
        needs to pass the <option>- -force</option> option to the
        <command>svn unlock</command> command:</para>
    -->
      <para>Subversion 还允许用户通过网络破坏其他用户的锁, 为了破坏 Harry 设置
        在 <filename>raisin.jpg</filename> 上的锁, Sally 要给 <command>
          svn unlock</command> 加上选项 <option>--force</option>:</para>

      <informalexample>
        <screen>
$ svn status -u
M               23   bar.c
M    O          32   raisin.jpg
        *       72   foo.h
Status against revision:     105
$ svn unlock raisin.jpg
svn: E195013: 'raisin.jpg' is not locked in this working copy
$ svn info raisin.jpg | grep ^URL
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: warning: W160039: Unlock failed on 'raisin.jpg' (403 Forbidden)
$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
$
</screen>
      </informalexample>

    <!--
      <para>Now, Sally's initial attempt to unlock failed because she
        ran <command>svn unlock</command> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <command>svn unlock</command>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <option>- -force</option>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</para>
    -->
      <para>在上面的例子里, Sally 第一次尝试解锁失败了, 因为她直接在工作副本
        的 <filename>raisin.jpg</filename> 上执行 <command>svn unlock</command>,
        而她的工作副本里并没有锁令牌. 为了直接从仓库中删除锁, 她需要向
        <command>svn unlock</command> 传递一个 URL 参数. 增加 URL 参数后的第
        一次尝试失败了, 因为她没有被授权为锁的所有者 (而且她也没有锁令牌). 但
        是增加了选项 <option>--force</option> 后, 锁成功的被打开 (破坏) 了.
      </para>
        
      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>stealing (窃取)</secondary>
        </indexterm>
        仅仅把锁破坏掉可能还不够. Sally 除了要打开 Harry 忘记打开的锁之外, 她
        还想重新锁定文件, 以便自己对文件进行编辑. 她可以先用带上选项 <option>
          --force</option> 的 <command>svn unlock</command> 把锁打开, 然后再
        用 <command>svn lock</command> 锁定文件. 但是在两个命令之间可能会有
        其他用户锁定了文件. 更简单的做法是 <firstterm>窃取</firstterm>
        (<firstterm>steal</firstterm>) 锁, 它是把锁的破坏与重新加锁合并成一个
        原子操作, 具体的做法是给 <command>svn lock</command> 加上选项
        <option>--force</option>:</para>
    <!--
        Simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but relock the file for her own use.
        She can accomplish this by using <command>svn unlock</command>
        with <option>- -force</option> and then <command>svn lock</command>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to do is to <firstterm>steal</firstterm> the lock, which involves
        breaking and relocking the file all in one atomic step.  To
        do this, Sally passes the <option>- -force</option> option
        to <command>svn lock</command>:</para>
    -->

      <informalexample>
        <screen>
$ svn lock raisin.jpg
svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h
arry' in filesystem '/var/svn/repos/db'
$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>locks (锁)</primary>
          <secondary>defunct (失效的)</secondary>
        </indexterm>
        无论锁是被破坏还是被窃取, Harry 都会感到惊讶. Harry 的工作副本仍然包
        含原来的锁令牌, 但是锁却不存在了, 此时把锁令牌称为 <firstterm>失效的
        </firstterm> (<firstterm>defunct</firstterm>), 锁令牌对应的锁要么被
        破坏 (不在仓库里), 要么被窃取 (被另一把不同的锁替换掉). 不管是哪一种
        情况, Harry 都可以用 <command>svn status</command> 查看详情:</para>
    <!--
        In any case, whether the lock is broken or stolen,
        Harry may be in for a surprise.  Harry's working copy still
        contains the original lock token, but that lock no longer
        exists.  The lock token is said to
        be <firstterm>defunct</firstterm>.  The lock represented by
        the lock token has either been broken (no longer in the
        repository) or stolen (replaced with a different lock).
        Either way, Harry can see this by asking
        <command>svn status</command> to contact the
        repository:</para>
    -->

      <informalexample>
        <screen>
$ svn status
     K  raisin.jpg
$ svn status -u
     B          32   raisin.jpg
Status against revision:     105
$ svn update
Updating '.':
  B  raisin.jpg
Updated to revision 105.
$ svn status
$
</screen>
      </informalexample>

    <!--
      <para>If the repository lock was broken, then <userinput>svn
        status - -show-updates</userinput> (<option>-u</option>)
        displays a <literal>B</literal> (Broken) symbol next to the
        file.  If a new lock exists in place of the old one, then a
        <literal>T</literal> (sTolen) symbol is shown.  Finally,
        <command>svn update</command> notices any defunct lock tokens
        and removes them from the working copy.</para>
    -->
      <para>如果仓库的锁被破坏了, <userinput>svn status --show-updates
          </userinput> (<option>-u</option>) 会在文件的旁边显示字符 <literal>B
        </literal> (Broken). 如果有一把新锁出现在原来的位置上, 显示的就是字符
        <literal>T</literal> (sTolen). 最后, <command>svn update</command>
        会从工作副本中移除所有的失效锁.</para>

      <sidebar>
    <!--
        <title>Locking Policies</title>
    -->
        <title>加锁策略</title>
        
    <!--
        <para>Different systems have different notions of how strict a
          lock should be.  Some folks argue that locks must be
          strictly enforced at all costs, releasable only by the
          original creator or administrator.  They argue that if
          anyone can break a lock, chaos runs rampant and the
          whole point of locking is defeated.  The other side argues
          that locks are first and foremost a communication tool.  If
          users are constantly breaking each other's locks, it
          represents a cultural failure within the team and the
          problem falls outside the scope of software enforcement.</para>
    -->
        <para>不同的系统对锁的严格程度都有不同的理解. 有些人认为应该不惜代价地
          维护锁的持有, 只有管理员或创建锁的原始用户才能释放锁, 他们的观点是
          如果任何人都可以破坏锁, 就会产生混乱, 也就实现不了加锁的目的. 另一些
          人认为锁是一个重要的沟通工具, 如果用户频繁地破坏其他人的锁, 那就说明
          是团队管理出现了问题, 而这种问题与软件无关.</para>

    <!--
        <para>Subversion defaults to the <quote>softer</quote>
          approach, but still allows administrators to create stricter
          enforcement policies through the use of hook scripts.  In
          particular, the pre-lock and
          pre-unlock hooks allow administrators
          to decide when lock creation and lock releases are allowed
          to happen.  Depending on whether a lock already exists,
          these two hooks can decide whether to allow a certain user
          to break or steal a lock.  The
          post-lock and post-unlock hooks are also available,
          and can be used to send email after locking actions.  To
          learn more about repository hooks, see
          <xref linkend="svn.reposadmin.hooks" />.</para>
    -->
        <para>Subversion 默认使用比较温和的做法, 但允许管理员通过钩子脚本, 创建
          更严格的加锁策略. 特别地, 钩子 pre-lock 和
          pre-unlock 允许管理员决定什么时候才能允许创建
          锁与释放锁, 取决于一个锁是否已经事先存在, 这两个钩子还可以决定一个
          特定的用户是否可以破坏或窃取锁. 还可以使用钩子
          post-lock 和 post-unlock
          在加锁与解锁后发送通知邮件. 关于钩子的更多信息, 见
          <xref linkend="svn.reposadmin.hooks"/>.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
    <!--
      <title>Lock Communication</title>
    -->
      <title>锁通信</title>

    <!--
      <para>We've seen how <command>svn lock</command>
        and <command>svn unlock</command> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</para>
    -->
      <para>我们已经介绍了如何使用 <command>svn lock</command> 和 <command>
          svn unlock</command> 完成锁的创建, 释放, 破坏与窃取. 锁实现了文件
        的串行提交, 但是我们应该如何防止浪费时间?</para>

    <!--
      <para>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <userinput>svn status
        -u</userinput>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out of date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away his or her work, and a lot of
        time has been wasted.</para>
    -->
      <para>比如说, Harry 锁定了一个图片文件, 然后开始编辑. 同时在几英里之外,
        Sally 也想编辑同一个文件, 她忘了执行
        <userinput>svn status -u</userinput>, 所以她完全不知道 Harry 已经锁定了
        她要编辑的文件. 她花了几个小时完成了图片的修改, 当她试图提交修改时,
        发现文件被锁定或者工作副本里的文件过时了. 无论如何, 她的修改无法与
        Harry 的修改合并, 两人中必须有一个人要放弃他的工作成果.</para>

      
    <!--
      <para>Subversion's solution to this problem is to provide a
        mechanism to remind users that a file ought to be locked
        <emphasis>before</emphasis> the editing begins.  The mechanism
        is a special property:  <literal>svn:needs-lock</literal>.  If
        that property is attached to a file (regardless of its value,
        which is irrelevant), Subversion will try to use
        filesystem-level permissions to make the file read-only&mdash;unless,
        of course, the user has explicitly locked the file.
        When a lock token is present (as a result of using
        <command>svn lock</command>), the file becomes read/write.
        When the lock is released, the file becomes read-only
        again.</para>
    -->
      <para>Subversion 的解决办法是提供了一种机制, 这种机制会提醒用户在开始
        修改文件之前, 要先锁定文件, 这种机制是一个特殊的属性 <literal>
          svn:needs-lock</literal>. 如果文件设置了该属性 (属性值并不重要),
        Subversion 将试图使用文件系统的权限把文件设置成只读&mdash;除非用户显式
        地锁定了文件. 如果提供了锁令牌 (<command>svn lock</command> 的运行结果),
        文件的权限就变成可读写, 如果锁被释放了, 文件再次变成只读.</para>

    <!--
      <para>The theory, then, is that if the image file has this
        property attached, Sally would immediately notice
        something is strange when she opens the file for editing:
        many applications alert users immediately when a read-only
        file is opened for editing, and nearly all would
        prevent her from saving changes to the file.  This
        reminds her to lock the file before editing, whereby she
        discovers the preexisting lock:</para>
    -->
      <para>如果图片文件设置了属性 <literal>svn:needs-lock</literal>, 当
        Sally 打开并开始修改图片时就会注意到有些地方不对劲: 很多程序在以读
        写方式打开文件时, 如果发现文件是只读的, 将会向用户发出警告, 并阻止用户
        向只读文件保存修改. 这将会提醒 Sally 应该在修改之前先锁定文件, 到那时
        她就会发现锁已经预先被别人锁定了:</para>

      <informalexample>
        <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h
arry' in filesystem '/var/svn/repos/db'
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
</screen>
      </informalexample>

      <tip>
    <!--
        <para>Users and administrators alike are encouraged to attach
          the <literal>svn:needs-lock</literal> property to any file
          that cannot be contextually merged.  This is the primary
          technique for encouraging good locking habits and preventing
          wasted effort.</para>
    -->
        <para>建议用户和管理员把属性 <literal>svn:needs-lock</literal> 设置到
          所有不支持合并的文件上, 这是养成良好的加锁习惯和避免浪费时间的主要
          方法.</para>
      </tip>

    <!--
      <para>Note that this property is a communication tool that
        works independently from the locking system.  In other words,
        any file can be locked, whether or not this property is
        present.  And conversely, the presence of this property
        doesn't make the repository require a lock when
        committing.</para>
    -->
      <para>注意 <literal>svn:needs-lock</literal> 是一个通信工具, 与加锁系统
        独立工作. 换句话说, 无论是否设置了这个属性, 文件都可以被锁定, 相反,
        设置了这个属性, 仓库也不会要求在提交时必须提供锁.</para>

    <!--
      <para>Unfortunately, the system isn't flawless.  It's possible
        that even when a file has the property, the read-only reminder
        won't always work.  Sometimes applications misbehave and
        <quote>hijack</quote> the read-only file, silently allowing
        users to edit and save the file anyway.  There's not much that
        Subversion can do in this situation&mdash;at the end of the
        day, there's simply no substitution for good interpersonal
        communication.<footnote><para>Except, perhaps, a classic
        Vulcan mind-meld.</para></footnote></para>
    -->
  <para>不幸的是, 这种机制并非毫无缺点. 即使文件设置了属性
    <literal>svn:needs-lock</literal>, 只读提醒也可能不会起作用. 有时候应用
    程序不够规范, 会 <quote>劫持</quote> 只读文件, 然后悄无声息地允许用户修改并
    保存文件. Subversion 对这种情况无能为力&mdash;目前为止还没有什么方法可以
    完全替代人与人之间的交流<footnote><para>除非我们可以像瓦肯人那样做到心灵
        融合.</para></footnote></para>


    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
    <!--
    <title>Externals Definitions</title>
    -->
    <title>外部定义</title>
    
    <!--
    <para>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository or perhaps from different
      repositories altogether.  You could certainly set up such a
      scenario by hand&mdash;using <command>svn checkout</command> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</para>
    -->
    <para>有时候, 构造一个由多个不同的检出所组成的工作副本是很有用的, 比如说,
      用户可能想把多个来自不同位置的子目录放到一个目录里, 这些子目录甚至来自不
      同的仓库. 用户当然可以手工实现&mdash;用 <command>svn checkout</command>
      创建出嵌套的工作副本结构. 但是如果每个用户都有这种需求, 那么所有的用户
      都得自己手工构造.</para>

    <para>
      <indexterm>
        <primary>externals definitions (外部定义)</primary>
      </indexterm>
      <indexterm>
        <primary>externals (外部定义)</primary>
        <see>externals definitions (外部定义)</see>
      </indexterm>
      <indexterm>
        <primary>properties (属性)</primary>
        <secondary>svn:externals</secondary>
      </indexterm>
      幸运的是, Subversion 支持 <firstterm>外部定义</firstterm> (<firstterm>
        externals definitions</firstterm>), 外部定义是一个本地目录到仓库目录
      URL 的映射. 用户使用属性 <literal>svn:externals</literal> 批量地声明外
      部定义, 创建或修改属性的命令是 <command>svn propset</command> 或
      <command>svn propedit</command> (见 <xref
        linkend="svn.advanced.props.manip" />). 属性 <literal>svn:externals
      </literal> 可以设置在任意一个被版本控制的目录上, 属性的值描述了外部
      仓库的位置, 以及检出到本地时得到的本地目录.</para>
    <!--
      Fortunately, Subversion provides support for
      <firstterm>externals definitions</firstterm>.  An externals
      definition is a mapping of a local directory to the
      URL&mdash;and ideally a particular revision&mdash;of a versioned
      directory.  In Subversion, you declare externals definitions in
      groups using the <literal>svn:externals</literal> property.  You
      can create or modify this property using <command>svn
      propset</command> or <command>svn propedit</command> (see <xref
      linkend="svn.advanced.props.manip" />).  It can be set on any
      versioned directory, and its value describes both the external
      repository location and the client-side directory to which that
      location should be checked out.</para>
    -->

    <!--
    <para>The convenience of the <literal>svn:externals</literal>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define the nested working
      copy structure, no one else has to bother&mdash;Subversion will,
      after checking out the original working copy, automatically also
      check out the external working copies.</para>
    -->
    <para><literal>svn:externals</literal> 的方便之处是一旦目录设置了该属性,
      所有检出该目录的用户都会受益. 换句话说, 如果有一个用户已经用外部定义
      构造好了一个嵌套的工作副本结构, 其他用户就不用再重新做一遍&mdash;
      当原始的工作副本检出完毕后, Subversion 还会自动检出外部的工作副本.
    </para>

    <warning>
    <!--
      <para>The relative target subdirectories of externals
        definitions <emphasis>must not</emphasis> already exist on
        your or other users' systems&mdash;Subversion will create them
        when it checks out the external working copy.</para>
    -->
      <para>外部定义里的目标子目录事先 <emphasis>不能</emphasis> 存在&mdash;
        Subversion 在检出外部的工作副本时会自动创建它们.</para>
    </warning>

    <!--
    <para>You also get in the externals definition design all the
      regular benefits of Subversion properties.  The definitions are
      versioned.  If you need to change an externals definition, you
      can do so using the regular property modification subcommands.
      When you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <userinput>svn update</userinput>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>
    -->
    <para><literal>svn:externals</literal> 是版本化的属性, 如果用户需要
      修改一个外部定义, 使用普通的属性修改子命令即可. 如果提交了属性
      <literal>svn:externals</literal> 的修改, 下一次执行 <userinput>
        svn update</userinput> 时, Subversion 将会根据修改后的外部定义更新
      检出的项目, 同样的事情也会发生在其他用户的工作副本里.</para>

    <tip>
    <!--
      <para>Because the <literal>svn:externals</literal> property has
        a multiline value, we strongly recommend that you use
        <command>svn propedit</command> instead of <command>svn
        propset</command>.</para>
    -->
    <para>因为属性 <literal>svn:externals</literal> 的值由多行文本组成, 所以我
      们强烈建议用户使用 <command>svn propedit</command> (而不是 <command>
        svn propset</command>) 修改属性.</para>
    </tip>

    <!--
    <para>Subversion releases prior to 1.5 honor an externals
      definition format that is a multiline table of subdirectories
      (relative to the versioned directory on which the property is
      set), optional revision flags, and fully qualified, absolute
      Subversion repository URLs.  An example of this might look as
      follows:</para>
    -->
    <para>Subversion 1.5 之前的外部定义的格式是一个多行表格, 每一行包括子
      目录 (相对于设置了属性的目录), 可选的版本号标志, 以及一个完全限定的
      Subversion 仓库 URL 的绝对路径. 外部定义的一个例子是:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
third-party/sounds             http://svn.example.com/repos/sounds
third-party/skins -r148        http://svn.example.com/skinproj
third-party/skins/toolkit -r21 http://svn.example.com/skin-maker
</screen>
    </informalexample>

    <!--
    <para>When someone checks out a working copy of the
      <filename>calc</filename> directory referred to in the previous
      example, Subversion also continues to check out the items found
      in its externals definition.</para>
    -->
    <para>如果用户检出了目录 <filename>calc</filename>, Subversion 会继续检出
      外部定义里的项目.</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A    calc/third-party/sounds/ding.ogg
A    calc/third-party/sounds/dong.ogg
A    calc/third-party/sounds/clang.ogg
&hellip;
A    calc/third-party/sounds/bang.ogg
A    calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
&hellip;
</screen>
    </informalexample>

    <!--
    <para>As of Subversion 1.5, though, a new format of the
      <literal>svn:externals</literal> property is supported.
      Externals definitions are still multiline, but the order and
      format of the various pieces of information have changed.  The
      new syntax more closely mimics the order of arguments you might
      pass to <command>svn checkout</command>: the optional revision
      flags come first, then the external Subversion repository URL,
      and finally the relative local subdirectory.  Notice, though,
      that this time we didn't say <quote>fully qualified, absolute
      Subversion repository URLs.</quote> That's because the new
      format supports relative URLs and URLs that carry peg revisions.
      The previous example of an externals definition might, in
      Subversion 1.5, look like the following:</para>
    -->
    <para>从 Subversion 1.5 开始, <literal>svn:externals</literal> 支持一
      种新的格式, 外部定义仍然是多行文本, 但某些信息的顺序与格式发生了变化.
      新的语法更加贴近 <command>svn checkout</command> 的参数: 首先是可选的
      版本号标志, 然后是外部仓库的 URL, 本地目录的相对路径. 注意, 这次我们没有
      说 <quote>完全限定的 Subversion 仓库的 URL 的绝对路径</quote>, 这是因为
      新的格式支持相对 URL 和带有限定版本号的 URL. 上面的例子在 Subversion 1.5
      里的写法是:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
      http://svn.example.com/repos/sounds third-party/sounds
-r148 http://svn.example.com/skinproj third-party/skins
-r21  http://svn.example.com/skin-maker third-party/skins/toolkit
</screen>
    </informalexample>

    <!--
    <para>Or, making use of the peg revision syntax (which we describe
      in detail in <xref linkend="svn.advanced.pegrevs" />), it might
      appear as:</para>
    -->
    <para>带有限定版本号 (见 <xref linkend="svn.advanced.pegrevs" />) 的写法是:
    </para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
http://svn.example.com/repos/sounds third-party/sounds
http://svn.example.com/skinproj@148 third-party/skins
http://svn.example.com/skin-maker@21 third-party/skins/toolkit
</screen>
    </informalexample>

    <tip>
      <!--
      <para>You should seriously consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides avoiding the surprise of getting changes to
        third-party repositories that you might not have any control
        over, using explicit revision numbers also means that as you
        backdate your working copy to a previous revision, your
        externals definitions will also revert to the way they looked
        in that previous revision, which in turn means that the
        external working copies will be updated to match the way
        <emphasis>they</emphasis> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</para>
      -->
      <para>用户应该在经过慎重地考虑后再决定要不要在外部定义中显式地指定版本号,
        这意味着用户必须决定应该在什么时候抓取哪一个版本的快照到外部目录里.
        显式地指定版本号除了可以避免向用户没有权限的仓库提交修改外, 当用户把
        工作副本回退到之前的版本时, 外部定义属性也会回退到当时的版本, 外部工作
        副本也会根据外部定义进行相应地更新. 对于软件项目而言, 这可能会造成旧版
        代码构建失败.</para>
    </tip>

    <!--
    <para>For most repositories, these three ways of formatting the
      externals definitions have the same ultimate effect.  They all
      bring the same benefits.  Unfortunately, they all bring the same
      annoyances, too.  Since the definitions shown use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with the
      renamed directory).  This can be confusing&mdash;even
      frustrating&mdash;in certain situations.  For example, say you
      have a top-level directory named
      <filename>my-project</filename>, and you've created an externals
      definition on one of its subdirectories
      (<filename>my-project/some-dir</filename>) that tracks the
      latest revision of another of its subdirectories
      (<filename>my-project/external-dir</filename>).</para>
    -->
    <para>对大多数仓库而言, 三种格式的外部定义的最终效果都是一样的, 它们都有
      同样的好处, 也都有同样的麻烦. 因为用到了 URL 的绝对路径, 如果移动或
      复制一个带有外部定义的目录, 这并不会对外部定义的检出造成影响 (虽然本地
      目标子目录的绝对路径会随着目录的重命名而发生变化). 在某些情况下, 这会给
      用户造成困扰, 比如说, 用户有一个名为 <filename>my-project</filename>
      的顶层目录, 用户在它的其中一个子目录 (<filename>my-project/some-dir
      </filename>) 上设置了外部定义, 外部定义指向的是另一个子目录 (<filename>
      my-project/external-dir</filename>).</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
&hellip;
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn propget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir

$
</screen>
    </informalexample>

    <!--
    <para>Now you use <command>svn move</command> to rename the
      <filename>my-project</filename> directory.  At this point, your
      externals definition will still refer to a path under the
      <filename>my-project</filename> directory, even though that
      directory no longer exists.</para>
    -->
    <para>现在用户用 <command>svn move</command> 重命名 <filename>my-project
      </filename>, 但外部定义仍然指向 <filename>my-project</filename> 的子目
      录, 即使这个目录已经不存在了.</para>

    <informalexample>
      <screen>
$ svn move -q my-project renamed-project
$ svn commit -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         renamed-project

Committed revision 12.
$ svn update
Updating '.':

svn: warning: W200000: Error handling externals definition for 'renamed-projec
t/some-dir/subdir':
svn: warning: W170000: URL 'http://svn.example.com/projects/my-project/externa
l-dir' at revision 12 doesn't exist
At revision 12.
svn: E205011: Failure occurred processing one or more externals definitions
$
</screen>
    </informalexample>

    <!--
    <para>Also, absolute URLs can cause problems with repositories
      that are available via multiple URL schemes.  For example, if
      your Subversion server is configured to allow everyone to check
      out the repository over <literal>http://</literal> or
      <literal>https://</literal>, but only allow commits to come in
      via <literal>https://</literal>, you have an interesting problem
      on your hands.  If your externals definitions use the
      <literal>http://</literal> form of the repository URLs, you
      won't be able to commit anything from the working copies created
      by those externals.  On the other hand, if they use the
      <literal>https://</literal> form of the URLs, anyone who might
      be checking out via <literal>http://</literal> because his
      client doesn't support <literal>https://</literal> will be
      unable to fetch the external items.  Be aware, too, that if you
      need to reparent your working copy (using <command>svn
      relocate</command>), externals definitions will
      <emphasis>not</emphasis> also be reparented.</para>
    -->
    <para>另外, 当使用绝对的 URL 路径时, 如果仓库支持多种 URL 模式, 这也会产
      生问题. 比如说仓库服务器允许任意用户通过 <literal>http://</literal>
      或 <literal>https://</literal> 访问仓库, 但只允许通过 <literal>https://
      </literal> 提交修改. 如果用户的外部定义使用了 <literal>http://</literal>
      形式的 URL, 用户将无法从外部定义创建的工作副本里提交修改. 另一方面,
      如果仓库服务器只支持 <literal>https://</literal> 形式的 URL, 但客户端
      只支持 <literal>http://</literal>, 那么它将无法检出外部项目. 还要注意,
      如果用户重定位了工作副本 (通过命令 <command>svn relocate</command>),
      外部定义检出的工作副本并 <emphasis>不会</emphasis> 被重定位.</para>

    <!--
   <para>Subversion 1.5 takes a huge step in relieving these
     frustrations.  As mentioned earlier, the URLs used in the new
     externals definition format can be relative, and Subversion
     provides syntax magic for specifying multiple flavors of URL
     relativity.</para>
    -->
   <para>在改善这些问题方面, Subversion 1.5 前进了一大步. 前面已经说过新的
     外部定义支持 URL 的相对路径, Subversion 1.5 提供了多种指定相对 URL 路径
     的语法.</para>

    <variablelist id="svn.advanced.externals.urlmagic">
      <indexterm>
        <primary>caret syntax (脱字符语法)</primary>
      </indexterm>

      <varlistentry>
        <term><literal>../</literal></term> 
    <!--
        <listitem><para>Relative to the URL of the directory on which
          the <literal>svn:externals</literal> property is
          set</para></listitem>
    -->
      <listitem><para>相对于设置了 <literal>svn:externals</literal> 的目录的
          URL</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>^/</literal></term> 
    <!--
        <listitem><para>Relative to the root of the repository in
          which the <literal>svn:externals</literal> property is
          versioned</para></listitem>
    -->
      <listitem><para>相对于 <literal>svn:externals</literal> 所在的仓库的根
          目录</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>//</literal></term> 
    <!--
        <listitem><para>Relative to the scheme of the URL of the
          directory on which the <literal>svn:externals</literal>
          property is set</para></listitem>
    -->
      <listitem><para>相对于设置了属性 <literal>svn:externals</literal> 的目录
          的 URL 模式</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>/</literal></term>
    <!--
        <listitem><para>Relative to the root URL of the server on
          which the <literal>svn:externals</literal> property is
          versioned</para></listitem>
    -->
      <listitem><para>相对于 <literal>svn:externals</literal> 所在的仓库的根
          URL</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>^/../<replaceable>REPO-NAME</replaceable></literal></term> 
    <!--
        <listitem><para>Relative to a sibling repository beneath the
          same <literal>SVNParentPath</literal> location as the
          repository in which the <literal>svn:externals</literal> is
          defined.</para></listitem>
    -->
      <listitem><para>相对于和定义了 <literal>svn:externals</literal> 的仓库
          处于同一个 <literal>SVNParentPath</literal> 位置下的兄弟仓库</para>
      </listitem>
      </varlistentry>
    </variablelist>

    <!--
    <para>So, looking a fourth time at our previous externals
      definition example, and making use of the new absolute URL
      syntax in various ways, we might now see:</para>
    -->
    <para>如果把绝对的 URL 路径改成相对路径, 之前的例子就可以写成:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
^/sounds third-party/sounds
/skinproj@148 third-party/skins
//svn.example.com/skin-maker@21 third-party/skins/toolkit
$
</screen>
    </informalexample>

    <!--
    <para>Subversion 1.6 brought two more improvements to externals
      definitions.  First, it added a quoting and escape mechanism to
      the syntax so that the path of the external working copy may
      contain whitespace.  This was previously problematic, of course,
      because whitespace is used to delimit the fields in an externals
      definition.  Now you need only wrap such a path specification in
      double-quote (<literal>"</literal>) characters or
      escape the problematic characters in the path with a backslash
      (<literal>\</literal>) character.  Of course, if you have spaces
      in the <emphasis>URL</emphasis> portion of the external
      definition, you should use the standard URI-encoding mechanism
      to represent those.</para>
    -->
    <para>Subversion 1.6 为外部定义添加了两个增强功能, 首先, 利用引号和转义字
      符, 外部工作副本的路径可以包含空格, 在此之前如何处理路径中的空格是一
      件很麻烦的事情, 因为空格被用作外部定义的字段分隔符, 现在只需要用双引号
      包裹路径, 或者用反斜杆 (<literal>\</literal>) 转义路径中会引起问题的字符.
      如果外部定义的 URL 部分包含空格, 此时应该使用标准的 URL 编码表示空格.
    </para>

    <informalexample>
      <screen>
$ svn propget svn:externals paint
http://svn.thirdparty.com/repos/My%20Project "My Project"
http://svn.thirdparty.com/repos/%22Quotes%20Too%22 \"Quotes\ Too\"
$
</screen>
    </informalexample>

    <para>
      <indexterm>
        <primary>externals (外部定义)</primary>
        <secondary>file (文件)</secondary>
      </indexterm>
      Subversion 1.6 还支持为文件设置外部定义. <firstterm>外部文件</firstterm>
      (<firstterm>file externals</firstterm>) 的配置方式与目录相同, 外部文件
      将以版本化文件的形式出现在工作副本里.</para>
    <!--
      Subversion 1.6 also introduced support for external
      definitions for files.  <firstterm>File externals</firstterm>
      are configured just like externals for directories and appear as
      a versioned file in the working copy.</para>
    -->
      
    <!--
    <para>For example, let's say you had the file
      <filename>/trunk/bikeshed/blue.html</filename> in your repository,
      and you wanted this file, as it appeared in revision 40,
      to appear in your working copy of <filename>/trunk/www/</filename>
      as <filename>green.html</filename>.</para>
    -->
    <para>比如说仓库中有一个文件 <filename>/trunk/bikeshed/blue.html</filename>,
      现在你想把文件在版本号 40 时的版本放在 <filename>/trunk/www/</filename>
      的工作副本里, 作为 <filename>green.html</filename>.</para>

    <!--
    <para>The externals definition required to achieve this should
      look familiar by now:</para>
    -->
    <para>实现这个要求的外部定义是:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals www/
^/trunk/bikeshed/blue.html@40 green.html
$ svn update
Updating '.':

Fetching external item into 'www'
E    www/green.html
Updated external to revision 40.

Update to revision 103.
$ svn status
    X   www/green.html
$
</screen>
    </informalexample>

    <!--
    <para>As you can see in the previous output, Subversion denotes file
      externals with the letter <literal>E</literal> when they are
      fetched into the working copy, and with the letter
      <literal>X</literal> when showing the working copy status.</para>
    -->
    <para>可以看到, 把文件抓取到工作副本里时, Subversion 在外部文件的左边显示字
      符 <literal>E</literal>, 执行 <command>svn status</command> 时, 在外部文
      件的左边显示字符 <literal>X</literal>.</para>

    <!-- ### TODO: Is Subversion using 'E' in the update output to
         ### mean "external"?  Or is this 'E' an "exists" notification,
         ### the side-effect of the file externals implementation? -->

    <warning>
    <!--
      <para>While directory externals can place the external
        directory at any depth, and any missing intermediate
        directories will be created, file externals must be placed
        into a working copy that is already checked out.</para>
    -->
      <para>外部目录可以把工作副本检出到任意深度的子目录内, 中间缺失的目录会
        被自动创建, 而外部文件只能检出到已存在的目录内.</para>
    </warning>

    <!--
    <para>When examining the file external with
      <command>svn info</command>, you can see the URL and revision
      the external is coming from:</para>
    -->
    <para>使用 <command>svn info</command> 检查外部文件时, 可以看到外部文件
      URL 与版本号:</para>

    <informalexample>
      <screen>
$ svn info www/green.html 
Path: www/green.html
Name: green.html
Working Copy Root Path: /home/harry/projects/my-project
URL: http://svn.example.com/projects/my-project/trunk/bikeshed/blue.html
Relative URL: ^/trunk/bikeshed/blue.html
Repository Root: http://svn.example.com/projects/my-project
Repository UUID: b2a368dc-7564-11de-bb2b-113435390e17
Revision: 40
Node kind: file
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 40
Last Changed Date: 2009-07-20 20:38:20 +0100 (Mon, 20 Jul 2009)
Text Last Updated: 2009-07-20 23:22:36 +0100 (Mon, 20 Jul 2009)
Checksum: 01a58b04617b92492d99662c3837b33b
$
</screen>
    </informalexample>

    <!--
    <para>Because file externals appear in the working copy as
      versioned files, they can be modified and even committed
      if they reference a file at the HEAD revision. The committed
      changes will then appear in the external as well as the file
      referenced by the external. However, in our example, we pinned
      the external to an older revision, so attempting to commit
      the external fails:</para>
    -->
    <para>因为外部文件是作为版本化的文件出现在工作副本里, 它们可以被修改, 如
      果引用的是版本号 HEAD 的文件, 还可以提交修改, 提交后的修改不仅会出现在
      外部文件时, 还包括被引用的文件. 然而在我们的例子里, 外部文件被指定了一
      个较旧的版本号, 所以无法提交成功:</para>

    <informalexample>
      <screen>
$ svn status
M   X   www/green.html
$ svn commit -m "change the color" www/green.html
Sending        www/green.html
svn: E155011: Commit failed (details follow):
svn: E155011: File '/trunk/bikeshed/blue.html' is out of date
$
</screen>
    </informalexample>

    <!--
    <para>Keep this in mind when defining file externals.
      If you need the external to refer to a certain revision
      of a file you will not be able to modify the external.
      If you want to be able to modify the external, you cannot
      specify a revision other than the <literal>HEAD</literal>
      revision, which is implied if no revision is specified.</para>
    -->
    <para>定义外部文件时要始终牢记这点: 如果外部定义指向的是一个特定版本号的
      文件, 将无法提交外部文件的修改. 如果用户希望可以提交外部文件的修改,
      就不要指定除了 <literal>HEAD</literal> 之外的其他版本号, 这与没有指定
      版本号是同样的效果.</para>

    <!--
    <para>Unfortunately, the support which exists for externals definitions
      in Subversion remains less than ideal.  Both file and directory
      externals have shortcomings. For either type of external, the
      local subdirectory part of the definition cannot contain
      <literal>..</literal> parent directory indicators (such as
      <filename>../../skins/myskin</filename>).  File externals cannot
      refer to files from other repositories. A file external's URL
      must always be in the same repository as the URL that the file
      external will be inserted into. Also, file externals cannot be
      moved or deleted. The <literal>svn:externals</literal> property
      must be modified instead. However, file externals can be copied.</para>
    -->
    <para>不幸的是, Subversion 对外部定义的支持仍然不够理想. 外部文件与外部
      目录都还有不足之外需要完善. 比如说外部定义的本地子目录不能包含父目录指示
      符 <literal>..</literal> (例如 <filename>../../skins/myskin</filename>).
      外部文件不能引用其他仓库的文件, 不能直接对外部文件进行移动或删除 (但可被
      复制), 而是应该修改 <literal>svn:externals</literal>.</para>

    <!--
    <para>Perhaps most disappointingly, the working copies created via the
      externals definition support are still disconnected from the primary
      working copy (on whose versioned directories the
      <literal>svn:externals</literal> property was actually set).
      And Subversion still truly operates only on nondisjoint working
      copies.  So, for example, if you want to commit changes that
      you've made in one or more of those external working copies, you
      must run <command>svn commit</command> explicitly on those
      working copies&mdash;committing on the primary working copy will
      not recurse into any external ones.</para>
    -->
    <para>或许最令人失望的是由外部定义创建的工作副本与主工作副本 (属性 <literal>
        svn:externals</literal> 所在的工作副本) 之间是分离的, 而且 Subversion
      也只能操作不相交的工作副本. 也就是说如果你想要提交一个或多个外部工作副本
      里的修改, 你只能显式地在每个外部工作副本里执行 <command>svn commit
    </command>&mdash;在主工作副本内提交并不会影响外部工作副本.</para>

    <!--
    <para>We've already mentioned some of the additional shortcomings
      of the old <literal>svn:externals</literal> format and how the
      newer Subversion 1.5 format improves upon it.  But be careful
      when making use of the new format that you don't inadvertently
      introduce new problems.  For example, while the latest clients
      will continue to recognize and support the original externals
      definition format, pre-1.5 clients will <emphasis>not</emphasis>
      be able to correctly parse the new format.  If you change all
      your externals definitions to the newer format, you effectively
      force everyone who uses those externals to upgrade their
      Subversion clients to a version that can parse them.  Also, be
      careful to avoid naively relocating
      the <literal>-r<replaceable>NNN</replaceable></literal> portion
      of the definition&mdash;the older format uses that revision as a
      peg revision, but the newer format uses it as an operative
      revision (with a peg revision of <literal>HEAD</literal> unless
      otherwise specified; see <xref linkend="svn.advanced.pegrevs" />
      for a full explanation of the distinction here).</para>
    -->
    <para>我们已经介绍了 <literal>svn:externals</literal> 旧格式的缺点, 以及
      Subversion 1.5 的新格式如何改善这些缺点, 但是在使用新的格式时注意不要
      引入新的问题. 举个例子, 最新的客户端仍然支持旧的外部定义格式, 1.5 版以前
      的客户端却不支持新格式. 如果用户把所有的外部定义格式都更新成新格式, 那
      就相当于强迫所有的用户都要把客户端更新成最新版. 同时还要注意外部定义里的
      <literal>-r<replaceable>NNN</replaceable></literal> 部分&mdash;旧格式把
      它作为限定版本号, 而新格式把它作为实施版本号 (除非显式指定, 否则使用
      <literal>HEAD</literal> 作为限定版本号, 限定版本号与实施版本号的区别见
      <xref linkend="svn.advanced.pegrevs"/>).</para>

    <warning>
    <!--
      <para>External working copies are still completely
        self-sufficient working copies.  You can operate directly on
        them as you would any other working copy.  This can be a handy
        feature, allowing you to examine an external working copy
        independently of any primary working copy
        whose <literal>svn:externals</literal> property caused its
        instantiation.  Be careful, though, that you don't
        inadvertently modify your external working copy in subtle ways
        that cause problems.  For example, while an externals
        definition might specify that the external working copy should
        be held at a particular revision number, if you
        run <command>svn update</command> directly on the external
        working copy, Subversion will oblige, and now your external
        working copy is out of sync with its declaration in the
        primary working copy.  Using <command>svn switch</command> to
        directly switch the external working copy (or some portion
        thereof) to another URL could cause similar problems if the
        contents of the primary working copy are expecting particular
        contents in the external content.</para>
    -->
      <para>外部工作副本是一个完全自给自足的工作副本, 和普通的工作副本没有
        任何区别. 这是一个很方便的特性, 允许用户独立地对外部工作副本进行操作,
        而不会受到主工作副本 (属性 <literal>svn:externals</literal> 所在的工
        作副本) 的影响, 但要注意不要无意间修改工作副本而产生一些微妙的问题.
        比如说外部定义可能指定了外部工作副本的版本号, 如果用户直接在外部工作
        副本里执行 <command>svn update</command>, Subversion 将允许操作执行,
        这会导致外部工作副本的版本号与外部定义指定的版本号不一致. 如果主工作
        副本期望外部工作副本具有特定的内容, 那么使用 <command>svn switch
        </command> 把外部工作副本 (或其中的一部分) 切换到另一个 URL 也会造成
        类似的问题.</para>
    </warning>

    <para>
      <indexterm>
        <primary>working copies (工作副本)</primary>
        <secondary>disjoint (不相交的)</secondary>
        </indexterm>
        <command>svn checkout</command>, <command>svn update</command>,
        <command>svn switch</command> 和 <command>svn export</command> 这些
        命令实际上管理的是 <firstterm>不相交的</firstterm>
        (<firstterm>disjoint</firstterm>), 检出了外部定义的子目录, 但
        <command>svn status</command> 可以识别外部工作副本.
        <command>svn status</command> 为外部
        工作副本所在的子目录显示字符 <literal>X</literal>, 然后递归地显示外部
        工作副本内的各个项目的状态. 为子命令添加选项
        <option>--ignore-externals</option> 将会禁止子命令处理外部定义.</para>
    <!--
      ### TODO
        Besides the <command>svn checkout</command>, <command>svn
      update</command>, <command>svn switch</command>, and
      <command>svn export</command> commands which actually manage the
      <firstterm>disjoint</firstterm> (or disconnected) subdirectories
      into which externals are checked out, the <command>svn
      status</command> command also recognizes externals definitions.
      It displays a status code of <literal>X</literal> for the
      disjoint external subdirectories, and then recurses into those
      subdirectories to display the status of the external items
      themselves.  You can pass the
      <option>- -ignore-externals</option> option to any of these
      subcommands to disable externals definition processing.</para>
    -->
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.changelists">
    <!--
    <title>Changelists</title>
    -->
    <title>变更列表</title>

    <!--
    <para>It is commonplace for a developer to find himself working at
      any given time on multiple different, distinct changes to a
      particular bit of source code.  This isn't necessarily due to
      poor planning or some form of digital masochism.  A software
      engineer often spots bugs in his peripheral vision while working
      on some nearby chunk of source code.  Or perhaps he's halfway
      through some large change when he realizes the solution he's
      working on is best committed as several smaller logical units.
      Often, these logical units aren't nicely contained in some
      module, safely separated from other changes.  The units might
      overlap, modifying different files in the same module, or even
      modifying different lines in the same file.</para>
    -->
    <para>对开发人员而言, 有时候可能会遇到这样一种情况: 在某些代码上完成
      多个不同的修改.
      这并非由于糟糕的工作计划, 因为开发人员常常在阅读某一部分的代码时, 发现另
      一部分代码的问题, 又或许是开发人员把一个大修改拆分成几个逻辑性更强的小
      修改, 而这几个小修改还没有全部完成. 很多时候, 这些小修改不能完全包含在一
      个模块里, 修改之间也不能安全地隔开, 修改可能有重叠, 或修改了同一模块
      的不同文件, 或修改了同一个文件的不同行.</para>

    <!--
    <para>Developers can employ various work methodologies
      to keep these logical changes organized.  Some use
      separate working copies of the same repository to hold each
      individual change in progress.  Others might choose to create
      short-lived feature branches in the repository and use a single
      working copy that is constantly switched to point to one such
      branch or another.  Still others use <command>diff</command> and
      <command>patch</command> tools to back up and restore uncommitted
      changes to and from patch files associated with each change.
      Each of these methods has its pros and cons, and to a large
      degree, the details of the changes being made heavily influence
      the methodology used to distinguish them.</para>
    -->
    <para>开发人员可以采用不同的方法对这些在逻辑上分开的修改进行组织. 有的人
      使用单独的工作副本保存未完成的修改, 其他人可能会创建短期的特性分支, 还
      有的人会使用 <command>diff</command> 和 <command>patch</command> 来备份
      与还原未提交的修改, 每一个修改都对应一个补丁文件. 每一种方法都有各自的
      优缺点, 而且修改的细节会在很大程度上影响对修改进行区分的方法.</para>

    <para>
      <indexterm>
        <primary>changelists (变更列表)</primary>
      </indexterm>
      Subversion 提供了一种新方法: <firstterm>变更列表</firstterm> (<firstterm>
        changelists</firstterm>). 变更列表基本上就是一些应用到工作副本文件上
      的任意标签 (每个文件上最多只能有一个标签), 用来表示多个互相关联的文件的
      共同目的, 经常使用谷歌软件的用户对此比较熟悉. 比如说 <ulink url=
        "http://mail.google.com/">谷歌邮箱</ulink> 并没有提供传统的基于文件夹
      的邮件组织形式, 用户可以把任意的标签应用到邮件上, 如果有多个邮件的标签
      相同, 就可以说它们是同一个组的, 查看具有类似标签的一组邮件变成了一个简单
      的用户界面技巧. 很多 Web 2.0 网站也提供了类似的机制, 比如 
      <ulink url="http://www.youtube.com/">YouTube</ulink> 和
      <ulink url="http://www.flickr.com/">Flickr</ulink> 的 <quote>标签</quote>
      (tag), 以及博文的 <quote>类别</quote> (categories). 人们已经明白数据的
      组织方式非常重要, 但是如何对数据进行组织应该是一个很灵活的概念.
      旧的 <quote>文件与文件夹</quote> 范式对某些应用程序来说过于刻板.</para>
    <!--
      Subversion provides a <firstterm>changelists</firstterm>
      feature that adds yet another method to the mix.  Changelists
      are basically arbitrary labels (currently at most one per file)
      applied to working copy files for the express purpose of
      associating multiple files together.  Users of many of Google's
      software offerings are familiar with this concept already.  For
      example, <ulink url="http://mail.google.com/">Gmail</ulink>
      doesn't provide the traditional folders-based email organization
      mechanism.  In Gmail, you apply arbitrary labels to emails, and
      multiple emails can be said to be part of the same group if they
      happen to share a particular label.  Viewing only a group of
      similarly labeled emails then becomes a simple user interface
      trick.  Many other Web 2.0 sites have similar
      mechanisms&mdash;consider the <quote>tags</quote> used by sites
      such as <ulink url="http://www.youtube.com/">YouTube</ulink> and
      <ulink url="http://www.flickr.com/">Flickr</ulink>,
      <quote>categories</quote> applied to blog posts, and so on.
      Folks understand today that organization of data is critical,
      but that how that data is organized needs to be a flexible
      concept.  The old files-and-folders paradigm is too rigid for
      some applications.</para>
    -->

    <!--
    <para>Subversion's changelist support allows you to create
      changelists by applying labels to files you want to be
      associated with that changelist, remove those labels, and limit
      the scope of the files on which its subcommands operate to only
      those bearing a particular label.  In this section, we'll look
      in detail at how to do these things.</para>
    -->
    <para>Subversion 允许用户通过向文件打标签来创建变更列表, 如果一个文件被打
      上标签, 说明该文件和这个变更列表是相关的, 用户还可以删除标签, 把命令的
      操作限定到具有特定标签的文件上, 具体的细节将在本节进行介绍.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.creating">
    <!--
      <title>Creating and Modifying Changelists</title>
    -->
      <title>创建与修改变更列表</title>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>        
        <indexterm>
          <primary>changelists (变更列表)</primary>
          <secondary>creating (创建)</secondary>
        </indexterm>
        命令 <command>svn changelist</command> 用于创建, 修改和删除变更列表,
        更准确地说这个命令可以设置或清除某个特定的工作副本文件上的变更列表关
        联. 当用户第一次用某个变更列表为文件打标签时, 变更列表才被创建出来;
        当用户把最后一个标签从文件上移除时, 对应的变更列表被删除. 下面用一个
        例子来解释这些概念.</para>
    <!--
        You can create, modify, and delete changelists using the
        <command>svn changelist</command> command.  More accurately,
        you use this command to set or unset the changelist
        association of a particular working copy file.  A changelist
        is effectively created the first time you label a file with
        that changelist; it is deleted when you remove that label from
        the last file that had it.  Let's examine a usage scenario
        that demonstrates these concepts.</para>
    -->

    <!--
      <para>Harry is fixing some bugs in the calculator application's
        mathematics logic.  His work leads him to change a couple of
        files:</para>
    -->
      <para>Harry 正在解决计算器程序中数字运算过程的几个问题, 他已经修改了几
        个文件:</para>

      <informalexample>
        <screen>
$ svn status
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

    <!--
      <para>While testing his bug fix, Harry notices that his changes
        bring to light a tangentially related bug in the user
        interface logic found in <filename>button.c</filename>.  Harry
        decides that he'll go ahead and fix that bug, too, as a
        separate commit from his math fixes.  Now, in a small working
        copy with only a handful of files and few logical changes,
        Harry can probably keep his two logical change groupings
        mentally organized without any problem.  But today he's going
        to use Subversion's changelists feature as a special favor to
        the authors of this book.</para>
    -->
      <para>在测试的过程中, Harry 发现他的修改暴露了用户接口实现 <filename>
          button.c</filename> 里的一个问题, Harry 决定在另一个单独的提交中把
        这个问题也解决掉. 在一个只包含了少量文件和修改的小工作副本里, Harry 可
        以不依靠 Subversion 就可以对两个逻辑上不相关的修改进行组织, 但是今天
        他想试用一下 Subversion 的变更列表.</para>

    <!--
      <para>Harry first creates a changelist and associates with it
        the two files he's already changed.  He does this by using the
        <command>svn changelist</command> command to assign the same
        arbitrary changelist name to those files:</para>
    -->
      <para>Harry 先创建一个变更列表, 并关联两个已被修改的文件, 具体的做法是
        用命令 <command>svn changelist</command> 向这两个文件分配一个任意的
        变更列表名:</para>

      <informalexample>
        <screen>
$ svn changelist math-fixes integer.c mathops.c
A [math-fixes] integer.c
A [math-fixes] mathops.c
$ svn status

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

    <!--
      <para>As you can see, the output of <command>svn
        status</command> reflects this new grouping.</para>
    -->
    <para>可以看到, <command>svn status</command> 的输出反映了新的分组.</para>

    <!--
      <para>Harry now sets off to fix the secondary UI problem.  Since
        he knows which file he'll be changing, he assigns that path to
        a changelist, too.  Unfortunately, Harry carelessly assigns this
        third file to the same changelist as the previous two files:</para>
    -->
      <para>现在 Harry 着手修改用户接口的问题. 因为他知道将要修改哪个文件, 所
        以他也向这个文件分配了一个变更列表, 不幸的是, Harry 错误地向第三个文件
        分配了和前两个文件一样的变更列表:</para>

      <informalexample>
        <screen>
$ svn changelist math-fixes button.c
A [math-fixes] button.c
$ svn status

--- Changelist 'math-fixes':
        button.c
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>        
        <indexterm>
          <primary>changelists (变更列表)</primary>
          <secondary>removing (删除)</secondary>
        </indexterm>
        幸好 Harry 很快就发现了错误, 现在他有两个选择, 一是删除与 <filename>
          button.c</filename> 关联的变更列表, 然后分配一个新的变更列表:</para>
    <!--
        Fortunately, Harry catches his mistake.  At this
        point, he has two options.  He can remove the changelist
        association from <filename>button.c</filename>, and then
        assign a different changelist name:</para>
    -->

      <informalexample>
        <screen>
$ svn changelist --remove button.c
D [math-fixes] button.c
$ svn changelist ui-fix button.c
A [ui-fix] button.c
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>        
        <indexterm>
          <primary>changelists (变更列表)</primary>
          <secondary>reassigning (重新分配)</secondary>
        </indexterm>
        二是直接向 <filename>button.c</filename> 分配一个新的变更列表, 此时
        Subversion 会先移除 <filename>button.c</filename> 原来的变更列表:</para>
    <!--
        Or, he can skip the removal and just assign a new
        changelist name.  In this case, Subversion will first warn
        Harry that <filename>button.c</filename> is being removed from
        the first changelist:</para>
    -->

      <informalexample>
        <screen>
$ svn changelist ui-fix button.c
D [math-fixes] button.c
A [ui-fix] button.c
$ svn status

--- Changelist 'ui-fix':
        button.c

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

    <!--
      <para>Harry now has two distinct changelists present in his
        working copy, and <command>svn status</command> will group its
        output according to these changelist determinations.  Notice
        that even though Harry hasn't yet modified
        <filename>button.c</filename>, it still shows up in the output
        of <command>svn status</command> as interesting because it has
        a changelist assignment.  Changelists can be added to and
        removed from files at any time, regardless of whether they
        contain local modifications.</para>
    -->
      <para>现在 Harry 的工作副本里有了两个不同的变更列表, <command>svn status
        </command> 会根据它们的变更列表对输出进行分组. 虽然 Harry 还没有修改
        <filename>button.c</filename>, 但 <command>svn status</command> 仍然
        会输出与它有关的信息, 这是因为 <filename>button.c</filename> 被分配了
        一个变更列表. 任何时候都可以向文件添加或删除变更列表, 无论它们是否含有
        本地修改.</para>

    <!--
      <para>Harry now fixes the user interface problem in
        <filename>button.c</filename>.</para>
    -->
      <para>接下来, Harry 解决了 <filename>button.c</filename> 的用户接口问题.
      </para>

      <informalexample>
        <screen>
$ svn status

--- Changelist 'ui-fix':
M       button.c

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.asfilters">
    <!--
      <title>Changelists As Operation Filters</title>
    -->
      <title>变更列表用作操作过滤器</title>

    <!--
      <para>The visual grouping that Harry sees in the output of
        <command>svn status</command> as shown in our previous section
        is nice, but not entirely useful.  The
        <command>status</command> command is but one of many
        operations that he might wish to perform on his working copy.
        Fortunately, many of Subversion's other operations understand
        how to operate on changelists via the use of the
        <option>- -changelist</option> option.</para>
    -->
      <para>我们在上一节看到的 <command>svn status</command> 对变更列表的分组
        效果还不错, 但还不是很有用. 除了 <command>svn status</command>, 通过
        选项 <option>--changelist</option>, 还有很多操作都会理解变更列表.
      </para>

    <!--
      <para>When provided with a <option>- -changelist</option> option,
        Subversion commands will limit the scope of their operation to
        only those files to which a particular changelist name is
        assigned.  If Harry now wants to see the actual changes he's
        made to the files in his <literal>math-fixes</literal>
        changelist, he <emphasis>could</emphasis> explicitly list only
        the files that make up that changelist on the <command>svn
        diff</command> command line.</para>
    -->
    <para>如果提供了选项 <option>--changelist</option>, Subversion 命令将会把
      操作的作用域限定到具有特定变更列表的文件上. 假如说 Harry 想查看变更列表
      <literal>math-fixes</literal> 里的文件的修改, 他可以在 <command>svn diff
      </command> 的后面显式地列出变更列表 <literal>math-fixes</literal> 的所有
      文件.</para>

      <informalexample>
        <screen>
$ svn diff integer.c mathops.c
Index: integer.c
===================================================================
--- integer.c	(revision 1157)
+++ integer.c	(working copy)
&hellip;
Index: mathops.c
===================================================================
--- mathops.c	(revision 1157)
+++ mathops.c	(working copy)
&hellip;
$
</screen>
      </informalexample>

    <!--
      <para>That works okay for a few files, but what if Harry's
        change touched 20 or 30 files?  That would be an annoyingly
        long list of explicitly named files.  Now that he's using
        changelists, though, Harry can avoid explicitly listing the
        set of files in his changelist from now on, and instead
        provide just the changelist name:</para>
    -->
      <para>如果文件比较少的话还可以接受, 但是如果变更列表包含了 20 个或 30 个
        文件, 那就有点麻烦了. 不过既然它们都属于同一个变更列表, 可以用变更列
        表替换文件列表:</para>

      <informalexample>
        <screen>
$ svn diff --changelist math-fixes
Index: integer.c
===================================================================
--- integer.c	(revision 1157)
+++ integer.c	(working copy)
&hellip;
Index: mathops.c
===================================================================
--- mathops.c	(revision 1157)
+++ mathops.c	(working copy)
&hellip;
$
</screen>
      </informalexample>

    <!--
      <para>And when it's time to commit, Harry can again use the
        <option>- -changelist</option> option to limit the scope of the
        commit to files in a certain changelist.  He might commit his
        user interface fix by doing the following:</para>
    -->
      <para>准备提交时, Harry 可以再次使用选项 <option>--changelist</option>
        把提交操作的作用域限定到具有特定变更列表的文件上. 他可以像下面这样提交
        用户接口的修改:</para>

      <informalexample>
        <screen>
$ svn commit -m "Fix a UI bug found while working on math logic." \
             --changelist ui-fix
Sending        button.c
Transmitting file data .
Committed revision 1158.
$
</screen>
      </informalexample>

    <!--
      <para>In fact, the <command>svn commit</command> command
        provides a second changelists-related option:
        <option>- -keep-changelists</option>.  Normally, changelist
        assignments are removed from files after they are committed.
        But if <option>- -keep-changelists</option> is provided,
        Subversion will leave the changelist assignment on the
        committed (and now unmodified) files.  In any case, committing
        files assigned to one changelist leaves other changelists
        undisturbed.</para>
    -->
      <para>实际上 <command>svn commit</command> 还提供了另一个和变更列表相关
        的选项: <option>--keep-changelists</option>. 一般情况下, 在文件提交后,
        变更列表就会从文件上移除, 但是如果提供了选项 <option>--keep-changelists
        </option>, Subversion 就会把变更列表保留在提交了的文件上. 在任何一种
        情况下, 提交某个变更列表的文件时, 不会对其他变更列表产生影响.</para>

      <informalexample>
        <screen>
$ svn status

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <note>
    <!--
        <para>The <option>- -changelist</option> option acts only as a
          filter for Subversion command targets, and will not add
          targets to an operation.  For example, on a commit operation
          specified as <userinput>svn commit /path/to/dir</userinput>, the
          target is the directory <filename>/path/to/dir</filename>
          and its children (to infinite depth).  If you then add a
          changelist specifier to that command, only those files in
          and under <filename>/path/to/dir</filename> that are
          assigned that changelist name will be considered as targets
          of the commit&mdash;the commit will not include files
          located elsewhere (such as in
          <filename>/path/to/another-dir</filename>), regardless of
          their changelist assignment, even if they are part of the
          same working copy as the operation's target(s).</para>
    -->
        <para>选项 <option>--changelist</option> 只是作为命令的操作目标的过滤
          器, 它不会向命令添加更多的操作目标. 举个例子, 命令 <userinput>
            svn commit /path/to/dir</userinput> 的操作目标是目录 <filename>
            /path/to/dir</filename> 及其子文件, 如果再向命令添加一个变更列表,
          那么只有位于 <filename>/path/to/dir</filename> 目录内的, 且分配了
          相应变更列表的文件才会被当作提交的目标&mdash;提交不会包含其他位置
          (例如 <filename>/path/to/another-dir</filename>) 的文件, 即使它们
          拥有和命令行相同的变更列表.</para>
      </note>

    <!--
      <para>Even the <command>svn changelist</command> command accepts
        the <option>- -changelist</option> option.  This allows you to
        quickly and easily rename or remove a changelist:</para>
    -->
      <para>命令 <command>svn changelist</command> 也支持选项 <option>
        --changelist</option>, 这允许用户方便地重命名或删除变更列表:</para>

      <informalexample>
        <screen>
$ svn changelist math-bugs --changelist math-fixes --depth infinity .
D [math-fixes] integer.c
A [math-bugs] integer.c
D [math-fixes] mathops.c
A [math-bugs] mathops.c
$ svn changelist --remove --changelist math-bugs --depth infinity .
D [math-bugs] integer.c
D [math-bugs] mathops.c
$
</screen>
      </informalexample>

    <!--
      <para>Finally, you can specify multiple instances of the
        <option>- -changelist</option> option on a single command
        line.  Doing so limits the operation you are performing to
        files found in any of the specified changesets.</para>
    -->
      <para>最后, 用户可以一次指定多个 <option>--changelist</option> 选项,
        此时受命令影响的文件将是它们的并集.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.limitations">
    <!--
      <title>Changelist Limitations</title>
    -->
      <title>变更列表的限制</title>

    <!--
      <para>Subversion's changelist feature is a handy tool for
        grouping working copy files, but it does have a few limitations.
        Changelists are artifacts of a particular working copy, which
        means that changelist assignments cannot be propagated to the
        repository or otherwise shared with other users.  Changelists
        can be assigned only to files&mdash;Subversion doesn't
        currently support the use of changelists with directories.
        Finally, you can have at most one changelist assignment on a
        given working copy file.  Here is where the blog post category
        and photo service tag analogies break down&mdash;if you find
        yourself needing to assign a file to multiple changelists,
        you're out of luck.</para>
    -->
      <para>变更列表是组织工作副本文件的好工具, 但是它也有一些限制. 变更列表
        是特定的工作副本的产物, 这就意味着变更列表不能被传送给仓库, 或与其他
        用户分享. 只能在文件上分配变更列表&mdash;Subversion 目前还不支持在目录
        上使用变更列表. 最后, 在工作副本的一个文件上最多只能分配一个变更列表,
        如果用户发现自己需要在一个文件上分配多个变更列表, 那只能算你倒霉了.
      </para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.netmodel">
    <!--
    <title>Network Model</title>
    -->
    <title>网络模型</title>

    <!--
    <para>At some point, you're going to need to understand how your
      Subversion client communicates with its server.  Subversion's
      networking layer is abstracted, meaning that Subversion clients
      exhibit the same general behaviors no matter what sort of server
      they are operating against.  Whether speaking the HTTP protocol
      (<literal>http://</literal>) with the Apache HTTP Server or
      speaking the custom Subversion protocol
      (<literal>svn://</literal>) with <command>svnserve</command>,
      the basic network model is the same.  In this section, we'll
      explain the basics of that network model, including how
      Subversion manages authentication and authorization
      matters.</para>
    -->
    <para>在某些情况下, 用户需要了解 Subversion 客户端如何与服务器通信.
      Subversion 的网络层是抽象的, 也就是说无论服务器是什么类型, Subversion
      表现出的行为总是类似的. 不管是用 HTTP 协议 (<literal>http://</literal>)
      与 Apache HTTP 服务器通信, 还是传统的 Subversion 协议 (<literal>
        svn://</literal>), 基本网络模式都是相同的. 本节将介绍 Subversion 网络
      模式的基本概念, 包括 Subversion 如何管理授权与认证.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.reqresp">
    <!--
      <title>Requests and Responses</title>
    -->
      <title>请求与响应</title>

    <!--
      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a remote
        repository, however, it makes a network request, and the
        server responds with an appropriate answer.  The details of
        the network protocol are hidden from the user&mdash;the client
        attempts to access a URL, and depending on the URL scheme, a
        particular protocol is used to contact the server (see <xref
        linkend="svn.advanced.reposurls"/>).</para>
    -->
    <para>Subversion 客户端的大部分时间都用在工作副本的管理上, 当它需要从远
      程仓库获取信息时, 客户端生成并向服务器发送网络请求, 服务器再用适当的回答
      响应该请求. 网络协议的细节对用户是透明的&mdash;客户端试图访问一个 URL,
      根据 URL 模式, 客户端将使用某种特定的协议与服务器通信.</para>

      <tip>
    <!--
        <para>Run <userinput>svn - -version</userinput> to see which
          URL schemes and protocols the client knows how to use.</para>
    -->
        <para>运行 <userinput>svn --version</userinput> 查看客户客户端支持的
          URL 模式与协议.</para>
      </tip>

      <para>
        <indexterm>
          <primary>authentication (认证)</primary>
          <secondary>credentials (证书)</secondary>
        </indexterm>
        当服务器接收到客户端发来的请求时, 它经常会要求客户端阐明自己的身份.
        服务器向客户端发送一个认证消息, 客户端提供 <firstterm>证书</firstterm>
        (<firstterm>credentials</firstterm>) 进行响应, 认证一旦完成, 服务器便
        向客户端返回它所请求的信息. 这与 CVS 系统不同, CVS 系统的客户端先向服
        务器提供证书 (<quote>登录</quote>), 然后再发送请求. 而在 Subversion
        中, 服务器在适当的时候向客户端索要证书, 在此之前客户端不会主动向服务
        器发送证书, 这样的话某些操作就更加方便. 比如说如果服务器被配置成允许
        任何用户读取仓库, 当客户端试图检出工作副本时 (<command>svn checkout
      </command>), 服务器将不会要求客户端提供证书.</para>
    <!--
        When the server process receives a client request, it
        often demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information that the client asked for.
        Notice that this system is different from systems such as CVS,
        where the client preemptively offers credentials (<quote>logs
        in</quote>) to the server before ever making a request.  In
        Subversion, the server <quote>pulls</quote> credentials by
        challenging the client at the appropriate moment, rather than
        the client <quote>pushing</quote> them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        the server will never issue an authentication challenge
        when a client attempts to <command>svn checkout</command>.</para>
    -->

    <!--
      <para>If the particular network requests issued by the client
        result in a new revision being created in the repository
        (e.g., <command>svn commit</command>), Subversion uses the
        authenticated username associated with those requests as the
        author of the revision.  That is, the authenticated user's
        name is stored as the value of the
        <literal>svn:author</literal> property on the new revision
        (see <xref linkend="svn.advanced.props.ref"/>).  If the
        client was not authenticated (i.e., if the server never issued
        an authentication challenge), the revision's
        <literal>svn:author</literal> property is empty.</para>
    -->
      <para>如果客户端发起的请求将会产生一个新的版本号 (例如 <command>svn commit
        </command>), Subversion 就使用请求中的, 经过认证的用户名作为新的版本号
        的作者, 具体来说就是把经过认证的用户名作为新版本号的 <literal>
          svn:author</literal> 属性值 (见
        <xref linkend="svn.advanced.props.ref"/>). 如果客户端未经过认证 (也就
        是说服务器没有向客户端发送认证请求), 新版本号的 <literal>svn:author
      </literal> 属性值将为空.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.creds">
    <!--
      <title>Client Credentials</title>
    -->
      <title>客户端证书</title>

    <!--
      <para>Many Subversion servers are configured to require
        authentication.  Sometimes anonymous read operations are
        allowed, while write operations must be authenticated.  In
        other cases, reads and writes alike require authentication.
        Subversion's different server options understand different
        authentication protocols, but from the user's point of view,
        authentication typically boils down to usernames and
        passwords.  Subversion clients offer several different ways to
        retrieve and store a user's authentication credentials, from
        interactive prompting for usernames and passwords to encrypted
        and non-encrypted on-disk data caches.</para>
    -->
      <para>很多 Subversion 服务器都会要求认证. 有时候匿名的读操作是允许的,
        但是写操作必须经过认证, 还有些服务器要求读写都需要认证. 不同的
        Subversion 服务器选项支持不同的认证协议, 但是从用户的视角来看, 可以
        把认证简单地理解为用户名与密码. Subversion 客户端提供了几种不同的方法
        来检索和存放用户的认证证书, 包括交互性地提示用户输入用户名与密码, 以及
        存放在磁盘上的加密或未加密过的数据缓存.</para>

    <!--
      <para>The security-conscious reader will suspect immediately
        that there is reason for concern here.  <quote>Caching
        passwords on disk?  That's terrible!  You should never do
        that!</quote>  Don't worry&mdash;it's not as bad as it sounds.
        The following sections discuss the various types of credential
        caches that Subversion uses, when it uses them, and how to
        disable that functionality in whole or in part.</para>
    -->
      <para>对安全比较敏感的读者可能在想 <quote>在磁盘上缓存密码? 这可是个
          馊主意, 千万不要这么干!</quote> 不用担心&mdash;并没有听起来的这么
        糟糕. 下面将介绍 Subversion 使用的几种证书缓存类型, 什么时候用到它们,
        以及如何禁止它们的全部或部分功能.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.netmodel.credcache">
    <!--
        <title>Caching credentials</title>
    -->
        <title>缓存证书</title>

    <!--
        <para>Subversion offers a remedy for the annoyance caused when
          users are forced to type their usernames and passwords over
          and over again.  By default, whenever the command-line
          client successfully responds to a server's authentication
          challenge, credentials are cached on disk and keyed on a
          combination of the server's hostname, port, and
          authentication realm.  This cache will then be automatically
          consulted in the future, avoiding the need for the user to
          re-type his or her authentication credentials.  If seemingly
          suitable credentials are not present in the cache, or if the
          cached credentials ultimately fail to authenticate, the
          client will, by default, fall back to prompting the user for
          the necessary information.</para>
    -->
        <para>Subversion 提供了一种方法, 用于避免用户每次都要输入用户名与密码.
          在默认情况下, 每当客户端成功地响应服务器的认证请求时, 认证证书都会
          被缓存到磁盘上, 并把服务器的主机名, 端口与认证域的组合作为键值. 这个
          缓存在将来会被自动查阅, 这就避免了用户再次输入认证证书. 如果在缓存中
          没有找到合适的证书, 或者是缓存的证书认证失败, 此时客户端就会提示用户
          输入用户名与密码.</para>

        <!--
        <para>The Subversion developers recognize that on-disk caches
          of authentication credentials can be a security risk.  To
          offset this, Subversion works with available mechanisms
          provided by the operating system and environment to try to
          minimize the risk of leaking this information.</para>
        -->
        <para>Subversion 开发人员承认在磁盘上缓存认证证书有可能成为安全隐患,
          为了解决这个问题, Subversion 会利用操作系统环境, 把信息泄漏的风险
          降到最低.</para>

        <itemizedlist>

          <listitem>
          <!--
            <para>On Windows, the Subversion client stores passwords
              in the <filename>%APPDATA%/Subversion/auth/</filename>
              directory.  On Windows 2000 and later, the standard
              Windows cryptography services are used to encrypt the
              password on disk.  Because the encryption key is managed
              by Windows and is tied to the user's own login
              credentials, only the user can decrypt the cached
              password.  (Note that if the user's Windows account
              password is reset by an administrator, all of the cached
              passwords become undecipherable.  The Subversion client
              will behave as though they don't exist, prompting for
              passwords when required.)</para>
    -->
            <para>在 Windows 操作系统中, Subversion 客户端把密码存放在
              <filename>%APPDATA%/Subversion/auth/</filename> 目录内. 在
              Windows 2000 及之后的系统里, 磁盘上的密码会使用标准的 Windows
              加密服务进行加密. 因为密钥由 Windows 管理, 且绑定到用户个人的
              登录证书, 所以只有用户才能解密缓存的密码. (如果用户的 Windows
              帐户密码被管理员重置, 那么所有缓存的密码都不能再被解密,
              此时 Subversion 就认为缓存密码不存在, 在需要时重新提示用户输入.)
            </para>
          </listitem>

          <listitem>
        <!--
            <para>Similarly, on Mac OS X, the Subversion client stores
              all repository passwords in the login keyring (managed
              by the Keychain service), which is protected by the
              user's account password.  User preference settings can
              impose additional policies, such as requiring that the
              user's account password be entered each time the
              Subversion password is used.</para>
        -->
            <para>类似的, 在 Mac OS X 系统中, Subversion 用登录名作为键值存放
              所有仓库的密码 (由 keychain 服务进行管理), 键值由登录密码进行
              保护. 用户可以施加额外的策略, 例如每当 Subversion 要使用密码时,
              就要求用户输入帐户密码.</para>
          </listitem>

          <listitem>
        <!--
            <para>For other Unix-like operating systems, no single
              standard <quote>keychain</quote> service exists.
              However, the Subversion client knows how to store
              passwords securely using the <quote>GNOME Keyring</quote>,
              <quote>KDE Wallet</quote>, and <quote>GnuPG
              Agent</quote> services.  Also, before storing
              unencrypted passwords in the
              <filename>~/.subversion/auth/</filename> caching area,
              the Subversion client will ask the user for permission
              to do so.  Note that the <filename>auth/</filename>
              caching area is still permission-protected so that only
              the user (owner) can read data from it, not the world at
              large.  The operating system's own file permissions protect
              the passwords from other non-administrative users on the
              same system, provided they have no direct physical access
              to the storage media of the home directory, or backups
              thereof.</para>
        -->
        <para>类 Unix 系统没有标准的 <quote>keychain</quote> 服务, 但
          Subversion 仍然知道如何用 <quote>GNOME Keyring</quote>, <quote>
                KDE Wallet</quote> 和 <quote>GnuPG Agent</quote> 服务安全地
              存放密码. 把未加密的密码存放在 <filename>~/.subversion/auth/
              </filename> 之前, Subversion 会询问用户是否要这么做. 注意缓存
              区 <filename>auth/</filename> 仍然受到权限的保护, 只有用户
              (目录的所有者) 才能读取其中的数据. 操作系统的文件权限保护避免了密码
              被系统中的其他非管理员用户看到, 当然前提是其他用户不能直接接触
              存储设备或备份.</para>
          </listitem>

        </itemizedlist>

      <!--
        <para>Of course, for the truly paranoid, none of these
          mechanisms meets the test of perfection.  So for those folks
          willing to sacrifice convenience for the ultimate in security,
          Subversion provides various ways of disabling its credentials
          caching system altogether.</para>
    -->
        <para>当然, 这些机制并不能完全解决问题, 对于那些为了追求安全而不惜牺牲
          便利的用户来说, Subversion 提供了多种方式用于禁止证书缓存.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.disabling-password-caching">
      <!--
        <title>Disabling password caching</title>
      -->
        <title>禁止密码缓存</title>

      <!--
        <para>When you perform a Subversion operation that requires
          you to authenticate, by default Subversion tries to cache
          your authentication credentials on disk in encrypted form.
          On some systems, Subversion may be unable to encrypt your
          authentication data.  In those situations, Subversion will
          ask whether you want to cache your credentials to disk in
          plaintext:</para>
    -->
        <para>用户在执行一个要求认证的操作时, Subversion 默认把密码加密后缓存
          在本地, 在某些操作系统中, Subversion 可能无法进行加密, 在这种情况
          下 Subversion 将会询问用户是否以明文地方式缓存证书:</para>
  
        <informalexample>
          <screen>
$ svn checkout https://host.example.com:443/svn/private-repo
-----------------------------------------------------------------------
ATTENTION!  Your password for authentication realm:

   &lt;https://host.example.com:443&gt; Subversion Repository

can only be stored to disk unencrypted!  You are advised to configure
your system so that Subversion can store passwords encrypted, if
possible.  See the documentation for details.

You can avoid future appearances of this warning by setting the value
of the 'store-plaintext-passwords' option to either 'yes' or 'no' in
'/tmp/servers'.
-----------------------------------------------------------------------
Store password unencrypted (yes/no)? 
</screen>
        </informalexample>

      <!--
        <para>If you want the convenience of not having to continually
          reenter your password for future operations, you can
          answer <literal>yes</literal> to this prompt.  If you're
          concerned about caching your Subversion passwords in
          plaintext and do not want to be asked about it again and
          again, you can disable caching of plaintext passwords either
          permanently, or on a server-by-server basis.</para>
    -->
        <para>如果用户贪图方便, 不想每次都输入密码, 那就输入 <literal>yes
          </literal>. 如果用户担心以明文的方式缓存密码不太安全, 而且不想每次
          都被询问是否要缓存密码, 你可以永久地禁止密码明文缓存, 或者为每一个
          服务器设置单独的策略.</para>

        <warning>
      <!--
          <para>When considering how to use Subversion's password
            caching system, you'll want to consult any governing
            policies that are in place for your client
            computer&mdash;many companies have strict rules about the
            ways that their employees' authentication credentials
            should be stored.</para>
    -->
          <para>用户在考虑如何使用 Subversion 的缓存功能时, 可能需要咨询一下
            公司制度&mdash;很多公司对于如何存放员工的认证证书都有很严格的规定.
          </para>
        </warning>

      <!--
        <para>To permanently disable caching of passwords in
          plaintext, add the line <literal>store-plaintext-passwords =
          no</literal> to the <literal>[global]</literal> section in
          the <filename>servers</filename> configuration file on the
          local machine.  To disable plaintext password caching for a
          particular server, use the same setting in the appropriate
          group section in the <filename>servers</filename>
          configuration file.  (See
          <xref linkend="svn.advanced.confarea.opts"/> in
          <xref linkend="svn.customization"/> for details.)</para>
    -->
        <para>为了永久地禁止以明文方式缓存密码, 在本地配置文件 <filename>
            servers</filename> 的 <literal>[global]</literal> 部分添加一行
          <literal>store-plaintext-passwords</literal>. 为了对特定的服务器
          禁止明文密码缓存, 在配置文件 <filename>servers</filename> 的适当
          位置添加同样的一行 (具体的细节见 <xref linkend="svn.customization"/>
          的 <xref linkend="svn.advanced.confarea.opts"/>).</para>

      <!--
        <para>To disable password caching entirely for any single
          Subversion command-line operation, pass
          the <option>- -no-auth-cache</option> option to that command
          line.  To permanently disable caching entirely, add the
          line <literal>store-passwords = no</literal> to your local
          machine's Subversion configuration file.</para>
    -->
        <para>为了禁止特定的 Subversion 命令缓存密码, 向该命令添加选项
          <option>--no-auth-cache</option>. 为了永久地禁止缓存, 在本地的
          Subversion 配置文件中添加一行 <literal>store-passwords = no</literal>.
        </para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.authn-cache-purge">
      <!--
        <title>Removing cached credentials</title>
      -->
        <title>删除已缓存的证书</title>
     
      <!--
        <para>Sometimes users will want to remove specific credentials
          from the disk cache.  To do this, you need to navigate into
          the <filename>auth/</filename> area and manually delete the
          appropriate cache file.  Credentials are cached in individual
          files;  if you look inside each file, you will see keys and
          values.  The <literal>svn:realmstring</literal> key describes
          the particular server realm that the file is associated
          with:</para>
      -->
        <para>有时候用户想从缓存中删除特定的证书, 为了实现这个目标, 你需要
          进入到 <filename>auth/</filename> 目录, 然后手动地删除对应的缓存文件.
          每一个证书都对应一个单独的文件, 如果查看文件的内容, 你将会看到关键字
          和值, 关键字 <literal>svn:realmstring</literal> 描述了文件与哪一个
          服务器关联.</para>

        <informalexample>
          <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>
        </informalexample>

      <!--
        <para>Once you have located the proper cache file, just delete
          it.</para>
      -->
      <para>一旦找到了对应的缓存文件, 直接删除即可.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.different-user">
      <!--
        <title>Command-line authentication</title>
      -->
        <title>命令行认证</title>

      <!--
        <para>All Subversion command-line operations accept
          the <option>- -username</option>
          and <option>- -password</option> options, which allow you to
          specify your username and password, respectively, so that
          Subversion isn't forced to prompt you for that information.
          This is especially handy if you need to invoke Subversion
          from a script and cannot rely on Subversion being able to
          locate valid cached credentials for you.  These options are
          also helpful when Subversion has already cached
          authentication credentials for you, but you know they aren't
          the ones you want it to use.  Perhaps several system users
          share a login to the system, but each have distinct
          Subversion identities.  You can omit
          the <option>- -password</option> option from this pair if
          you wish Subversion to use only the provided username, but
          still prompt you for that username's password.</para>
      -->
        <para>所有的 Subversion 命令都支持选项 <option>--username</option>
          和 <option>--password</option>, 选项的作用分别是指定用户名与密码,
          这样 Subversion 就不会再提示用户输入这两项信息. 有了这两个选项, 就
          可以很方便地在脚本里执行 Subversion 命令, 而不用依赖缓存的认证证书.
          除此之外, 如果 Subversion 已经缓存了认证证书, 但你知道这不是你想使
          用的那个 (比如多个人使用相同的登录名登录操作系统, 但每个人所使用的
          Subversion 认证证书却不一样), 可以用这两个选项重新指定用户名与密码.
          用户可以不指定选项 <option>--password</option>, 只让 Subversion 从
          命令行参数中获取用户名, 但它仍然会提示用户输入与用户名对应的密码.
        </para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.authn-wrapup">
      <!--
        <title>Authentication wrap-up</title>
      -->
        <title>认证小结</title>

      <!--
        <para>One last word about <command>svn</command>'s
          authentication behavior, specifically regarding the
          <option>- -username</option> and <option>- -password</option>
          options.  Many client subcommands accept these options, but it
          is important to understand that using these options does
          <emphasis>not</emphasis> automatically send credentials to the
          server.  As discussed earlier, the server <quote>pulls</quote>
          credentials from the client when it deems necessary; the
          client cannot <quote>push</quote> them at will.  If a username
          and/or password are passed as options, they will be
          presented to the server only if the server requests them.  These
          options are typically used to authenticate as a different user
          than Subversion would have chosen by default (such as your
          system login name) or when trying to avoid interactive
          prompting (such as when calling <command>svn</command> from a
          script).</para>
      -->
        <para>关于 Subversion 的认证行为最后再讲一点, 尤其是 <option>--username
          </option> 和 <option>--password</option> 这两个选项. 很多客户端子
          命令都支持这两个选项, 但是要注意使用它们并不会 <emphasis>自动
          </emphasis> 地把证书发送给服务器, 前面已经说过, 只有当服务器认为需要
          证书时, 才会主动向客户端 <quote>索要</quote> 证书, 客户端不能随心所
          欲地向服务器 <quote>推送</quote> 证书. 如果在命令行选项上指定了用户
          名和 (或) 密码, 只有当服务器需要时, 它们才会被递送给服务器. 使用这
          两个选项的最典型情况是用户想要明确地指定用户名, 而不是让 Subversion
          自己猜一个 (例如登录操作系统的用户名), 又或者是避免出现交互式的提示
          信息 (例如命令是在脚本里执行的).</para>

        <note>
      <!--
          <para>A common mistake is to misconfigure a server so
            that it never issues an authentication challenge.  When
            users pass <option>- -username</option> and
            <option>- -password</option> options to the client, they're
            surprised to see that they're never used; that is, new
            revisions still appear to have been committed
            anonymously!</para>
      -->
          <para>服务器的一个常见的配置错误是从来不向客户端发起认证请求, 如果
            用户在命令行上指定了选项 <option>--username</option> 和
            <option>--password</option>, 会发现它们不起作用, 新的版本号总是
            匿名提交的.</para>
        </note>

      <!--
        <para>Here is a final summary that describes how a Subversion
          client behaves when it receives an authentication
          challenge.</para>
      -->
        <para>下面几点介绍了当客户端收到一个认证请求时所做的操作.</para>

        <orderedlist>
          <listitem>
      <!--
            <para>First, the client checks whether the user specified
              any credentials as command-line options
              (<option>- -username</option> and/or
              <option>- -password</option>).  If so, the client will try
              to use those credentials to authenticate against the
              server.</para>
      -->
            <para>首先, 客户端检查用户是否在命令行上输入了证书 (选项 <option>
                --username</option> 和 (或) <option>--password</option>), 如果
              是, 客户端将使用它们响应服务器的认证请求.</para>
          </listitem>
          <listitem>
      <!--
            <para>If no command-line credentials were provided, or the
              provided ones were invalid, the client looks up the server's
              hostname, port, and realm in the runtime configuration's
              <filename>auth/</filename> area, to see whether appropriate 
              credentials are cached there.  If so, it attempts to use
              those credentials to authenticate.</para>
      -->
            <para>如果命令行参数没有提供证书, 又或者是提供的证书是无效的, 客户
              端就在运行时配置的 <filename>auth/</filename> 目录查找服务器的
              主机名, 端口和认证域, 检查是否有合适的证书缓存. 如果有就使用缓存
              的证书响应请求.</para>
          </listitem>
          <listitem>
      <!--
            <para>Finally, if the previous mechanisms failed to
              successfully authenticate the user against the server, the
              client resorts to interactively prompting the user for
              valid credentials (unless instructed not to do so via the
              <option>- -non-interactive</option> option or its
              client-specific equivalents).</para>
      -->
            <para>最后, 如果前面的认证都失败了, 客户端就会提示用户输入用户
              名与密码 (除非指定了选项 <option>--non-interactive</option> 或
              其他等效的设置).</para>
          </listitem>
        </orderedlist>

      <!--
        <para>If the client successfully authenticates by any of these
          methods, it will attempt to cache the credentials on disk
          (unless the user has disabled this behavior, as mentioned
          earlier).</para>
      -->
        <para>如果客户端成功地用上面的任意一种方法满足了服务器的认证请求,
          它就试图把证书缓存在本地磁盘上 (除非用户禁止了缓存).</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.working-without-a-wc">
      <!--
    <title>Working Without a Working Copy</title>
      -->
    <title>在没有工作副本的情况下工作</title>

      <!--
    <para>As we described in <xref linkend="svn.basic.in-action.wc"
      />, the Subversion working copy is a sort of staging area where
      a user can privately make changes to his or her versioned data
      and then&mdash;when those changes are complete and ready for
      sharing with others&mdash;commit them to the repository.  It
      should come as no surprise, then, that most of the interaction
      you will have with Subversion will be in the form of asking your
      Subversion client to do <emphasis>something</emphasis> to one or
      more items in a local working copy.  Even for those operations
      which don't manipulate the working copy data itself (such
      as <command>svn log</command>), it's often just easier to use a
      working copy file or directory as a convenient target for that
      operation.</para>
      -->
    <para><xref linkend="svn.basic.in-action.wc"/> 已经说过, Subversion 的工作
      副本是一种暂存区, 暂存用户的私有修改, 当修改完成, 准备共享给其他用户时,
      就把修改提交到仓库中. 于是, 用户的大部分时间都是在用客户端与工作副本打
      交道, 即使是不处理工作副本的操作 (例如 <command>svn log</command>), 也
      经常使用工作副本里的文件或目录作为操作的目标文件.</para>

      <!--
    <para>Clearly, the typical approach to making changes to
      your versioned data is via commits from a Subversion working
      copy.  Fortunately, it's not the only way.  Users of Subversion
      who need to make relatively simple changes to their versioned
      data can do so without the overhead of checking out a working
      copy.  We'll cover some of those supported operations in this
      section.</para>
      -->
    <para>明确地说, 从工作副本里提交是修改文件的典型方式, 幸运的是这并不是唯一
      的选择, 如果修改相对比较简单, 用户甚至可以在不检出工作副本的前提下提交
      修改, 本节就是介绍与此有关的内容.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.working-without-a-wc.svn">
      <!--
      <title>Remote command-line client operations</title>
      -->
      <title>远程客户端命令行操作</title>

      <!--
      <para>The Subversion command-line client supports a number of
        operations which can be performed directly against repository
        URLs in order to make simple changes without a working copy.
        Some of these are described elsewhere in this book, but we
        provide an exhaustive list of them here for your
        convenience.</para>
      -->
      <para>为了完成一些相对较小的修改, Subversion 的客户端命令行工具的很
        多操作都可以在没有工作副本的前提下, 直接对仓库 URL 发起. 其中的部分
        内容在本书的其他地方介绍, 但是为了方便读者, 我们在这里详尽地列出了
        它们.</para>

      <!--
      <para>Perhaps the most obvious remote commit-like operation is
        the <command>svn import</command> command.  We describe that
        command in <xref linkend="svn.tour.importing.import" /> as
        part of explaining how you can easily get a whole tree of
        unversioned information into your Subversion repository so you
        can start doing version-controlled operations on it.</para>
      -->
      <para>最明显的远程类提交操作应该是命令 <command>svn import</command>,
        我们在 <xref linkend="svn.tour.importing.import"/> 介绍如何快速地把
        一个目录导入到仓库中时, 提到了这个命令.</para>

      <!--
      <para>The <command>svn mkdir</command> and <command>svn
        delete</command> commands, when used with URL targets, are
        also remote commit-type operations.  These allow the user to
        create one or more new versioned directories or remove
        (recursively) one or more versioned files or directories,
        respectively, without the use of a working copy.  Each time
        you issue one of these commands, the client communicates with
        the server in a way that's similar to how it would describe
        the commit of a directory added or of an item removed from the
        working copy.  If there's no problem or conflict detected with
        the requested operation, the server commits the additions or
        removals in a single new revision.</para>
      -->
      <para>当目标参数是 URL 时, 命令 <command>svn mkdir</command> 和 <command>
          svn delete</command> 也可以是远程操作, 这允许用户在没有工作副本的前
        提下, 在仓库中添加新的目录或 (递归地) 删除文件. 每次执行这两个命令时,
        客户端与服务器的通信过程类似于把工作副本里新增的目录或删除的文件提交
        给服务器的过程. 如果认证没有问题, 并且没有发生冲突, 服务器就在一个单独
        的版本号里完成添加或删除.</para>

      <!--
      <para>You can use <command>svn copy</command> or <command>svn
        move</command> with two URLs&mdash;a copy/move source and a
        destination&mdash;to commit a copies and moves of files and
        directories directly in the repository.  These operations tend
        to be some of the most expensive ones when performed within a
        working copy, but they complete in constant time when
        performed remotely using repository URLs.  In fact,
        the <command>svn copy</command> remote operation is commonly
        used to create branches in Subversion, as we discuss later in
        <xref linkend="svn.branchmerge.using.create" />.</para>
      -->
      <para>你可以用两个 URL 作为 <command>svn copy</command> 或 <command>
          svn move</command> 的参数&mdash;一个是源, 另一个是目标&mdash;直接向
        仓库提交文件的复制或移动. 如果是在工作副本里执行, 这两个操作将会是耗时
        最长的操作之一, 如果使用仓库的 URL 进行远程操作, 它们就可以在常数时间
        内完成. 实际上, 在创建分支时, 人们经常使用 <command>svn copy</command>
        远程操作, 这部分内容将在 <xref linkend="svn.branchmerge.using.create"/>
        介绍.</para>

      <!--
      <para>As with the regular <command>svn commit</command> command,
        you can supply a log message with any of these commands we've
        discussed so far to describe the changes you're making.  Use
        the <option>- -file (-F)</option> or <option>- -message
        (-m)</option> option, or otherwise allow the client to prompt
        you for the log message.</para>
      -->
      <para>和普通的 <command>svn commit</command> 一样, 上面介绍的几个远程
        操作都接受用户输入一段日志, 描述本次操作做了什么, 输入日志的方式可以
        用选项 <option>--file</option> (<option>-F</option>) 或 <option>
          --message</option> (<option>-m</option>), 如果这两个选项都没有指定,
        客户端就会提示用户输入日志消息.</para>

      <!--
      <para>Finally, there are a number of operations related to
        unversioned revision properties which can be performed
        directly against the repository.  In fact, revision properties
        are somewhat unique in this context, as they aren't stored in
        the working copy and therefore <emphasis>must</emphasis> be
        modified without working copy interaction.  See
        <xref linkend="svn.advanced.props" /> for a more detailed
        description of how to manage properties in Subversion.</para>
      -->
      <para>最后, 很多与版本号属性相关的操作都可以直接对仓库发起. 实际上, 这
        里谈到的版本号属性比较独特, 因为它们不是存放在工作副本里, 所以它们
        <emphasis>必须</emphasis> 在不与工作副本交互的情况下修改. 关于如何管理
        Subversion 属性的更多信息, 见 <xref linkend="svn.advanced.props"/>.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.working-without-a-wc.svnmucc">
      <!--
      <title>Using svnmucc</title>
      -->
      <title>使用 svnmucc</title>

      <!--
      <para>One shortcoming of the remote commit operation support
        offered in the command-line client is that you are essentially
        limited to one operation&mdash;or, really, one type of
        operation&mdash;per commit.  For example, it's perfectly
        natural and supported to, say, use <command>svn
        delete</command> followed by <command>svn mkdir</command>
        within a working copy to replace an existing versioned
        directory with a brand new one.  When you commit the results
        of those operations, a single new revision is created in the
        repository, and that revision carries the full replacement of
        your directory.  You can't really do the same thing as remote
        operations using the command-line client while still
        preserving the it-happened-in-a-single-revision-ness of the
        change&mdash;<command>svn
        delete <replaceable>URL</replaceable></command> would create a
        new revision that removed the directory; <command>svn
        mkdir <replaceable>URL</replaceable></command> would generate
        a second revision for the directory's re-creation.</para>
      -->
      <para>客户端命令行工具的远程提交操作的一个缺点是用户每次提交只能执行一
        个操作&mdash;或者说一种类型的操作. 比如说在一个工作副本内, 为了用一个
        全新的目录替换掉旧目录, 先执行 <command>svn delete</command>, 再执行
        <command>svn mkdir</command>&mdash;是一个很自然的操作. 当用户提交这两
        个操作的执行结果时, 仓库将创建一个新的版本号, 该版本号完整地记录了这两
        个操作. 但是客户端命令行的远程操作不能在单个版本号中完成这两步操作
        &mdash;<command>svn delete <replaceable>URL</replaceable></command>
        会创建一个新的版本号并删除目录; <command>svn mkdir <replaceable>URL
      </replaceable></command> 会在第二个版本号中完成目录的创建.</para>

      <!--
      <para>Fortunately, Subversion provides a separate tool which
        exists solely to allow users to string together a set of
        remote operations and commit them as one atomic change.  That
        tool is the <command>svnmucc</command> tool&mdash;the
        Subversion Multiple URL Command Client:</para>
      -->
      <para>幸运的是, Subversion 另外提供了一个工具, 用于把多个远程操作放在一
        个提交中完成, 这个工具是 <command>svnmucc</command>&mdash;Subversion
        多 URL 命令行客户端 (Multiple URL Command Client):</para>

      <informalexample>
        <screen>
$ svnmucc --help
Subversion multiple URL command client
usage: svnmucc ACTION...

  Perform one or more Subversion repository URL-based ACTIONs, committing
  the result as a (single) new revision.

Actions:
  cp REV URL1 URL2       : copy URL1@REV to URL2
  mkdir URL              : create new directory URL
  mv URL1 URL2           : move URL1 to URL2
  rm URL                 : delete URL
  put SRC-FILE URL       : add or modify file URL with contents copied from
                           SRC-FILE (use "-" to read from standard input)
  propset NAME VAL URL   : set property NAME on URL to value VAL
  propsetf NAME VAL URL  : set property NAME on URL to value from file VAL
  propdel NAME URL       : delete property NAME from URL
&hellip;
</screen>
      </informalexample>

      <!--
      <para><command>svnmucc</command> has been a part of the Subversion
        project's source code tree for many years
        (as <command>mucc</command> for most of that time), but it was
        only in Subversion 1.8 that it become a fully supported member
        of the Subversion command-line tool suite.</para>
      -->
      <para><command>svnmucc</command> 很多年前就已经包含在 Subversion 的源代
        码树中 (那时候称为 <command>mucc</command>), 但是直到 1.8, <command>
          svnmucc</command> 才享受到完全的支持, 成为 Subversion 客户端命令行工
        具套装的正式成员.</para>

      <!--
      <para>The <command>svnmucc</command> tool can perform any
        transformation on your versioned data that <command>svn</command>
        itself can.  But unlike <command>svn</command>, the functionality
        that <command>svnmucc</command> offers isn't broken up into
        subcommands.  Rather, you provide a list of actions and
        operands in a single command line (or from a file stream, via
        the <option>- -extra-args (-X)</option> option).  Some of the
        actions supported by <command>svnmucc</command> mimic those of
        the command-line client.  You'll notice in the previous
        command output actions such as <literal>cp</literal>,
        <literal>mkdir</literal>, <literal>mv</literal>,
        and <literal>rm</literal>, all of which are very similar to
        the commands we mentioned in
        <xref linkend="svn.advanced.working-without-a-wc.svn" />.  But
        remember, the key difference here is that you can use any
        number of these actions together in a single command
        invocation, resulting in a single committed revision in the
        repository.</para>
      -->
      <para><command>svn</command> 可以做到的转换, <command>svnmucc</command>
        都可以做到, 但不同的是, <command>svnmucc</command> 的功能并不是把操作
        切分成多个子命令. 用户可以在一条命令行上 (或者在一个文件中, 通过选项
        <option>--extra-args</option> (<option>-X</option>) 把文件传递给
        <command>svnmucc</command>) 输入多个操作及其参数, <command>svnmucc
        </command> 支持的某些操作模仿了对应的客户端命令行. 读者可能已经注意到
        <command>svnmucc</command> 帮助信息中
        列出的操作, 例如 <literal>cp</literal>, <literal>mkdir</literal>,
        <literal>mv</literal> 和 <literal>rm</literal>, 和我们在
        <xref linkend="svn.advanced.working-without-a-wc.svn"/> 提到的操作非常
        类似, 但是请记住, 它们之间最关键的区别是用户可以在
        <command>svnmucc</command> 的一次调用中, 执行任意多的操作, 所有的这些
        操作只会产生一个新的版本号.</para>

      <!--
      <para>Let's take our previous example of trying to simply
        replace a remote directory.  Using <command>svnmucc</command>,
        you would accomplish this as follows:</para>
      -->
      <para>如果使用 <command>svnmucc</command> 完成本节开头的远程目录替换操
        作, 一个示例是:</para>

      <informalexample>
        <screen>
$ svnmucc rm http://svn.example.com/projects/sandbox \
          mkdir http://svn.example.com/projects/sandbox \
          -m "Replace my old sandbox with a fresh new one."
r22 committed by harry at 2013-01-15T21:45:26.442865Z
$ 
</screen>
      </informalexample>

      <!--
      <para>As you can see, <command>svnmucc</command> accomplished in
        a single revision what <command>svn</command>&mdash;without
        the benefit of a working copy&mdash;required two revisions to
        complete.</para>
      -->
      <para>可以看到, <command>svnmucc</command> 在一个版本号中完成了两步操作,
        而在没有工作副本的情况下, <command>svn</command> 会产生两个新的版本号.
      </para>

      <warning>
      <!--
        <para>Another difference between <command>svnmucc</command>
          and <command>svn</command> is that the former currently will
          not prompt you for a commit log message if you fail to
          supply one via the command line.  Rather, it will use a
          stock (that is, relatively valueless) log message.</para>
      -->
        <para><command>svnmucc</command> 和 <command>svn</command> 的另一个区
          别是如果用户没有在命令行提供日志消息 (通过选项
          <option>--message</option> (<option>-m</option>) 或
          <option>--file</option> (<option>-F</option>)), <command>svnmucc
        </command> 将不会提示用户输入提示日志, 转而使用一段常备的日志
        (相对来说没什么价值).</para>
      </warning>

      <!--
      <para>The <command>svnmucc</command> tool is not limited to
        merely remixing actions that <command>svn</command> itself can
        perform.  It introduces some additional functionality not
        found in the command-line client.  For example, you can use
        the <command>put</command> action to add or modify a file in
        the repository, copying the file's intended new contents from
        either a file on your local machine or from data piped in via
        standard input.  The tool also offers <command>propset</command>,
        <command>propsetf</command>, and <command>propdel</command>
        actions, useful for setting properties on versioned files and
        directories (explicitly, or by copying the property's value
        from a local file) and for deleting properties on the same.
        Those actions are unsupported in the command-line client at
        this time.</para>
      -->
      <para><command>svnmucc</command> 的作用不仅仅是混合 <command>svn</command>
        的操作, 它还增加了一些其他命令行工具不支持的功能. 例如用户可以使用操作
        <command>put</command> 添加或修改仓库里的文件, 把来自本地文件或标准输入
        的内容复制到仓库的文件中. <command>svnmucc</command> 还提供了
        <command>propset</command>, <command>propsetf</command> 和
        <command>propdel</command> 这三种操作,  用于设置或删除文件和目录的属性
        (属性值既可以显式地在命令行指定, 也可以从本地文件中读取), 而其他客户端
        命令行工具还不支持这些操作 (其他命令行工具只能直接操作工作副本里的文件
        的属性).
      </para>

      <!--
      <para>At this point, though, it seems prudent to discuss the
        difference between what <emphasis>can</emphasis> be done
        with <command>svnmucc</command> and what
        <emphasis>should</emphasis> be done.  A pair of notable quotes
        comes to mind:</para>
      -->
      <para><command>svnmucc</command> 可以做哪些事, 以及什么事应该由它来做
        &mdash;这两者的区别非常重要, 先来两句名言:</para>

      <blockquote>
      <!--
        <attribution>Jesus</attribution>
        <para><quote>To whom much has been given, much will be
          expected.</quote></para>
      -->
        <attribution>耶稣</attribution>
      <para><quote>给予越多, 期望越多.</quote></para>
      </blockquote>

      <blockquote>
      <!--
        <attribution>"Spiderman" Peter Parker's Uncle Ben</attribution>
        <para><quote>With great power comes great
          responsibility.</quote></para>
      -->
        <attribution>Ben, 蜘蛛侠 Peter Parker 的叔叔</attribution>
        <para><quote>能力越大, 责任越大.</quote></para>
      </blockquote>

      <!--
      <para>Inherent in modifications without a working copy is the loss of
        the very conflict detection safeguards which make the use of a
        working copy so valuable.  When using <command>svn</command>
        in the typical way, changes are committed to the server
        against a specific base version of a file or directory so that
        you don't inadvertently overwrite contemporary changes made to
        the same item by another team member.  The server knows what
        version of the file you had before you changed it, and it
        knows if other folks have changed that same file since that
        revision was created.  That's all the information the server
        needs to deny your commit when it would clobber someone else's
        change, forcing you to integrate their change into your
        working copy and reconsider your own change.  Because there is
        no working copy in the mix here, <command>svnmucc</command>
        really gives you the power to bypass those safeguards and to
        act as if the current state of the repository is precisely the
        base state against which you are working.  But hopefully it is
        obvious to you that this is not a power you should cavalierly
        wield.</para>
      -->
      <para>不使用工作副本的坏处是丧失了冲突检测的能力. 当按照典型的方式使用
        <command>svn</command> 时, 被提交的修改是相对于仓库中文件的特定基础
        版本, 这样用户就不会无意中覆盖其他用户对相同文件提交的修改. 服务器知道
        被用户修改的文件的版本, 也知道在该版本之后是否有其他用户修改了文件,
        有了这些, 当用户的提交会破坏其他用户的修改时, Subversion 就会拒绝提交,
        强迫用户合并其他用户已提交的修改, 并重新考虑自己的修改. 因为
        <command>svnmucc</command> 没有用到工作副本, 也就绕过了冲突检测,
        使得 <command>svnmucc</command> 提交的每个修改都是相对于仓库中的最新
        版本, 希望这种情况不是用户正想看到的样子.</para>

      <!--
      <para>Fortunately, <command>svnmucc</command> allows you to be
        more conservative in the way you use the tool.  In order to
        provide a safety mechanism similar to what is offered by the
        use of a working copy, <command>svnmucc</command> offers
        a <option>- -revision (-r)</option> option.  With this option,
        you can manually specify a base revision for the changes you
        are attempting to commit.  The base revision you choose
        is ideally the most recent revision in your repository of
        which you can reasonably claim knowledge.</para>
      -->
      <para>幸运的是, <command>svnmucc</command> 也希望用户在使用它时能更加地
        谨慎, 方法是使用选项 <option>--revision</option> (<option>-r</option>).
        通过这个选项, 用户可以明确地指定相对于提交的基础版本号, 该版本号应该是
        用户在提交前看到的最新的版本号.</para>
      
      <warning>
      <!--
        <para>Users are strongly encouraged to use, and to use
          correctly, the <option>- -revision (-r)</option> option
          to <command>svnmucc</command>.</para>
      -->
        <para>强烈建议用户总是为 <command>svnmucc</command> 加上选项
          <option>--revision</option> (<option>-r</option>), 并指定正确的
          版本号.</para>
      </warning>

      <!--
      <para>Proper use of the <command>svnmucc put</command> action
        best demonstrates how this <option>- -revision (-r)</option>
        option should be used.  Say Harry wishes to change the
        contents of a versioned <filename>README</filename> file
        without bothering with a full checkout of a working copy.
        (We'll assume that there is no other value in using a working
        copy for this operation, such as the presence of scripts Harry
        should run in advance of his commit to verify that it's a
        reasonable one.)  The first decision he has to make is which
        revision of the file he wants to work with.  Typically, users
        wish to modify the most recent version of a file.  So Harry
        queries the revision in which the file was last modified, and
        then uses that revision to fetch the contents of the file into
        a temporary local file:</para>
      -->
      <para>说明选项 <option>--revision</option> (<option>-r</option>) 重要性
        的最好方式是展示如何正确地使用命令 <command>svnmucc put</command>.
        假设 Harry 想在没有工作副本的情况下修改仓库里的文件
        <filename>README</filename> (仅针对修改 <filename>README</filename>
        这个操作而言, 我们假设使用工作副本不会带来其他额外的使用, 例如在提交
        前执行工作副本里的一个脚本, 以保证 Harry 的修改是符合要求的),
        他要确定的第一件事是针对文件的哪个版本进行
        修改. 在典型的情况下, 用户总是想修改文件的最新版, 于是 Harry 查询文件
        最后一次被提交的版本号, 并把该版本号对应的文件内容抓取到本地的一个临时
        文件中.</para>

      <informalexample>
        <screen>
$ svn info http://svn.example.com/projects/sandbox/README
Path: README
URL: http://svn.example.com/projects/sandbox/README
Relative URL: ^/sandbox/README
Repository Root: http://svn.example.com/projects
Repository UUID: 13f79535-47bb-0310-9956-ffa450edef68
Revision: 22
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 14
Last Changed Date: 2012-09-02 10:34:09 -0400 (Sun, 02 Sep 2012)

$ svn cat -r 14 http://svn.example.com/projects/sandbox/README \
      > README.tmpfile
$
</screen>
      </informalexample>

      <!--
      <para>Harry now has a copy of the <filename>README</filename>
        file as it looked when it it was last modified.  He makes the
        edits he wishes to make to this copy of the file.  Naturally,
        when he's finished, he wishes to then commit those changes to
        the repository.</para>
      -->
      <para>现在 Harry 有了 <filename>README</filename> 的一个副本, 副本的内容
        和它最后一次被提交时的内容相同. 他按照自己的想法对副本进行了修改, 修改
        完成后, 他打算提交到仓库中.</para>

      <!--
      <para>Now, if Harry naively uses <userinput>svnmucc put
        &hellip;</userinput> at this point to replace the contents of
        <filename>README</filename> in the repository with his locally
        modified contents, he has just abused the power
        that <command>svnmucc</command> affords.  What if, just
        microseconds prior to his commit, Sally had also modified
        the <filename>README</filename> file?  As with the
        <command>svn</command> program, <command>svnmucc</command>
        won't attempt some sort of server-side content merge in order
        to preserve both users' changes.  Rather,
        <command>svnmucc</command> will happily replace the current
        latest version of the file with the contents specified.  Harry
        will be oblivious.  Sally will be livid.</para>
      -->
      <para>如果 Harry 单纯地使用 <userinput>svnmucc put&hellip;</userinput>,
        将仓库中 <filename>README</filename> 的内容替换成本地修改后的版本,
        那他就是在滥用 <command>svnmucc</command> 的能力. 要是在他提交前一
        毫秒, Sally 也提交了 <filename>README</filename> 的修改, 那会怎样?
        和 <command>svn</command> 相比, <command>svnmucc</command> 不会为了同时
        保留两个用户的修改而尝试在服务器端做一些内容合并操作,
        <command>svnmucc</command> 会直接使用指定的内容替换掉文件的最新版本.
        Harry 不会察觉到这些, 但 Sally 可能会大发雷霆.</para>

      <informalexample>
        <screen>
$ svnmucc put README.tmpfile \
          http://svn.example.com/projects/sandbox/README \
          -m "Tweak the README file."
r24 committed by harry at 2013-01-21T16:21:23.100133Z
$
Message from sally@shell.example.com on pts/2 at 16:26 ...
We need to talk.  Now.
EOF
</screen>
      </informalexample>

      <!--
      <para>Harry should instead recall the revision he originally
        used as the revision on which to base his changes, supplying
        that revision to <command>svnmucc</command> via
        the <option>- -revision (-r)</option> option, and thus giving
        the server the opportunity to bounce his commit if, by his own
        (perhaps ignorant) admission, he's attempting to modify an
        out-of-date item:</para>
      -->
      <para>Harry 应该回想被自己修改的本地文件来自哪个版本号, 然后把该版本号
        通过选项 <option>--revision</option> (<option>-r</option>) 传递给命令
        <command>svnmucc</command>, 这样服务器就有机会检查被用户修改的文件是否
        过旧, 如果是的话就拒绝提交.</para>

      <informalexample>
        <screen>
$ svnmucc -r 14 put README.tmpfile \
          http://svn.example.com/projects/sandbox/README \
          -m "Tweak the README file."
svnmucc: E170004: Item '/sandbox/README' is out of date
$
</screen>
      </informalexample>

      <!--
      <para>Like other <command>svnmucc</command> options,
        the <option>- -revision (-r)</option> option operates at a
        scope global to the whole command&mdash;every action specified
        in that command.  This enables you to have the same sort of
        safeguards you would have if you had checked out a working
        copy of your entire repository (and thus had a working copy
        entirely at a single uniform revision), made changes to that
        working copy, and then committed all those changes at
        once.</para>
      -->
      <para>和 <command>svnmucc</command> 的其他其他选项一样, 选项
        <option>--revision</option> (<option>-r</option>) 的作用域是整个命令
        &mdash;命令中指定的每一个操作. 这就使得用户在使用
        <command>svnmucc</command> 时, 具有了和下面这种情形同样的保护措施
        &mdash;检出整个仓库的工作副本 (并且工作副本具有一致的版本号), 修改工作
        副本里的文件, 最后提交工作副本的所有修改.</para>

      <!--
      <para>As you can see, <command>svnmucc</command> is a handy
        addition to the Subversion user's tool chest.  For a complete
        reference of this tool's offerings, see
        <xref linkend="svn.ref.svnmucc" />.</para>
      -->
      <para><command>svnmucc</command> 是 Subversion 客户端工具集的有益补充,
        它的完整手册见 <xref linkend="svn.ref.svnmucc"/>.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.summary">
      <!--
    <title>Summary</title>
      -->
    <title>小结</title>

      <!--
    <para>After reading this chapter, you should have a firm grasp on
      some of Subversion's features that, while perhaps not used
      <emphasis>every</emphasis> time you interact with your version
      control system, are certainly handy to know about.  But don't
      stop here!  Read on to the following chapter, where you'll learn
      about branches, tags, and merging.  Then you'll have nearly full
      mastery of the Subversion client.  Though our lawyers won't
      allow us to promise you anything, this additional knowledge
      could make you measurably more cool.<footnote><para>No purchase
      necessary.  Certains terms and conditions apply.  No guarantee
      of coolness&mdash;implicit or otherwise&mdash;exists.  Mileage
      may vary.</para></footnote></para>
      -->
  <para>读完本章后, 读者应该牢固地掌握了 Subversion 的某些特性, 虽然这些
    特性不可能每次都会被用到, 但了解它们总是会派上用场. 读者应该继续往下阅读,
    在下面的内容里, 你将会学到分支, 标签与合并, 学习完这些知识后, 读者基本上
    就算是完全掌握了 Subversion 的客户端操作. 虽然我们的律师不允许我们向你做
    出任何承诺, 但了解这些知识会让你更加潇洒.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
