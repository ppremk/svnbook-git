<!-- -*- sgml -*- -->

<chapter id="svn.reposadmin">
      <!--
  <title>Repository Administration</title>
      -->
  <title>仓库管理</title>

      <!--
  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>
      -->
  <para>Subversion 仓库是存放所有版本化数据的中心位置, 因此受到系统管理员的
    额外照顾也是很正常的. 仓库的维护工作很少, 更重要的是理解如何正确地配置它,
    这样才能避免出现潜在的问题, 并解决实际发生的问题.</para>

      <!--
  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use various
    related tools provided with Subversion.  We'll address some common
    questions and mistakes and give some suggestions on how to arrange
    the data in the repository.</para>
      -->
  <para>本章将介绍如何创建与配置 Subversion 仓库, 还将通过几个例子, 介绍
    应该在什么时候, 怎么用 Subversion 提供的工具维护仓库. 在这过程中, 我
    们将解决一些常见的问题和误区, 并对如何管理仓库的数据提出一些建议.</para>

      <!--
  <para>If you plan to access a Subversion repository only in the role
    of a user whose data is under version control (i.e., via a
    Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,<footnote><para>This may sound really prestigious
    and lofty, but we're just talking about anyone who is interested
    in that mysterious realm beyond the working copy where everyone's
    data hangs out.</para></footnote> this chapter is for you.</para>
      -->
    <para>如果读者只是作为一名普通用户访问仓库中的数据 (通过 Subversion
      客户端), 完全可以跳过本章. 但如果你是 (或者想成为) 一名 Subversion
      仓库管理员<footnote><para>说得可能过于严肃了, 其实我们说的是那些对工作
          副本以外的神秘领域感兴趣的读者.</para></footnote>, 那么本章就是为
      你而写的.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
      <!--
    <title>The Subversion Repository, Defined</title>
      -->
    <title>仓库的定义</title>

      <!--
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective&mdash;how a repository looks and
      acts with respect to non-Subversion tools&mdash;and from a
      logical perspective&mdash;dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>
      -->
    <para>在进入与仓库管理有关的主题之前, 先给出仓库的定义. 它是什么样的?
      感觉怎么样? 它喜欢喝热茶还是冰茶, 加不加糖或柠檬? 作为一名管理员, 人们
      期望你能同时从字面和系统层面理解仓库的组成&mdash;仓库看起来是什么
      样的, 被 Subversion 以外的工具操作时如何反应; 还要从逻辑层面理解在
      仓库 <emphasis>内部</emphasis> 数据是如何表示的.</para>

      <!--
    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>
      -->
    <para>如果站在文件浏览器 (例如 Windows 资源管理器) 或基于命令行的文件
      系统导航工具来看, Subversion 仓库只是一个包含了众多数据的普通目录,
      其中一些子目录包含了人类可读的配置文件, 还有些子目录包含的是人类不可
      读的文件. 在设计 Subversion 时, 开发人员非常注意模块化与层次化, 因此
      简单地浏览一个典型仓库, 对于展示仓库的基本组件来说已经足够了.</para>

    <informalexample>
      <screen>
$ ls repos
conf/  db/  format  hooks/  locks/  README.txt
</screen>
    </informalexample>

      <!--
    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology&mdash;detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>
      -->
    <para>下面是关于目录中的文件及其子目录的简单介绍. (不要拘泥于术语的具体
      意思&mdash;更详细的内容将在本章的其他地方进行介绍)</para>

    <variablelist>
      <varlistentry>
        <term>conf/</term>
        <listitem>
      <!--
          <para>This directory is a container for configuration
            files.</para>
      -->
          <para>存放配置文件的目录.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db/</term>
        <listitem>
      <!--
          <para>This directory contains the data store for all of your
            versioned data.<footnote><para>Strictly speaking,
            Subversion doesn't dictate that the versioned data live
            here, and there are known (albeit proprietary) alternative
            backend storage implementations which do not, in fact,
            store data in this directory.</para></footnote></para>
      -->
      <para>该目录包含了与所有版本化数据相关的数据. <footnote><para>严格地讲,
            Subversion 并没有强制要求版本化数据一定要存放在该目录内, 还存在
            一些其他的后端存储实现 (尽管是有专利的) 不把数据存放在该目录内.
      </para></footnote></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
      <!--
          <para>This file describes the repository's internal
            organizational scheme.  (As it turns out,
            the <filename>db/</filename> subdirectory sometimes also
            contains a <filename>format</filename> file which
            describes only the contents of that subdirectory and which
            is not to be confused with this file.)</para>
      -->
          <para>该文件描述了仓库的内部组织结构. (目录 <filename>db/</filename>
            有时候也会有一个叫做 <filename>format</filename> 的文件, 这个
            <filename>format</filename> 仅仅是在描述 <filename>db/</filename>
            的内容, 这两个 <filename>format</filename> 之间并没有关系.)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks/</term>
        <listitem>
      <!--
          <para>This directory contains hook script templates and
            hook scripts, if any have been installed.</para>
      -->
          <para>该目录包含了钩子脚本模板和已安装的钩子脚本.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks/</term>
        <listitem>
      <!--
          <para>Subversion uses this directory to house repository
            lock files, used for managing concurrent access to the
            repository.</para>
      -->
          <para>Subversion 用该目录存放仓库的锁文件, 锁文件用于管理仓库的并发
            访问.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
      <!--
          <para>This is a brief text file containing merely a notice
            to readers that the directory they are looking in is a
            Subversion repository.</para>
      -->
          <para>包含了一小段内容的文本文件, 文件的内容仅仅是为了提醒计算机
            用户该文件所在的目录是一个 Subversion 仓库.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>
        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activities</secondary>
        </indexterm>
        在 Subversion 1.5 之前, 仓库还有一个子目录 <filename>dav</filename>,
        <filename>mod_dav_svn</filename> 使用该目录存放与 WebDAV
        <firstterm>活动</firstterm> (<firstterm>activities</firstterm>)&mdash;
        高层的 WebDAV 协议概念到 Subversion 提交事务的映射&mdash;有关的信息.
        Subversion 1.5 修改了这一行为, 它把活动目录的所有权和配置目录位置的
        能力移交给了 <filename>mod_dav_svn</filename>. 如今, 新的仓库不需要
        再保留子目录 <filename>dav</filename>, 除非
        <filename>mod_dav_svn</filename> 正在被使用, 并且还没有把活动数据库
        存放位置设置到其他地方. 更多信息见
        <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" /></para>
      <!--
        Prior to Subversion 1.5, the on-disk repository
        structure also always contained a <filename>dav</filename>
        subdirectory. <filename>mod_dav_svn</filename> used this
        directory to store information about
        WebDAV <firstterm>activities</firstterm>&mdash;mappings of
        high-level WebDAV protocol concepts to Subversion commit
        transactions.  Subversion 1.5 changed that behavior, moving
        ownership of the activities directory, and the ability to
        configure its location, into <filename>mod_dav_svn</filename>
        itself.  Now, new repositories will not necessarily have
        a <filename>dav</filename> subdirectory
        unless <filename>mod_dav_svn</filename> is in use and hasn't
        been configured to store its activities database elsewhere.
        See <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" />
        for more information.</para>
      -->
    </note>

      <!--
    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem&mdash;it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>
      -->
    <para>当然, 当我们通过 Subversion 库函数访问仓库时, 这些文件与目录就成为
      了一种虚拟的, 版本化的文件系统的实现, 并且搭配了可定制的事件触发器.
      这个文件系统对文件和目录的概念都
      有自己的理解, 和真正的文件系统 (例如 NTFS, FAT32, ext3 等) 非常类似,
      但它又比较特殊&mdash;它把文件和目录悬挂在版本号上, 安全地记录用户曾经
      对它们做出的修改, 并保证这些修改是永远可访问的. 这就是存放用户所有
      版本化数据的地方.</para>

    <sidebar id="svn.reposadmin.basics.backends">
      <!--
      <title>Speaking of Filesystems&hellip;</title>
      -->
      <title>文件系统</title>

      <!--
      <para>When the initial design phase of Subversion was in
        progress, the developers decided to use Berkeley DB (BDB) as
        the storage mechanism behind the virtual versioned filesystem
        implementation.  Berkeley DB was a logical choice for a
        variety of reasons, including its open source license,
        transaction support, reliability, performance, API simplicity,
        thread safety, support for cursors, and so on.</para>
      -->
      <para>在设计 Subversion 的开始阶段, 开发人员使用 Berkeley DB (BDB) 实现
        虚拟版本化文件系统的后端存储机制. 选择 Berkeley DB 基于多种理由, 包
        括它的开源授权, 事务支持, 可靠性, 高性能, 简单的 API, 线程安全, 支持
        游标等.</para>

      <!--
      <para>In the years since, the
        newer <firstterm>FSFS</firstterm><footnote><para>While it is
            ### TODO
        often pronounced <quote>fuzz-fuzz,</quote> per Jack
        Repenning's rendition, this book assumes that the reader is
        thinking <quote>eff-ess-eff-ess.</quote></para></footnote>
        backend was introduced.  This so-called <quote>filesystem
        filesystem</quote> was a versioned filesystem implemented not
        within an opaque database container, but instead as a larger
        collection of more transparent files stored in the OS's
        filesystem.  FSFS enjoyed continual development and
        improvement, and eventually earned the right to be the default
        Subversion backend.  But improvements to that backend kept
        coming, and ultimately the FSFS storage layer surpassed the
        Berkeley DB one in nearly every meaningful metric, from
        performance to scalability to reliability and beyond.</para>
      -->
      <para>后来, 引入了新的后端存储机制&mdash;<firstterm>FSFS</firstterm>.
        <footnote><para>虽然经常被读作 <quote>fuzz-fuzz</quote>, 但本书
            假定读者把它念作 <quote>eff-ess-eff-ess</quote>.</para></footnote>
        这个所谓的 <quote>文件系统的文件系统</quote> 并不是一个在不透明的
        数据库容器中实现的版本化文件系统, 而是一个由大量文件组成的集合,
        这些文件更加透明, 存放在操作系统的文件系统中. 随着软件的成熟, FSFS
        最终成为了 Subversion 默认的后端存储机制. FSFS 并没有因此停止前进的
        脚步, 后来, 几乎在每一项指标上&mdash;从性能, 到可扩展性, 再到可靠性
        &mdash;FSFS 都超越了 Berkeley DB.</para> 

      <!--
      <para>These days, it is generally assumed that if you are using
        the open source Subversion product, you are using the FSFS
        backend for your repositories.  In fact, beginning with
        Subversion 1.8, the Berkeley DB Subversion repository
        filesystem backend has been officially deprecated.  Subversion
        repositories which still use this storage layer option will
        continue to function with newer Subversion 1.x releases, but
        no further development&mdash;including feature introduction or
        expansion&mdash;is planned for the Berkeley DB backend.
        Subversion effectively offers a single viable repository
        storage layer option.  FSFS won.</para>
      -->
      <para>如今, 如果用户使用的是开源的 Subversion 产品, 那么一般情况下使用
        FSFS 作为仓库的后端存储. 实际上从 Subversion 1.8 开始, 官方不再推荐
        使用 Berkeley DB 作为仓库的后端存储, 仍然使用 Berkeley DB 的仓库在新
        版的 Subversion 1.x 下可以继续工作, 但与 Berkeley DB 相关的开发工作
        不再继续&mdash;包括新特性或扩展. Subversion 只想提供一种单一的仓库
        后端存储机制, 而 FSFS 赢得了青睐.</para>

      <!--
      <para>This book will continue to provide information relevant to
        administrators of BDB-backed repositories where it makes sense
        to do so, but most of this chapter will assume what the rest
        of the world does: that FSFS is <emphasis>the</emphasis>
        Subversion storage backend implementation.  Please refer to
        <xref linkend="svn.berkeleydb"/> or to older versions of this
        documentation for more complete information about
        administering such repositories.</para>
      -->
      <para>必要时, 本书仍然会介绍如何管理基于 BDB 的仓库, 但本章的大部分内容
        假设仓库后端存储用的是 FSFS. 关于如何管理基于 BDB 仓库的更完整的信息,
        请参考 <xref linkend="svn.berkeleydb"/> 或本书的旧版.</para>
    </sidebar>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
      <!--
    <title>Strategies for Repository Deployment</title>
      -->
    <title>仓库部署策略</title>

      <!--
    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>
      -->
    <para>得益于 Subversion 仓库在整体设计和技术上的简洁, 创建与配置一个仓库
      是一个相对来说比较简单的任务. 需要做一些初步决定, 但是设置仓库所涉及
      到的实际工作非常基础, 多做几次就能得心应手.</para>

      <!--
    <para>Some things you'll want to consider beforehand, though, are:</para>
      -->
    <para>在开始创建仓库之前需要考虑的事情有:</para>

    <itemizedlist>
      <listitem>
      <!--
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
      -->
        <para>仓库会存放哪些数据, 如何组织这些数据?</para>
      </listitem>
      <listitem>
      <!--
        <para>Where will your repository live, and how will it be
          accessed?</para>
      -->
        <para>仓库会放在哪儿, 如何访问仓库?</para>
      </listitem>
      <listitem>
      <!--
        <para>What types of access control do you need?</para>
      -->
        <para>你需要哪些类型的访问控制?</para>
      </listitem>
    </itemizedlist>

      <!--
    <para>In this section, we'll try to help you answer those
      questions.</para>
      -->
    <para>本节将帮助读者回答上面的几个问题.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <!--
      <title>Planning Your Repository Organization</title>
      -->
      <title>规划仓库的组织方式</title>

      <!--
      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>
      -->
      <para>虽然 Subversion 允许用户随意地移动目录和文件, 而不丢失任何信息,
        甚至还可以把版本历史的整个集合从一个仓库移动到另一个仓库, 但这样做
        难免会影响到那些需要经常访问仓库的人, 他们希望仓库及其文件的位置能
        够保持稳定. 所以说在创建新的仓库之前, 试着为将来考虑, 提前做好规划.
        提前认真地规划好仓库及其所管理的数据, 可以避免将来出现很多不必要的
        麻烦.</para>

      <!--
      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>
      -->
      <para>假设仓库管理员需要为几个项目提供版本控制支持, 首先需要决定的
        是用一个单独的仓库存放这些项目, 还是每个项目一个仓库, 还是介于两者
        之间.</para>

      <!--
      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>
      -->
      <para>把多个项目放在一个单独的仓库里有一定的好处, 最明显的就是减少了
        重复劳动. 一个单独的仓库意味着只有一个钩子集合, 需要例行备份的东西
        只有一个, 如果 Subversion 发布了不兼容旧版的新版本, 只有一个仓库需
        要转储和加载等. 另外, 用户还可以方便地在项目之间移动数据, 而不会丢失
        任何历史信息.</para>

      <!--
      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course&mdash;it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.<footnote><para>Whether founded in
            ### TODO
        ignorance or in poorly considered concepts about how to derive
        legitimate software development metrics, global revision
        numbers are a silly thing to fear,
        and <emphasis>not</emphasis> the kind of thing you should
        weigh when deciding how to arrange your projects and
        repositories.</para></footnote></para>
      -->
  <para>缺点是不同的项目对仓库的事件触发的需求可能不同, 例如把提交通知发到不同
    的邮件列表, 对于如何构成一次合法的提交, 其要求也会有所不同. 当然, 这些问
    题并非无法克服&mdash;只是说所有的钩子脚本都依赖仓库的布局, 而不是假定整个
    仓库只和单独的一组人有关系. 另外还要注意 Subversion 版本号的作用域是整个
    仓库, 虽然这些数字并没有任何特殊的魔力, 但还是有人不喜欢看到这样一种情况:
    虽然他们的项目最近都没有提交什么修改, 但是由于其他项目的活动, 他们自己的
    项目的版本号仍然在不断增长.</para>

      <!--
      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>
      -->
      <para>还有一种折衷一点的方式可以采用. 比如说根据项目之间的相关性进行
        分组, 把相关性强的项目放在一个单独的仓库里. 这样的话项目之间共享数
        据就会更加方便, 如果有新的版本号产生, 开发人员至少会知道这些新的版
        本号和仓库中的项目都有或多或少的联系.</para>

      <para>
        <indexterm>
          <primary>project root</primary>
        </indexterm>

        项目的组织方式确定后, 接下来就要考虑仓库内部的目录结构. 因为 Subversion
        在创建分支和标签时使用的是常规的目录拷贝操作 (见 <xref
          linkend="svn.branchmerge"/>), Subversion 社区建议管理员为每一个项目
        的根目录&mdash;包含了所有与项目相关的数据的 <quote>顶层</quote> 目录
        &mdash;选择一个仓库位置, 然后在项目根目录下创建 3 个子目录:
        <filename>trunk</filename> 是开发主线; <filename>branches</filename>
        存放所有的分支; <filename>tags</filename> 存放所有的标签.<footnote>
          <para><filename>trunk</filename>, <filename>tags</filename>
            和 <filename>branches</filename> 这 3 者有时被称为 <quote>TTB
              目录</quote></para></footnote></para>
      <!--
        After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each project
        root&mdash;the <quote>topmost</quote> directory
        that contains data related to that project&mdash;and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.<footnote><para>The <filename>trunk</filename>,
        <filename>tags</filename>, and <filename>branches</filename>
        trio is sometimes referred to as <quote>the TTB
        directories.</quote></para></footnote></para>
      -->

      <!--
      <para>For example, your repository might look like this:</para>
      -->
      <para>比如说, 仓库的目录结构可能是下面这样:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</literallayout>
      </informalexample>

      <!--
      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>
      -->
      <para>注意, 项目根目录在仓库中的位置并不重要. 如果每个仓库只包含一个项
        目, 那么最常见的安排就是把仓库的根目录作为项目的根目录. 如果一个仓库
        内包含了多个项目, 管理员可能会对它们进行分组, 例如把目标类似或共享代
        码的项目放在同一个子目录内, 或者只是根据字母顺序进行分组. 一个例子是:
      </para>

      <informalexample>
        <literallayout>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</literallayout>
      </informalexample>

      <!--
      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>
      -->
      <para>管理员完全可以按照自己的喜好决定仓库的布局, Subversion 对仓库的布局
        并没有特殊的要求&mdash;在它看来, 一个目录只是个目录而已. 总而言之,
        仓库的布局应该满足项目及其开发人员的需求.</para>

      <!--
      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>
      -->
      <para>为了使讨论更加完整, 再介绍一种非常常见的仓库布局. 在这种布局里,
        <filename>trunk</filename>, <filename>tags</filename> 和
        <filename>branches</filename> 位于仓库的根目录, 而各个项目是它们各
        自的子目录, 例如:</para>

      <informalexample>
        <literallayout>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</literallayout>
      </informalexample>

      <!--
      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons&mdash;it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history&mdash;past, present, tagged, and branched&mdash;for
        that project and that project alone.</para>
      -->
      <para>这种布局并没有什么错误的地方, 但是对用户来说可能不够直观. 如果项
        目很多, 并且每个项目都比较复杂, 开发人员也很多, 那么开发人员可能更希
        望每个仓库只包含一两个项目. 但上面的做法倾向于弱化项目的独特性, 更
        希望把整个项目集合看作一个单一的实体. 尽管这只是一个社会议题, 但我们
        更希望读者使用一开始就推荐的仓库布局, 因为如果在一个单一的仓库路径上
        单独记录了一个项目的整个历史, 那么查询 (修改或迁移) 单个项目的整个历
        史&mdash;过去的, 现在的, 打过标签的和创建过分支的&mdash;就更加方便.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <!--
      <title>Deciding Where and How to Host Your Repository</title>
      -->
      <title>确定仓库的托管方式和位置</title>

      <!--
      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>
      -->
      <para>在创建你的 Subversion 仓库之前, 需要回答的一个问题是仓库应该放在
        哪里. 这个问题关系到很多其他的选择, 例如仓库的访问方式 (是通过
        Subversion 服务器进行访问, 还是直接访问), 哪些用户可以访问 (是只允许
        公司的内部员工, 还是开放给整个互联网), 围绕着 Subversion 还提供了哪
        些服务 (仓库浏览接口, 基于邮件的提交通知等), 数据的备份策略等.</para>

      <!--
      <para>We cover server choice and configuration in
        <xref linkend="svn.serverconfig" />, but the point we'd like
        to briefly make here is simply that the answers to some of
        these other questions might have implications that force your
        hand when deciding where your repository will live.  For
        example, certain deployment scenarios might require accessing
        the repository via a remote filesystem from multiple
        computers, or using multiple repositories with syncronized
        contents distributed geographically to permit more performant
        access to that data by users around the globe.  Addressing
        each possible way to deploy Subversion is both impossible and
        outside the scope of this book.  We simply encourage you to
        evaluate your options using these pages and other sources as
        your reference material and to plan ahead.</para>
      -->
      <para>本书在 <xref linkend="svn.serverconfig" /> 介绍服务器的配置, 但我
        们在这里要说明的是有些问题的答案可能会影响仓库的位置. 比如说特定的部
        署场景可能会要求从多台计算机, 通过远程文件系统访问仓库, 或者是使用多
        个仓库, 而这些仓库的数据是在地理上分布的同步数据, 从而为分散在世界各
        地的用户提供更有效的访问. 介绍 Subversion 的每一种部署方式不仅不可能,
        也超出了本书的范围, 我们只希望读者能根据本章的内容以及读者能找到的其他
        参考资料, 评估自己的部署方式.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.accesscontrol">
      <!--
      <title>Controlling Access to Your Repository</title>
      -->
      <title>仓库的访问控制</title>

      <!--
      <para>Access control in Subversion is almost entirely managed by
        the Subversion server processes.  We discuss the available
        Subversion servers in <xref linkend="svn.serverconfig" />, and
        explain path-based access control specifically in
        <xref linkend="svn.serverconfig.pathbasedauthz" />.  In
        addition to those user-level access control questions, you'll also
        want to ensure that your repository is accessible by the
        programs on your hosting machine which need to access it.
        Consider the OS-level user and group ownership that makes
        sense for your repository.  Once again, the information found
        in <xref linkend="svn.serverconfig" /> should be able to help
        you make these decisions.</para>
      -->
      <para>Subversion 的访问控制几乎全由 Subversion 服务器进程进行管理, 可
        供选择的 Subversion 服务器在 <xref linkend="svn.serverconfig" /> 介绍,
        在 <xref linkend="svn.serverconfig.pathbasedauthz" /> 详细介绍基于路径
        的访问控制. 除了用户级的访问控制外, 用户可能还希望仓库能被主机上的程序
        访问. 操作系统层面的用户与用户组权限对仓库也有影响. <xref
          linkend="svn.serverconfig" /> 的内容将帮助读者解决与访问权限有关的
        问题.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
      <!--
    <title>Creating and Configuring Your Repository</title>
      -->
    <title>创建与配置仓库</title>

      <!--
    <para>Earlier in this chapter (in
      <xref linkend="svn.reposadmin.planning" />), we looked at some
      of the important decisions that should be made before creating
      and configuring your Subversion repository.  Now, we finally get
      to get our hands dirty!  In this section, we'll see how to
      actually create a Subversion repository and configure it to
      perform custom actions when special repository events
      occur.</para>
      -->
    <para>在本章的开头部分 (<xref linkend="svn.reposadmin.planning" />), 我们
      看到了几个在创建与配置仓库之前需要确定的几个问题. 现在, 我们终于要真枪
      实弹地开始干了! 本节读者将看到如何创建一个 Subversion 仓库, 并对它进行
      配置, 使得当特定的事件发生时, 仓库将执行预定的操作.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <!--
      <title>Creating the Repository</title>
      -->
      <title>创建仓库</title>

      <!--
      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>
      -->
    <para>创建 Subversion 仓库是一件非常简单的工作, 用到的命令是
      <command>svnadmin create</command>.</para>

      <informalexample>
        <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
      </informalexample>

      <!--
      <para>Assuming that the parent directory 
        <filename>/var/svn</filename> exists and that you have
        sufficient permissions to modify that directory, the previous
        command creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store (FSFS).  You can explicitly choose the
        filesystem type using the <option>- -fs-type</option> argument,
        which accepts as a parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>
      -->
      <para>假设父目录 <filename>/var/svn</filename> 已存在, 并且管理员对父
        目录拥有写权限, 上面的命令在 <filename>/var/svn/repos</filename>
        创建了一个新的仓库, 使用的是默认的后端存储类型 (FSFS). 你还可以利用
        选项 <option>--fs-type</option> 显式地指定后端存储类型, 该选项接受
        的参数是 <literal>fsfs</literal> 或 <literal>bdb</literal>.</para>

      <informalexample>
        <screen>
$ # Create an FSFS-backed repository
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</screen>
      </informalexample>

      <informalexample>
        <screen>
# Create a legacy Berkeley-DB-backed repository
$ svnadmin create --fs-type bdb /var/svn/repos
$
</screen>
      </informalexample>

      <!--
      <para>After running this simple command, you have a Subversion
        repository.  Depending on how users will access this new
        repository, you might need to fiddle with its filesystem
        permissions.  But since basic system administration is rather
        outside the scope of this text, we'll leave further
        exploration of that topic as an exercise to the reader.</para>
      -->
      <para>执行完这个简单的命令, 你就拥有了一个新的 Subversion 仓库. 取决于
        用户的访问方式, 管理员可能还需要调整仓库目录的文件系统权限. 与系统
        管理有关的基础知识不在本书的讨论范围之内, 所以这方面的内容就当作训练
        留给读者.</para>

      <tip>
      <!--
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities&mdash;they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
      -->
        <para>传递给 <command>svnadmin</command> 的路径参数只是一个普通的文件
          系统路径, 而不是一个 URL (就像 <command>svn</command> 访问仓库时用
          到的 URL 参数). <command>svnadmin</command> 和
          <command>svnlook</command> 都是服务器端的工具&mdash;它们只在存放着
          仓库的主机上使用, 用于查看或修改仓库的某些部分, 实际上它们也无法
          跨网络执行任务. Subversion 新手的一个常见错误是试图为这两个工具传
          递 URL (即使是 <literal>file://</literal> 也不行).</para>
      </tip>

      <!--
      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem.  Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>
      -->
      <para>存放在仓库子目录 <filename>db/</filename> 内的就是版本化文件系统的
        实现. 新仓库的版本化文件系统的生命开始于版本号 0, 根据定义版本号 0 不
        包含任何数据, 只有最顶层的根目录. 初始时, 版本号 0 也有一个版本号属性,
        <literal>svn:date</literal>, 属性的值是创建仓库的日期.</para>

      <!--
      <para>Now that you have a repository, it's time to customize
        it.</para>
      -->
      <para>仓库既然创建好了, 接下来就可以对它进行改造.</para>

      <warning>
      <!--
        <para>While some parts of a Subversion repository&mdash;such
          as the configuration files and hook scripts&mdash;are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools for tweaking relevant subsections of the
          repository.  Do <emphasis>not</emphasis> attempt manual
          manipulation of your version control history by poking and
          prodding around in your repository's data store
          files!</para>
      -->
        <para>虽然仓库的一部分&mdash;例如配置文件和钩子脚本&mdash;需要手工
          查看和修改, 但管理员不应该 (也不需要) 手工修改仓库的其他部分.
          <command>svnadmin</command> 工具应该足以应付仓库的任意修改, 或者管理
          员也可以用第三方工具对仓库进行调整. <emphasis>不要</emphasis> 为了篡改
          版本控制历史而手工修改仓库里的数据文件!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.hooks">
      <!--
      <title>Implementing Repository Hooks</title>
      -->
      <title>实现仓库钩子</title>

      <para>
        <indexterm>
          <primary>hook scripts</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>hook scripts</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>hooks</secondary>
          <see>hook scripts</see>
        </indexterm>
         <firstterm>钩子</firstterm> (<firstterm>hook</firstterm>) 是
         一个由某些仓库事件触发的程序, 仓库事件包括但不限于新版本号的产生或
         是某些非版本化属性被修改了. 有些钩子 (称为 <quote>前置钩子</quote>)
         在仓库的操作执行之前运行, 从而实现提前报告即将发生的事情, 或阻止即将
         发生的事情. 还有些钩子 (称为 <quote>后置钩子</quote>) 在仓库事件完成
         之后运行, 可以用来执行一些检查&mdash;但不修改&mdash;仓库的任务. 每一
         个钩子都能得到足够的信息, 包括发生了什么事件, 被修改的仓库, 以及触发
         事件的用户.</para>
      <!--
        A <firstterm>hook</firstterm> is a program
        triggered by some repository event, such as the creation of a
        new revision or the modification of an unversioned property.
        Some hooks (the so-called <quote>pre hooks</quote>) run in
        advance of a repository operation and provide a means by which
        to both report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine&mdash;but don't
        modify&mdash;the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
      -->
            
      <!--
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>
      -->
      <para>默认情况下, 子目录 <filename>hooks</filename> 包含了各种
        钩子的模板:</para>

      <informalexample>
        <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
      </informalexample>
            
      <!--
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
      -->
      <para>Subversion 仓库支持的每个钩子都有一个模板, 通过查看这些模板脚本的
        内容, 用户可以看到每个脚本所执行的操作, 以及传递给脚本的参数. 模
        板展示了用户可能会用钩子完成哪些操作, 借助 Subversion 工具的配合,
        钩子可以完成一些常见的操作. 为了安装一个能实际工作的钩子, 用户只
        需要把可执行程序或脚本放到仓库目录的 <filename>hooks</filename>
        子目录里, 按照钩子的要求对文件进行命名后, Subversion 就可以根据文件名
        (例如 <filename>start-commit</filename> 或
        <filename>post-commit</filename>) 决定在什么时候执行它.</para>

      <!--
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>
      -->
      <para>如果存放仓库的主机是 Unix 操作系统, 这就意味着用户必须提供一个脚
        本或程序 (可以是 shell 脚本, Python 程序, 已编译的二进制程序, 或其他
        形式的可执行文件), 文件的名字必须严格按照钩子的规定进行命名. 当然,
        子目录 <filename>hooks</filename> 里的模板不仅仅是为了向用户展示钩子的
        典型内容&mdash;在 Unix 系统中, 安装钩子最简单的方法是复制一个适当的
        模板文件, 复制出的新文件要删掉扩展名 <filename>.tmpl</filename>, 然后
        对脚本的内容进行必要的修改, 并确保脚本具有可执行权限. 然而, Windows
        操作系统是根据文件的扩展名判断文件是否是可执行的, 因此管理员所提供的
        钩子, 其文件名 (不包括扩展名部分) 是钩子的名字, 而扩展名是 Windows
        规定的可作为可执行程序的几种扩展名之一, 例如二进制可执行文件用
        <filename>.exe</filename>, 批处理文件用 <filename>.bat</filename>.
      </para>

      <!--
      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>
      -->
      <para>Subversion 执行钩子时的用户身份, 和访问仓库的进程的所有者的身份
        是相同的, 在大多数情况下, 仓库经由一个 Subversion 服务器进程进行访问,
        因此执行钩子的用户身份和 Subversion 服务器进程的所有者是一致的. 为
        了能让这个用户执行钩子, 操作系统必须允许该用户执行钩子脚本, 这还意味
        着将被钩子直接或间接访问到的程序或文件 (包括 Subversion 仓库里的文件),
        都是以该用户的身份进行访问. 总之, 要注意与权限有关的问题可能会导致
        钩子无法正常工作.</para>

      <!--
      <para>There are several hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>
      -->
      <para>Subversion 目前支持多种钩子, 详细的信息见 <xref
          linkend="svn.ref.reposhooks" />. 作为一个仓库管理员, 你需要决定仓库
        应该实现哪些钩子 (通过提供具有适当名字与权限的钩子文件), 以及如何实现.
        在做这个决定时, 始终在心里面记着仓库的部署方式, 比如说如果你是通过服务
        器配置来决定哪些用户可以向仓库提交修改, 那就没必要再在钩子里实现相同的
        访问权限控制.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.configuration">
      <!--
        <title>Hook script environment configuration</title>
      -->
        <title>钩子脚本环境配置</title>

      <!--
        <para>By default, Subversion executes hook scripts with an
          empty environment&mdash;that is, no environment variables
          are set at all, not even <literal>$PATH</literal>
          (or <literal>%PATH%</literal>, under Windows).  Because of
          this, many administrators are baffled when their hook
          program runs fine by hand, but doesn't work when invoked by
          Subversion.  Administrators have historically worked around
          this problem by manually setting all the environment
          variables their hook scripts need in the scripts
          themselves.</para>
      -->
        <para>默认情况下, Subversion 在空环境中执行钩子脚本, 空环境指的是没有
          设置任何环境变量的运行环境, 甚至连 <literal>$PATH</literal> (在
          Windows 系统中则是 <literal>%PATH%</literal>) 都没有设置. 正是因为
          这个原因, 很多管理员都曾遇到过这种问题: 自己手工执行钩子程序是没问题
          的, 但由 Subversion 执行时却无法正常工作. 传统的解决办法是在钩子脚本
          中手工设置钩子所需的所有环境变量.</para>

      <!--
        <para>Subversion 1.8 introduces a new way to manage the
          environment of Subversion-executed hook scripts&mdash;the
          hook script environment configuration file.  If a Subversion
          server finds a file named <filename>hooks-env</filename> in
          the repository's <filename>conf/</filename> subdirectory, it
          parses that file as an INI-formatted configuration file and
          applies the option names and variables found therein to the
          hook script's execution environment as environment
          variables.</para>
      -->
        <para>Subversion 1.8 为钩子脚本的运行环境管理引入了一种新方法&mdash;
          钩子脚本环境配置文件. 如果 Subversion 服务器进程在仓库的子目录
          <filename>conf/</filename> 内找到了一个名为
          <filename>hooks-env</filename> 的文件, 它就把该文件当成 INI 格式的
          配置文件进行解析, 将解析到的选项名和值作为环境变量, 添加到钩子脚本
          的运行环境中.</para>

      <!--
        <para>The syntax of the <filename>hooks-env</filename> file is
          pretty straightforward: each section name is the name of a
          hook script (such as <literal>pre-commit</literal>
          or <literal>post-revprop-change</literal>), and the
          configuration items inside that section are treated as
          mappings of environment variable names to desired values.
          Additionally, there is a
          special <literal>[default]</literal> section, which can be
          used to configure environment variable mappings that should
          be applied to <emphasis>all</emphasis> hook scripts (unless
          explicitly overridden by per-hook-script settings).  See
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          for a sample <filename>hooks-env</filename> configuration
          file.</para>
      -->
        <para><filename>hooks-env</filename> 的语法非常简单直观: 每一节的名字
          就是钩子脚本的名字 (例如 <literal>[pre-commit]</literal> 和
          <literal>[post-revprop-change]</literal>), 节内的配置项被看成是环境
          变量的名字到值的映射. 另外还有一个特殊的 <literal>[default]</literal>
          节, 它所配置的环境变量对所有的钩子脚本都起作用 (除非又被各节自己的
          设置显式地覆盖了). <filename>hooks-env</filename> 配置文件的例子
          如 <xref linkend="svn.reposadmin.hooks.configuration.ex-1" /> 所示.
        </para>

        <example id="svn.reposadmin.hooks.configuration.ex-1">
      <!--
          <title>hooks-env (custom hook script environment
            configuration)</title>
      -->
          <title>hooks-env (配置钩子脚本环境)</title>

          <programlisting>
# All scripts should use a UTF-8 locale and have our hook script
# utilities directory on the search path.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# The post-commit and post-revprop-change scripts want to run
# programs from our custom synctools replication software suite, too.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>

        <note>
      <!--
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> also demonstrates the nifty string substitution syntax
            found in Subversion's configuration file parser.  In this
            example, the value of the <literal>PATH</literal>
            option&mdash;pulled from the <literal>[default]</literal>
            section of the file&mdash;is substituted in place of
            the <literal>%(PATH)s</literal> placeholder text in the
            per-hook sections.  For more about this special syntax,
            see the <filename>README.txt</filename> file which lives
            in the Subversion runtime configuration directory.  (And
            for more information about that directory, see
            <xref linkend="svn.advanced.confarea" />.)</para>
      -->
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
            还展示了 Subversion 配置文件解析器灵活的字符串替换语法. 在这个
            例子里, 选项 <literal>PATH</literal> 的值&mdash;拉取自文件的
            <literal>[default]</literal> 部分&mdash;会替换掉其他地方的占位
            符文本 <literal>%(PATH)s</literal>. 关于这种语法的更多信息,
            见 Subversion 运行时配置目录内的 <filename>README.txt</filename>
            文件. (关于运行时配置目录的更多信息, 见
            <xref linkend="svn.advanced.confarea" />.)</para>
        </note>

      <!--
        <para>Of course, having exact duplicates of your custom hook
          script environment configuration files in every single
          repository's <filename>conf/</filename> directory could get
          cumbersome, especially when you need to make changes to them
          all.  So Subversion's servers allow you to specify an
          alternate (possibly shared) location for this configuration
          information.</para>
      -->
        <para>当然, 在每一个仓库的 <filename>conf/</filename> 目录内都放置
          一份完全一样的钩子环境配置文件, 做起来可能会有点笨拙, 特别是当它
          们都需要修改时. 为此, Subversion 允许管理员为配置信息指定一个可
          选的位置 (可能是共享的).</para>

        <!-- ### TODO:  Add cross reference for the above! -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.uses">
      <!--
        <title>Common uses for hook scripts</title>
      -->
        <title>钩子脚本的常见用法</title>

      <!--
        <para>Repository hook scripts can offer a wide range of
          utility, but most tend to fall into a few basic categories:
          notification, validation, and replication.</para>
      -->
        <para>仓库的钩子脚本可以提供非常多的用处, 但大多数都可以简单地归类成
          以下几种: 通知, 验证和重复.</para>

      <!--
        <para>Notification scripts are those which tell someone that
          something happened.  The most common of these found in a
          Subversion service offering involve programs which send
          commit and revision property change notification emails to
          project members, driven by the post-commit and
          post-revprop-change hooks, respectively.  There are numerous
          other notification approaches, from issue tracker integration
          scripts to scripts which operate as IRC bots to announce
          that something's changed in the repository.</para>
      -->
        <para>通知脚本用于通知用户发生了某些事情. 最常见的用法是把每次提交的
          修改以邮件的形式发送给项目的每一位成员, 用到的钩子是
          post-commit 和 (或) post-revprop-change. 除此之外还有很多其他形式的
          通知, 例如整合了问题跟踪的脚本, 或者是充当 IRC 机器人的脚本, 当仓库
          发生变化时向大家通报.</para>

      <!--
        <para>On the validation side of things, the start-commit and
          pre-commit hooks are widely used to allow or disallow
          commits based on various criteria: the author of the commit,
          the formatting and/or content of the log message which describes the
          commit, and even the low-level details of the changes made
          to files and directories in the commit.  Likewise, the
          pre-revprop-change hook acts as the gateway to revision
          property changes, which is an especially valuable role
          considering the fact that revision properties are not
          themselves versioned, and can therefore only be modified
          destructively.</para>
      -->
        <para>站在验证的角度, 人们经常使用钩子 start-commit 和 pre-commit,
          根据不同的标准去禁止或允许提交, 常用的判断标准有提交的作者, 描述
          提交的日志消息的格式和 (或) 内容, 甚至是所提交的修改的底层细节.
          同样地, 钩子 pre-revprop-change 充当的是版本号属性修改的看门狗,
          考虑到版本号属性不属于版本控制的范畴, pre-revprop-change 在保护
          版本号属性免受破坏性修改这一点上非常重要.</para>
        
      <!--
        <para>One special class of change validation that has seen
          widespread use since Subversion 1.5 was released is
          validation of the committing client software itself.  When
          Subversion's merge tracking feature (described extensively
          in <xref linkend="svn.branchmerge" />) was introduced in
          that release, Subversion administrators needed a way to
          ensure that once users of their repositories started using
          the new feature that <emphasis>all</emphasis> their merges
          were tracked.  To reduce the chance of someone committing an
          untracked merge to the repository, they used start-commit
          hooks to examine the feature capabilities string advertised
          by Subversion clients.  If the committing client didn't
          advertise support for merge tracking, the commit was denied
          with instructions to the user to immediately update their
          Subversion client!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> provides
          an example of a start-commit script which does precisely
          this.</para>
      -->
        <para>Subversion 1.5 发布后, 有一类验证用得非常广泛, 那就是验证提交
          修改的客户端软件. Subversion 从 1.5 开始支持合并跟踪 (关于合并跟踪
          的详细介绍, 见 <xref linkend="svn.branchmerge" />), 管理员需要提供
          一种方法, 以便确保一旦仓库的用户开始使用新的合并跟踪特性, 那么他们
          <emphasis>所有的</emphasis> 合并都要被跟踪. 为了避免用户向仓库提交
          未被跟踪的合并, 管理员使用钩子 start-commit 检查客户端公示的特性字
          符串, 如果客户端没有宣称支持合并跟踪, 那么提交就会被拒绝, 从而迫使
          用户升级他们的客户端软件!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> 展示了如何用钩子
          start-commit 实现这个功能.</para>

        <example id="svn.reposadmin.hooks.uses.ex-1">
      <!--
          <title>start-commit hook to require merge tracking
            support</title>
      -->
          <title>要求客户端必须支持合并跟踪的钩子 start-commit</title>

          <programlisting>
#!/usr/bin/env python
import sys

# sys.argv[3] is a colon-delimited capabilities list
if 'mergeinfo' not in sys.argv[3].split(':'):
  sys.stderr.write("""\
ERROR: Commits to this repository must be made using Subversion
clients which support the merge tracking feature.  Please upgrade
your client to at least Subversion 1.5.0.
""")
  sys.exit(1)
</programlisting>
        </example>
        
        <para>
          <indexterm>
            <primary>properties</primary>
            <secondary>ephemeral transaction properties</secondary>
          </indexterm>
          从 Subversion 1.8 开始, 向 Subversion 1.8 服务器提交修改的客户端,
          除了提供它自己的特性字符串外, 还会通过
          <firstterm>短暂事务属性</firstterm>
          (<firstterm>ephemeral transaction properties</firstterm>) 提供关于
          它自己的额外信息. 短暂事务属性本质上是版本号属性, 在提交时由客户
          端将短暂事务属性设置到提交事务上, 服务器端在事务成为最终的版本号
          之前, 删除该属性. 查看短暂事务属性的方法和查看设置在提交事务上的其
          他非版本化属性的方法相同, 需要用到的钩子是 start-commit 和 (或)
          pre-commit.</para>
      <!--
          Beginning in Subversion 1.8, clients committing
          against a Subversion 1.8 server will still provide the
          feature capabilities string, but will also provide
          additional information about themselves by way
          of <firstterm>ephemeral transaction properties</firstterm>.
          Ephemeral transaction properties are essentially revision
          properties which are set on the commit transaction by the
          client at the earliest opportunity while committing, but
          which are automatically removed by the server immediately
          prior to the transaction becoming a finalized revision.  You
          can inspect these properties using the same tools with which
          you'd inspect other unversioned properties set on commit
          transactions during the timeframe between which the
          start-commit and pre-commit repository hook scripts would
          operate.</para>
      -->

      <!--
        <para>The following are the ephemeral transaction properties
          which Subversion currently provides and implements:</para>
      -->
        <para>下面是 Subversion 当前提供并已实现的短暂事务属性:</para>

        <variablelist>
  
          <varlistentry>
            <term><literal>svn:txn-client-compat-version</literal></term>
            <listitem>
      <!--
              <para>Carries the Subversion library version string with
                which the committing client claims compatibility.
                This is useful for deciding whether the client
                supports the minimal feature set required for proper
                handling of the repository data.</para>
      -->
              <para>携带了客户端支持的 Subversion 函数库版本字符串, 这对于判
                断客户端是否支持仓库数据处理所要求的最小特性集非常有用.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:txn-user-agent</literal></term>
            <listitem>
      <!--
              <para>Carries the <quote>user agent</quote> string which
                describes the committing client program.  Subversion's
                libraries define the initial portion of this string,
                but third-party consumers of the API (GUI clients,
                etc.) can append custom information to it.</para>
      -->
              <para>携带了 <quote>用户代理</quote> (user agent) 字符串, 它描述
                了发起提交的客户端程序. Subversion 库函数定义了该字符串的起始
                部分的内容, 但是使用了 Subversion API 的第三方程序 (例如 GUI
                客户端) 可以向字符串附加自定义的信息.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>

        <!-- ### TODO: Show an example of these being used?  Or ### -->
        <!-- ###       do so in ch07 - Customizing Subversion   ### -->
        <!-- ###       with a cross-reference here.             ### -->

        <note>
      <!--
          <para>While most clients will transmit ephemeral transaction
            properties early enough in the commit process that they
            may be inspected by the start-commit hook script, some
            configurations of Subversion will cause those properties
            to not be set on the transaction until later in the commit
            process.  Administrators should consider performing any
            validation based on ephemeral transaction properties in
            both the start-commit and pre-commit hooks&mdash;the
            former to rule out invalid clients before those clients
            transmit the commit payload; the latter <quote>just in
            case</quote> the validation checks couldn't be performed
            by the start-commit hook.</para>
      -->
          <para>大多数客户端是在提交过程的早期阶段传送短暂事务属性, 从而可以
            被钩子 start-commit 检查, 但 Subversion 的某些配置会使得这些属性
            直到提交过程的后期才会被设置上. 管理员应该考虑同时在钩子
            start-commit 和 pre-commit 上执行基于短暂事务属性的检查工作.
            利用钩子 start-commit 过滤掉无效的客户端, 如果无法在 start-commit
            完成检查工作, 就在 pre-commit 完成.</para>
        </note>

      <!--
        <para>As noted before, ephemeral transaction properties are
          removed from the transaction just before it is promoted to a
          new revision.  Some administrators may wish to preserve the
          information in those properties indefinitely.  We suggest
          that you do so by using the pre-commit hook script to copy
          the values of those properties to new property names.  In
          fact, the Subversion source code distribution provides a
          <filename>persist-ephemeral-txnprops.py</filename> script
          (in the <filename>tools/hook-scripts/</filename>
          subdirectory) for doing precisely that.</para>
      -->
        <para>前面已经说过, 就在事务变成最终的版本号之前, 短暂事务属性将会被
          删除, 因此有些管理员希望这些属性上的信息能够永久保留. 我们的建议是
          在钩子 pre-commit 里, 把属性上的值复制到新的属性上. 实际上,
          Subversion 发布的源代码所提供的脚本
          <filename>persist-ephemeral-txnprops.py</filename> (在
          <filename>tools/hook-scripts/</filename>) 做的正是这件事.</para>

      <!--
        <para>The third common type of hook script usage is for the
          purpose of replication.  Whether you are driving a simple
          backup process or a more involved remote repository
          mirroring scenario, hook scripts can be critical.  See
          <xref linkend="svn.reposadmin.maint.backup" /> and
          <xref linkend="svn.reposadmin.maint.replication" /> for more
          information about these aspects of repository
          maintenance.</para>
      -->
        <para>钩子的第三种常见用途是重复. 如果管理员只是在做一个简单的备份,
          又或者是远程仓库镜像备份, 钩子脚本都能起到非常重要的作用. 关于仓库
          备份的更多内容, 见
          <xref linkend="svn.reposadmin.maint.backup" /> 和
          <xref linkend="svn.reposadmin.maint.replication" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.summary">
      <!--
        <title>Finding hook scripts or rolling your own</title>
      -->
        <title>搜索或自己编写钩子脚本</title>

      <!--
        <para>As you might imagine, there is no shortage of Subversion
          hook programs and scripts that are freely available either
          from the Subversion community itself or elsewhere.  In fact,
          the Subversion distribution provides several commonly used
          hook scripts in its <filename>tools/hook-scripts/</filename>
          subdirectory.  However, if you are unable to find one that
          meets your specific needs, you might consider writing your
          own.  See <xref linkend="svn.developer" /> for information
          about developing software using Subversion's public
          APIs.</para>
      -->
        <para>读者应该可以想到, 从 Subversion 社区或其他地方都能找到大量可以
          随意使用的钩子程序和脚本. 实际上, Subversion 发布的源代码就提供了
          几个适用性很广泛的钩子脚本, 脚本文件放在
          <filename>tools/hook-scripts/</filename>. 然而, 如果读者无法找到
          满意的钩子脚本, 就可能需要自己编写. 关于如何使用 Subversion
          的公共 API 进行软件开发, 见 <xref linkend="svn.developer" />.</para>

        <warning>
      <!--
          <para>Hook scripts can do almost anything, but hook script
            authors should show restraint.  It might be tempting to,
            say, use hook scripts to automatically correct errors,
            shortcomings, or policy violations present in the files
            being committed.  Unfortunately, doing so can cause
            problems.  Subversion keeps client-side caches of certain
            bits of repository data, and if you change a commit
            transaction in this way, those caches become indetectably
            stale, leading to surprising and unexpected behavior.
            While it is generally okay to add new commit transaction
            properties via a hook script, essentially everything else
            about a commit transaction should be considered read-only.
            Instead of modifying a transaction to polish its payload,
            simply <emphasis>validate</emphasis> the transaction in
            the pre-commit hook and reject the
            commit if it does not meet the desired requirements.  As a
            bonus, your users will learn the value of careful,
            compliance-minded work habits.</para>
      -->
          <para>钩子脚本几乎可以做任何事情, 但作者应该对脚本的功能有所控制.
            虽然说使用钩子脚本去自动纠正被提交的文件中的错误, 缺陷或违反策略
            的做法&mdash;是一件很有诱惑力的事情, 但这样做会导致问题.
            Subversion 在客户端缓存了仓库的部分数据, 如果钩子脚本按照这种方式
            修改了提交事务, 那么客户端缓存的数据就成了过时了的, 且难以察觉,
            过时的缓存会产生不可预料的后果. 虽然通过钩子脚本添加新的提交事务属
            性通常没什么问题, 但除此之外, 一个提交事务的其它信息都应该看成是只
            读的. 管理员不应该为了优化事务的载荷而对事务进行修改, 更好的做法是
            在钩子 pre-commit 里 <emphasis>验证</emphasis> 事务, 拒绝不满足要
            求的事务. 作为回报, 仓库的用户将逐渐养成良好的提交习惯.</para>
        </warning>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.fsfs">
      <!--
      <title>FSFS Configuration</title>
      -->
      <title>FSFS 配置</title>

      <!--
      <para>As of Subversion 1.6, FSFS filesystems have several
        configurable parameters which an administrator can use to
        fine-tune the performance or disk usage of their repositories.
        You can find these options&mdash;and the documentation for
        them&mdash;in the <filename>db/fsfs.conf</filename> file in
        the repository.</para>
      -->
      <para>从 Subversion 1.6 开始, FSFS 提供了几个配置参数, 管理员可利用它
        们对仓库的性能和磁盘使用进行调整. 管理员可以在仓库目录的
        <filename>db/fsfs.conf</filename> 里找到所有的配置参数及其说明.</para>

      <!-- TODO: Document the fsfs.conf options herein. -->

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
      <!--
    <title>Repository Maintenance</title>
      -->
    <title>仓库维护</title>

      <!--
    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>
      -->
    <para>维护 Subversion 仓库可能会令人望而却步, 大部分是由于后端存储所固
      有的复杂度. 完成任务的关键在于如何充分地利用工具&mdash;它们是什么,
      什么时候使用它们, 以及如何使用. 本节将会介绍如何使用 Subversion 提供的
      管理工具完成常见的仓库维护工作, 例如数据迁移, 升级, 备份和清理.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <!--
      <title>An Administrator's Toolkit</title>
      -->
      <title>管理员工具箱</title>

      <!--
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your
        repository.  Let's look more closely at each of those
        tools.</para>
      -->
      <para>Subversion 提供了几个用于创建, 检查, 修改和修复仓库的工具, 下面简
        单介绍一下这些工具.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>
          命令 <command>svnadmin</command> 是仓库管理员最优秀的助手. 除了可以
          用来创建仓库外, 它还提供了几种维护操作. <command>svnadmin</command>
          的使用方法和其他的 Subversion 命令行工具非常类似:</para>
      <!--
          The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>
      -->

        <informalexample>
          <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>
        </informalexample>

      <!--
        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>
      -->
        <para>在本章的前面 (<xref linkend="svn.reposadmin.basics.creating"/>)
          我们已经介绍了子命令 <command>svnadmin create</command>,
          稍后就会介绍 <command>svnadmin</command> 的其他子命令. 关于
          <command>svnadmin</command> 完整的子命令列表, 以及它们的功能, 见
          <xref linkend="svn.ref.svnadmin" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>
            
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>revisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <command>svnlook</command> 用于查看仓库的各个版本号和
          <firstterm>事务</firstterm> (<firstterm>transactions</firstterm>,
          正在生成过程中的版本号), 不会向仓库执行写操作. <command>svnlook
          </command> 经常被钩子使用, 用于报告仓库即将提交或刚刚提交的修改,
          用到的钩子分别是 pre-commit 和 post-commit. 管理员还可以用
          <command>svnlook</command> 诊断问题.</para>
      <!--
          <command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          pre-commit hook) or that were just
          committed (in the case of the post-commit
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
      -->
            
      <!--
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
      -->
        <para><command>svnlook</command> 的语法非常直观:</para>

        <informalexample>
          <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
&hellip;
</screen>
        </informalexample>

      <!--
        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>- -revision</option>
          (<option>-r</option>) and <option>- -transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>- -revision</option> (<option>-r</option>)
          and <option>- -transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>
      -->
        <para><command>svnlook</command> 的大部分子命令都能根据一个给定的版本
          号或事务, 输出与前一个版本号的不同之外或事务本身的信息, 指定版本号和
          事务的选项分别是 <option>--revision</option> (<option>-r</option>)
          和 <option>--transaction</option> (<option>-t</option>). 如果没有
          指定 <option>--revision</option> (<option>-r</option>) 和
          <option>--transaction</option> (<option>-t</option>),
          <command>svnlook</command> 将查看仓库最年轻的版本号 (即
          <literal>HEAD</literal>). 如果版本号 19 是仓库
          <filename>/var/svn/repos</filename> 目前最年轻的版本号, 则下面的 2
          个命令是等价的:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>
        </informalexample>

      <!--
        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>
      -->
        <para>有一个例外是子命令 <command>svnlook youngest</command> 不接受
          任何选项, 只是打印出仓库最年轻的版本号:</para>

        <informalexample>
          <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>
        </informalexample>

        <note>
      <!--
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>- -revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
      -->
          <para>始终记住, 管理员只能浏览未提交的事务, 但这种事务在大多数仓库中
            都不存在, 因为事务要么是已提交了的 (此时应该使用选项
            <option>--revision</option> (<option>-r</option>)), 要么被中止并
            删除.</para>
        </note>
            
      <!--
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>
      -->
        <para><command>svnlook</command> 的输出既能被人类理解, 也能被程序解析.
          例如, 假设 <command>svnlook info</command> 的输出是:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
$
</screen>
        </informalexample>

      <!--
        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>
      -->
        <para>根据输出顺序, <command>svnlook info</command> 的输出由以下几
          部分构成:</para>

        <orderedlist>
          <listitem>
      <!--
            <para>The author, followed by a newline</para>
      -->
            <para>作者, 然后是换行符</para>
          </listitem>
          <listitem>
      <!--
            <para>The date, followed by a newline</para>
      -->
            <para>日期, 然后是换行符</para>
          </listitem>
          <listitem>
      <!--
            <para>The number of characters in the log message,
              followed by a newline</para>
      -->
            <para>日志消息的字符个数, 然后是换行符</para>
          </listitem>
          <listitem>
      <!--
            <para>The log message itself, followed by a newline</para>
      -->
            <para>日志消息本身的内容, 然后是换行符</para>
          </listitem>
        </orderedlist>

      <!--
        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
      -->
        <para>打印的内容是人类可读的, 例如对于日期来说, 它是以文本形式表示,
          而不是某种很费解的形式 (例如把日期表示成距离某个特殊日期的
          纳秒数). 打印的内容同时也能被程序解析, 因为日志消息可能有很
          多行, 在长度上也没有限制, 所以 <command>svnlook</command> 在打印日
          志消息本身的内容之前, 先打印消息的长度, 这就允许处理
          <command>svnlook</command> 输出的程序针对日志消息做出更明智的决策,
          例如为日志消息分配多少内存, 或者是应该跳过多少字节才能完全跳过日志
          消息.</para>

      <!--
        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>
      -->
        <para><command>svnlook</command> 还能执行很多查询: 只显示上面提到的
          信息的部分内容, 递归地列出被版本控制的目录树, 报告哪些路径在给定
          的版本号或事务中被修改了, 显示文件和目录的内容和属性的变化, 等等.
          <command>svnlook</command> 完整的参考手册, 见
          <xref linkend="svn.ref.svnlook" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

      <!--
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>
      -->
        <para>虽然 <command>svndumpfilter</command> 不是管理员最常使用的工具
          之一, 但它却提供了一种非常特别且有用的功能&mdash;它可以作为一种基
          于路径的过滤器, 快速地修改 Subversion 仓库历史的数据流.</para>

      <!--
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
      -->
        <para><command>svndumpfilter</command> 的使用语法是:</para>

        <informalexample>
          <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type 'svndumpfilter help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
</screen>
        </informalexample>

      <!--
        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>
      -->
      <para><command>svndumpfilter</command> 包含了 2 个子命令:
        <command>svndumpfilter exclude</command> 和 <command>svndumpfilter
          include</command>, 它们允许管理员从历史数据流中排除或保留指定的
        路径. 在本章的 <xref linkend="svn.reposadmin.maint.filtering" />
        读者将会学习到子命令的用法, 以及它们的典型应用.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnrdump">
        <title>svnrdump</title>

      <!--
        <para>The <command>svnrdump</command> program is, to put it
          simply, essentially just network-aware flavors of
          the <command>svnadmin dump</command> and <command>svnadmin
          load</command> subcommands, rolled up into a separate
          program.</para>
      -->
        <para>简单点说, <command>svnrdump</command> 本质上就是把
          <command>svnadmin dump</command> 和 <command>svnadmin load</command>
          与网络有关的部分单独拿出来, 形成一个单独的程序.</para>

        <informalexample>
          <screen>
$ svnrdump help
general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]
Type 'svnrdump help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnrdump --version' to see the program version and RA modules.

Available subcommands:
   dump
   load
   help (?, h)

$
</screen>
        </informalexample>

      <!--
        <para>We discuss the use of <command>svnrdump</command> and
          the aforementioned <command>svnadmin</command> commands
          later in this chapter (see
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>
      -->
        <para>我们将在 <xref linkend="svn.reposadmin.maint.migrate" /> 介绍
          <command>svnrdump</command> 和上面提到的 2 个
          <command>svnadmin</command> 子命令.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

      <!--
        <para>The <command>svnsync</command> program provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote><footnote><para>Or is that,
          the <quote>sync</quote>?</para></footnote> repositories may
          be on different computers from each other and
          from <command>svnsync</command> itself.</para>
      -->
        <para><command>svnsync</command> 提供了维护 Subversion 仓库只读镜像
          所需的全部功能. 该命令只做一件事&mdash;把一个仓库的历史传送到另一
          个仓库, 完成这项工作的方式有很多种, 但它最方便的地方在于操作可以
          远程执行&mdash;<quote>源</quote> 和 <quote>同步</quote> 仓库, 以及
          <command>svnsync</command> 程序都可以在不同的主机上.</para>

      <!--
        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>
      -->
        <para><command>svnsync</command> 的语法和本章介绍的其他命令非常
          类似.</para>

        <informalexample>
          <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)
$
</screen>
        </informalexample>

      <!--
        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>
      -->
      <para>关于如何使用 <command>svnsync</command> 复制仓库的更多内容, 我们
        将在 <xref linkend="svn.reposadmin.maint.replication" /> 介绍.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

      <!--
        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories use individual
          files to house information about each revision.  Sometimes
          these files all live in a single directory; sometimes they
          are sharded across many directories.</para>
      -->
        <para>虽然脚本 <filename>fsfs-reshard.py</filename> (放在 Subversion
          源代码目录的 <filename>tools/server-side</filename> 子目录内) 不是
          Subversion 工具集的正式成员, 但是如果仓库使用 FSFS 作为后端存储,
          那么管理员就可以用 <filename>fsfs-reshard.py</filename> 优化性能.
          基于 FSFS 的仓库把版本号的相关信息记录在单独的文件里, 有时候这些
          文件会全部存放在一个目录里, 有时候分散在多个目录里.</para>

      <!--
        <para>The earliest FSFS release versions would house all the
          revision files within a single directory that grew&mdash;one
          file per revision&mdash;throughout the lifetime of your
          repository.  This created problems on systems which have
          hard limits on the number of files permitted in a given
          directory, and was a performance burden even on systems
          where such limits didn't exist or were set sufficiently
          high.</para>
      -->
        <para>FSFS 的早期版本把所有的版本号文件&mdash;每一个版本号都有对应的
          一个文件&mdash;放在一个目录里, 在仓库的整个生命周期内, 目录内的文件
          数量都在增长. 有些系统对同一目录内的文件数量限制较大, 即使是限制较
          宽或没有限制的系统, 如果目录内的文件数量较多也会产生严重的性能问题.
        </para>

      <!--
        <para>Beginning in version 1.5, Subversion creates FSFS-backed
          repositories using a slightly modified layout in which the
          contents of the revision files directory (and other
          always-growing directories)
          are <firstterm>sharded</firstterm>, or scattered across
          several subdirectories.  This can greatly reduce the time it
          takes the system to locate any one of these files, and
          therefore increases the overall performance of Subversion
          when reading from the repository.</para>
      -->
        <para>从 Subversion 1.5 开始, 基于 FSFS 的仓库在布局上稍有变化: 存放
          版本号文件的目录 (和其他不断增长的目录) 是
          <firstterm>碎化地</firstterm> (<firstterm>sharded</firstterm>), 或
          者说版本号文件分散在多个目录内. 这可以大幅减少系统定位文件的时间,
          从而提高仓库的整体读取性能.</para>

      <!--
        <para>The number of files permitted to live in a given
          subdirectory is a configurable thing (though the defaults
          are reasonable ones for most known platforms), but changing
          that configuration after the repository has been in use for
          some time could cause Subversion to be unable to locate the
          files it is looking for.  That's
          where <command>fsfs-reshard.py</command> comes in.</para>
      -->
        <para>在同一个目录内可以存放的文件数量是可配置的 (虽然默认值对于大多
          数平台而言都是比较合理的), 但是如果在仓库使用一段时间后, 再去修改
          这个配置, 将导致 Subversion 无法定位当前正在搜索的文件. 这时候
          <filename>fsfs-reshard.py</filename> 就派上的用场.</para>

      <!--
        <para><command>fsfs-reshard.py</command> reshuffles the
          repository's file structure into a new arrangement that
          reflects the requested number of sharding subdirectories and
          updates the repository configuration to preserve this
          change.  When used in conjunction with the <command>svnadmin
          upgrade</command> command, this is especially useful for
          upgrading a pre-1.5 Subversion (unsharded) repository to the
          latest filesystem format and sharding its data files (which
          Subversion will not automatically do for you).  This script
          can also be used for fine-tuning an already sharded
          repository.</para>
      -->
        <para><command>fsfs-reshard.py</command> 重新编排仓库的目录结构, 以满
          足需要被碎化的子目录的个数要求, 并更新仓库的配置, 以便修改能够持久
          化地保留下来. <command>fsfs-reshard.py</command> 和
          <command>svnadmin upgrade</command> 配合使用时, 对于把 1.5 版之前
          的仓库升级成最新的文件系统格式和碎化文件非常有用 (Subversion 不会
          自动地对文件进行碎化). <command>fsfs-reshard.py</command> 还能
          继续优化已经碎化过的仓库.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <!--
      <title>Commit Log Message Correction</title>
      -->
      <title>修正提交日志消息</title>
            
      <!--
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        pre-revprop-change hook; see
        <xref linkend="svn.reposadmin.hooks" />) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>
      -->
      <para>有时候, 用户可能会写错提交日志消息 (例如拼写错误, 或包含了错误的
        信息). 如果仓库的配置允许提交结束后仍然可以对日志消息进行修改 (使用
        钩子 pre-revprop-change, 见 <xref linkend="svn.reposadmin.hooks" />),
        用户就可以用命令 <command>svn propset</command> (见 <xref
          linkend="svn.ref.svn"/> 的 <xref linkend="svn.ref.svn.c.propset"/>)
        <quote>修正</quote> 包含错误的日志消息. 然而, 这种做法可能会导致信息
        永久丢失, 因此 Subversion 仓库的默认配置是禁止修改未版本化的属性&mdash;
        只有管理员除外.</para>

      <!--
      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
      -->
      <para>如果管理员需要修改日志消息, 将会用到的命令是
        <command>svnadmin setlog</command>. 命令从给定的文件中读取新的日志
        消息, 覆盖掉指定的版本号的日志.</para>

      <informalexample>
        <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      </informalexample>
      
      <!--
      <para>The <command>svnadmin setlog</command> command, by
        default, is still bound by the same protections against
        modifying unversioned properties as a remote client
        is&mdash;the pre-revprop-change and
        post-revprop-change hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>- -bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
      -->
      <para>默认情况下, <command>svnadmin setlog</command> 受到的限制与企图
        修改未版本化属性的客户端受到的限制是一样的&mdash;钩子
        pre-revprop-change 和 post-revprop-change 仍然会被触发, 因此命令若想
        成功执行还要求仓库进行相应的配置. 但管理员可以通过向
        <command>svnadmin setlog</command> 添加选项
        <option>--bypass-hooks</option>, 绕开这条限制.</para>
 
      <warning>
      <!--
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      -->
        <para>记住, 如果选择绕开钩子, 很可能会导致属性发生变化时, 不发送通知
          邮件, 备份系统不对未版本化的属性进行备份, 以及诸如此类的事情. 管理
          员必须非常清楚自己在做什么.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <!--
      <title>Managing Disk Space</title>
      -->
      <title>管理磁盘空间</title>

      <!--
      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>
      -->
      <para>虽然最近几年, 存储的成本已经下降了很多, 但是如果是对大量的数据进行
        版本控制, 那么管理员仍然需要关注磁盘的使用情况. 在一个活跃的仓库中,
        每增加一条版本历史, 就需要把历史信息备份到其他地方, 有可能还会为了
        保险起见而多次备份. 为了降低备份的数据量和磁盘消耗, 知道仓库的哪些
        数据需要保持在线, 哪些数据需要备份, 哪些数据可以删除&mdash;就显得非常
        重要.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
      <!--
        <title>How Subversion saves disk space</title>
      -->
        <title>Subversion 如何节约磁盘空间</title>

        <para>
          <indexterm>
            <primary>deltification</primary>
          </indexterm>
          为了尽量降低仓库的存储空间消耗, Subversion 使用了
          <firstterm>增量存储技术</firstterm>. 增量存储技术通过一块数据及
          相对于它的一系列差异来表示另一块数据, 如果两块数据的差异非常小,
          增量存储技术就可以仅保存其中一组数据以及两组数据之间的差异, 而不
          需要同时保存两组数据, 从而节省存储空间. 采用增量存储技术的结果是
          原本体积庞大的文件, 其所消耗的存储空间与全文保存相比, 只占很小的
          一部分.</para>
      <!--
          To keep the repository small, Subversion uses
          <firstterm>deltification</firstterm> (or delta-based storage)
          within the repository itself.  Deltification involves
          encoding the representation of a chunk of data as a
          collection of differences against some other chunk of data.
          If the two pieces of data are very similar, this
          deltification results in storage savings for the deltified
          chunk&mdash;rather than taking up space equal to the size of
          the original data, it takes up only enough space to
          say, <quote>I look just like this other piece of data over
          here, except for the following couple of changes.</quote>
          The result is that most of the repository data that tends to
          be bulky&mdash;namely, the contents of versioned
          files&mdash;is stored at a much smaller size than the
          original full-text representation of that data.</para>
      -->

        <para>
          <indexterm>
            <primary>representation sharing</primary>
          </indexterm>
          在一开始设计 Subversion 时, 就已经包含了增量存储技术, 后来也对其进
          行不断地改进. 从 1.4 开始, Subversion 将对全文表示的文件内容进行
          压缩. 从 1.6 开始, 新特性 <firstterm>表示共享</firstterm>
          (<firstterm>representations sharing</firstterm>) 为 Subversion 节
          省了更多的空间. 该特性允许内容相同的多个文件或多个版本号引用
          到一个单一的共享数据实例上, 而不是每个人都存一份自己的副本.</para>
      <!--
          While deltified storage has been a part of Subversion's
          design since the very beginning, there have been additional
          improvements made over the years.  Subversion repositories
          created with Subversion 1.4 or later benefit from
          compression of the full-text representations of file
          contents.  Repositories created with Subversion 1.6 or later
          further enjoy the disk space savings afforded by
          <firstterm>representation sharing</firstterm>, a feature
          which allows multiple files or file revisions with identical
          file content to refer to a single shared instance of that data
          rather than each having their own distinct copy thereof.</para>
      -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
      <!--
        <title>Removing dead transactions</title>
      -->
        <title>删除僵死的事务</title>

      <!--
        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>
      -->
        <para>虽然不太常见, 但仍然存在提交失败的情况, 此时便会在仓库中留下
          残骸&mdash;一个未提交的事务和与之相关的文件或目录修改. 造成提交
          失败的原因很多, 可能是客户端操作被用户粗暴地终止, 也可能是在操作
          执行中发生了网络错误. 不管是什么原因, 僵死事务总是有可能出现, 除
          了占用存储空间外, 它们并不会产生实际的危害, 但一个讲究的管理员的眼
          睛里是揉不得沙子的.</para>

      <!--
        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>
      -->
        <para>管理员可以用命令 <command>svnadmin lstxns</command> 列出未完成
          事务:</para>

        <informalexample>
          <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
        </informalexample>

      <!--
        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>- -transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>
      -->
        <para>输出中的每一项都能用作 <command>svnlook</command> (添加选项
          <option>--transaction</option> (<option>-r</option>)) 的参数, 用来
          判断是谁, 在什么时候创建了这个事务, 在这个事务中做了哪些类型的修改.
          这些信息有助于管理员判断该事务是否可以安全地删除. 如果确实是要删除
          一个事务, 就把它的名字作为命令 <command>svnadmin rmtxns</command>
          的参数. 实际上, <command>svnadmin lstxns</command> 的输出可以直接
          作为 <command>svnadmin rmtxns</command> 的输入!</para>

        <informalexample>
          <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
        </informalexample>

      <!--
        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>
      -->
        <para>如果管理员打算以上面这种形式执行这两个命令, 就得考虑暂时禁止
          客户端对仓库的访问, 避免在你清理期间有合法的事务产生. <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" /> 展示
        了如何编写一个 shell 脚本来打印仓库中未完成的事务.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
      <!--
          <title>txn-info.sh (reporting outstanding transactions)</title>
      -->
          <title>txn-info.sh (打印未完成的事务)</title>

          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

      <!--
        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>
      -->
        <para>脚本的输出基本上就是多个 <command>svnlook info</command> 输出
          内容 (见 <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) 的拼接,
          就像下面这样:</para>

        <informalexample>
          <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
        </informalexample>

      <!--
        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>
      -->
        <para>一个被废弃了很久的事务通常表示一个失败或中止了的提交. 事务的时间
          戳可以提供很有用的信息&mdash;比如说, 9 个月前开始的操作有没有可能
          还是活跃的?</para>

      <!--
        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>
      -->
        <para>简言之, 决定清理事务不用太过深思熟虑, 很多信息&mdash;包括 Apache
          的错误和访问日志, Subversion 的操作日志和版本号历史&mdash;都可以作为
          决策的参考. 当然, 管理员也可以通过与事务的所有者沟通 (比如说通过
          电子邮件) 来判断一个看似僵死的事务, 是否真得处于僵死状态.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.fsfspacking">
      <!--
        <title>Packing FSFS filesystems</title>
      -->
        <title>FSFS 文件系统压缩</title>

      <!--
        <para>FSFS repositories contain files that describe the
          changes made in a single revision, and files that contain
          the revision properties associated with a single revision.
          Repositories created in versions of Subversion prior to 1.5
          keep these files in two directories&mdash;one for each type
          of file.  As new revisions are committed to the repository,
          Subversion drops more files into these two
          directories&mdash;over time, the number of these files in
          each directory can grow to be quite large.  This has been
          observed to cause performance problems on certain
          network-based filesystems.</para>
      -->
        <para>在基于 FSFS 的仓库中, 有些文件描述了在一个单独的版本号做了哪些
          修改, 有些文件包含了与一个单独的的版本号相关的版本号属性. Subversion
          1.5 之前创建的仓库, 把这两种文件分别放在两个目录里. 当仓库中有新的
          版本号生成时, Subversion 就向这两个目录存放更多的文件, 随着时间的推
          移, 目录内的文件数量将增长到非常大的规模. 人们已经发现, 这会在某些
          基于网络的文件系统上造成严重的性能问题.</para>

      <!--
        <para>The first problem is that the operating system has to
          reference many different files over a short period of time.
          This leads to inefficient use of disk caches and, as a
          result, more time spent seeking across large disks.  Because
          of this, Subversion pays a performance penalty when
          accessing your versioned data.</para>
      -->
        <para>第一个问题是操作系统必须在短时间内引用大量不同的文件, 这会导致
          磁盘缓存被快速消耗, 于是操作系统会在读取磁盘上花费更多的时间, 表
          现在 Subversion 身上, 就是在访问数据时性能低下.</para>

      <!--
        <para>The second problem is a bit more subtle.  Because of the
          ways that most filesystems allocate disk space, each file
          claims more space on the disk than it actually uses.  The
          amount of extra space required to house a single file can
          average anywhere from 2 to 16 kilobytes <emphasis>per
          file</emphasis>, depending on the underlying
          filesystem in use.  This translates directly
          into a per-revision disk usage penalty for FSFS-backed
          repositories.  The effect is most pronounced in repositories
          which have many small revisions, since the overhead involved
          in storing the revision file quickly outgrows the size of
          the actual data being stored.</para>
      -->
        <para>第二个问题比较微妙. 受到大多数文件系统的磁盘空间分配方式的影响,
          每一个文件实际消耗的存储空间会多于它要求的存储空间. 为了管理一个文
          件所消耗的额外存储空间在 2 KB 到 16 KB 之间, 具体的大小取决于操作
          系统的文件系统的实现. 反映到以 FSFS 作为后端存储的仓库身上, 就是每
          一个版本号都会产生额外的存储空间消耗. 对于含有大量小版本号的仓库
          来说, 最明显的影响就是为了存放版本号文件而消耗的磁盘空间, 会迅速超
          过数据的实际大小.</para>

      <!--
        <para>To solve these problems, Subversion 1.6 introduced the
          <command>svnadmin pack</command> command.  By concatenating
          ### TODO
          all the files of a completed shard into a single <quote>pack</quote> file
          and then removing the original per-revision
          files, <command>svnadmin pack</command> reduces the file
          count within a given shard down to just a single file.  In
          doing so, it aids filesystem caches and reduces (to one) the
          number of times a file storage overhead penalty is
          paid.</para>
      -->
        <para>为了解决这 2 个问题, Subversion 1.6 增加了命令
          <command>svnadmin pack</command>, 它的作用是把一个完整的碎片内的所
          有文件都打包到一个单独的文件内, 然后再删除原来的文件, 从而降低因文
          件过多而导致的空间与性能开销.</para>

      <!--
        <para>Subversion can pack existing sharded repositories which
          have been upgraded to the 1.6 filesystem format or later (see
          <xref linkend="svn.ref.svnadmin.c.upgrade"/>) in
          <xref linkend="svn.ref.svnadmin"/>.  To do so, just
          run <command>svnadmin pack</command> on the
          repository:</para>
      -->
        <para>只要是 1.6 版及以上的文件系统格式, 都可以用 <command>svnadmin
            pack</command> 进行压缩 (如果文件系统格式较旧, 可以用
          <command>svnadmin upgrade</command> 对仓库进行升级, 见
          <xref linkend="svn.ref.svnadmin"/> 的 <xref
            linkend="svn.ref.svnadmin.c.upgrade"/>). 为了压缩文件系统, 只需要
          对仓库执行 <command>svnadmin pack</command>:</para>

        <informalexample>
          <screen>
$ svnadmin pack /var/svn/repos
Packing shard 0...done.
Packing shard 1...done.
Packing shard 2...done.
&hellip;
Packing shard 34...done.
Packing shard 35...done.
Packing shard 36...done.
$
</screen>
        </informalexample>

      <!--
        <para>Because the packing process obtains the required locks
          before doing its work, you can run it on live repositories,
          or even as part of a post-commit hook.  Repacking packed
          shards is legal, but will have no effect on the disk usage
          of the repository.</para>
      -->
        <para>因为打包过程会事先获取所需要的锁, 所以管理员可以在活动仓库上
          执行这个操作, 甚至可以作为钩子 post-commit 的一部分. 压缩已经压缩过
          的碎片是合法的操作, 但不会对仓库的磁盘使用产生影响.</para>

      <!--
        <para><command>svnadmin pack</command> has no effect on
          BDB-backed Subversion repositories.</para>
      -->
        <para>如果仓库以 BDB 作为后端存储, 则 <command>svnadmin pack</command> 
          不会对仓库产生任何效果.</para>

      </sect3>
    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <!--
      <title>Migrating Repository Data Elsewhere</title>
      -->
      <title>迁移仓库数据</title>
    
      <!--
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>
      -->
      <para>Subversion 文件系统的数据分布在仓库的很多文件中, 其存储方式通常
        只有 Subversion 开发人员才能理解 (或对它们感兴趣). 然而, 在某些情况
        下文件系统的全部或部分数据需要被复制或移动到其他仓库中.</para>

      <para>
        <indexterm>
          <primary>repository dump streams</primary>
        </indexterm>
        <indexterm>
          <primary>dump files</primary>
          <see>repository dump streams</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>
        Subversion 通过 <firstterm>仓库转储流</firstterm>
        (<firstterm>repository dump streams</firstterm>) 实现这个功能. 仓库
        转储流 (如果作为文件存储到磁盘上, 习惯上称为 <quote>转储文件</quote>)
        是一种可移植的平面文件格式, 描述了仓库中的各个版本号&mdash;是谁, 在
        什么时候, 做了哪些修改等. 这种转储流是仓库之间组织版本历史&mdash;
        全部的或部分的, 未修改或修改过的&mdash;的主要机制. Subversion 提供了
        创建与加载转储流所必需的工具: 命令 <command>svnadmin dump</command>
        和 <command>svnadmin load</command>, 以及 <command>svnrdump</command>.
      </para>
      <!--
        Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands, respectively,
        and the <command>svnrdump</command> program.</para>
      -->

      <warning>
      <!--
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      -->
        <para>虽然 Subversion 仓库的转储文件格式包含了人类可读的部分内容
          和让人感到熟悉的结构 (它的格式很像 RFC 822 格式, 这是大多数邮件
          所使用的格式), 但它 <emphasis>不是</emphasis> 一个纯文本文件,
          而是二进制文件, 即使是非常细微的修改也会非常敏感. 比如说, 很多
          文本编辑器会自动转换行结束符, 但这样做会损坏文件.</para>
      </warning>

      <!--
      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>
      -->
      <para>有很多情况都需要对 Subversion 仓库数据进行转储和加载. 在 Subversion
        的早期阶段, 最常见的原因是 Subversion 的演变. 随着 Subversion 的不断成
        熟, 可能会出现这样一种情况: 后端数据库概要的变化会导致旧版本的仓库出现
        兼容性问题, 于是管理员必须使用旧版的 Subversion 转储仓库数据, 再把转
        出的数据加载到新版 Subversion 创建的仓库中. 从 Subversion 1.0 开始,
        不会再出现这种需要转储和加载仓库数据的概要变化, 并且 Subversion 开发
        人员承诺在次版本之间升级时 (例如从 1.3 到 1.4), 不会强迫用户转储和加
        载仓库. 但除了升级 Subversion 外, 还有其他需要用到转储和加载的场景,
        例如重新部署 Berkeley DB 仓库到新的操作系统或 CPU 平台上, 或者在
        Berkeley DB 和 FSFS 两种后端存储之间切换, 以及从仓库历史中清除被版本
        控制的数据 (在本章的 <xref linkend="svn.reposadmin.maint.filtering" />
        介绍).</para>

      <note>
      <!--
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      -->
        <para>Subversion 仓库的转储文件只是描述了版本历史, 它不会携带任何与
          未提交的事务, 文件系统路径上的用户锁, 仓库或服务器的配置 (包括钩子
          脚本) 等有关的信息.
        </para>
      </note>

      <!--
      <para>The Subversion repository dump format also enables
        conversion from a different storage mechanism or version
        control system altogether.  Because the dump file format is,
        for the most part, human-readable, it should be relatively
        easy to describe generic sets of changes&mdash;each of which
        should be treated as a new revision&mdash;using this file
        format.  In fact, the <command>cvs2svn</command> utility (see
        <xref linkend="svn.forcvs.convert" />) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>
      -->
      <para>利用 Subversion 仓库的转储文件, 管理员还可以实现在不同的后端存储
        方式或版本控制系统之间转换. 因为转储文件的绝大部分内容是人类可读的,
        用它来描述一般的修改集&mdash;修改集中的每一个修改都应当看作是一个新
        的版本号&mdash;相对来说比较容易. 实际上, 工具
        <command>cvs2svn</command> (见 <xref linkend="svn.forcvs.convert" />)
        可以通过转储文件, 把 CVS 仓库的内容复制到 Subversion 仓库中.</para>

      <!--
      <para>For now, we'll concern ourselves only with migration of
        repository data between Subversion repositories, which we'll
        describe in detail in the sections which follow.</para>
      -->
      <para>现在, 我们只关心如何在 Subversion 仓库之间迁移数据, 具体的内容
        将在接下来的一节里进行介绍.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnadmin">
      <!--
        <title>Repository data migration using svnadmin</title>
      -->
        <title>使用 svnadmin 迁移仓库数据</title>

      <!--
        <para>Whatever your reason for migrating repository history,
          using the <command>svnadmin dump</command> and
          <command>svnadmin load</command> subcommands is
          straightforward.  <command>svnadmin dump</command> will output
          a range of repository revisions that are formatted using
          Subversion's custom filesystem dump format.  The dump format
          is printed to the standard output stream, while informative
          messages are printed to the standard error stream.  This
          allows you to redirect the output stream to a file while
          watching the status output in your terminal window.  For
          example:</para>
      -->
        <para>无论迁移仓库历史是出于什么样的原因, <command>svnadmin
            dump</command> 和 <command>svnadmin load</command> 的用法都非常
          简单直接. <command>svnadmin dump</command> 按照 Subversion 的文件
          系统转储格式, 输出一段范围内的版本号. 转储的结果会被打印到标准输出,
          而提示性的信息则会打印到标准错误, 这就允许管理员把输出重定向到文件
          的同时, 在终端窗口中查看命令的状态输出, 例如:</para>

        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
        </informalexample>

      <!--
        <para>At the end of the process, you will have a single file
          (<filename>dumpfile</filename> in the previous example) that
          contains all the data stored in your repository in the
          requested range of revisions.  Note that <command>svnadmin
          dump</command> is reading revision trees from the repository
          just like any other <quote>reader</quote> process would
          (e.g., <command>svn checkout</command>), so it's safe
          to run this command at any time.</para>
      -->
        <para>命令执行结束时, 你将得到一个文件 (在上面的例子里, 文件名是
          <filename>dumpfile</filename>), 这个文件包含了在指定的版本号范围
          内, 存放在仓库中的所有数据. 因为 <command>svnadmin dump</command>
          从仓库中读取版本号的过程和其他 <quote>读者</quote> (例如
          <command>svn checkout</command>) 读取仓库的过程是一样的, 所以
          可以在任意时刻, 安全地执行 <command>svnadmin dump</command>.</para>

      <!--
        <para>The other subcommand in the pair, <command>svnadmin
          load</command>, parses the standard input stream as a
          Subversion repository dump file and effectively replays those
          dumped revisions into the target repository for that
          operation.  It also gives informative feedback, this time
          using the standard output stream:</para>
      -->
        <para>与 <command>svnadmin dump</command> 配对的命令 <command>svnadmin
            load</command> 从标准输入读取 Subversion 仓库的转储文件, 把文件中
          的版本号重放到目标仓库中. 在命令的执行过程中仍然会输出提示性的信息,
          不过这次是打印到标准输出:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        </informalexample>

      <!--
        <para>The result of a load is new revisions added to a
          repository&mdash;the same thing you get by making commits
          against that repository from a regular Subversion client.
          Just as in a commit, you can use hook programs to perform
          actions before and after each of the commits made during a
          load process.  By passing the
          <option>- -use-pre-commit-hook</option> and
          <option>- -use-post-commit-hook</option> options to
          <command>svnadmin load</command>, you can instruct
          Subversion to execute the pre-commit and post-commit hook
          programs, respectively, for each loaded revision.  You might
          use these, for example, to ensure that loaded revisions pass
          through the same validation steps that regular commits pass
          through.  Of course, you should use these options with
          care&mdash;if your post-commit hook sends emails to a
          mailing list for each new commit, you might not want to spew
          hundreds or thousands of commit emails in rapid succession
          at that list!  You can read more about the use of hook
          scripts in <xref linkend="svn.reposadmin.hooks" />.</para>
      -->
        <para>加载的结果是有新的版本号被添加到仓库中&mdash;相当于从 Subversion
          客户端向仓库提交. 和普通的提交一样, 可以利用钩子, 在加载产生的提交
          之前或之后执行特定的操作, 向 <command>svnadmin load</command> 添加
          选项 <option>--use-pre-commit-hook</option> 和
          <option>--use-post-commit-hook</option>, 可以分别指示 Subversion
          为每一个加载的版本号, 执行钩子 pre-commit 和 post-commit. 比如说
          管理员可能会利用钩子, 以确保加载的版本号能够经历与普通提交一样的验证
          过程. 当然, 在使用这两个选项时要小心&mdash;如果钩子 post-commit 会为
          每一个新的版本号发送一封邮件, 你可能不希望在几分钟内收到几百上千封
          邮件. 关于钩子的更多内容, 在 <xref linkend="svn.reposadmin.hooks" />
          介绍.</para>

      <!--
        <para>Note that because <command>svnadmin</command> uses
          standard input and output streams for the repository dump and
          load processes, people who are feeling especially saucy can try
          things such as this (perhaps even using different versions of
          <command>svnadmin</command> on each side of the pipe):</para>
      -->
        <para>因为 <command>svnadmin</command> 在转储和加载过程中会用到标准
          输出和标准输入, 感兴趣的读者可以试一下像下面这样执行命令 (在管道的
          两边甚至可以使用不同版本的 <command>svnadmin</command>):</para>

        <informalexample>
          <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>
        </informalexample>

      <!--
        <para>By default, the dump file will be quite large&mdash;much
          larger than the repository itself.  That's because by default
          every version of every file is expressed as a full text in the
          dump file.  This is the fastest and simplest behavior, and
          it's nice if you're piping the dump data directly into some other
          process (such as a compression program, filtering program, or
          loading process).  But if you're creating a dump file
          for longer-term storage, you'll likely want to save disk space
          by using the <option>- -deltas</option> option.  With this
          option, successive revisions of files will be output as
          compressed, binary differences&mdash;just as file revisions
          are stored in a repository.  This option is slower, but it
          results in a dump file much closer in size to the original
          repository.</para>
      -->
        <para>默认情况下, 转储文件会很大&mdash;比仓库要大得多, 这是因为每个
          文件的每个版本在转储文件中都是全文本表示. 这是最快速和最简单的方式,
          如果转储文件还会被其他程序 (例如压缩程序, 过滤程序等) 处理, 处理
          起来也会非常方便. 但是如果管理员需要长时间保存转储文件, 向
          <command>svnadmin</command> 添加选项 <option>--deltas</option> 可以
          减小转储文件的大小, 从而节省存储空间. 添加选项
          <option>--deltas</option> 后, 文件的连续版本号将会以压缩的二进制差
          异格式输出&mdash;和仓库保存文件版本号的方式是一样的. 添加选项后命令
          会执行得更慢一些, 但得到的转储文件大小会更接近仓库的大小.</para>

      <!--
        <para>We mentioned previously that <command>svnadmin
          dump</command> outputs a range of revisions.  Use the
          <option>- -revision</option> (<option>-r</option>) option to
          specify a single revision, or a range of revisions, to dump.
          If you omit this option, all the existing repository revisions
          will be dumped.</para>
      -->
        <para>我们前面已经提到 <command>svnadmin dump</command> 可以输出一段
          范围内的版本号. 使用选项 <option>--revision</option>
          (<option>-r</option>) 指定一个单独的, 或一段范围内的版本号进行转
          储. 如果省略该选项, 仓库内所有的版本号都会被转储.</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>
        </informalexample>

      <!--
        <para>As Subversion dumps each new revision, it outputs only
          enough information to allow a future loader to re-create that
          revision based on the previous one.  In other words, for any
          given revision in the dump file, only the items that were
          changed in that revision will appear in the dump.  The only
          exception to this rule is the first revision that is dumped
          with the current <command>svnadmin dump</command>
          command.</para>
      -->
        <para>Subversion 在转储新的版本号时, 输出的信息仅能满足加载过程根据
          前面的版本号来重新创建新的版本号. 换句话说, 对于转储文件中给定的
          任意一个版本号, 只有在该版本号中被修改了的项目, 才会出现在转储文件
          里, 唯一的例外是被当前 <command>svnadmin dump</command> 转储的第一
          个版本号.</para>

      <!--
        <para>By default, Subversion will not express the first dumped
          revision as merely differences to be applied to the previous
          revision.  For one thing, there is no previous revision in the
          dump file!  And second, Subversion cannot know the state of
          the repository into which the dump data will be loaded (if it
          ever is).  To ensure that the output of each
          execution of <command>svnadmin dump</command> is
          self-sufficient, the first dumped revision is, by default, a
          full representation of every directory, file, and property in
          that revision of the repository.</para>
      -->
        <para>默认情况下, Subversion 不会把第一个被转储的版本号表示成与前一
          个版本号的差异. 第一个原因是对于第一个版本号来说, 它的前一个版本号
          在转储文件中不存在, 第二个原因是 Subversion 无法预知加载转储文件的
          仓库状态. 为了确保每次执行 <command>svnadmin dump</command> 所产生
          的输出是自我完备的, Subversion 在默认情况下将会完整地表示被转储的
          第一个版本号, 包括它的每一个目录, 文件, 和版本号的每一个属性.</para>

      <!--
        <para>However, you can change this default behavior.  If you add
          the <option>- -incremental</option> option when you dump your
          repository, <command>svnadmin</command> will compare the first
          dumped revision against the previous revision in the
          repository&mdash;the same way it treats every other revision that
          ### TODO
          gets dumped.  It will then output the first revision exactly
          as it does the rest of the revisions in the dump
          range&mdash;mentioning only the changes that occurred in that
          revision.  The benefit of this is that you can create several
          small dump files that can be loaded in succession, instead of
          one large one, like so:</para>
      -->
        <para>然而, 管理员可以修改这种默认行为. 如果在转储时添加了选项
          <option>--incremental</option>, <command>svnadmin</command> 会把
          转储的第一个版本号与前一个版本号作比较&mdash;就像对待其他被转储的
          版本号那样, 只输出在版本号中被修改了的内容. 这样做的好处是管理员
          可以创建出几个较小的转储文件&mdash;而不是一整个大文件&mdash;它们被
          加载时可以连续进行, 就像下面这样:</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>
        </informalexample>

      <!--
        <para>These dump files could be loaded into a new repository
          with the following command sequence:</para>
      -->
        <para>可以用下面的命令序列, 把这几个转储文件加载到新的仓库中:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
        </informalexample>

      <!--
        <para>Another neat trick you can perform with this
          <option>- -incremental</option> option involves appending to an
          existing dump file a new range of dumped revisions.  For
          example, you might have a post-commit hook
          that simply appends the repository dump of the single revision
          that triggered the hook.  Or you might have a script that runs
          nightly to append dump file data for all the revisions that
          were added to the repository since the last time the script
          ran.  Used like this, <command>svnadmin dump</command> can be
          one way to back up changes to your repository over time in case
          of a system crash or some other catastrophic event.</para>
      -->
        <para>选项 <option>--incremental</option> 的另一个奇妙用法是向已有的
          转储文件添加新的版本号. 比如说, 管理员可能会利用钩子 post-commit,
          将每次触发钩子的版本号转储到同一个转储文件中. 又或者是每晚都运行
          一个脚本, 把上一次脚本运行结束后, 仓库中新增的版本号转储到同一个
          文件中. 利用这种方式, <command>svnadmin dump</command> 就能实现仓库
          的备份.</para>

      <!--
        <para>The dump format can also be used to merge the contents of
          several different repositories into a single repository.  By
          using the <option>- -parent-dir</option> option of
          <command>svnadmin load</command>, you can specify a new
          virtual root directory for the load process.  That means if
          you have dump files for three repositories&mdash;say
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename>, and
          <filename>ss-dumpfile</filename>&mdash;you can first create a new
          repository to hold them all:</para>
      -->
        <para>利用转储文件, 还能把不同的几个仓库合并成一个仓库. 为
          <command>svnadmin load</command> 添加选项
          <option>--parent-dir</option>, 就能为加载过程指定一个新的虚拟根目录,
          这就意味着如果你有三个仓库的转储文件&mdash;假设文件名分别是
          <filename>calc-dumpfile</filename>, <filename>cal-dumpfile</filename>,
          <filename>ss-dumpfile</filename>&mdash;先创建一个将会用来加载所有
          转储文件的仓库:</para>

        <informalexample>
          <screen>
$ svnadmin create /var/svn/projects
$
</screen>
        </informalexample>

      <!--
        <para>Then, make new directories in the repository that will
          encapsulate the contents of each of the three previous
          repositories:</para>
      -->
        <para>然后, 在仓库中为每一个转储文件创建一个对应的目录:</para>

        <informalexample>
          <screen>
$ svn mkdir -m "Initial project roots" \
            file:///var/svn/projects/calc \
            file:///var/svn/projects/calendar \
            file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>
        </informalexample>

      <!--
        <para>Lastly, load the individual dump files into their
          respective locations in the new repository:</para>
      -->
        <para>最后, 把转储文件加载到各自对应的目录内:</para>

        <informalexample>
          <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnrdump">
      <!--
        <title>Repository data migration using svnrdump</title>
      -->
        <title>使用 svnrdump 迁移仓库数据</title>

      <!--
        <para>In Subversion 1.7, <command>svnrdump</command> joined
          the set of stock Subversion tools.  It offers fairly
          specialized functionality, essentially as a network-aware
          version of the <command>svnadmin dump</command>
          and <command>svnadmin load</command> commands which we
          discuss in depth in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> will generate a dump
          stream from a remote repository, spewing it to standard
          output; <command>svnrdump load</command> will read a dump
          stream from standard input and load it into a remote
          repository.  Using <command>svnrdump</command>, you can
          generate incremental dumps just as you might
          with <command>svnadmin dump</command>.  You can even dump a
          subtree of the repository&mdash;something
          that <command>svnadmin dump</command> cannot do.</para>
      -->
        <para>Subversion 1.7 引入了一个新工具, <command>svnrdump</command>.
          它提供了较为特殊的功能, 本质上就是 <command>svnadmin dump</command>
          和 <command>svnadmin load</command> (见
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"/>) 的跨网络
          版本. <command>svnrdump dump</command> 从一个远程仓库转储数据, 打印
          到标准输出; <command>svnrdump load</command> 从标准输入读取转储数据,
          加载到一个远程仓库上. <command>svnrdump</command> 可以像
          <command>svnadmin dump</command> 那样生成增量转储, 甚至可以只转储
          仓库的某个子目录, <command>svnadmin</command> 却无法做到这一点.</para>

      <!--
        <para>The primary difference is that instead of requiring
          direct access to the repository, <command>svnrdump</command>
          operates remotely, using the very same Repository Access
          (RA) protocols that the Subversion client does.  As such,
          you might need to provide authentication credentials.  Also,
          your remote interactions are subject to any authorization
          limitations configured on the Subversion server.</para>
      -->
        <para><command>svnadmin</command> 与 <command>svnrdump</command> 之间
          最关键的区别在于后者不需要直接访问仓库, <command>svnrdump</command>
          使用与 Subversion 客户端相同的仓库访问 (Repository Access, 简称 RA)
          协议完成操作
          的远程执行, 因此用户可能需要提供认证证书, 除此之外, 远程交互可能还会
          受到 Subversion 服务器的授权限制.</para>

        <note>
      <!--
          <para><command>svnrdump dump</command> requires that the
            remote server be running Subversion 1.4 or newer.  It
            currently generates dump streams only of the sort which
            are created when you pass the <option>- -deltas</option>
            option to <command>svnadmin dump</command>.  This isn't
            interesting in the typical use-cases, but might impact
            specific types of custom transformations you might wish to
            apply to the resulting dump stream.</para>
      -->
          <para><command>svnrdump dump</command> 要求远程服务器运行的是
            Subversion 1.4 或更新的版本. 它能生成的转储流的唯一类型, 就是添加
            了选项 <option>--deltas</option> 后, <command>svnadmin
              dump</command> 所生成的转储流. 在典型的使用情况下这并没有什么
            特殊之处, 但是如果你想在生成的转储流上执行一些特定类型的转换, 这
            些转换可能会受到影响.</para>
        </note>

        <note>
      <!--
          <para>Because it modifies revision properties after
            committing new revisions, <command>svnrdump load</command>
            requires that the target repository have revision property
            changes enabled via the pre-revprop-change hook.  See
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/> for details.</para>
      -->
          <para>因为在提交完新的版本号后, 版本号的属性将被修改, 所以
            <command>svnrdump load</command> 要求目标仓库通过钩子
            pre-revprop-change, 允许修改版本号属性, 更多信息见
            <xref linkend="svn.ref.reposhooks"/> 的
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" />.</para>
        </note>

      <!--
        <para>As you might expect, you can use
          <command>svnadmin</command> and <command>svnrdump</command>
          in concert.  You can, for example, use <command>svnrdump
          dump</command> to generate a dump stream from a remote
          repository, and pipe the results thereof through
          <command>svnadmin load</command> to copy all that repository
          history into a local repository.  Or you can do the reverse,
          copying history from a local repository into a remote
          one.</para>
      -->
        <para>管理员可以一起使用 <command>svnadmin</command> 和
          <command>svnrdump</command>, 例如用 <command>svnrdump dump</command>
          从远程仓库获取转储流, 然后再把结果通过管道输送给 <command>svnadmin
            load</command>, 把远程仓库历史复制到本地仓库, 或者反之, 把本地仓库
          的历史复制到远程仓库.</para>

        <tip>
      <!--
          <para>By using <literal>file://</literal>
            URLs, <command>svnrdump</command> can also access local
            repositories, but it will be doing so via Subversion's
            Repository Access (RA) abstraction layer&mdash;you'll get
            better performance out of <command>svnadmin</command> in
            such situations.</para>
      -->
          <para>如果使用 <literal>file://</literal> 形式的 URL,
            <command>svnrdump</command> 也能访问本地仓库, 但仍然需要借助
            Subversion 的仓库访问 (Repository Access, 简称 RA) 抽象层&mdash;
            这种情况下使用 <command>svnadmin</command> 会比较划算.</para>
        </tip>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <!--
      <title>Filtering Repository History</title>
      -->
      <title>过滤仓库历史</title>

      <!--
      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        ### TODO
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion generally
        doesn't provide an easy way to remove that
        data.<footnote><para>That's rather the reason you use version
        control at all, right?</para></footnote>  But inevitably, there
        will be times when you would like to manipulate the history of
        your repository.  You might need to strip out all instances of
        a file that was accidentally added to the repository (and
        shouldn't be there for whatever
        ### TODO
        reason).<footnote><para>Conscious, cautious removal of certain
        bits of versioned data is actually supported by real use
        cases.  That's why an <quote>obliterate</quote> feature has
        been one of the most highly requested Subversion features, and
        one which the Subversion developers hope to soon
        provide.</para></footnote>  Or, perhaps you have multiple
        projects sharing a single repository, and you decide to split
        them up into their own repositories.  To accomplish tasks such
        as these, administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>
      -->
      <para>因为 Subversion 在存储版本历史时, 大量地使用了二进制差异算法和
        数据压缩 (在完全不透明的数据库系统中是可选的), 如果管理员觉得不是很
        困难而手工地修改历史, 这是非常不明智的做法, 大家应该极力避免这样操作.
        数据一旦存储到仓库中, Subversion 通常不会允许管理员轻易地删除数据.
        <footnote><para>这不正是你使用版本控制系统的原因吗?</para></footnote>
        但总会出现需要修改仓库历史的情况, 例如从历史中抹去与某个文件相关的所
        有记录, 这个文件出现在历史中只是个意外 (或者因为其他一些原因).
        <footnote><para>从版本化的数据中删除某些数据实际上是允许的,
            <quote>清除</quote> 特性是 Subversion 必须提供的功能之一, 也是
            Subversion 开发人员想尽快实现的功能之一.</para></footnote> 又或者
        是多个项目本来共享同一个仓库, 现在你想把它们分别存放到自己独享的一个
        仓库中. 为了完成这些任务, 仓库数据需要向管理员提供更加容易管理和延展
        的表示形式&mdash;Subversion 仓库转储格式.</para>

      <!--
      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> or <command>svnrdump
        dump</command> command to generate the dump data,
        and <command>svnadmin load</command> or <command>svnrdump
        load</command> to populate a new repository with it.  The
        great thing about the human-readability aspect of the dump
        format is that, if you aren't careless about it, you can
        manually inspect and modify it.  Of course, the downside is
        that if you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>
      -->
      <para>我们已经在 <xref linkend="svn.reposadmin.maint.migrate" /> 说过,
        Subversion 的仓库转储格式是用户提交到仓库中的修改的表示形式, 它是人类
        可读懂的. 使用 <command>svnadmin dump</command> 或 <command>svnrdump
          dump</command> 获取转储数据, 用 <command>svnadmin load</command>
        或 <command>svnrdump load</command> 把转储数据加载到仓库中. 采用人类
        可读的转储格式的最大好处是用户可以手工地查看和修改转储文件. 当然, 坏
        处是如果转储文件非常庞大 (例如包含了三年历史的转储数据), 手工地查看和
        修改转储文件将会非常耗时.</para>

      <!--
      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>
      -->
      <para>所以我们需要 <command>svndumpfilter</command>. 它可以作为仓库
        转储流的基于路径的过滤器, 用户所要做的就是向它提供希望保留或删除的路
        径列表, 然后把仓库转储流以管道的方式输送给
        <command>svndumpfilter</command>, 最终得到的转储数据就只会包含用户
        (显式地或隐式地) 希望保留的路径.</para>

      <!--
      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>
      -->
      <para>现在介绍一个使用 <command>svndumpfilter</command> 的实际例子. 本章
        早些时候 (见 <xref linkend="svn.reposadmin.projects.chooselayout"/>),
        我们讨论了如何规划仓库的布局&mdash;为每一个项目创建一个单独的仓库, 或
        者把所有的项目都放在一个仓库中, 或其他布局. 但是随着工作的进行, 用户
        可能会觉得仓库的布局需要做一些修改, 比较常见的修改是把原本放在同一个
        仓库中的多个项目, 分别放到属于自己的一个单独的仓库中.</para>

      <!--
      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>
      -->
      <para>假设我们的仓库包含了三个项目: <literal>calc</literal>,
        <literal>calendar</literal> 和 <literal>spreadsheet</literal>, 它们在
        仓库中的位置如下:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <!--
      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>
      -->
      <para>为了把三个项目分开存放到三个仓库, 首先转储整个仓库:</para>

      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
      </informalexample>

      <!--
      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>
      -->
      <para>然后, 用 <command>svndumpfilter</command> 过滤转储文件, 每次过滤
        一个项目的顶层目录, 得到三个新的转储文件:</para>

      <informalexample>
        <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>
      </informalexample>

      <!--
      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>
      -->
      <para>这时候, 你必须做出决定. 每一个转储文件都将创建一个有效的仓库,
        但保留的路径与原仓库中的路径一模一样, 也就是说即使你想为项目
        <literal>calc</literal> 创建一个单独的仓库, 根据转储文件创建出的
        仓库也会有顶层目录 <filename>calc</filename> 存在. 如果想把目录
        <filename>trunk</filename>, <filename>tags</filename> 和
        <filename>branches</filename> 放在仓库的根目录下, 你可能希望能够
        修改转储文件, 调整头部 <literal>Node-path</literal> 和
        <literal>Node-copyfrom-path</literal>, 使得它们不再包含路径分量
        <filename>calc/</filename>. 并且, 你可能还想删除创建目录
        <filename>calc</filename> 的转储数据, 这部分的转储数据看起来就像下面
        这样:</para>

      <informalexample>
        <programlisting>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</programlisting>
      </informalexample>

      <warning>
      <!--
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      -->
        <para>如果你已经决定手工地修改转储文件, 以便删除顶层目录, 一定要确保
          你所用的编辑器不会自动地把行结束符转换成本地格式 (例如把
          <literal>\r\n</literal> 转换成 <literal>\n</literal>), 以免文件的
          内容与元数据不一致. 否则的话, 转储文件将变成一堆废纸.</para>
      </warning>

      <!--
      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>
      -->
      <para>剩下的工作就是创建三个新的仓库, 然后分别加载对应的转储文件, 并忽略
        在转储流中发现的 UUID:</para>

      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
      </informalexample>

      <!--
      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>
      -->
      <para><command>svndumpfilter</command> 的两个子命令都支持用于决定如何
        处理 <quote>空</quote> 版本号的选项. 如果一个版本号只包含了被过滤掉的
        路径的修改, 就可以把这个空的版本号当成不需要的版本号. 为了允许用户
        决定如何处理这两种版本号, <command>svndumpfilter</command> 提供了以
        下选项:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
      <!--
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
      -->
            <para>不要生成空版本号&mdash;直接忽略它们.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
      <!--
            <para>If empty revisions are dropped (using the
              <option>- -drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
      -->
            <para>如果空版本号被丢弃 (通过选项
              <option>--drop-empty-revs</option>), 修改后面所有的版本号的号码,
              使得版本号号码是连续的.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
      <!--
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
      -->
            <para>如果空版本号未被丢弃, 则保留它们的版本号属性 (日志消息,
              作者, 日期, 和其他自定义的属性). 如果未指定该选项, 则该版本号
              将只会包含原始的提交日期和一条生成的日志消息, 该消息指出版本号
              是被 <command>svndumpfilter</command> 清空的.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      <!--
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>
      -->
      <para>虽然 <command>svndumpfilter</command> 非常实用, 而且可以节省
        大量的时间, 但它仍然有几点需要特别注意的地方. 首先, 命令对路径语义
        非常敏感. 要特别注意转储文件中的路径是否以斜杠开始, 即头部
        <literal>Node-path</literal> 和 <literal>Node-copyfrom-path</literal>.
      </para>

      <informalexample>
        <programlisting>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</programlisting>
      </informalexample>

      <!--
      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an
        inconsistent usage of leading slashes for some
        reason,<footnote><para>While <command>svnadmin dump</command>
        has a consistent leading slash policy (to not include them),
        other programs that generate dump data might not be so
        consistent.</para></footnote> you should probably normalize
        those paths so that they all have, or all lack, leading
        slashes.</para>
      -->
      <!-- ### FIXME: Is this still accurate?
                             Surely we've fixed ### this by now! -->
      <para>如果路径以斜杠开始 (也就是说路径含有前导斜杠), 那么
        <command>svndumpfilter include</command> 
        和 <command>svndumpfilter exclude</command> 的路径参数也应该以斜杠
        开始 (反之亦然). 更进一步, 如果转储文件对前导斜杠的使用不太一致,
        <footnote><para><command>svnadmin dump</command> 对前导斜杠的处理
            策略总是一致的 (不包含前导斜杠), 生成转储数据的其他程序就不一定
            了.</para></footnote> 那你应该对路径进行规范化处理, 使得它们全部
        都有 (或都没有) 前导斜杠.</para>

      <!--
      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        ### TODO
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>
      -->
      <para>另外, 被复制的路径也可能会带来一些麻烦. Subversion 支持在仓库中
        执行复制操作&mdash;通过复制已存在的路径来创建新的路径. 在仓库的生命
        周期中, 有可能出现这种时刻: 你从一个被 <command>svndumpfilter</command>
        排除的位置复制了一个文件或目录, 放到另一个被
        <command>svndumpfilter</command> 包含的位置上. 为了保证转储数据是自我
        满足的, <command>svndumpfilter</command> 仍然需要显示新路径的添加
        &mdash;包含了通过复制而创建的文件的所有内容&mdash;但并不把新路径的添加
        表示成某个源路径的复制, 因为这个源路径在已过滤的转储数据中并不存在.
        但是因为 Subversion 的转储格式只会显示每个版本号中发生变化的内容,
        而源数据可能没那么容易做到随时可用. 如果管理员觉得在仓库中存在这种
        类型的复制, 那就要重新考虑被包含或排除的路径, 或许应该包含在复制操作
        中充当数据源的路径.</para>

      <!--
      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>
      -->
      <para>最后, <command>svndumpfilter</command> 在过滤路径时采取的是非常
        字面的理解. 如果你试图复制一个根目录为
        <filename>trunk/my-project</filename> 的仓库的历史, 到它自己的仓库中,
        那你就要用 <command>svndumpfilter include</command> 保留
        <filename>trunk/my-project</filename> 内的所有修改, 但是生成的转储
        文件对于将来加载它的仓库没有任何假定. 特别地, 转储文件可能以添加目录
        <filename>trunk/my-project</filename> 的版本号作为开始, 但它
        <emphasis>不会</emphasis> 包含创建目录 <filename>trunk</filename> 的
        版本号 (因为 <filename>trunk</filename> 不匹配包含过滤器). 管理员需要
        确保在加载转储文件前, 转储文件期望存在的目录在目标仓库中确实存在.
      </para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <!--
      <title>Repository Replication</title>
      -->
      <title>仓库复制</title>

      <!--
      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>
      -->
      <para>有时候, 如果仓库的历史能和另一个仓库保持一模一样, 那么在完成很
        多事情时将会变得非常方便. 比如最明显的一个就是当主仓库无法访问时
        (可能是系统硬件故障, 网络故障等), 把服务切换到备份仓库. 其他场景
        还包括利用镜像仓库, 把访问负载分散到多台服务器上, 实现软升级等.</para>

      <!--
      <para>Subversion provides a program for managing scenarios such
        as these.  <command>svnsync</command> works by essentially
        asking the Subversion server to <quote>replay</quote>
        revisions, one at a time.  It then uses that revision
        information to mimic a commit of the same to another
        repository.  Neither repository needs to be locally accessible
        to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>
      -->
      <para>Subversion 提供了 <command>svnsync</command> 实现仓库的复制.
        <command>svnsync</command> 的工作本质上就是要求 Subversion 服务
        <quote>重放</quote> 版本号, 每次一个, 然后利用这个版本号的相关信息,
        在另一个仓库中模拟一个相同的提交. 仓库所在的主机和执行
        <command>svnsync</command> 的主机不必是同一台&mdash;如果命令的参数
        是仓库的 URL, <command>svnsync</command> 将通过 Subversion 的仓库访问
        (Repository Access, RA) 接口完成工作. <command>svnsync</command>
        所要求的就是源仓库的读权限和目标仓库的读写权限.</para>

      <note>
      <!--
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
      -->
        <para><command>svnsync</command> 要求远程的源仓库的 Subversion 版本
          必须至少是 1.4.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync">
      <!--
        <title>Replication with svnsync</title>
      -->
        <title>使用 svnsync 复制仓库</title>

      <!--
        <para>Assuming you already have a source repository that you'd
          like to mirror, the next thing you need is a target repository
          that will actually serve as that mirror.  This target
          repository can use either of the available filesystem
          data-store backends (see
          <xref linkend="svn.reposadmin.basics.backends"
          />)&mdash;Subversion's abstraction layers ensure that such
          details don't matter.  But by default, it must
          not yet have any version history in it.  (We'll discuss an
          exception to this later in this section.)</para>
      -->
        <para>假设你已经有了一个源仓库, 现在想为它创建一个镜像, 下一件需要准备
          的东西就是充当镜像的目标仓库. 这个目标仓库可以使用与源仓库不同的
          后端存储机制 (见 <xref linkend="svn.reposadmin.basics.backends" />)
          &mdash;Subversion 的抽象层保证了具体的后端存储不会对复制操作产生
          影响. 但是在默认情况下, 目标仓库此时不能包含任何版本历史 (我们将在
          本节的后面介绍一种例外情况).</para>
  
      <!--
        <para>The protocol that <command>svnsync</command> uses to
          communicate revision information is highly sensitive to
          mismatches between the versioned histories contained in the
          source and target repositories.  For this reason,
          while <command>svnsync</command>
          cannot <emphasis>demand</emphasis> that the target repository
          be read-only,<footnote><para>In fact, it can't truly be
          read-only, or <command>svnsync</command> itself would have a
          tough time copying revision history into it.</para></footnote>
          allowing the revision history in the target repository to
          change by any mechanism other than the mirroring process is a
          recipe for disaster.</para>
      -->
        <para><command>svnsync</command> 用于交流版本号信息的协议对源仓库与
          目标仓库不匹配的版本历史非常敏感, 因此, 虽然
          <command>svnsync</command> 并没有 <emphasis>要求</emphasis> 目标
          仓库是只读的,<footnote><para>实际上, 目标仓库不能是完全只读的, 否则
              的话, <command>svnsync</command> 就不能有效地复制历史.</para>
          </footnote>除了 <command>svnsync</command>, 如果还允许其他进程或
          用户修改目标仓库的历史, 常常会导致灾难性的后果.</para>

        <warning>
      <!--
          <para>Do <emphasis>not</emphasis> modify a mirror repository
            in such a way as to cause its version history to deviate
            from that of the repository it mirrors.  The only commits
            and revision property modifications that ever occur on that
            mirror repository should be those performed by the
            <command>svnsync</command> tool.</para>
      -->
          <para>不要用除了 <command>svnsync</command> 之外的其他方法修改镜像
            仓库, 使得镜像仓库偏离源仓库的历史. 发生在镜像仓库的提交和版本号
            属性修改只能由 <command>svnsync</command> 完成.</para>
        </warning>

      <!--
        <para>Another requirement of the target repository is that the
          <command>svnsync</command> process be allowed to modify
          revision properties.  Because <command>svnsync</command> works
          within the framework of that repository's hook system, the
          default state of the repository (which is to disallow revision
          property changes; see <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) is insufficient.
          You'll need to explicitly implement the pre-revprop-change
          hook, and your script must allow <command>svnsync</command>
          to set and change revision properties.  With those
          provisions in place, you are ready to start mirroring
          repository revisions.</para>
      -->
        <para>对目标仓库的另一项要求是允许 <command>svnsync</command> 修改版
          本号属性. 因为 <command>svnsync</command> 仍然受到目标仓库的钩子的
          影响, 而仓库的默认配置还不全面 (见 <xref
            linkend="svn.ref.reposhooks"/> 的 <xref
            linkend="svn.ref.reposhooks.pre-revprop-change" />). 管理员需要
          显式地实现钩子 pre-revprop-change, 在钩子脚本中允许设置和修改版本号
          属性. 如果这些条件都满足了, 那么创建镜像前的工作就已经准备就绪了.
        </para>

        <tip>
      <!--
          <para>It's a good idea to implement authorization measures
            that allow your repository replication process to perform
            its tasks while preventing other users from modifying the
            contents of your mirror repository at all.</para>
      -->
          <para>一种很好的做法是实现一种授权方式, 使得除了执行复制操作的
            进程外, 不允许任何其他用户或程序修改镜像仓库.</para>
        </tip>

      <!--
        <para>Let's walk through the use of <command>svnsync</command>
          in a somewhat typical mirroring scenario.  We'll pepper this
          discourse with practical recommendations, which you are free to
          disregard if they aren't required by or suitable for your
          environment.</para>
      -->
        <para>现在我们将介绍一个使用 <command>svnsync</command> 的典型场景,
          如果读者觉得这里介绍的情况与自己的环境不太符合, 大可不必理会我们
          的例子.</para>

      <!--
        <para>We will be mirroring the public Subversion repository
          which houses the source code for this very book and exposing
          that mirror publicly on the Internet, hosted on a different
          machine than the one on which the original Subversion source
          code repository lives.  This remote host has a global
          configuration that permits anonymous users to read the
          contents of repositories on the host, but requires users to
          authenticate to modify those repositories.  (Please forgive
          us for glossing over the details of Subversion server
          configuration for the moment&mdash;those are covered
          thoroughly in <xref linkend="svn.serverconfig" />.)  And for
          no other reason than that it makes for a more interesting
          example, we'll be driving the replication process from a
          third machine&mdash;the one that we currently find ourselves
          using.</para>
      -->
        <para>我们将会对存放本书源代码的 Subversion 仓库创建镜像仓库, 并把镜
          像仓库发布到 Internet 上, 镜像仓库将托管在与源仓库不同的主机上.
          本书的源代码仓库允许匿名只读访问, 但修改仓库需要验证身份. (这里先
          不介绍如何配置 Subversion 服务器, 这是 <xref
            linkend="svn.serverconfig" /> 的主题.) 为了使例子更加有趣, 我们
          将在第三台主机上发起复制操作&mdash;例如笔者当前正在使用的主机.</para>

      <!--
        <para>First, we'll create the repository which will be our
          mirror.  This and the next couple of steps do require shell
          access to the machine on which the mirror repository will
          live.  Once the repository is all configured, though, we
          shouldn't need to touch it directly again.</para>
      -->
        <para>首先, 创建用作镜像的仓库. 这一步及后面的两个步骤都要求托管镜像
          仓库的主机提供 shell 访问权限, 一旦仓库配置完成, 就不用再直接访问
          主机.</para>

        <informalexample>
          <screen>
$ ssh admin@svn.example.com "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>
        </informalexample>

      <!--
        <para>At this point, we have our repository, and due to our
          server's configuration, that repository is now
          <quote>live</quote> on the Internet.  Now, because we don't
          want anything modifying the repository except our replication
          process, we need a way to distinguish that process from other
          would-be committers.  To do so, we use a dedicated username
          for our process.  Only commits and revision property
          modifications performed by the special username
          <literal>syncuser</literal> will be allowed.</para>
      -->
        <para>现在, 我们已经有了一个自己的仓库, 得益于服务器的配置, 我们可以
          在 Internet 上访问到仓库. 因为我们不希望除了复制之外的其他过程修改
          仓库, 所以需要把除了复制之外的其他修改操作区分出来. 为了实现这个
          目标, 为复制过程使用一个专用的用户名, 只有使用用户名
          <literal>syncuser</literal> 提交的修改才会被允许.</para>

      <!--
        <para>We'll use the repository's hook system both to allow the
          replication process to do what it needs to do and to enforce
          that only it is doing those things.  We accomplish this by
          implementing two of the repository event
          hooks&mdash;pre-revprop-change and start-commit.  Our
          pre-revprop-change hook script is found
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />, and basically verifies that the user attempting the
          property changes is our <literal>syncuser</literal> user.  If
          so, the change is allowed; otherwise, it is denied.</para>
      -->
        <para>我们将使用 Subversion 的钩子系统保证复制过程可以完成它需要
          完成的操作, 并且只有它能够做这些事情. 为此我们需要实现两个钩子
          &mdash;pre-revprop-change 和 start-commit. 我们的 pre-revprop-change
          钩子脚本的内容见 <xref
            linkend="svn.reposadmin.maint.replication.pre-revprop-change" />,
          基本思路是如果试图修改属性的用户是 <literal>syncuser</literal>, 则
          允许; 否则禁止修改属性.</para>

        <example id="svn.reposadmin.maint.replication.pre-revprop-change">
      <!--
          <title>Mirror repository's pre-revprop-change hook script</title>
      -->
          <title>镜像仓库的 pre-revprop-change 钩子脚本</title>
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
        </example>

      <!--
        <para>That covers revision property changes.  Now we need to
          ensure that only the <literal>syncuser</literal> user is
          permitted to commit new revisions to the repository.  We do
          this using a start-commit hook script
          such as the one in <xref
          linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>
      -->
      <para>上面的脚本针对的是版本号属性的修改. 现在考虑如何做到只允许用户
        <literal>syncuser</literal> 向仓库提交新的版本号, 这需要用到
        start-commit 钩子脚本, 如 <xref
          linkend="svn.reposadmin.maint.replication.start-commit" /> 所示.
      </para>

        <example id="svn.reposadmin.maint.replication.start-commit">
      <!--
          <title>Mirror repository's start-commit hook script</title>
      -->
          <title>镜像仓库的 start-commit 钩子脚本</title>
  
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
        </example>

      <!--
        <para>After installing our hook scripts and ensuring that they
          are executable by the Subversion server, we're finished with
          the setup of the mirror repository.  Now, we get to actually
          do the mirroring.</para>
      -->
        <para>安装了我们的钩子脚本后, 并确保 Subversion 服务器对脚本具有可
          执行权限, 镜像仓库这边的设置就算结束了, 现在开始真正地创建镜像.
        </para>

      <!--
        <para>The first thing we need to do with
          <command>svnsync</command> is to register in our target
          repository the fact that it will be a mirror of the source
          repository.  We do this using the <command>svnsync
          initialize</command> subcommand.  The URLs we provide point
          to the root directories of the target and source
          repositories, respectively.  In Subversion 1.4, this is
          required&mdash;only full mirroring of repositories is
          permitted.  Beginning with Subversion 1.5, though, you can
          use <command>svnsync</command> to mirror only some subtree
          of the repository, too.</para>
      -->
        <para>使用 <command>svnsync</command> 做的第一件事就是告诉目标仓库,
          它是源仓库的镜像, 这会用到子命令 <command>svnsync
            initialize</command>, 目标仓库与源仓库的 URL 将作为命令的参数.
          Subversion 1.4 要求镜像必须针对整个仓库, 从 Subversion 1.5 开始,
          允许只对仓库的子目录创建镜像.</para>

        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     https://svn.code.sf.net/p/svnbook/source \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0 (svn:sync-* properties skipped).
NOTE: Normalized svn:* properties to LF line endings (1 rev-props, 0 node-props).
$
</screen>
        </informalexample>

      <!--
        <para>Our target repository will now remember that it is a
          mirror of the public Subversion source code repository.
          Notice that we provided a username and password as arguments
          to <command>svnsync</command>&mdash;that was required by the
          pre-revprop-change hook on our mirror repository.</para>
      -->
        <para>目标仓库现在已经记住它是本书源码仓库的镜像. 需要注意的是我们向
          <command>svnsync</command> 提供了用户名和密码&mdash;这是镜像仓库
          的 pre-revprop-change 钩子所要求的.</para>

        <note>
      <!--
          <para>In Subversion 1.4, the values given to
            <command>svnsync</command>'s <option>- -username</option> and
            <option>- -password</option> command-line options were used
            for authentication against both the source and destination
            repositories.  This caused problems when a user's
            credentials weren't exactly the same for both repositories,
            especially when running in noninteractive mode (with the
            <option>- -non-interactive</option> option).  This was
            fixed in Subversion 1.5 with the introduction of two new
            pairs of options.  Use
            <option>- -source-username</option> and
            <option>- -source-password</option> to provide authentication
            credentials for the source repository; use
            <option>- -sync-username</option> and
            <option>- -sync-password</option> to provide credentials for
            the destination repository.  (The old
            <option>- -username</option> and <option>- -password</option>
            options still exist for compatibility, but we advise against
            using them.)</para>
      -->
          <para>在 Subversion 1.4, <command>svnsync</command> 选项
            <option>--username</option> 和 <option>--password</option> 的值
            同时用于源仓库和目标仓库的身份验证, 如果用户在两个仓库中的证书
            不是完全一样, 就会造成问题, 尤其是命令在非交互模式下运行时
            (通过添加选项 <option>--non-interactive</option>), Subversion 1.5
            通过引入两对新的选项解决了这个问题. 选项
            <option>--source-username</option> 和
            <option>--source-username</option> 用于指定源仓库的身份验证证书;
            选项 <option>--sync-username</option> 和
            <option>--sync-password</option> 用于指定目标仓库的身份验证证书.
            (为了兼容旧版本, 仍然保留旧选项 <option>--username</option> 和
            <option>--password</option>, 但我们建议使用新选项.)</para>
        </note>

      <!--
        <para>And now comes the fun part.  With a single subcommand, we
          can tell <command>svnsync</command> to copy all the
          as-yet-unmirrored revisions from the source repository to the
          target.<footnote><para>Be forewarned that while it will take
          only a few seconds for the average reader to parse this
          paragraph and the sample output that follows it, the actual
          time required to complete such a mirroring operation is, shall
          we say, quite a bit longer.</para></footnote> The
          <command>svnsync synchronize</command> subcommand will peek
          into the special revision properties previously stored on the
          target repository and determine how much of the source
          repository has been previously mirrored&mdash;in this case,
          the most recently mirrored revision is r0.  Then it will query
          the source repository and determine what the latest revision
          in that repository is.  Finally, it asks the source
          repository's server to start replaying all the revisions
          between 0 and that latest revision.  As
          <command>svnsync</command> gets the resultant response from
          the source repository's server, it begins forwarding those
          revisions to the target repository's server as new
          commits.</para>
      -->
        <para>现在到了最有趣的部分. 只要一个命令, 就能要求
          <command>svnsync</command> 把源仓库中未复制的版本号, 复制到目标
          仓库.<footnote><para>虽然阅读这段文字和例子只需要几秒钟的时间,
              但 <command>svnsync</command> 实际消耗的时间比这长得多.</para>
          </footnote> 子命令 <command>svnsync synchronize</command> 查看
          存放在目标仓库中的特殊的版本号属性, 从而确定源仓库的镜像进度&mdash;
          在这个例子里, 最近一次创建镜像的版本号是 r0. 然后
          <command>svnsync</command> 查询源仓库, 确定源仓库最新的版本号是多少,
          最后请求源仓库的服务器开始重放从 0 到最新版本号之间的所有版本号.
          随着 <command>svnsync</command> 不断地从源仓库服务器获取到结果,
          它开始把版本号作为新提交, 转发到目标仓库服务器上.</para>

        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL [SOURCE_URL]

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      https://svn.code.sf.net/p/svnbook/source
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data .
Committed revision 4063.
Copied properties for revision 4063.
Transmitting file data .
Committed revision 4064.
Copied properties for revision 4064.
Transmitting file data ....
Committed revision 4065.
Copied properties for revision 4065.
$
</screen>
        </informalexample>

      <!--
        <para>Of particular interest here is that for each mirrored
          revision, there is first a commit of that revision to the
          target repository, and then property changes follow.  This
          two-phase replication is required because the initial commit
          is performed by (and attributed to) the user
          <literal>syncuser</literal> and is datestamped with the time
          as of that revision's creation.  <command>svnsync</command>
          has to follow up with an immediate series of property
          modifications that copy into the target repository all the
          original revision properties found for that revision in the
          source repository, which also has the effect of fixing the
          author and datestamp of the revision to match that of the
          source repository.</para>
      -->
        <para>其中比较有趣的地方是, 对于每一个需要创建镜像的版本号, 首先向
          目标仓库提交该版本号, 然后再修改版本号属性. 之所以需要这种两步骤
          的复制是因为提交操作由用户 <literal>syncuser</literal> 完成, 版本
          号的时间戳是创建时的时间, <command>svnsync</command> 接下来通过
          一系列的属性修改操作, 使得源仓库的版本号属性与目标仓库的版本号属性
          保持一致, 其中就包括修改版本号的作者和时间戳.</para>

      <!--
        <para>Also noteworthy is that <command>svnsync</command>
          performs careful bookkeeping that allows it to be safely
          interrupted and restarted without ruining the integrity of the
          mirrored data.  If a network glitch occurs while mirroring a
          repository, simply repeat the <command>svnsync
          synchronize</command> command, and it will happily pick up
          right where it left off.  In fact, as new revisions appear in
          the source repository, this is exactly what you do
          to keep your mirror up to date.</para>
      -->
        <para>还值得注意的一点是 <command>svnsync</command> 会记住工作的当
          前进度, 从而允许操作被中断, 并在以后的某个时间人上次中断的地方
          重新开始. 如果在命令执行的过程中, 网络临时断开, 只要再次执行
          <command>svnsync synchronize</command> 即可. 实际上, 如果有新的
          版本号出现在源仓库中, 你所需要做的也就是执行 <command>svnsync
            synchronize</command> 而已.</para>

        <warning>
      <!--
          <para>As part of its bookkeeping, <command>svnsync</command>
            records in the mirror repository the URL with which the
            mirror was initialized.  Because of this, invocations of
            <command>svnsync</command> which follow the initialization
            step do not <emphasis>require</emphasis> that you provide
            the source URL on the command line again.  However, for
            security purposes, we recommend that you continue to do so.
            Depending on how it is deployed, it may not be safe for
            <command>svnsync</command> to trust the source URL which it
            retrieves from the mirror repository, and from which it
            pulls versioned data.</para>
      -->
          <para>作为记账操作的一部分, <command>svnsync</command> 在镜像仓库
            记录了源仓库的 URL. 正是因为这个原因, 在初始化后执行的
            <command>svnsync</command> 命令不会 <emphasis>要求</emphasis>
            在命令行上必须提供源仓库的 URL. 但是为了安全起见, 我们建议用户继
            续在命令行上提供源仓库的 URL 参数. 取决定于具体的部署方式,
            在镜像仓库检索源仓库信息, 或推送版本化数据时, 任凭
            <command>svnsync</command> 信任源仓库 URL 可能不太安全.</para>
        </warning>

        <sidebar>
      <!--
          <title>svnsync Bookkeeping</title>
      -->
          <title>svnsync 记账</title>

      <!--
          <para><command>svnsync</command> needs to be able to set and
            modify revision properties on the mirror repository because
            those properties are part of the data it is tasked with
            mirroring.  As those properties change in the source
            repository, those changes need to be reflected in the mirror
            repository, too.  But <command>svnsync</command> also uses a
            set of custom revision properties&mdash;stored in revision 0
            of the mirror repository&mdash;for its own internal
            bookkeeping.  These properties contain information such as
            the URL and UUID of the source repository, plus some
            additional state-tracking information.</para>
      -->
          <para><command>svnsync</command> 必须有能力修改镜像仓库的版本号
            属性, 因为这些属性是镜像数据的一部分. 如果版本号属性在源仓库
            被修改了, 这些修改也要反应到镜像仓库中. 但是
            <command>svnsync</command> 还会用到一套定制的版本号属性集合&mdash;
            存放在镜像仓库的版本号 0 上&mdash;用作内部的记账操作. 这些属性
            包含的信息包括源仓库的 URL 和 UUID, 还有一些状态跟踪信息.</para>

      <!--
          <para>One of those pieces of state-tracking information is a
            flag that essentially just means <quote>there's a
            synchronization in progress right now.</quote> This is used
            to prevent multiple <command>svnsync</command> processes
            from colliding with each other while trying to mirror data
            to the same destination repository.  Now, generally you
            won't need to pay any attention whatsoever to
            <emphasis>any</emphasis> of these special properties (all of
            which begin with the prefix <literal>svn:sync-</literal>).
            Occasionally, though, if a synchronization fails
            unexpectedly, Subversion never has a chance to remove this
            particular state flag.  This causes all future
            synchronization attempts to fail because it appears that a
            synchronization is still in progress when, in fact, none is.
            Fortunately, recovering from this situation is easy to do.
            In Subversion 1.7, you can use the newly introduced
            <option>- -steal-lock</option> option with
            <command>svnsync</command>'s commands.  In previous
            Subversion versions, you need only to remove the
            <literal>svn:sync-lock</literal> property which serves as
            this flag from revision 0 of the mirror repository:</para>
      -->
          <para>状态跟踪信息中, 有一个标志信息用来指出 <quote>目前有同步操作
              正在进行中</quote>, 这是为了避免多个 <command>svnsync</command>
            往同一个目标仓库复制数据时, 产生冲突. 一般来说, 用户不用关心这些
            属性 (这些属性全都以 <literal>svn:sync-</literal> 开始), 但在少数
            情况下, 如果同步过程意外失败, Subversion 可能来不及删除这个状态
            标志, 这将导致后面的同步操作失败, 因为未删除的标志表明当前同步操作
            正在进行中 (但实际上并没有). 幸运的是, 从这种错误状态中恢复非常
            容易, 在 Subversion 1.7, 你可以通过为 <command>svnsync</command>
            添加新增的选项 <option>--steal-lock</option>; 如果 1.7 之前的版本,
            只需要删除镜像仓库版本号 0 上的属性
            <literal>svn:sync-lock</literal>:</para>

          <informalexample>
            <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
          </informalexample>

      <!--
          <para>Also, <command>svnsync</command> stores the source
            repository URL provided at mirror initialization time in a
            bookkeeping property on the mirror repository.  Future
            synchronization operations against that mirror which omit
            the source URL at the command line will consult the
            special <literal>svn:sync-from-url</literal> property
            stored on the mirror itself to know where to synchronize
            from.  This value is used literally by the synchronization
            process, though.  Be wary of using non-fully-qualified
            domain names (such as referring
            to <literal>svnbook.red-bean.com</literal> as
            simply <literal>svnbook</literal> because that happens to
            work when you are connected directly to
            the <literal>red-bean.com</literal> network), domain names
            which don't resolve or resolve differently depending on
            where you happen to be operating from, or IP addresses
            (which can change over time).  But here again, if you need
            an existing mirror to start referring to a different URL
            for the same source repository, you can change the
            bookkeeping property which houses that information.  Users
            of Subversion 1.7 or better can use <command>svnsync init
            - -allow-non-empty</command> to reinitialize their mirrors
            with new source URL:</para>
      -->
          <para>另外, <command>svnsync</command> 还会把源仓库的 URL 存放到
            镜像仓库的记账属性中. 如果在命令行中省略了源仓库的 URL, 后面的
            同步操作就使用镜像仓库的特殊属性
            <literal>svn:sync-from-url</literal> 的值, 作为源仓库的 URL.
            同步过程按照字面意义理解并使用属性值, 所以要小心使用非完全限定的
            域名 (例如用 <literal>svnbook</literal> 代替
            <literal>svnbook.red-bean.com</literal>, 这种域名只有在主机直接
            与 <literal>svnbook.red-bean.com</literal> 的网络相连时, 才能
            正常工作); 无法解析的域名; 网络环境不同, 解析也不同的域名; 以及
            IP 地址 (有可能发生变化). 如果用户需要把一个已存在的镜像仓库
            映射到另一个不同的 URL (但仍然是同一个源仓库), 可以修改存放该
            信息的记账属性. Subversion 1.7 及其新版可以使用
            <command>svnsync init --allow-non-empty</command> 重新初始化镜像
            仓库的源仓库 URL:</para>

          <informalexample>
            <screen>
$ svnsync initialize --allow-non-empty http://svn.example.com/svn-mirror \
                                       <replaceable>NEW-SOURCE-URL</replaceable>
Copied properties for revision 4065.
$
</screen>
          </informalexample>

      <!--
          <para>If you are running an older version of Subversion,
            you'll need to manually tweak
            the <literal>svn:sync-from-url</literal> bookkeeping
            property:</para>
      -->
          <para>如果 Subversion 版本较旧, 管理员需要手工调整记账属性
            <literal>svn:sync-from-url</literal> 的值:</para>
          
          <informalexample>
            <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>
          </informalexample>

      <!--
          <para>Another interesting thing about these special
            bookkeeping properties is that <command>svnsync</command>
            will not attempt to mirror any of those properties when they
            are found in the source repository.  The reason is probably
            obvious, but basically boils down to
            ### TODO
            <command>svnsync</command> not being able to distinguish the
            special properties it has merely copied from the source
            repository from those it needs to consult and maintain for
            its own bookkeeping needs.  This situation could occur if,
            for example, you were maintaining a mirror of a mirror of a
            third repository.  When <command>svnsync</command> sees its
            own special properties in revision 0 of the source
            repository, it simply ignores them.</para>
      -->
          <para>关于这些记账属性的另一件有趣的事情是: 如果
            <command>svnsync</command> 在源仓库也发现了这些记账用的属性,
            那么 <command>svnsync</command> 不会对这些属性进行镜像操作.
            原因是显然的, 但归结到 <command>svnsync</command> 身上, 其实是因
            为它无法区分从从源仓库复制来的记账属性和自己用来记账的属性.
            如果用户在维护一个仓库的镜像的镜像, 就会出现这种情况, 当
            <command>svnsync</command> 在源仓库版本号 0 上看到它自己的记账
            属性时, 就会直接忽略它们.</para>

      <!--
          <para>An <command>svnsync info</command> subcommand was
            added in Subversion 1.6 to easily display the special
            bookkeeping properties in the destination
            repository.</para>
      -->
          <para>Subversion 1.6 添加了新的子命令 <command>svnsync
              info</command>, 用来显示目标仓库的记账属性.</para>

          <informalexample>
            <screen>
$ svnsync help info
info: usage: svnsync info DEST_URL

Print information about the synchronization destination repository
located at DEST_URL.
&hellip;
$ svnsync info http://svn.example.com/svn-mirror
Source URL: https://svn.code.sf.net/p/svnbook/source
Source Repository UUID: 931749d0-5854-0410-9456-f14be4d6b398
Last Merged Revision: 4065
$
</screen>
          </informalexample>
        </sidebar>

      <!--
        <para>There is, however, one bit of inelegance in the process.
          Because Subversion revision properties can be changed at any
          time throughout the lifetime of the repository, and because
          they don't leave an audit trail that indicates when they were
          changed, replication processes have to pay special attention
          to them.  If you've already mirrored the first 15 revisions of
          a repository and someone then changes a revision property on
          revision 12, <command>svnsync</command> won't know to go back
          and patch up its copy of revision 12.  You'll need to tell it
          to do so manually by using (or with some additional tooling
          around) the <command>svnsync copy-revprops</command>
          subcommand, which simply rereplicates all the revision
          properties for a particular revision or range thereof.</para>
      -->
        <para>然而, <command>svnsync</command> 无法做到面面俱到. 因为用户可
          以在任意时刻修改版本号属性, 而且这些修改不会留下任何历史信息, 所以
          复制操作要特别注意这种情况. 假设你已经复制了仓库的前 15 个版本号,
          如果有人修改了版本号 12 的版本号属性, 则 <command>svnsync</command>
          不会知道这件事, 更不会回过头来重新复制版本号 12. 你必须使用
          子命令 <command>svnsync copy-revprops</command> (或者还需要一些额外
          工具的辅助), 把特定的或指定范围内的版本号的所有属性都复制过来.</para>

        <informalexample>
          <screen>
$ svnsync help copy-revprops
copy-revprops: usage:

    1. svnsync copy-revprops DEST_URL [SOURCE_URL]
    2. svnsync copy-revprops DEST_URL REV[:REV2]

&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>
        </informalexample>

      <!--
        <para>That's repository replication
          via <command>svnsync</command> in a nutshell.  You'll likely
          want some automation around such a process.  For example,
          while our example was a pull-and-push setup, you might wish to
          have your primary repository push changes to one or more
          blessed mirrors as part of its post-commit and
          post-revprop-change hook implementations.  This would enable
          the mirror to be up to date in as near to real time as is
          likely possible.</para>
      -->
        <para>为了使用 <command>svnsync</command> 复制仓库, 你可能想设置
          一个自动化过程. 比如说, 我们展示的例子的模式是
          <quote>抓取与推送</quote>, 你可能觉得更方便的做法是在钩子
          post-commit 和 post-revprop-change 完成版本号到镜像仓库的推送, 这种
          做法有助于镜像仓库时刻保持最新的状态.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-partial">
      <!--
        <title>Partial replication with svnsync</title>
      -->
        <title>使用 svnsync 进行部分复制</title>

      <!--
        <para><command>svnsync</command> isn't limited to full copies
          of everything which lives in a repository.  It can handle
          various shades of partial replication, too.  For example,
          while it isn't very commonplace to do so,
          <command>svnsync</command> does gracefully mirror repositories
          in which the user as whom it authenticates has only partial
          read access.  It simply copies only the bits of the repository
          that it is permitted to see.  Obviously, such a mirror is not
          useful as a backup solution.</para>
      -->
        <para><command>svnsync</command> 不仅限于复制仓库的全部内容, 它也能
          进行部分复制. 一个常见的例子是, 如果用户只对仓库的部分内容具有读取
          权限, 那么 <command>svnsync</command> 也能优雅地对仓库进行镜像,
          但是它只会复制它能读取到的仓库内容. 显然, 这种镜像并不能作为有效
          的仓库备份策略.</para>

      <!--
        <para>As of Subversion 1.5, <command>svnsync</command> also
          has the ability to mirror a subset of a repository rather than
          the whole thing.  The process of setting up and maintaining
          such a mirror is exactly the same as when mirroring a whole
          repository, except that instead of specifying the source
          repository's root URL when running <command>svnsync
          init</command>, you specify the URL of some subdirectory
          within that repository.  Synchronization to that mirror will
          now copy only the bits that changed under that source
          repository subdirectory.  There are some limitations to this
          support, though.  First, you can't mirror multiple disjoint
          subdirectories of the source repository into a single mirror
          repository&mdash;you'd need to instead mirror some parent
          directory that is common to both.  Second, the filtering
          logic is entirely path-based, so if the subdirectory you are
          mirroring was renamed at some point in the past, your mirror
          would contain only the revisions since the directory appeared
          at the URL you specified.  And likewise, if the source
          subdirectory is renamed in the future, your synchronization
          processes will stop mirroring data at the point that the
          source URL you specified is no longer valid.</para>
      -->
        <para>从 Subversion 1.5 开始, <command>svnsync</command> 支持对仓库
          的子目录进行复制. 在复制时, 除了用把 <command>svnsync init</command>
          的 URL 参数指定成待复制的仓库子目录的 URL 外, 其余步骤和复制整个
          仓库是完全一样的. 现在同步过程就只会复制源仓库的子目录内的版本号,
          但有些限制条件需要注意. 首先, <command>svnsync</command> 不支持把
          源仓库内的多个不连贯的子目录复制到一个镜像仓库中&mdash;此时正确的
          做法应该是复制它们的公共父目录. 然后, 因为过滤操作是完全基于路径的,
          所以说如果被复制的子目录曾经被重命名过, 则镜像仓库只会包含在指定的
          URL 中出现的版本号. 类似的, 如果源仓库的子目录在将来被重命名了,
          则同步过程将无法继续, 因为你所指定的源仓库的子目录 URL 已经不再有效.
        </para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-init-nonempty">
      <!--
        <title>A quick trick for mirror creation</title>
      -->
        <title>创建镜像的小窍门</title>

      <!--
        <para>We mentioned previously the cost of setting up an
          initial mirror of an existing repository.  For many folks,
          the sheer cost of transmitting thousands&mdash;or
          millions&mdash;of revisions of history to a new mirror
          repository via <command>svnsync</command> is a show-stopper.
          Fortunately, Subversion 1.7 provides a workaround by way of
          a new <option>- -allow-non-empty</option> option to
          <command>svnsync initialize</command>.  This option allows
          you to initialize one repository as a mirror of another
          while bypassing the verification that the to-be-initialized
          mirror has no version history present in it.  Per our
          previous warnings about the sensitivity of this whole
          replication process, you should rightly discern that this is
          an option to be used only with great caution.  But it's
          wonderfully handy when you have administrative access to the
          source repository, where you can simply make a physical copy
          of the repository and then initialize that copy as a new
          mirror:</para>
      -->
        <para>前面我们已经介绍了为了给一个已存在的仓库创建镜像需要完成哪些
          工作. 对于很多人而言, 使用 <command>svnsync</command> 传送成千&mdash;
          甚至成百万&mdash;的版本号历史所带来的代价, 就像是看一场被掌声中断
          了很久的表演. 幸运的是, Subversion 1.7 提供了一个变通方
          法, 通过为 <command>svnsync initialize</command> 添加新选项
          <option>--allow-non-empty</option>, 该选项允许用户在把仓库初始化成
          另一个仓库的镜像时, 不去检查将被初始化的镜像仓库是否含有版本历史.
          通过前面几次使用过程中的警告, 读者应该很快就能看出必须小心使用这个
          选项. 但是, 如果用户拥有源仓库的管理员权限, 那么这个选项就会非常
          方便, 因为用户可以直接复制仓库, 然后把复制出的仓库初始化成新镜像:
        </para>

        <informalexample>
          <screen>
$ svnadmin hotcopy /path/to/repos /path/to/mirror-repos
$ ### create /path/to/mirror-repos/hooks/pre-revprop-change
$ svnsync initialize file:///path/to/mirror-repos \
                     file:///path/to/repos
svnsync: E000022: Destination repository already contains revision history; co
nsider using --allow-non-empty if the repository's revisions are known to mirr
or their respective revisions in the source repository
$ svnsync initialize --allow-non-empty file:///path/to/mirror-repos \
                                       file:///path/to/repos
Copied properties for revision 32042.
$
</screen>
        </informalexample>

      <!--
        <para>Admins who are running a version of Subversion prior to
          1.7 (and thus do not have access to <command>svnsync
          initialize</command>'s <option>- -allow-non-empty</option>
          feature) can accomplish effectively the same thing that that
          feature does through <emphasis>careful</emphasis>
          manipulation of the r0 revision properties on the copy of
          the repository which is slated to become a mirror of the
          original.  Use <command>svnadmin setrevprop</command> to
          create the same bookkeeping properties
          that <command>svnsync</command> would have created
          there.</para>
      -->
        <para>如果管理员使用的 Subversion 版本低于 1.7 (即 <command>svnsync
            initialize</command> 不支持选项 <option>--allow-non-empty</option>),
          还可以通过其他手段实现相同的目的, 那就是 <emphasis>认真地</emphasis>
          修改仓库副本 (该副本将作为源仓库的镜像) 的版本号 r0 的属性, 使得
          r0 的属性与 <command>svnsync</command> 将会创建的记账属性相同.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.wrapup">
      <!--
        <title>Replication wrap-up</title>
      -->
        <title>复制小结</title>

      <!--
        <para>We've discussed a couple of ways to replicate revision
          history from one repository to another.  So let's look now
          at the user end of these operations.  How does replication
          and the various situations which call for it affect
          Subversion clients?</para>
      -->
        <para>本节讨论了几种用于复制版本号历史到其他仓库的方法, 现在从普通
          用户的角度看待这些操作: 仓库复制和各种不同情况下的执行方式将会如
          何影响客户端?</para>

      <!--
        <para>As far as user interaction with repositories and mirrors
          goes, it <emphasis>is</emphasis> possible to have a single
          working copy that interacts with both, but you'll have to
          jump through some hoops to make it happen.  First, you need
          to ensure that both the primary and mirror repositories have
          the same repository UUID (which is not the case by default).
          See <xref linkend="svn.reposadmin.maint.uuids" /> later in
          this chapter for more about this.</para>
      -->
        <para>如果用户需要同时和仓库及其镜像打交道, 那么使用一个
          <emphasis>单独的</emphasis> 工作副本同时与多个仓库交互是有可能做到
          的, 但要满足一些条件. 首先, 用户要确保主仓库和镜像仓库拥有相同的
          UUID (默认情况下并不相同), 关于仓库 UUID 的更多内容, 见
          <xref linkend="svn.reposadmin.maint.uuids" />.</para>
        
      <!--
        <para>Once the two repositories have the same UUID, you can use
          <command>svn relocate</command> to point your working
          copy to whichever of the repositories you wish to operate
          against, a process that is described in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref.svn"/>.  There is a possible danger here,
          though, in that if the primary and mirror repositories
          aren't in close synchronization, a working copy up to date
          with, and pointing to, the primary repository will, if
          relocated to point to an out-of-date mirror, become confused
          about the apparent sudden loss of revisions it fully expects
          to be present, and it will throw errors to that effect.  If
          this occurs, you can relocate your working copy back to the
          primary repository and then either wait until the mirror
          repository is up to date, or backdate your working copy to a
          revision you know is present in the sync repository, and
          then retry the relocation.</para>
      -->
        <para>一旦两个仓库拥有相同的 UUID, 用户就可以用命令 <command>svn
            relocate</command> 把工作副本重定向到任意一个仓库, 见
          <xref linkend="svn.ref.svn"/> 的 <xref
            linkend="svn.ref.svn.c.relocate" />. 但其中有一个潜在的问题: 如果
          主仓库和镜像仓库不是完全同步, 而工作副本当前指向主仓库, 并且处于最
          新的状态, 如果此时把工作副本重定向到过时的镜像仓库, 工作副本就会
          报错, 因为本来应该存在的版本号突然无缘无故的消失了. 如果发生了这种
          情况, 可以再把工作副本重定向回原来的主仓库, 然后等镜像仓库与主仓库
          完全同步, 或者把工作副本回退到在镜像仓库中存在的版本号, 然后再重
          定向工作副本.</para>

      <!--
        <para>Finally, be aware that the revision-based replication
          provided by <command>svnsync</command> is only
          that&mdash;replication of revisions.  Only the kinds of
          information carried by the Subversion repository dump file
          format are available for replication.  As such, tools such
          as <command>svnsync</command>
          (and <command>svnrdump</command>, which we discuss in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />)
          are limited in ways similar to that of the repository dump
          stream.  They do not include in their replicated information
          such things as the hook implementations, repository or
          server configuration data, uncommitted transactions, or
          information about user locks on repository paths.</para>
      -->
        <para>最后, 要注意 <command>svnsync</command> 所提供的基于版本号的
          复制流程只会复制版本号. 只有仓库转储文件格式所携带的信息类型才能
          用于复制, 因此, <command>svnsync</command> (以及
          <command>svnrdump</command>, 见
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />) 受到的
          限制与仓库转储流受到的限制类似, 它们不会复制已实现的钩子, 仓库或
          服务器的配置, 未提交的事务, 或用户施加在仓库路径上的锁.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <!--
      <title>Repository Backup</title>
      -->
      <title>仓库备份</title>

      <!--
      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>
      -->
      <para>自现代计算机诞生以来, 不管出现了多么先进的技术, 有一点总是挥之不
        去&mdash;有时候, 事情会变得非常糟糕. 即使是最小心翼翼的管理员, 也不得
        不面对断电, 网络故障, 内存与硬盘损坏. 因此本节的主题是如何备份仓库数
        据.</para>

      <!--
      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>
      -->
      <para>对于 Subversion 仓库管理员来说, 有两种备份策略&mdash;全量备份与
        增量备份. 全量备份涉及到在一个操作中记录所有的信息, 这些信息可以在
        灾难发生后, 重新构造出原来的仓库. 通常意味着复制整个仓库目录 (包括
        后端存储 Berkeley DB 或 FSFS 的数据). 增量备份每次记录的数据量相对
        较少: 它只备份上一次备份以来, 发生变化的仓库数据.</para>

      <!--
      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutiae involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>
      -->
      <para>对于全量备份来说, 这个笨拙的方法看起来似乎很合理, 但是除非管理员
        临时禁止对仓库的其他访问, 否则的话, 如果只是简单地复制目录, 得到的
        备份也可能是有问题的. Berkeley DB 的文档描述了一种特定的数据库文件
        复制顺序, 它可以保证得到的备份是有效的, 类似的复制顺序同样存在于 FSFS.
        管理员不用考虑如何实现它们所要求的复制顺序, 因为 Subversion 开发团队
        已经帮你实现好了, 命令 <command>svnadmin hotcopy</command> 会处理好
        仓库热拷贝涉及到的各种细枝末节, 它们调用方式就像 Unix 的
        <command>cp</command> 或 Windows 的 <command>copy</command> 那样简单:
      </para>

      <informalexample>
        <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>
      </informalexample>

      <!--
      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>
      -->
      <para>得到的备份是一个完整的 Subversion 仓库, 能够在原仓库出现故障时
        顶替上去.</para>

      <!--
      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>
      -->
      <para>围绕该命令, 还有其他一些额外的工具可供使用. Subversion 源代码目录
        <filename>tools/backup</filename> 存放了一个脚本:
        <command>hot-backup.py</command>. <command>hot-backup.py</command>
        在 <command>svnadmin hotcopy</command> 之上增加了一些备份管理策略,
        允许用户只保留最近几次的仓库备份. <command>hot-backup.py</command>
        自动管理通过备份得到的仓库目录的名字, 避免出现名字冲突, 而且会
        <quote>轮换</quote> 旧备份, 只保留最近的几次备份. 即使管理员使用的是
        增量备份策略, 也有使用 <command>hot-backup.py</command> 的需求. 例如
        管理员可以在调度程序 (比如 Unix 系统中的 <command>cron</command>)
        中执行 <command>hot-backup.py</command>, 从而实现每晚运行一次 (或
        管理员认为合适的其他时间间隔) 脚本.</para>

      <!--
      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with
        the <option>- -incremental</option> option to perform an
        incremental backup of a given revision or range of revisions.
        And of course, you can achieve a full backup variation of this
        by omitting the <option>- -incremental</option> option to that
        command.  There is some value in these methods, in that the
        format of your backed-up information is flexible&mdash;it's
        not tied to a particular platform, versioned filesystem type,
        or release of Subversion or the libraries it uses.  But that
        flexibility comes at a cost, namely that restoring that data
        can take a long time&mdash;longer with each new revision
        committed to your repository.  Also, as is the case with so
        many of the various backup methods, revision property changes
        that are made to already backed-up revisions won't get picked
        up by a nonoverlapping, incremental dump generation.  For
        these reasons, we recommend against relying solely on
        dump-based backup approaches.</para>
      -->
      <para>围绕仓库转储数据的生成与存放, 有些管理员会使用不同的备份方法.
        在 <xref linkend="svn.reposadmin.maint.migrate" /> 我们介绍了如何
        使用带有选项 <option>--incremental</option> 的 <command>svnadmin
          dump</command>, 在给定的版本号或版本号范围内执行增量备份. 当然,
        也可以忽略选项 <option>--incremental</option>, 实现一个完全备份.
        使用仓库转储数据的好处是这种备份信息的格式非常灵活&mdash;它与特定
        的平台, 仓库文件系统类型, Subversion 的版本及其所使用的函数库都是
        无关的. 但灵活性也带来了一定的开销, 就是需要较长的时间才能完全恢复
        数据&mdash;每当有一个新的版本号提交时, 时间就会变得更长一点. 另外,
        和其他备份方法相比, 如果修改了已经备份过的版本号的版本号属性, 这些
        修改将不会体现在增量的转储数据中. 由于这些原因, 我们建议读者不要单独
        依靠基于转储的备份策略.</para>

      <!--
      <para>Beginning with Subversion 1.8, <command>svnadmin hotcopy</command>
        accepts <option>- -incremental</option> option and supports incremental
        hotcopy mode for FSFS repositories.  In incremental hotcopy mode,
        revision data which has already been copied from the source to the
        destination repository will not be copied again. When
        <option>- -incremental</option> option is used with
        <command>svnadmin hotcopy</command>, Subversion will only copy new
        revisions, and revisions which have changed in size or had their
        modification time stamp changed since the previous hotcopy
        operation.  Moreover, unlike with <command>svnsync</command> or
        <command>svnadmin dump - -incremental</command>, performance of
        <command>svnadmin hotcopy - -incremental</command> is only limited to
        disk I/O.  Therefore, incremental hotcopy can be a huge
        time saver when making a backup of a large repository.</para>
      -->
      <para>从 Subversion 1.8 开始, <command>svnadmin hotcopy</command> 支持
        选项 <option>--incremental</option>, 允许对 FSFS 仓库进行增量热拷贝,
        在增量热拷贝模式下, 已经复制到目标仓库的版本号数据不会再复制一次.
        如果 <command>svnadmin hotcopy</command> 带上选项
        <option>--incremental</option>, Subversion 将只会复制新的版本号, 以及
        上一次热拷贝后, 大小或时间戳发生变化的版本号. 而且, 与
        <command>svnsync</command> 或 <command>svnadmin dump
          --incremental</command> 有所不同的是 <command>svnadmin hotcopy
          --incremental</command> 仅受限于磁盘的读写性能, 在备份大型仓库时,
        增量热拷贝可以节省大量的时间.</para>

      <!--
      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>
      -->
      <para>可以看到, 不同的备份方式都有各自的优点和缺点, 目前最简单的选择就
        是全量的热拷贝, 它总能得到一份可用的仓库副本, 一旦主仓库出现故障,
        只要简单地递归复制目录, 就能从备份仓库中恢复. 不幸的是, 如果同时存
        在多个仓库副本, 这些全量拷贝所消耗的磁盘空间将会是很可观的. 与此相对,
        生成增量副本更快, 消耗的磁盘空间也更少, 但是复原过程就比较痛苦了,
        经常需要应用多个增量备份. 其他几种备份方法也有各自的特点. 管理员需要
        在备份和复原的开销之间, 找到最适合的平衡点.</para>

      <!--
      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>
      -->
      <para><command>svnsync</command> (见 <xref
          linkend="svn.reposadmin.maint.replication" />) 提供了非常方便的折衷
        方案. 如果管理员周期性地把主仓库同步到只读的镜像仓库, 在主仓库发生
        故障时, 镜像仓库就会是一个很好的替补. 这种方法的主要缺点是只有版本化
        的仓库数据才会被同步&mdash;仓库的配置文件, 用户指定的仓库路径锁, 以
        及其他存放在仓库目录中的项目, 只要它们不在仓库的版本化文件系统中,
        就不会被 <command>svnsync</command> 处理.</para>

      <!--
      <para>In any backup scenario, repository administrators need to
        be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change
        hooks.<footnote><para><command>svnadmin setlog</command> can
        be called in a way that bypasses the hook interface
        altogether.</para></footnote>  And since you can change
        revision properties without respect to chronological
        order&mdash;you can change any revision's properties at any
        time&mdash;an incremental backup of the latest few revisions
        might not catch a property modification to a revision that was
        included as part of a previous backup.</para>
      -->
      <para>在任何一种备份场景下, 管理员都要注意版本号属性将如何影响他们的
        备份. 版本号属性的修改不会产生新的版本号, 不会触发钩子 post-commit,
        甚至也不会触发钩子 pre-revprop-change 和 post-revprop-change.
        <footnote><para>命令 <command>svnadmin setlog</command> 可以完全旁路
            掉钩子接口</para></footnote> 而且用户可以按照任意的时间顺序修改
        版本号属性&mdash;在任意时刻修改任意一个版本号的属性&mdash;在增量备份
        的情况下, 如果某个版本号已经包含在前一次备份中, 它的属性在后来被修改
        了, 那么修改将不会包含在后面的增量备份中.</para>

      <!--
      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
      -->
      <para>一般来说, 只有真正偏执的人才想在每次提交后备份整个仓库, 然而,
        如果仓库已经具备了一些相对细致的冗余机制 (例如每次提交后的邮件通知
        或增量转储), 那么仓库管理员可能会把数据库的热拷贝作为每夜例行工作的
        一部分去执行. 这是你的数据&mdash;你想怎么保护它们都不为过.</para>
            
      <!--
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of
        Fate,<footnote><para>You know&mdash;the collective term for
            ### TODO
        all of her <quote>fickle fingers.</quote></para></footnote> it
        should certainly help you recover from those trying
        times.</para>
      -->
      <para>很多时候, 备份仓库的最佳方式是本节所描述的各种方法的组合. 比如说
        Subversion 开发人员备份 Subversion 源代码仓库的方式是每晚使用
        <command>hot-backup.py</command> 和异地的 <command>rsync</command>
        完成全量备份; 为所有的提交和属性修改通知邮件维护多份归档; 由不同的
        志愿者使用 <command>svnsync</command> 维护多份仓库镜像. 你的最终
        方案可能与此类似, 但应该根据你的具体需求维持好易用性与安全性之间的
        平衡. 无论你怎么做, 应该偶尔检查备份是否可用&mdash;如果连备胎都有漏洞,
        那还怎么用? 虽然这一些都无法避免硬件遭受命运的捶打, 但备份确实能够
        帮助你从灾难中恢复.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
      <!--
      <title>Managing Repository UUIDs</title>
      -->
      <title>管理仓库的 UUID</title>

      <!--
      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>
      -->
      <para>每个 Subversion 仓库都有一个全局统一标识 (universally unique
        identifier, 简称 UUID) 与之关联. 当其他手段不够完善时 (例如检查仓库的
        URL, 但 URL 可以会变化), 客户端可以使用 UUID 识别仓库. 大多数管理员
        极少需要考虑仓库的 UUID, 对他们而言, UUID 只是 Subversion 的一个实现
        上的细节而已. 然而, 少数情况下这个细节也需要引起注意.</para>

      <!--
      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>
      -->
      <para>一般来说, 管理员希望活动仓库的 UUID 是独一无二的, 毕竟这就是
        UUID 的主要特点. 但在某些情况下需要两个仓库拥有一模一样的 UUID, 比如
        说管理员为仓库制作了一个副本, 并且希望该副本是源仓库的完美镜像, 因为
        管理员希望当备份仓库替换掉活动仓库时, 用户不会突然看到一个似乎不同的
        仓库. 在转储和加载仓库历史时 (见 <xref
          linkend="svn.reposadmin.maint.migrate" />), 管理员可以根据实际情况
        决定是否向目标仓库应用封装在转储流中的 UUID.</para>

      <!--
      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>
      -->
      <para>有若干种方式可以用来设置或重置仓库的 UUID, 对于 Subversion 1.5
        而言, 用到的命令是 <command>svnadmin setuuid</command>. 如果在命令行
        上显式地提供了 UUID 参数, 命令将验证 UUID 的格式是否正确, 如果正确就
        把它设置到仓库上. 如果省略了 UUID 参数, 命令就自动为仓库生成一个全新
        的 UUID.</para>

      <informalexample>
        <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <!--
      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load - -force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>.</para>
      -->
    <para>如果你用的是 1.5 版之前的 Subversion, 那么设置 UUID 的过程会更复杂
      一点. 为了设置 UUID, 管理员可以把带有新 UUID 的桩转储文件, 以管道地方式
      传递给 <userinput>svnadmin load --force-uuid <replaceable>REPOS-PATH
    </replaceable></userinput>, 从而显式设置仓库的 UUID.</para>

      <informalexample>
        <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <!--
      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>
      -->
      <para>使用旧版的 Subversion 来生成全新的 UUID 并不是一件非常容易的事情,
        管理员最好找到生成 UUID 的其他方法, 然后再通过上面的方式为仓库显式地
        设置新 UUID.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
      <!--
    <title>Moving and Removing Repositories</title>
      -->
    <title>移动与删除仓库</title>

      <!--
    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>
      -->
    <para>Subversion 仓库的所有数据都存放在仓库目录中, 所以说管理员可以使用
      操作系统提供的命令&mdash;Unix 系统的 <command>mv</command>,
      <command>cp -a</command>, <command>rm -r</command>; Windows 系统的
      <command>move</command>, <command>copy</command>, <command>rmdir
        /s /q</command>; 或其他图形化文件浏览器提供的鼠标和菜单操作&mdash;
      实现仓库的移动, 重命名, 复制和删除.</para>

      <!--
    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>
      -->
    <para>当然, 在做完上面的操作后还有些清理工作需要完成. 比如说, 管理员需要
      为移动后的仓库更新 Subversion 服务器的配置, 或者删除一些配置 (因为相关
      的仓库已经被移除了). 如果管理员设置了与仓库有关的自动化信息发布系统, 它
      们可能需要更新, 钩子脚本可能需要重新配置, 还可能需要通知用户... 工作列
      表可以不停地写下去, 至少应该覆盖到与仓库有关的构建过程.</para>

      <!--
    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including
      their UUIDs.  In some circumstances, this might be desirable.
      But in the instances where it is not, you'll need to generate a
      new UUID for one of these identical repositories.  See
      <xref linkend="svn.reposadmin.maint.uuids" /> for more about
      managing repository UUIDs.</para>
      -->
    <para>对于通过复制得到的仓库, 需要注意 Subversion 使用 UUID 区分仓库. 如
      果管理员是用一个典型的递归复制命令来复制仓库, 那么和源仓库相比, 两者完
      全没有区别&mdash;甚至连 UUID 也相同. 在某些情况下这是合理的效果, 但有
      时候却不是, 此时管理员需要为其中一个仓库重新生成一个新的 UUID. 关于如何
      管理仓库的 UUID, 见 <xref linkend="svn.reposadmin.maint.uuids" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
      <!--
    <title>Summary</title>
      -->
    <title>小结</title>

      <!--
    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>
      -->
    <para>读到这里, 读者应该具备了创建, 配置与维护 Subversion 仓库的基本知识,
      本章介绍了多个和这些任务相关的工具, 对于常见的管理问题, 我们也提供了很
      多建议与解决方案.</para>

      <!--
    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>
      -->
    <para>剩下的就是由你来决定把什么数据放在仓库里, 以及如何将仓库发布到网络
      上. 下一章讨论的是与网络相关的内容.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
