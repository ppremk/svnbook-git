<!-- -*- sgml -*- -->

<chapter id="svn.tour">
  <!--
  <title>Basic Usage</title>
  -->
  <title>基本用法</title>

  <!--
  <para>Theory is useful, but its application is just plain fun.
    Let's move now into the details of using Subversion.  By the time
    you reach the end of this chapter, you will be able to perform all
    the tasks you need to use Subversion in a normal day's work.
    You'll start with getting your files into Subversion, followed by
    an initial checkout of your code.  We'll then walk you through
    making changes and examining those changes.  You'll also see how
    to bring changes made by others into your working copy, examine
    them, and work through any conflicts that might arise.</para>
  -->
  <para>理论是很用的, 但是实际使用它们的乐趣却很简单. 现在我们开始介绍使用
    Subversion 的细节, 到这一章结束时, 读者在日常工作中使用 Subversion 将
    不会遇到太大的问题. 本章首先介绍如何把文件纳入 Subversion, 然后对代码
    进行首次检出, 接下来将对代码进行一些修改, 并检查修改前后的具体差异. 读
    者还将会看到如何把其他人的修改应用到自己的工作副本中, 检查修改并解决可
    能的冲突.</para>

  <!--
  <para>This chapter will not provide exhaustive coverage
    of all of Subversion's commands&mdash;rather, it's a conversational
    introduction to the most common Subversion tasks that you'll
    encounter.  This chapter assumes that you've read and understood
    <xref linkend="svn.basic"/> and are familiar with the general
    model of Subversion.  For a complete reference of all commands,
    see <xref linkend="svn.ref.svn"/>.</para>
  -->
  <para>本章不会介绍 Subversion 的所有命令 &mdash; 而是以对话的方式介绍在使
    用 Subversion 的过程中最经常遇到的问题. 本章假设读者已经读过并理解了
    <xref linkend="svn.basic"/> 的内容, 而且熟悉 Subversion 的一般模型. 关
    于全部命令的完整参考手册, 请阅读 <xref linkend="svn.ref.svn"/>.</para>

  <!--
  <para>Also, this chapter assumes that the reader is seeking
    information about how to interact in a basic fashion with an
    existing Subversion repository.  No repository means no working
    copy; no working copy means not much of interest in this chapter.
    There are many Internet sites which offer free or inexpensive
    Subversion repository hosting services.  Or, if you'd prefer to
    set up and administer your own repositories, check out
    <xref linkend="svn.reposadmin"/>.  But don't expect the
    examples in this chapter to work without the user having access
    to a Subversion repository.</para>
  -->
  <para>另外, 本章还假设读者已经拥有了一个已存在的 Subversion 仓库. 没有仓库
    就没有工作副本, 没有工作副本就无法练习本章的内容. 在因特网上可以找到许多
    提供免费或廉价的 Subversion 仓库托管服务的网站, 如果读者想要自己创建仓库,
    请阅读 <xref linkend="svn.reposadmin"/>. 为了练习本章的例子, 读者必须对
    Subversion 仓库拥有访问权限.</para>

  <!--
  <para>Finally, any Subversion operation that contacts the repository
    over a network may potentially require that the user authenticate.
    For the sake of simplicity, our examples throughout this chapter
    avoid demonstrating and discussing authentication.  Be aware that
    if you hope to apply the knowledge herein to an existing,
    real-world Subversion instance, you'll probably be forced to
    provide at least a username and password to the server.  See
    <xref linkend="svn.serverconfig.netmodel.creds"/> for a detailed
    description of Subversion's handling of authentication and client
    credentials.</para>
  -->
  <para>最后, 如果某个 Subversion 命令需要通过网络连接仓库, 这可能需要用户
    认证. 为简单起见, 本章的所有例子都会避开和认证相关的内容. 需要注意的是,
    如果读者想把本章介绍的内容应用到某个真实世界中的 Subversion 实例, 你很可
    能需要向服务器提供用户名与密码. 关于认证和客户端证书的更多内容, 请阅读
    <xref linkend="svn.serverconfig.netmodel.creds"/>.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.help">
    <!--
    <title>Help!</title>
    -->
    <title>帮助!</title>

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands (子命令)</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <!--
    <para>It goes without saying that this book exists to be a source
      of information and assistance for Subversion users new and old.
      Conveniently, though, the Subversion command-line is
      self-documenting, alleviating the need to grab a book off the
      shelf (wooden, virtual, or otherwise).  The <command>svn
      help</command> command is your gateway to that built-in
      documentation:</para>
    -->
    <para>本书的目标是成为 Subversion 新老用户的助手与信息来源, 不过,
      Subversion 的命令行工具本身就带有丰富的帮助文档, 如此一来, 读者就
      用不着每次都从书架上拿这本书. 命令 <command>svn help</command> 是
      打开内置文档的入口:</para>

    <informalexample>
      <screen>
$ svn help
usage: svn &lt;subcommand&gt; [options] [args]
Subversion command-line client, version 1.8.13.
Type 'svn help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svn --version' to see the program version and RA modules
  or 'svn --version --quiet' to see just the version number.

Most subcommands take file and/or directory arguments, recursing
on the directories.  If no arguments are supplied to such a
command, it recurses on the current directory (inclusive) by default.

Available subcommands:
   add
   blame (praise, annotate, ann)
   cat
&hellip;
</screen>
    </informalexample>

    <!--
    <para>As described in the previous output, you can ask for help on
      a particular subcommand by running <userinput>svn help
      <replaceable>SUBCOMMAND</replaceable></userinput>.  Subversion
      will respond with the full usage message for that subcommand,
      including its syntax, options, and behavior:</para>
    -->
    <para>上面的输出内容已经说了, 读者可以用 <userinput>svn help <replaceable>
      SUBCOMMAND</replaceable></userinput> 查看特定子命令的帮助信息,
      Subversion 会输出这个子命令完整的使用方法, 包括它的语法, 选项和功能:
      </para>

    <informalexample>
      <screen>
$ svn help help
help (?, h): Describe the usage of this program or its subcommands.
usage: help [SUBCOMMAND...]

Global options:
  --username ARG           : specify a username ARG
  --password ARG           : specify a password ARG
&hellip;
</screen>
    </informalexample>

    <sidebar>
      <!--
      <title>Options and Switches and Flags, Oh My!</title>
      -->
      <title>选项 (Options), 开关 (Switches) 和标志 (Flags), 这都是什
        么鬼?</title>
        
      <indexterm>
        <primary>svn</primary>
        <secondary>options (选项)</secondary>
      </indexterm>

      <!--
      <para>The Subversion command-line client has numerous command
        modifiers.  Some folks refer to such things
        as <quote>switches</quote> or <quote>flags</quote>&mdash;in
        this book, we'll call them <quote>options</quote>.  You'll
        find the options supported by a given <command>svn</command>
        subcommand, plus a set of options which are globally supported
        by all subcommands, listed near the bottom of the built-in
        usage message for that subcommand.</para>
      -->
      <para> Subversion 的客户端命令行工具拥有大量的命令修饰符, 有些人把它们
        叫作 <quote>开关</quote> 或 <quote>标志</quote> &mdash; 本书把它们叫
        作 <quote>选项</quote>. 读者将会看到特定的 <command>svn</command>
        子命令支持的选项, 再加上所有子命令都支持的全局选项, 全局选项显示在
        子命令帮助信息靠近底部的位置.</para>

      <!--
      <para>Subversion's options have two distinct forms:  short
        options are a single hyphen followed by a single letter, and
        long options consist of two hyphens followed by several
        letters and hyphens (e.g., <literal>-s</literal>
        and <literal>-this-is-a-long-option</literal>, respectively).
        Every option has at least one long format.  Some, such as
        the <option>-changelist</option> option, feature an
        abbreviated long-format alias (<option>-cl</option>, in this
        case).  Only certain options&mdash;generally the most-used
        ones&mdash;have an additional short format.  To maintain
        clarity in this book, we usually use the long form in code
        examples, but when describing options, if there's a short
        form, we'll provide the long form (to improve clarity) and the
        short form (to make it easier to remember).  Use the form
        you're more comfortable with when executing your own
        Subversion commands.</para>
      -->
      <para>Subversion 的选项有两种形式: 短选项由一个连字符和一个英文字母
        组成, 长选项以两个连续的连字符开始, 后跟几个英文字母和连字符 (例如
        短选项 <literal>-s</literal> 和长选项 <literal>--this-is-a-long-option
        </literal>), 每一个选项都至少有一个长格式. 有些选项&mdash;例如 <option>
        --changelist</option>&mdash;会有一个缩写的长格式别名 (<option>--cl
      </option>), 只有特定的几个选项 &mdash; 通常是最经常用到的选项 &mdash;
      才会拥有一个额外的短格式. 为了使书中的内容更加清晰, 在例子中我们通常
      使用选项的长格式, 但是在描述选项时, 如果该选项存在短格式, 我们会
      同时列出长格式 (为了清晰) 和短格式 (为了方便记忆). 读者在执行 Subversion
      命令时, 可以自由选择选项的格式.</para>

    </sidebar>

    <!--
    <para>Many Unix-based distributions of Subversion include manual
      pages of the sort that can be invoked using
      the <command>man</command> program, but those tend to carry only
      pointers to other sources of real help, such as the project's
      website and to the website which hosts this book.  Also, several
      companies offer Subversion help and support, too, usually via a
      mixture of web-based discussion forums and fee-based consulting.
      And of course, the Internet holds a decade's worth of
      Subversion-related discussions just begging to be located by
      your favorite search engine.  Subversion help is never too far
      away.</para>
    -->
    <para>许多基于 Unix 的 Subversion 发行版都包含了手册页, 可以通过命令
      <command>man</command> 打开, 但是手册页往往只是指出了帮助信息的真正
      位置, 例如项目网址. 另外, 有些公司会通过论坛和有偿咨询提供 Subversion
      的帮助与支持. 当然, 还有资源最丰富的因特网. 获取 Subversion 的帮助从
      来就不是一件难事.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.importing">
    <!--
    <title>Getting Data into Your Repository</title>
    -->
    <title>往仓库中添加数据</title>

    <!--
    <para>You can get new files into your Subversion
      repository in two ways: <command>svn import</command> and <command>svn
      add</command>.  We'll discuss <command>svn import</command> now
      and will discuss <command>svn add</command> later in this
      chapter when we review a typical day with Subversion.</para>
    -->
    <para>往 Subversion 仓库中添加新文件有 2 种办法:
      <command>svn import</command> 和 <command>svn add</command>. 这里先介绍
      <command>svn import</command>, <command>svn add</command> 在本章的后面
      再作介绍.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.import">
      <!--
      <title>Importing Files and Directories</title>
      -->
      <title>导入文件和目录</title>

      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands (子命令)</secondary>
        <tertiary>import</tertiary>
      </indexterm>

      <!--
      <para>The <command>svn import</command> command is a quick way to
        copy an unversioned tree of files into a repository, creating
        intermediate directories as necessary.  <command>svn
        import</command> doesn't require a working copy, and your files
        are immediately committed to the repository.  You typically
        use this when you have an existing tree of files that you want to
        begin tracking in your Subversion repository.  For example:</para>
      -->
      <para>命令 <command>svn import</command> 可以快速地向仓库中添加新文件
        或目录. <command>svn import</command> 不要求工作副本, 新增的文件会
        马上提交到仓库中. 使用该命令的典型情况是用户想要把一个已存在的目录
        添加到 Subversion 仓库中, 例如:</para>

      <informalexample>
        <screen>
$ svn import /path/to/mytree \
             http://svn.example.com/svn/repo/some/project \
             -m "Initial import"
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.
$
</screen>
      </informalexample>

      <!--
      <para>The previous example copied the contents of the local
        directory <filename>mytree</filename> into the directory
        <filename>some/project</filename> in the repository.  Note
        that you didn't have to create that new directory
        first&mdash;<command>svn import</command> does that for you.
        Immediately after the commit, you can see your data in the
        repository:</para>
      -->
      <para>上面的例子把本地目录 <filename>mytree</filename> 中的内容添加到
        仓库的 <filename>some/project</filename> 目录中. 注意, 用户在导入
        前无需创建新目录 &mdash; <command>svn import</command> 会自动完成这
        些工作. 提交后, 用户就可以在仓库中看到新增的文件和目录:</para>

      <informalexample>
        <screen>
$ svn list http://svn.example.com/svn/repo/some/project
bar.c
foo.c
subdir/
$
</screen>
      </informalexample>

      <!--
      <para>Note that after the import is finished, the original local
        directory is <emphasis>not</emphasis> converted into a working
        copy.  To begin working on that data in a versioned fashion,
        you still need to create a fresh working copy of that
        tree.</para>
      -->
      <para>注意, 导入完成后, 本地的原始目录并没有被转换成工作副本, 为了能够以
        版本控制的方式对文件进行管理, 用户仍然需要创建一份最新的工作副本.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.layout">
      <!--
      <title>Recommended Repository Layout</title>
      -->
      <title>推荐的仓库布局</title>

      <!--
      <para>Subversion provides the ultimate flexibility in terms of
        how you arrange your data.  Because it simply versions
        directories and files, and because it ascribes no particular
        meaning to any of those objects, you may arrange the data in
        your repository in any way that you choose.  Unfortunately,
        this flexibility also means that it's easy to find
        yourself <quote>lost without a roadmap</quote> as you attempt
        to navigate different Subversion repositories which may carry
        completely different and unpredictable arrangements of the
        data within them.</para>
      -->
      <para>为了方便用户管理数据, Subversion 提供了很大的灵活性. Subversion
        只是简单地对目录和文件进行版本控制, 不会给它们附上特殊的意义, 用户
        完全可以按照自己的喜好来决定数据的布局. 不过, 这种灵活性有时也会带
        来一些麻烦, 如果用户同时在 2 个或多个布局完全不同的仓库中浏览, 而这
        些仓库的布局又没有规律, 用户往往会感到迷失, 不知身在何处.</para>

      <para>
        <indexterm>
          <primary>trunk (主干)</primary>
        </indexterm>
        <indexterm>
          <primary>tags (标签)</primary>
        </indexterm>
        <indexterm>
          <primary>branches (分支)</primary>
        </indexterm>
        <indexterm>
          <primary>project root (项目根目录)</primary>
        </indexterm>为了避免这种问题, 我们推荐读者遵循传统的仓库布局 (这种布局
        出现在很久以前, 在 Subversion 项目早期阶段就已经开始使用), 传统布局的
        特点是, 仓库中的目录名可以向用户传达出与它们所存放的数据相关的信息.
        大多数项目都有一条公认的开发 <quote>主线</quote>, 或者叫作
        <firstterm>主干</firstterm> (<firstterm>trunk</firstterm>); 还有一
        些 <firstterm>分支</firstterm> (<firstterm>branches</firstterm>), 分
        支是某一条开发线的分叉; 还有一些 <firstterm>标签</firstterm>
        (<firstterm>tags</firstterm>), 标签是某一条开发线的稳定版快照.
        我们首先建议
        每一个项目在仓库中都一个公认的 <firstterm>项目根目录</firstterm>
        (<firstterm>project root</firstterm>), 目录中只存放和该项目相关的
        数据. 然后, 我们建议每一个项目根目录下都有一个表示开发主线的
        <filename>trunk</filename> 子目录, 存放所有分支的 <filename>branches
        </filename> 子目录, 存放所有标签的 <filename>tags</filename> 子目录.
        如果仓库只存放单个项目, 那么仓库的根目录也可以作为项目根目录.</para>

        <!--
        To counteract this confusion, we recommend that
        you follow a repository layout convention (established long
        ago, in the nascency of the Subversion project itself) in
        which a handful of strategically named Subversion repository
        directories convey valuable meaning about the data they hold.
        Most projects have a recognizable <quote>main line</quote>,
        or <firstterm>trunk</firstterm>, of development;
        some <firstterm>branches</firstterm>, which are divergent
        copies of development lines; and
        some <firstterm>tags</firstterm>, which are named, stable
        snapshots of a particular line of development.  So we first
        recommend that each project have a
        recognizable <firstterm>project root</firstterm> in the
        repository, a directory under which all of the versioned
        information for that project&mdash;and only that
        project&mdash;lives.  Secondly, we suggest that each project
        root contain a <filename>trunk</filename> subdirectory for the
        main development line, a
        <filename>branches</filename> subdirectory in which specific
        branches (or collections of branches) will be created, and
        a <filename>tags</filename> subdirectory in which specific
        tags (or collections of tags) will be created.  Of course, if
        a repository houses only a single project, the root of the
        repository can serve as the project root, too.</para>
        -->

      <!--
      <para>Here are some examples:</para>
      -->
      <para>这里有一些例子:</para>

      <informalexample>
        <screen>
$ svn list file:///var/svn/single-project-repo
trunk/
branches/
tags/
$ svn list file:///var/svn/multi-project-repo
project-A/
project-B/
$ svn list file:///var/svn/multi-project-repo/project-A
trunk/
branches/
tags/
$
</screen>
      </informalexample>

      <!--
      <para>We talk much more about tags and branches in
        <xref linkend="svn.branchmerge"/>.  For details and some
        advice on how to set up repositories when you have multiple
        projects, see <xref linkend="svn.branchmerge.maint.layout"/>.
        Finally, we discuss project roots more in
        <xref linkend="svn.reposadmin.projects.chooselayout"/>.</para>
      -->
      <para>关于标签和分支的更多内容, 我们将在 <xref linkend="svn.branchmerge"/>
        介绍. 如果用户要为多个项目创建仓库, 其中的细节与建议请参考
        <xref linkend="svn.branchmerge.maint.layout"/>. 关于项目根目录的更多
        内容, 我们将在 <xref linkend="svn.reposadmin.projects.chooselayout"/>
        介绍.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.naming">
      <!--
      <title>What's In a Name?</title>
      -->
      <title>名字中有什么</title>

      <!--
      <para>Subversion tries hard not to limit the type of data you
        can place under version control.  The contents of files and
        property values are stored and transmitted as binary data, and
        <xref linkend="svn.advanced.props.special.mime-type"/>
        tells you how to give Subversion a hint that
        <quote>textual</quote> operations don't make sense for a
        particular file.  There are a few places, however, where
        Subversion places restrictions on information it
        stores.</para>
      -->
      <para>Subversion 尽量不去限制用户想要管理的数据类型, 文件的内容及其
        属性被看成二进制数据进行存放和传输,
        <xref linkend="svn.advanced.props.special.mime-type"/> 将会介绍如何向
        Subversion 提示某个文件不需要 <quote>文本</quote> 操作. 然而, 在有些
        地方, Subversion 会限制其中所存放的数据类型.</para>

      <!--
      <para>Subversion internally handles certain bits of
        data&mdash;for example, property names, pathnames, and log
        messages&mdash;as UTF-8-encoded Unicode.  This is not to say
        that all your interactions with Subversion must involve UTF-8,
        though.  As a general rule, Subversion clients will gracefully
        and transparently handle conversions between UTF-8 and the
        encoding system in use on your computer, if such a conversion
        can meaningfully be done (which is the case for most common
        encodings in use today).</para>
      -->
      <para>某些数据由 Subversion 内部进行处理 &mdash; 例如属性名, 文件路径,
        日志消息 &mdash; 这些数据使用 UTF-8 编码, 不过这并不意味着和 Subversion
        交互时一定要使用 UTF-8 编码, 一般情况下, Subversion 客户端会自动对
        编码进行转换, 不需要用户参与.</para>

      <!--
      <para>In WebDAV exchanges and older versions of some of
        Subversion's administrative files, paths are used as XML
        attribute values, and property names in XML tag names.  This
        means that pathnames can contain only legal XML (1.0)
        characters, and properties are further limited to ASCII
        characters.  Subversion also prohibits <literal>TAB</literal>,
        <literal>CR</literal>, and <literal>LF</literal> characters in
        path names to prevent paths from being broken up in diffs or
        in the output of commands such as <command>svn log</command>
        or <command>svn status</command>.</para>
      -->
      <para>在 WebDAV 交换数据过程和版本比较老的 Subversion 管理文件中,
        文件路径是
        XML 的属性值, 属性名是 XML 的标签名, 此时文件路径只能包含合法的
        XML (1.0) 字符, 属性也只能使用 ASCII 字符. Subversion 禁止在文件路径
        中出现 <literal>TAB</literal>, <literal>CR</literal> 和
        <literal>LF</literal> 这些字符, 这是为了避免在差异比较时, 或者在命令
        <command>svn log</command> 和 <command>svn status</command> 和输出中
        文件路径被错误地断开.</para>

      <!--
      <para>While it may seem like a lot to remember, in practice
        these limitations are rarely a problem.  As long as your
        locale settings are compatible with UTF-8 and you don't use
        control characters in path names, you should have no trouble
        communicating with Subversion.  The command-line client adds
        an extra bit of help&mdash;to create
        <quote>legally correct</quote> versions for internal
        use it will automatically escape illegal
        path characters as needed in URLs that you type.</para>
      -->
      <para>听起来有许多规则需要记住, 但是在实际使用时这些限制极少会对用户产
        生影响. 只要用户的本地化设置和 UTF-8 兼容, 而且不在文件路径中使用
        控制字符, 在和 Subversion 通信时就不会产生任何问题. 客户端命令行工具
        也能提供帮助 &mdash; 为了方便内部使用, 用户在输入 URL 时, 命令行工具
        自动地对非法路径字符进行转义, 从而创建出方便内部使用的合法路径.</para>

      <warning>
      <!--
        <para>Of course, when it comes to choosing valid path names,
          Subversion isn't the only limiting factor.  Teams using
          multiple operating systems need to consider the limitations
          placed on path names by those operating systems, too.  For
          example, while Windows disallows the use of colon characters
          in file names, a user on a Linux system can very easily add
          such a file to version control, resulting in a dataset that
          can no longer be checked out on Windows.  Adding multiple
          files to a directory whose names differ only in their letter
          casing will likewise cause problems for users checking out
          working copies onto case-insensitive filesystems.  So, some
          broad awareness of the various limitations introduced by
          different operating systems and filesystems, then, is
          recommended.</para>
      -->
        <para>在选择有效的路径名时, Subversion 不是唯一的限制因素, 使用多个
          操作系统的开发团队还需要考虑不同操作系统对路径名的限制. 例如,
          Windows 不允许文件名包含冒号, 但是使用 Linux 系统的用户可以轻易地
          在仓库中添加这样的文件, 这些文件将不能被 Windows 用户检出. 有些
          操作系统区分文件名的大小写, 而有些不区分. 所以和 Subversion 相比,
          用户更应该注意不同的操作系统和文件系统所产生的限制.</para>
      </warning>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.initial">
      <!--
    <title>Creating a Working Copy</title>
      -->
    <title>创建工作副本</title>

    <para>
      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands (子命令)</secondary>
        <tertiary>checkout</tertiary>
      </indexterm>
      大多数时候, 用户开始使用仓库是通过执行 <firstterm>检出</firstterm>
      (<firstterm>checkout</firstterm>) 命令. 检出仓库中的目录将会在用户的
      本地主机上创建一个该目录的工作副本. 除非特意指定, 否则这个副本将包
      含仓库最新版本的数据:</para>
      <!--
      Most of the time, you will start using a Subversion
      repository by performing a <firstterm>checkout</firstterm> of
      your project.  Checking out a directory from a repository
      creates a working copy of that directory on your local machine.
      Unless otherwise specified, this copy contains the youngest
      (that is, most recently created or modified) versions of the
      directory and its children found in the Subversion
      repository:</para>
      -->

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/svn/repo/trunk
A    trunk/README
A    trunk/INSTALL
A    trunk/src/main.c
A    trunk/src/header.h
&hellip;
Checked out revision 8810.
$
</screen>
    </informalexample>

      <!--
    <para>Although the preceding example checks out the trunk
      directory, you can just as easily check out a deeper
      subdirectory of a repository by specifying that subdirectory's
      URL as the checkout URL:</para>
      -->
    <para>上面的例子检出的是主干目录, 但用户也可以轻易地检出更深层的子目录,
      只需要在检出命令的参数中写上子目录对应的 URL 即可:</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/svn/repo/trunk/src
A    src/main.c
A    src/header.h
A    src/lib/helpers.c
&hellip;
Checked out revision 8810.
$
</screen>
    </informalexample>

      <!--
    <para>Since Subversion uses a copy-modify-merge model instead of
      lock-modify-unlock (see <xref linkend="svn.basic.vsn-models"/>),
      you can immediately make changes to the files and directories in
      your working copy.  Your working copy is just like any other
      collection of files and directories on your system.  You can
      edit the files inside it, rename it, even delete the entire
      working copy and forget about it.</para>
      -->
    <para>因为 Subversion 用的是 复制-修改-合并 模型, 而非 加锁-修改-解锁
      (见 <xref linkend="svn.basic.vsn-models"/>), 所以用户马上就可以修改
      工作副本里的文件与目录. 工作副本就像一个普通目录, 用户可以编辑, 重
      命名里面的文件, 甚至可以删除整个工作副本.</para>

    <warning>
      <!--
      <para>While your working copy is <quote>just like any other
        collection of files and directories on your system,</quote>
        you can edit files at will, but you must tell Subversion
        about <emphasis>everything else</emphasis> that you do.  For
        example, if you want to copy or move an item in a working
        copy, you should use <command>svn copy</command> or
        <command>svn move</command> instead of the copy and move
        commands provided by your operating system.  We'll talk more
        about them later in this chapter.</para>
      -->
      <para>虽然工作副本 <quote>像一个普通目录</quote>, 用户可以按照自己
        的意愿编辑里面的文件, 但是其他事情必须告诉给 Subversion. 例如, 如果
        用户想要复制或移动工作副本中的某个文件或目录, 必须使用
        <command>svn copy</command> 或 <command>svn move</command>, 而不是
        操作系统提供的复制与移动命令. 关于它们的更多内容会在后面讲到.</para>
    </warning>

      <!--
    <para>Unless you're ready to commit the addition of a new file or
      directory or changes to existing ones, there's no need to
      further notify the Subversion server that you've done
      anything.</para>
      -->
    <para>除非用户准备提交修改, 否则不需要通知 Subversion 服务器你做了哪些
      修改.</para>

    <sidebar>
      <!--
      <title>What Is This .svn Directory?</title>
      -->
      <title>目录 .svn 里有什么东西?</title>

      <!--
      <para>The topmost directory of a working copy&mdash;and prior to
        version 1.7, every versioned subdirectory
        thereof&mdash;contains a special administrative subdirectory
        named <filename>.svn</filename>.  Usually, your operating
        system's directory listing commands won't show this
        subdirectory, but it is nevertheless an important directory.
        Whatever you do, don't delete or change anything in the
        administrative area!  Subversion uses that directory and its
        contents to manage your working copy.</para>
      -->
      <para>工作副本的根目录 &mdash; 1.7 版以前是每个目录及其子目录 &mdash;
        都有一个用于管理的子目录 <filename>.svn</filename>. 通常情况下, 操作
        系统的目录列表指令不会显示该目录, 但它是一个非常重要的目录, 无论用户
        做什么操作, 都不能删除或修改其中的内容, Subversion 管理工作副本的信息
        都存放在这个目录里.</para>
    </sidebar>

      <!--
    <para>Notice that in the previous pair of examples, Subversion
      chose to create a working copy in a directory named for the
      final component of the checkout URL.  This occurs only as a
      convenience to the user when the checkout URL is the only bit of
      information provided to the <command>svn checkout</command>
      command.  Subversion's command-line client gives you additional
      flexibility, though, allowing you to optionally specify the
      local directory name that Subversion should use for the working
      copy it creates.  For example:</para>
      -->
    <para>在上面的两个例子中, Subversion 在本地创建的目录名是检出命令中
      URL 参数的最后一个分量. 如果用户只向 <command>svn checkout</command>
      提供了 URL 参数, 那么根据最后一个分量来创建目录对用户来说就比较方便.
      不过 Subversion 客户端命令行工具也允许用户自己指定一个目录名, 例如:
    </para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/svn/repo/trunk my-working-copy
A    my-working-copy/README
A    my-working-copy/INSTALL
A    my-working-copy/src/main.c
A    my-working-copy/src/header.h
&hellip;
Checked out revision 8810.
$
</screen>
    </informalexample>

      <!--
    <para>If the local directory you specify doesn't yet
      exist, that's okay&mdash;<command>svn checkout</command> will
      create it for you.</para>
      -->
    <para>如果用户指定的本地目录不存在, <command>svn checkout</command>
      会自动创建该目录.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.cycle">
      <!--
    <title>Basic Work Cycle</title>
      -->
    <title>基本工作周期</title>

      <!--
    <para>Subversion has numerous features, options, bells, and
      whistles, but on a day-to-day basis, odds are that you will use
      only a few of them.  In this section, we'll run through the most
      common things that you might find yourself doing with Subversion
      in the course of a day's work.</para>
      -->
    <para>Subversion 支持的特性与选项非常丰富, 但是能够在日常工作中用到的却很
      少. 本节将介绍日常工作中最常用到的 Subversion 操作.</para>

      <!--
    <para>The typical work cycle looks like this:</para>
      -->
    <para>典型的工作周期就像:</para>

    <orderedlist>
      <listitem>
      <!--
        <para><emphasis>Update your working copy.</emphasis> This
          involves the use of the <command>svn update</command>
          command.</para>
      -->
        <para><emphasis>更新工作副本.</emphasis> 这会用到命令
          <command>svn update</command>.</para>
      </listitem>
      <listitem>
      <!--
        <para><emphasis>Make your changes.</emphasis> The most common
          changes that you'll make are edits to the contents of your
          existing files.  But sometimes you need to add, remove, copy
          and move files and directories&mdash;the <command>svn
          add</command>, <command>svn delete</command>, <command>svn
          copy</command>, and <command>svn move</command> commands
          handle those sorts of structural changes within the working
          copy.</para>
      -->
        <para><emphasis>修改.</emphasis>最常见的修改就是编辑已有文件的内容,
          但有时还要添加, 删除, 复制和移动文件或目录 &mdash; 命令
          <command>svn add</command>, <command>svn delete</command>,
          <command>svn copy</command> 和 <command>svn move</command> 负责
          处理工作副本的结构性调整.</para>
      </listitem>
      <listitem>
      <!--
        <para><emphasis>Review your changes.</emphasis>
          The <command>svn status</command> and <command>svn
          diff</command> commands are critical to reviewing the
          changes you've made in your working copy.</para>
      -->
        <para><emphasis>审查修改.</emphasis> 用命令
          <command>svn status</command> 和 <command>svn diff</command>
          查看工作副本发生了哪些变化.</para>
      </listitem>
      <listitem>
      <!--
        <para><emphasis>Fix your mistakes.</emphasis>  Nobody's
          perfect, so as you review your changes, you may spot
          something that's not quite right.  Sometimes the easiest way
          to fix a mistake is start all over again from scratch.
          The <command>svn revert</command> command restores a file
          or directory to its unmodified state.</para>
      -->
        <para><emphasis>修正错误.</emphasis> 人无完人, 在审查修改时用户可
          能会发现某些修改是不正确的. 有时候修正错误最简单的方式是撤消所有的
          修改, 重新开始. 命令 <command>svn revert</command> 可以把文件或目
          录恢复到修改前的样子.</para>
      </listitem>
      <listitem>
      <!--
        <para><emphasis>Resolve any conflicts (merge others'
          changes).</emphasis>  In the time it takes you to make and
          review your changes, others might have made and published
          changes, too.  You'll want to integrate their changes into
          your working copy to avoid the potential out-of-dateness
          scenarios when you attempt to publish your own.  Again,
          the <command>svn update</command> command is the way to do
          this.  If this results in local conflicts, you'll need to
          resolve those using the <command>svn resolve</command>
          command.</para>
      -->
        <para><emphasis>解决冲突 (合并其他人的修改).</emphasis> 当一个用户
          正在修改文件时, 其他人可能已经把自己的修改提交到了服务器上. 为了防止
          在提交修改时, 由于工作副本过旧导致提交失败, 用户需要把其他人的修改
          更新到本地, 用到的命令是 <command>svn update</command>. 如果命令
          的执行结果有冲突产生, 用户需要用命令 <command>svn resolve</command>
          解决冲突.</para>
      </listitem>
      <listitem>
      <!--
        <para><emphasis>Publish (commit) your changes.</emphasis>
          The <command>svn commit</command> command transmits your
          changes to the repository where, if they are accepted, they
          create the newest versions of all the things you modified.
          Now others can see your work, too!</para>
      -->
        <para><emphasis>发布 (提交) 修改.</emphasis> 命令
          <command>svn commit</command> 把工作副本的修改提交到仓库中, 如果修改
          被接受, 其他用户就可以看到这些修改.</para>
      </listitem>
    </orderedlist>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.update">
      <!--
      <title>Update Your Working Copy</title>
      -->
      <title>更新工作副本</title>

      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands (子命令)</secondary>
        <tertiary>update</tertiary>
      </indexterm>

      <!--
      <para>When working on a project that is being modified via
        multiple working copies, you'll want to update your working
        copy to receive any changes committed from other working
        copies since your last update.  These might be changes that
        other members of your project team have made, or they might
        simply be changes you've made yourself from a different
        computer.  To protect your data, Subversion won't
        allow you commit new changes to out-of-date files and
        directories, so it's best to have the latest versions
        of all your project's files and directories before making new
        changes of your own.</para>
      -->
      <para>如果某个项目正在被多个工作副本修改, 用户就需要更新自己本地的
        工作副本, 以获取其他人提交的修改. 这些修改可能来自团队中的其他开发
        人员, 也可能是自己在其他地方提交的修改. Subversion 不允许用户向过时
        的文件或目录提交修改, 所以在开始修改前, 最好保证本地工作副本的内容
        是最新的.</para>

      <!--
      <para>Use <command>svn update</command> to bring your working
        copy into sync with the latest revision in the
        repository:</para>
      -->
      <para>命令 <command>svn update</command> 把仓库上的最新数据同步到本地
        的工作副本:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
U    foo.c
U    bar.c
Updated to revision 2.
$
</screen>
      </informalexample>

      <!--
      <para>In this case, it appears that someone committed
        modifications to both <filename>foo.c</filename>
        and <filename>bar.c</filename> since the last time you
        updated, and Subversion has updated your working copy to
        include those changes.</para>
      -->
      <para>从上面的例子可以看到, 在你最后一次更新了工作副本后, 有人修改了
        <filename>foo.c</filename> 和 <filename>bar.c</filename>, Subversion
        把更新同步到本地工作副本.</para>

      <!--
      <para>When the server sends changes to your working copy via
        <command>svn update</command>, a letter code is displayed next
        to each item to let you know what actions Subversion performed
        to bring your working copy up to date.  To find out what these
        letters mean, run <userinput>svn help update</userinput> or
        see <xref linkend="svn.ref.svn.c.update"/> in
        <xref linkend="svn.ref.svn"/>.</para>
      -->
      <para>通过命令 <command>svn update</command>, 服务器把修改应用到本地的
        工作副本, 同时在被更新项目的旁边显示一个字母, 表示 Subversion 对文件
        采取了什么操作. 为了明白这些字母的涵义, 查看
        <userinput>svn help update</userinput> 的输出或参考
        <xref linkend="svn.ref.svn"/> 的
        <xref linkend="svn.ref.svn.c.update"/>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.edit">
      <!--
      <title>Make Your Changes </title>
      -->
      <title>修改</title>

      <para>
        <indexterm>
          <primary>file changes (文件变化)</primary>
        </indexterm>
        <indexterm>
          <primary>tree changes (目录树变化)</primary>
        </indexterm>
      <!--
        Now you can get to work and make changes in your
        working copy.  You can make two kinds of changes to your
        working copy: <firstterm>file changes</firstterm>
        and <firstterm>tree changes</firstterm>.  You don't need to
        tell Subversion that you intend to change a file; just make
        your changes using your text editor, word processor, graphics
        program, or whatever tool you would normally use.  Subversion
        automatically detects which files have been changed, and in
        addition, it handles binary files just as easily as it handles
        text files&mdash;and just as efficiently, too.  Tree changes
        are different, and involve changes to a directory's structure.
        Such changes include adding and removing files, renaming files
        or directories, and copying files or directories to new
        locations.  For tree changes, you use Subversion operations
        to <quote>schedule</quote> files and directories for removal,
        addition, copying, or moving.  These changes may take place
        immediately in your working copy, but no additions or removals
        will happen in the repository until you commit them.</para>
      -->
        现在用户可以开始工作, 修改工作副本里的资料. 工作副本支持的修改类型分
        为两种: <firstterm>文件修改</firstterm>
        (<firstterm>file changes</firstterm>) 和 <firstterm>目录修改</firstterm>
        (<firstterm>tree changes</firstterm>). 在修改文件时不需要告知
        Subversion, 用户可以使用任意一种自己喜欢的工具来修改文件, 例如编辑
        器, 字处理程序, 图形工具等. Subversion 可以自动检测到哪些文件发生了
        变化, 处理二进制文件和处理文本文件一样简单高效. 目录修改涉及到目录结构
        的变化, 例如添加和删除文件, 重命名文件和目录, 复制文件和目录. 目录修改
        要使用 Subversion 的命令完成. 文件修改和目录修改只有在提交后才会更新
        到仓库中.</para>

      <sidebar>
      <!--
        <title>Versioning Symbolic Links</title>
      -->
        <title>对符号链接进行版本控制</title>

        <para>
          <indexterm>
            <primary>symlink (符号链接)</primary>
          </indexterm>
          <indexterm>
            <primary>symbolic link (符号链接)</primary>
            <see>symlink (符号链接)</see>
          </indexterm>
      <!--
          On non-Windows platforms, Subversion is able to
          version files of the special type <firstterm>symbolic
          link</firstterm> (or <quote>symlink</quote>).  A symlink is
          a file that acts as a sort of transparent reference to some
          other object in the filesystem, allowing programs to read
          and write to those objects indirectly by performing
          operations on the symlink itself.</para>
      -->
        在类 Unix 系统中, Subversion 还能对特殊的文件类型&mdash;
        <firstterm>符号链接</firstterm> (<firstterm>symbolic link</firstterm>,
        或者叫作 <quote>软链接 </quote>) 进行版本控制. 软链接是一种透明的
        引用, 引用到文件系统中的其他文件或目录, 对软链接的操作会间接地作用到
        它所引用的文件或目录上.</para>

      <!--
        <para>When a symlink is committed into a Subversion
          repository, Subversion remembers that the file was in fact a
          symlink, as well as the object to which the symlink
          <quote>points.</quote>  When that symlink is checked out to
          another working copy on a non-Windows system, Subversion
          reconstructs a real filesystem-level symbolic link from the
          versioned symlink.  But that doesn't in any way limit the
          usability of working copies on systems such as Windows that
          do not support symlinks.  On such systems, Subversion simply
          creates a regular text file whose contents are the path to
          which the original symlink pointed.  While that file
          can't be used as a symlink on a Windows system, it also
          won't prevent Windows users from performing their other
          Subversion-related activities.</para> </sidebar>
      -->
      <para>如果把一个软链接提交到仓库中, Subversion 会自动加以识别.
        如果在不支持软链接的 Windows 操作系统中检出工作副本, Subversion 就会
        创建一个同名的普通文件, 文件内容是软链接所指向的对象的路径, 虽然该
        文件不能当作一个软链接使用, 但 Windows 用户仍然可以编辑该文件.</para>
    </sidebar>

      <!--
      <para>Here is an overview of the five Subversion subcommands
        that you'll use most often to make tree changes:</para>
      -->
      <para>下面是最常用到的 5 个改变目录结构的 Subversion 子命令:</para>

      <variablelist>

        <varlistentry>
          <term><userinput>svn add FOO</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands (子命令)</secondary>
              <tertiary>add</tertiary>
            </indexterm>
      <!--
            <para>Use this to schedule the file, directory, or
              symbolic link <filename>FOO</filename> to be added to
              the repository.  When you next
              commit, <filename>FOO</filename> will become a child of
              its parent directory.  Note that if
              <filename>FOO</filename> is a directory, everything
              underneath <filename>FOO</filename> will be scheduled
              for addition.  If you want only to add
              <filename>FOO</filename> itself, pass the
              <option>- -depth=empty</option> option.</para>
      -->
            <para>这个命令把文件, 目录或软链接 <filename>FOO</filename> 添加
              到需要进行版本控制的名单中, 在下一次提交时,
              <filename>FOO</filename> 就会正式添加到仓库里. 如果
              <filename>FOO</filename> 是一个目录, 那么目录内的所有内容都会
              被添加到仓库中. 如果只想添加 <filename>FOO</filename> 它自己,
              就带上选项 <option>--depth=empty</option>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn delete FOO</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands (子命令)</secondary>
              <tertiary>delete</tertiary>
            </indexterm>
      <!--
            <para>Use this to schedule the file, directory, or
              symbolic link <filename>FOO</filename> to be deleted
              from the repository.  <filename>FOO</filename> is
              immediately deleted from your working copy.
              (Of course, nothing is ever totally deleted from the
              repository&mdash;just from its <literal>HEAD</literal> revision.
              You may continue to access the deleted item in previous
              revisions).
              <footnote><para>Should you desire to resurrect the item
              so that it is again present in <literal>HEAD</literal>, see
              <xref linkend="svn.branchmerge.basicmerging.resurrect"
              />.</para></footnote></para>
      -->
      <para>上面的命令从工作副本中删除文件, 目录或符号链接
        <filename>FOO</filename>, 在下一次提交时, <filename>FOO</filename>
        就会从仓库中删除. (当然, 没有什么东西可以从仓库中被完全地删除干净
            &mdash;它们只是从版本号 <literal>HEAD</literal> 中删除, 用户可以
            从更早的版本中看到被删除的文件). <footnote><para>如果你希望在
                <literal>HEAD</literal> 中重新看到被删除的文件, 参考
            <xref linkend="svn.branchmerge.basicmerging.resurrect"/>.
      </para></footnote></para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn copy FOO BAR</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands (子命令)</secondary>
              <tertiary>copy</tertiary>
            </indexterm>
      <!--
            <para>Create a new item <filename>BAR</filename> as a
              duplicate of <filename>FOO</filename> and automatically
              schedule <filename>BAR</filename> for addition.  When
              <filename>BAR</filename> is added to the repository on
              the next commit, its copy history is recorded (as having
              originally come from <filename>FOO</filename>).
              <command>svn copy</command> does not create intermediate
              directories unless you pass the
              <option>- -parents</option> option.</para>
      -->
            <para>从 <filename>FOO</filename> 复制出一个
              <filename>BAR</filename>, 并把 <filename>BAR</filename> 添加到
              需要进行版本控制的名单中. <filename>BAR</filename> 被提交到仓库
              后, Subversion 会记录它是由 <filename>FOO</filename> 复制得到的.
              除非带上选项 <option>--parents</option>, 否则
              <command>svn copy</command> 不会创建父目录.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn move FOO BAR</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands (子命令)</secondary>
              <tertiary>move</tertiary>
            </indexterm>
      <!--
            <para>This command is exactly the same as running
              <userinput>svn copy FOO BAR; svn delete FOO</userinput>.
              That is, <filename>BAR</filename> is scheduled for
              addition as a copy of <filename>FOO</filename>, and
              <filename>FOO</filename> is scheduled for removal.
              <command>svn move</command> does not create intermediate
              directories unless you pass the
              <option>- -parents</option> option.</para>
      -->
            <para>这条命令等价于 <userinput>svn copy FOO BAR; svn delete FOO
              </userinput>, 也就是从 <filename>FOO</filename> 复制出一个
              <filename>BAR</filename>, 然后再删除 <filename>FOO</filename>.
              除非带上选项 <option>--parents</option>, 否则
              <command>svn move</command> 不会创建父目录.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn mkdir FOO</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands (子命令)</secondary>
              <tertiary>mkdir</tertiary>
            </indexterm>
      <!--
            <para>This command is exactly the same as running
              <userinput>mkdir FOO; svn add FOO</userinput>.  That is,
              a new directory named <filename>FOO</filename> is
              created and scheduled for addition.</para>
      -->
          <para>该命令等价于 <userinput>mkdir FOO; svn add FOO</userinput>,
          也就是创建一个新目录 <filename>FOO</filename>, 并把它添加到仓库中.
        </para>
          </listitem>
        </varlistentry>

      </variablelist>

      <sidebar>
      <!--
        <title>Changing the Repository Without a Working Copy</title>
      -->
        <title>在没有工作副本的情况下修改仓库</title>

      <!--
        <para>Subversion <emphasis>does</emphasis> offer ways to
          immediately commit tree changes to the repository without an
          explicit commit action.  In particular, specific uses
          of <command>svn mkdir</command>, <command>svn
          copy</command>, <command>svn move</command>, and
          <command>svn delete</command> can operate directly on
          repository URLs as well as on working copy paths.  Of
          course, as previously mentioned, <command>svn
          import</command> always makes direct changes to the
          repository.  We discuss the ways to commit tree changes
          without a working copy in
          <xref linkend="svn.advanced.working-without-a-wc"/>.</para>
      -->
        <para>Subversion <emphasis>确实</emphasis> 支持在没有显式的提交操作
          下, 马上把目录修改提交到仓库中. 除了工作副本中的路径,
          <command>svn mkdir</command>, <command>svn copy</command> 和
          <command>svn delete</command> 还可以接受仓库的 URL 作为参数. 前面
          我们也提到过, <command>svn import</command> 总是直接修改仓库.
          我们会在 <xref linkend="svn.advanced.working-without-a-wc"/> 介绍
          如何在没有工作副本的情况下提交目录修改.</para>

      <!--
        <para>There are pros and cons to performing URL-based
          operations.  One obvious advantage to doing so is speed:
          sometimes, checking out a working copy that you don't
          already have solely to perform some seemingly simple action
          is an overbearing cost.  A disadvantage is that you are
          generally limited to a single, or single type of, operation
          at a time when operating directly on URLs.  Finally, the
          primary advantage of a working copy is in its utility as a
          sort of <quote>staging area</quote> for changes.  You can
          make sure that the changes you are about to commit make
          sense in the larger scope of your project before committing
          them.  And, of course, these staged changes can be as
          complex or as a simple as they need to be, yet result in but
          a single new revision when committed.</para>
      -->
        <para>执行基于 URL 的操作既有好处也有坏处, 比较明显的好处是速度快:
          仅仅为了执行一个很简单的操作而检出工作副本, 未免也太麻烦了. 坏处
          是用户一次只能执行一个或一种类型的操作. 使用工作副本最大的好处是
          它可以作为修改的 <quote>暂存区</quote>, 在提交之前用户可以检查
          修改是否正确. 暂存区的修改既可以简单, 也可以很复杂, 它们都
          会被当作一个单独的修改提交到仓库中.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.examine">
      <!--
      <title>Review Your Changes</title>
      -->
      <title>审查修改</title>

      <para>
        <indexterm>
          <primary>log message (日志消息)</primary>
        </indexterm>
      <!--
        Once you've finished making changes, you need to commit
        them to the repository, but before you do so, it's usually a
        good idea to take a look at exactly what you've changed.  By
        examining your changes before you commit, you can compose a
        more accurate <firstterm>log message</firstterm> (a
        human-readable description of the committed changes stored
        alongside those changes in the repository).  You may also
        discover that you've inadvertently changed a file, and that
        you need to undo that change before committing.  Additionally,
        this is a good opportunity to review and scrutinize changes
        before publishing them.  You can see an overview of the
        changes you've made by using the <command>svn status</command>
        command, and you can dig into the details of those changes by
        using the <command>svn diff</command> command.
      -->
        工作副本修改完成后, 就要把它们都提交到仓库中, 不过在提交之前, 应该查看
        一下自己到底修改了哪些东西. 通过检查修改, 用户可以写出更准确的
        <firstterm>提交日志</firstterm> (<firstterm>log message</firstterm>,
        和修改一起存放到仓库中的一段文本, 该文本以人类可读的形式描述了本次
        修改的相关信息). 在审查修改时, 用户可能会发现自己无意中修改了一个不相
        关的文件, 因此在提交之前需要撤消它的修改. 用户可以使用命令
        <command>svn status</command> 查看修改的整体概述, 用命令
        <command>svn diff</command> 查看修改的细节. </para>

      <sidebar>
      <!--
        <title>Look Ma! No Network!</title>
      -->
        <title>看, 没网络!</title>

      <!--
        <para>You can use the commands <command>svn status</command>,
          <command>svn diff</command>, and <command>svn
          revert</command> without any network access even if your
          repository <emphasis>is</emphasis> across the network.  This
          makes it easy to manage and review your changes-in-progress
          when you are working offline or are otherwise unable to
          contact your repository over the network.</para>
      -->
        <para>如果仓库是通过网络访问的, 那么即使没有网络连接, 用户也可以执行
          <command>svn status</command>, <command>svn diff</command> 和
          <command>svn revert</command>, 这就方便用户在离线的情况下管理和
          审查未完成的修改.</para>

        <para>
          <indexterm>
            <primary>text-base (基于文本的)</primary>
          </indexterm>
          <indexterm>
            <primary>delta</primary>
          </indexterm>
      <!--
          Subversion does this by keeping private caches
          of pristine, unmodified versions of each versioned file
          inside its working copy administrative area (or prior to
          version 1.7, potentially multiple administrative areas).
          This allows Subversion to report&mdash;and
          revert&mdash;local modifications to those
          files <emphasis>without network access</emphasis>.  This
          cache (called the
          <firstterm>text-base</firstterm>) also allows Subversion to
          send the user's local modifications during a commit to the
          server as a compressed <firstterm>delta</firstterm> (or
          <quote>difference</quote>) against the pristine version.
          Having this cache is a tremendous benefit&mdash;even if you
          have a fast Internet connection, it's generally much faster
          to send only a file's changes rather than the whole file to
          the server.
      -->
          为了完成这些功能, Subversion 为每一个正在被版本控制的文件, 在工作
          副本的管理区中 (1.7 前的版本有多个管理区) 缓存一份未修改的原始文
          件, 这就允许 Subversion 在不需要连接网络的情况下, 查看或撤消本地
          的修改. 这些缓存 (称为 <firstterm>基文本</firstterm>
          (<firstterm>text-base</firstterm>)) 允许 Subversion 把用户的修改
          压缩后再向服务器提交. 这样做有很大的好处 &mdash; 就算用户的网络
          访问速度很快, 但是和发送整个文件相比, 只发送差异会快得多.
        </para>

      </sidebar>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.examine.status">
      <!--
        <title>See an overview of your changes</title>
      -->
        <title>查看修改的整体概述</title>

        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands (子命令)</secondary>
          <tertiary>status</tertiary>
        </indexterm>

      <!--
        <para>To get an overview of your changes, use the
          <command>svn status</command> command.  You'll probably use
          <command>svn status</command> more than any other Subversion
          command.</para>
      -->
        <para>为了看到修改的整体概述, 使用命令 <command>svn status</command>,
          它可能是用户最常用到的一个 Subversion 命令.</para>

        <tip>
      <!--
          <para>Because the <command>cvs status</command> command's
            output was so noisy, and because <command>cvs
            update</command> not only performs an update, but also
            reports the status of your local changes, most CVS users
            have grown accustomed to using <command>cvs
            update</command> to report their changes.  In Subversion,
            the update and status reporting facilities are completely
            separate.  See
            <xref linkend="svn.forcvs.status-vs-update"/> for more
            details.</para>
      -->
          <para>因为 <command>cvs status</command> 的输出非常庞杂,
            而 <command>cvs update</command> 不仅执行更新操作, 还会报告本
            地的修改情况, 所以大多数 CVS 用户更喜欢用
            <command>cvs update</command> 来查看修改情况. 对 Subversion 来
            说, 更新和状态报告这两个功能是完全分离的, 更多的细节在
            <xref linkend="svn.forcvs.status-vs-update"/>.</para>
        </tip>

      <!--
        <para>If you run <userinput>svn status</userinput> at the top
          of your working copy with no additional arguments, it will
          detect and report all file and tree changes you've
          made.</para>
      -->
        <para>如果在工作副本的根目录不加任何参数地执行
          <userinput>svn status</userinput>, Subversion 就会检查并报告所有
          文件和目录的修改.</para>

        <informalexample>
          <screen>
$ svn status
?       scratch.c
A       stuff/loot
A       stuff/loot/new.c
D       stuff/old.c
M       bar.c
$
</screen>
        </informalexample>

      <!--
        <para>In its default output mode, <command>svn
          status</command> prints seven columns of characters,
          followed by several whitespace characters, followed by a
          file or directory name.  The first column tells the status
          of a file or directory and/or its contents.  Some of the
          most common codes that <command>svn status</command>
          displays are:</para>
      -->
        <para>在默认的输出模式下, <command>svn status</command> 先打印 7 列
          字符, 然后是几个空白字符, 最后是文件或目录名. 第一列字符报告文件或
          目录的状态, 其中最常的几种字符或状态是:</para>

        <variablelist>

          <varlistentry>
            <term><computeroutput>?      item</computeroutput></term>
            <listitem>
      <!--
              <para>The file, directory, or symbolic link
                <filename>item</filename> is not under version
                control.</para>
      -->
              <para>文件, 目录或符号链接 <filename>item</filename> 不在版本
                控制的名单中.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>A      item</computeroutput></term>
            <listitem>
      <!--
              <para>The file, directory, or symbolic link
                <filename>item</filename> has been scheduled for
                addition into the repository.</para>
      -->
              <para>文件, 目录或符号链接 <filename>item</filename> 是新增的,
                在下一次提交时就会加入到仓库中.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>C      item</computeroutput></term>
            <listitem>
      <!--
              <para>The file <filename>item</filename> is in a state
                of conflict.  That is, changes received from the
                server during an update overlap with local changes
                that you have in your working copy (and weren't
                resolved during the update).  You must resolve this
                conflict before committing your changes to the
                repository.</para>
      -->
              <para>文件 <filename>item</filename> 有未解决的冲突, 意思是说从
                服务器收到的更新和该文件的本地修改有所重叠, Subversion 在处理
                这些重叠的修改时发生了冲突. 用户必须解决掉冲突后才能向仓库
                提交修改.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>D      item</computeroutput></term>
            <listitem>
      <!--
              <para>The file, directory, or symbolic link
                <filename>item</filename> has been scheduled for
                deletion from the repository.</para>
      -->
              <para>文件, 目录或符号链接 <filename>item</filename> 已被删除,
                在下一次提交时就会从仓库中删除 <filename>item</filename>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>M      item</computeroutput></term>
            <listitem>
      <!--
              <para>The contents of the file <filename>item</filename>
                have been modified.</para>
      -->
              <para>文件 <filename>item</filename> 的内容被修改.</para>
            </listitem>
          </varlistentry>

        </variablelist>

      <!--
        <para>If you pass a specific path to <command>svn
          status</command>, you get information about that item
          alone:</para>
      -->
        <para>如果给 <command>svn status</command> 传递一个路径名, 那么命
          令只会输出和该路径相关的状态信息:</para>

        <informalexample>
          <screen>
$ svn status stuff/fish.c
D       stuff/fish.c
</screen>
        </informalexample>

      <!--
        <para><command>svn status</command> also has a
          <option>- -verbose</option> (<option>-v</option>) option,
          which will show you the status of <emphasis>every</emphasis>
          item in your working copy, even if it has not been
          changed:</para>
      -->
        <para><command>svn status</command> 支持选项 <option>--verbose</option>
          (<option>-v</option>), 带上该选项后, 命令会输出当前目录中每一项的
          状态, 即使是未被修改的项目:</para>

        <informalexample>
          <screen>
$ svn status -v
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c
</screen>
        </informalexample>

      <!--
        <para>This is the <quote>long form</quote> output of
          <command>svn status</command>.  The letters in the first
          column mean the same as before, but the second column shows
          the working revision of the item.  The third and fourth
          columns show the revision in which the item last changed,
          and who changed it.</para>
      -->
        <para>这是 <command>svn status</command> 的 <quote>长格式</quote>
          (long form) 输出. 第一列字符的含义不变, 第二列显示该项在工作副本
          中的版本号, 第三和第四列显示该项最后一次被修改的版本号和作者.</para>

      <!--
        <para>None of the prior invocations to <command>svn
          status</command> contact the repository&mdash;they merely
          report what is known about the working copy items based on
          the records stored in the working copy administrative area
          and on the timestamps and contents of modified files.  But
          sometimes it is useful to see which of the items in your
          working copy have been modified in the repository since the
          last time you updated your working copy.  For
          this, <command>svn status</command> offers the
          <option>- -show-updates</option> (<option>-u</option>)
          option, which contacts the repository and adds information
          about items that are out of date:</para>
      -->
        <para>前面执行的几次 <command>svn status</command> 都不需要和仓库
          通信 &mdash; 它们只是根据工作副本管理区里的数据和文件当前的内容
          来报告各个文件的状态. 有时候用户可能想知道在上一次更新之后, 哪些
          文件在仓库中又被更新了, 为此, 可以给 <command>svn status</command>
          带上选项 <option>--show-updates</option> (<option>-u</option>),
          这样 Subversion 就会和仓库通信, 输出工作副本中已过时的项目:</para>

        <informalexample>
          <screen>
$ svn status -u -v
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46
</screen>
        </informalexample>

      <!--
        <para>Notice in the previous example the two asterisks: if you
          were to run <userinput>svn update</userinput> at this point,
          you would receive changes to <filename>README</filename>
          and <filename>trout.c</filename>.  This tells you some very
          useful information&mdash;because one of those items is also
          one that you have locally modified (the
          file <filename>README</filename>), you'll need to update and
          get the server's changes for that file before you commit, or
          the repository will reject your commit for being out of
          date.  We discuss this in more detail later.</para>
      -->
        <para>注意带有星号的那 2 行, 如果此时执行
          <userinput>svn update</userinput>, 就会从仓库收到
          <filename>README</filename> 和 <filename>trout.c</filename> 的更新.
          除此之外我们还可以知道, 在本地被修改的文件当中, 至少有一个在仓库中
          也被更新了 (文件 <filename>README</filename>), 所以用户必须在提交前把
          仓库的更新同步到本地, 否则仓库将会拒绝针对已过时文件的提交,
          关于这点我们会在后面介绍更多的细节.</para>

      <!--
        <para><command>svn status</command> can display much more
          information about the files and directories in your working
          copy than we've shown here&mdash;for an exhaustive
          description of <command>svn status</command> and its output,
          run <userinput>svn help status</userinput> or see
          <xref linkend="svn.ref.svn.c.status"/> in
          <xref linkend="svn.ref.svn"/>.</para>
      -->
        <para>除了我们介绍的例子, <command>svn status</command> 还可以显示更
          丰富的信息, 关于 <command>svn status</command> 更详细的介绍,
          查看 <userinput>svn help status</userinput> 的输出或阅读
          <xref linkend="svn.ref.svn"/> 的
          <xref linkend="svn.ref.svn.c.status"/></para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.examine.diff">
      <!--
        <title>Examine the details of your local modifications</title>
      -->
        <title>查看修改的细节</title>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands (子命令)</secondary>
            <tertiary>diff</tertiary>
          </indexterm>
          <indexterm>
            <primary>differences (差异)</primary>
            <secondary>unified diff (标准差异)</secondary>
          </indexterm>
      <!--
          Another way to examine your changes is with the
          <command>svn diff</command> command, which displays
          differences in file content.  When you run <userinput>svn
          diff</userinput> at the top of your working copy with no
          arguments, Subversion will print the changes you've made to
          human-readable files in your working copy.  It displays
          those changes in <firstterm>unified diff</firstterm> format,
          a format which describes changes as <quote>hunks</quote>
          (or <quote>snippets</quote>) of a file's content where each
          line of text is prefixed with a single-character code: a
          space, which means the line was unchanged; a minus sign
          (<literal>-</literal>), which means the line was removed
          from the file; or a plus sign (<literal>+</literal>), which
          means the line was added to the file.  In the context
          of <command>svn diff</command>, those minus-sign- and
          plus-sign-prefixed lines show how the lines looked before
          and after your modifications, respectively.
      -->
          查看修改的另一个命令是 <command>svn diff</command>, 它会输出文件
          内容的变化. 如果在工作副本的根目录不加任何参数地执行
          <userinput>svn diff</userinput>, Subversion 就会输出工作副本中人类
          可读的文件的变化. 文件的变化以 <firstterm>标准差异</firstterm>
          (<firstterm>unified diff</firstterm>) 的格式输出, 这种格式把文件
          内容的变化描述成 <quote>块</quote> (hunk) 或 <quote>片断</quote>
          (snippet), 其中每一行文本都加上一个单字符前缀: 空格表示该行没有
          变化; 负号 (<literal>-</literal>) 表示该行被删除; 正号
          (<literal>+</literal>) 表示该行是新增的. 在
          <command>svn diff</command> 的语境中, 这些冠以正负号的行显示了修改
          前的行和修改后的行分别是什么样子的.</para>

      <!--
        <para>Here's an example:</para>
      -->
        <para>这是一个执行 <userinput>svn diff</userinput> 的例子:</para>

        <informalexample>
          <screen>
$ svn diff
Index: bar.c
===================================================================
--- bar.c	(revision 3)
+++ bar.c	(working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
--- README	(revision 3)
+++ README	(working copy)
@@ -193,3 +193,4 @@
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
--- stuff/fish.c	(revision 1)
+++ stuff/fish.c	(working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
--- stuff/things/bloo.h	(revision 8)
+++ stuff/things/bloo.h	(working copy)
+Here is a new file to describe
+things about bloo.
</screen>
        </informalexample>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands (子命令)</secondary>
            <tertiary>patch</tertiary>
          </indexterm>
          <indexterm>
            <primary>patches (补丁)</primary>
          </indexterm>
          <indexterm>
            <primary>patch file (补丁文件)</primary>
            <see>patches (补丁)</see>
          </indexterm>
      <!--
          The <command>svn diff</command> command produces this
          output by comparing your working files against its pristine
          text-base.  Files scheduled for addition are displayed as
          files in which every line was added; files scheduled for
          deletion are displayed as if every line was removed from
          those files.  The output from <command>svn diff</command> is
          somewhat compatible with the <command>patch</command>
          program&mdash;more so with the <command>svn patch</command>
          subcommand introduced in Subversion 1.7.  Patch processing
          commands such as these read and apply <firstterm>patch
          files</firstterm> (or <quote>patches</quote>), which are
          files that describe differences made to one or more files.
          Because of this, you can share the changes you've made in
          your working copy with someone else without first committing
          those changes by creating a patch file from the redirected
          output of <command>svn diff</command>:
      -->
          <command>svn diff</command> 在比较了工作副本中的文件和基文本后
          再输出它们之间的差异. 在命令的输出中, 新增的文件其每一行都被冠
          以正号; 被删除的文件其每一行都被冠以负号. <command>svn diff</command>
          的输出格式和程序 <command>patch</command> 以及 Subversion 1.7
          引入的子命令 <command>svn patch</command> 兼容. 处理补丁的命令
          (例如 <command>patch</command> 和 <command>svn patch</command>)
          可以读取并应用 <firstterm>补丁文件</firstterm> 
          (<firstterm>patch files</firstterm>, 简称 <quote>补丁</quote>).
          利用补丁, 用户就可以在不提交的情况下, 把工作副本的修改分享给其他
          人, 创建补丁的方式是把 <command>svn diff</command> 的输出重定向到
          补丁文件里:</para>

        <informalexample>
          <screen>
$ svn diff &gt; patchfile
$
</screen>
        </informalexample>

      <!--
        <para>Subversion uses its internal diff engine, which produces
          unified diff format, by default.  If you want diff output in
          a different format, specify an external diff program using
          <option>- -diff-cmd</option> and pass any additional flags
          that it needs via the <option>- -extensions</option>
          (<option>-x</option>) option.  For example, you might want
          Subversion to defer its difference calculation and display
          to the GNU <command>diff</command> program, asking that
          program to print local modifications made to the
          file <filename>foo.c</filename> in context diff format
          (another flavor of difference format) while ignoring changes
          made only to the case of the letters used in the file's
          contents:</para>
      -->
        <para>Subversion 默认使用它自己内部的差异比较程序来生成标准差异格式
          的输出. 如果用户想要其他格式的差异输出, 就用选项
          <option>--diff-cmd</option> 指定一个外部的差异比较程序, 如果需要
          的话, 还可以用选项 <option>--extensions</option> 向差异比较程序
          传递其他额外的参数. 例如, 用户想用 GNU 的程序 <command>diff</command>
          对文件 <filename>foo.c</filename> 进行差异比较, 还要求
          <command>diff</command> 在比较时忽略大小写, 按照上下文差异格式来
          产生输出:</para>

        <informalexample>
          <screen>
$ svn diff --diff-cmd /usr/bin/diff -x "-i" foo.c
&hellip;
$
</screen>
        </informalexample>

      </sect3>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.revert">
      <!--
      <title>Fix Your Mistakes</title>
      -->
      <title>修正错误</title>

      <!--
      <para>Suppose while viewing the output of <command>svn
        diff</command> you determine that all the changes you made to
        a particular file are mistakes.  Maybe you shouldn't have
        changed the file at all, or perhaps it would be easier to make
        different changes starting from scratch.  You could edit the
        file again and unmake all those changes.  You could try to
        find a copy of how the file looked before you changed it, and
        then copy its contents atop your modified version.  You
        could attempt to apply those changes to the file again in
        reverse using <userinput>svn patch - -reverse-diff</userinput>
        or using your operating system's <userinput>patch -R</userinput>.  
        And there are probably other approaches you could take.</para>
      -->
      <para>假设用户在查看 <command>svn diff</command> 的输出时发现针对某
        一文件的修改都是错误的, 也许这个文件就不应该被修改, 也许重新开始
        修改文件会更加容易. 为了撤消现在的修改, 用户可以再次编辑文件, 手动
        地复原成原来的样子, 又或者是从其他地方找到一个原始文件, 把改错的
        文件覆盖掉, 还可以用 <userinput>svn patch --reverse-diff</userinput>
        或 <userinput>patch -R</userinput> 逆向应用补丁, 除此之外可能还有
        其他办法.</para>

      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands (子命令)</secondary>
        <tertiary>revert</tertiary>
      </indexterm>

      <!--
      <para>Fortunately in Subversion, undoing your work and starting
        over from scratch doesn't require such acrobatics.  Just use
        the <command>svn revert</command> command:</para>
      -->
      <para>幸运的是 Subversion 提供了一种简便的方法来撤消工作副本中的
        修改, 用到的命令是 <command>svn revert</command>:</para>

      <informalexample>
        <screen>
$ svn status README
M       README
$ svn revert README
Reverted 'README'
$ svn status README
$
</screen>
      </informalexample>

      <!--
      <para>In this example, Subversion has reverted the file to its
        premodified state by overwriting it with the pristine version
        of the file cached in the text-base area.  But note that
        <command>svn revert</command> can undo
        <emphasis>any</emphasis> scheduled operation&mdash;for
        example, you might decide that you don't want to add a new
        file after all:</para>
      -->
      <para>在上面的例子里, Subversion 利用缓存在基文本中的内容, 把文件
        回滚到修改前的原始状态. 需要注意的是, <command>svn revert</command>
        会撤消 <emphasis>任何</emphasis> 一个未提交的修改, 例如用户可能不
        想往仓库中添加新文件:</para>

      <informalexample>
        <screen>
$ svn status new-file.txt
?       new-file.txt
$ svn add new-file.txt
A         new-file.txt
$ svn revert new-file.txt
Reverted 'new-file.txt'
$ svn status new-file.txt
?       new-file.txt
$
</screen>
      </informalexample>

      <!--
      <para>Or perhaps you mistakenly removed a file from version
        control:</para>
      -->
      <para>或者是用户错误地删除了一个本不该删除的文件:</para>

      <informalexample>
        <screen>
$ svn status README
$ svn delete README
D         README
$ svn revert README
Reverted 'README'
$ svn status README
$
</screen>
      </informalexample>

      <!--
      <para>The <command>svn revert</command> command offers salvation
        for imperfect people.  It can save you huge amounts of time
        and energy that would otherwise be spent manually unmaking
        changes or, worse, disposing of your working copy and checking
        out a fresh one just to have a clean slate to work with
        again.</para>
      -->
      <para><command>svn revert</command> 提供了一个很好的补救机会,
        否则的话, 用户就得花费大量的时间, 自己一点一点地手工撤消修改, 又或
        者采用一个更麻烦的做法, 直接删除工作副本, 然后重新从服务器上检出一个
        干净的工作副本.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.resolve">
      <!--
      <title>Resolve Any Conflicts</title>
      -->
      <title>解决冲突</title>

      <para>
        <indexterm>
          <primary>conflicts (冲突)</primary>
          <secondary>resolution (解决)</secondary>
          </indexterm>
      <!--
          We've already seen how <userinput>svn status
        -u</userinput> can predict conflicts, but dealing with those
        conflicts is still something that remains to be done.
        Conflicts can occur any time you attempt to merge or integrate
        (in a very general sense) changes from the repository into
        your working copy.  By now you know that <command>svn
        update</command> creates exactly that sort of
        scenario&mdash;that command's very purpose is to bring your
        working copy up to date with the repository by merging all the
        changes made since your last update into your working copy.
        So how does Subversion report these conflicts to you, and how
        do you deal with them?</para>
      -->
      我们已经看过 <command>svn status -u</command> 如何预测是否
        有冲突, 但是解决冲突仍然需要由用户自己来完成. 冲突可以在用户把
        仓库中的修改合并到本地工作副本的任何时候发生, 到目前为止用户已经
        知道的命令中, <command>svn update</command> 就有可能产生冲突&mdash;
        该命令的唯一功能就是把仓库中的更新合并到本地工作副本. 那么当发生冲突
        时 Subversion 如何通知用户, 以及用户应该如何处理它们?</para>

      <!--
      <para>Suppose you run <userinput>svn update</userinput> and you
        see this sort of interesting output:</para>
      -->
      <para>假设用户在执行 <userinput>svn update</userinput> 后看到了如下
        输出:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
U    INSTALL
G    README
Conflict discovered in 'bar.c'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options:
        </screen>
      </informalexample>

      <!--
      <para>The <computeroutput>U</computeroutput> (which stands for
        <quote>Updated</quote>) and <computeroutput>G</computeroutput>
        (for <quote>merGed</quote>) codes are no cause for concern;
        those files cleanly absorbed changes from the repository.  A
        file marked with <computeroutput>U</computeroutput> contains
        no local changes but was updated with changes from the
        repository.  One marked with
        <computeroutput>G</computeroutput> had local changes to begin
        with, but the changes coming from the repository didn't
        conflict with those local changes.</para>
      -->
      <para>不用担心左边有 <computeroutput>U</computeroutput> (Updated, 更新)
        或 <computeroutput>G</computeroutput> (merGed, 合并) 的文件, 这表示
        它们成功地吸收了来自仓库的更新. <computeroutput>U</computeroutput>
        表示该文件不包含本地修改, 只是用仓库中的修改更新了文件内容.
        <computeroutput>G</computeroutput> 表示该文件含有本地修改, 但是这
        些修改和来自仓库的修改没有冲突.</para>

      <!--
      <para>It's the next few lines which are interesting.  First,
        Subversion reports to you that in its attempt to merge
        outstanding server changes into the
        file <filename>bar.c</filename>, it has detected that some of
        those changes clash with local modifications you've made to
        that file in your working copy but have not yet committed.
        Perhaps someone has changed the same line of text you also
        changed.  Whatever the reason, Subversion instantly flags this
        file as being in a state of conflict.  It then asks you what
        you want to do about the problem, allowing you to
        interactively choose an action to take toward resolving the
        conflict.  The most commonly used options are displayed, but
        you can see all of the options by
        typing <replaceable>s</replaceable>:</para>
      -->
      <para>再下来几行就比较有趣了. 首先, Subversion 报告说在把仓库的修改
        合并到文件 <filename>bar.c</filename> 时, 发现其中一些修改和本地未
        提交的修改产生了冲突. 原因可能是其他人和用户都修改了同一行, 无论是
        因为什么, Subversion 在发现冲突时会马上把文件置成冲突状态, 然后询问
        用户他想怎么办. 用户可以从 Subversion 给出的几个选项中选择一个,
        如果想看完整的选项列表, 就输入 <replaceable>s</replaceable>:</para>
      <informalexample>
        <screen>
&hellip;
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: s

  (e)  - change merged file in an editor  [edit]
  (df) - show all changes made to merged file
  (r)  - accept merged version of file

  (dc) - show all conflicts (ignoring merged version)
  (mc) - accept my version for all conflicts (same)  [mine-conflict]
  (tc) - accept their version for all conflicts (same)  [theirs-conflict]

  (mf) - accept my version of entire file (even non-conflicts)  [mine-full]
  (tf) - accept their version of entire file (same)  [theirs-full]

  (m)  - use internal merge tool to resolve conflict
  (l)  - launch external tool to resolve conflict  [launch]
  (p)  - mark the conflict to be resolved later  [postpone]
  (q)  - postpone all remaining conflicts
  (s)  - show this list (also 'h', '?')
Words in square brackets are the corresponding --accept option arguments.

Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options:
</screen>
      </informalexample>

      <!--
      <para>Let's briefly review each of these options before we go
        into detail on what each option means.</para>
      -->
      <para>先简单地介绍一下每一个选项.</para>

      <variablelist>
        <varlistentry>
          <term><computeroutput>(e)  edit  [edit]</computeroutput></term>
          <listitem>
      <!--
            <para>Open the file in conflict with your favorite editor,
              as set in the environment variable
              <literal>EDITOR</literal>.</para>
      -->
            <para>使用环境变量 <literal>EDITOR</literal> 定义的编辑器打开
              发生冲突的文件.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(df)  diff-full</computeroutput></term>
          <listitem>
      <!--
            <para>Display the differences between the base revision
              and the conflicted file itself in unified diff format.</para>
      -->
            <para>按照标准差异格式显示基础修订版和冲突的文件之间的差异.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(r)  resolved</computeroutput></term>
          <listitem>
      <!--
            <para>After editing a file, tell
              <command>svn</command> that you've resolved the
              conflicts in the file and that it should accept the
              current contents&mdash;basically that you've
              <quote>resolved</quote> the conflict.</para>
      -->
            <para>编辑完成后, 告诉 <command>svn</command> 用户已经解决了冲突,
              现在应该接受文件的当前内容.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(dc)  display-conflict</computeroutput></term>
          <listitem>
      <!--
            <para>Display all conflicting regions of the file,
              ignoring changes which were successfully merged.</para>
      -->
            <para>显示冲突的区域, 忽略合并成功的修改.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(mc)  mine-conflict  [mine-conflict]</computeroutput></term>
          <listitem>
      <!--
            <para>Discard any newly received changes from the server
              which conflict with your local changes to the file under
              review.  However, accept and merge all non-conflicting
              changes received from the server for that file.</para>
      -->
            <para>丢弃从服务器收到的, 与本地冲突的所有修改, 但是接受不会产生
              冲突的修改.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(tc)  theirs-conflict  [theirs-conflict]</computeroutput></term>
          <listitem>
      <!--
            <para>Discard any local changes which conflict with
              incoming changes from the server for the file under
              review.  However, preserve all non-conflicting local
              changes to that file.</para>
      -->
            <para>丢弃与服务器产生冲突的所有本地修改, 但是保留不会产生冲突
              的本地修改.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(mf)  mine-full  [mine-full]</computeroutput></term>
          <listitem>
      <!--
            <para>Discard all newly received changes from the server
              for the file under review, but preserve all your local
              changes for that file.</para>
      -->
            <para>丢弃从服务器收到的该文件的所有修改, 但是保留该文件的
              本地修改.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(tf)  theirs-full  [theirs-full]</computeroutput></term>
          <listitem>
      <!--
            <para>Discard all your local changes to the file under
              review and use only the newly received changes from the
              server for that file.</para>
      -->
            <para>丢弃该文件的所有本地修改, 只使用从服务器收到的修改.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(m)  merge</computeroutput></term>
          <listitem>
      <!--
            <para>Launch an internal file merge tool to perform the
              conflict resolution.  The option is available starting
              with Subversion 1.8.</para>
      -->
            <para>打开一个内部文件合并工具来解决冲突, 该选项从 Subversion 1.8
              开始支持.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(l)  launch</computeroutput></term>
          <listitem>
      <!--
            <para>Launch an external program to perform the conflict
              resolution.  This requires a bit of preparation
              beforehand.</para>
      -->
            <para>打开一个外部程序来解决冲突, 在第一次使用该选项之前需要完成
              一些准备工作.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(p)  postpone  [postpone]</computeroutput></term>
          <listitem>
      <!--
            <para>Leave the file in a conflicted state for you to
              resolve after your update is complete.</para>
      -->
            <para>让文件停留在冲突状态, 在更新完成后再解决冲突.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(s)  show all</computeroutput></term>
          <listitem>
      <!--
            <para>Show the list of all possible commands you can use
              in interactive conflict resolution.</para>
      -->
            <para>显示所有的, 可以用在交互式的冲突解决中的命令.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <!--
      <para>We'll cover these commands in more detail now, grouping
        them together by related functionality.</para>
      -->
      <para>我们将对以上命令进行更为详细的说明, 说明中将按照功能对命令进行
        分组.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.diff">

      <!--
        <title>Viewing conflict differences interactively</title>
      -->
        <title>交互式地查看冲突差异</title>

        <para>
          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>reviewing (审查)</secondary>
          </indexterm>
      <!--
          Before deciding how to attack a conflict
          interactively, odds are that you'd like to see exactly what
          is in conflict.  Two of the commands available at the
          interactive conflict resolution prompt can assist you here.
          The first is the <quote>diff-full</quote> command
          (<userinput>df</userinput>), which displays all the local
          modifications to the file in question plus any conflict
          regions:</para>
      -->
        在决定如何交互地解决冲突之前, 有必要看一下冲突的内容, 其中有两
          个命令可以帮到我们. 第一个是 <userinput>df</userinput>:</para>

        <informalexample>
          <screen>
&hellip;
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: df
--- .svn/text-base/sandwich.txt.svn-base      Tue Dec 11 21:33:57 2007
+++ .svn/tmp/tempfile.32.tmp     Tue Dec 11 21:34:33 2007
@@ -1 +1,5 @@
-Just buy a sandwich.
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
+Go pick up a cheesesteak.
+=======
+Bring me a taco!
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r32
&hellip;
</screen>
        </informalexample>

      <!--
        <para>The first line of the diff content shows the previous
          contents of the working copy (the <literal>BASE</literal>
          revision), the next content line is your change, and the
          last content line is the change that was just received from
          the server (<emphasis>usually</emphasis> the
          <literal>HEAD</literal> revision).</para>
      -->
        <para>差异内容的第一行显示了工作副本之前的内容 (版本号
          <literal>BASE</literal>), 下一行是用户的修改, 最后一行是从服务器
          收到的修改 (<emphasis>通常</emphasis> 是版本号
          <literal>HEAD</literal>).</para>

      <!--
        <para>The second command is similar to the first, but
          the <quote>display-conflict</quote>
          (<userinput>dc</userinput>) command shows only the conflict
          regions, not all the changes made to the file.
          Additionally, this command uses a slightly different display
          format for the conflict regions which allows you to more
          easily compare the file's contents in those regions as they
          would appear in each of three states: original and unedited;
          with your local changes applied and the server's conflicting
          changes ignored; and with only the server's incoming changes
          applied and your local, conflicting changes reverted.</para>
      -->
        <para>第二个命令和第一个比较类似, 但是 <userinput>dc</userinput>
          只会显示冲突区域, 而不是文件的所有修改. 另外, 该命令显示冲突区域
          的格式也稍有不同, 这种格式允许用户更方便地比较文件在三种状态下的
          内容: 原始状态; 带有用户的本地修改, 忽略服务器的冲突修改; 带有服
          务器的修改, 忽略用户的本地修改.</para>

      <!--
        <para>After reviewing the information provided by these
          commands, you're ready to move on to the next action.</para>
      -->
        <para>审查完这些命令提供的信息之后, 用户就可以采取下一步动作.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.resolve">

      <!--
        <title>Resolving conflict differences interactively</title>
      -->
        <title>交互式地解决冲突差异</title>

        <para>
          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>resolution (解决)</secondary>
            <tertiary>interactive (交互式地)</tertiary>
          </indexterm>
      <!--
          The main way to resolve conflicts interactively
          is to use an internal file merge tool.  The tool asks you
          what to do with each conflicting change and allows you to
          selectively merge and edit changes.  However, there are
          several other different ways to resolve conflicts
          interactively&mdash;two of them allow you to selectively
          merge and edit changes using external editors, the rest of
          which allow you to simply pick a version of the file and
          move along.  Internal merge tool combines all of the
          available ways to resolve conflicts.</para>
      -->
        交互式地解决冲突的主要方法是使用一个内部文件合并工具, 该工具
          询问用户如何处理每一个冲突修改, 而且允许用户有选择地合并和编辑修改.
          除此之外还有其他几种方式用于交互式地解决冲突&mdash;其中两种允许用
          户使用外部编辑器, 有选择地合并和编辑修改, 另外几种允许用户简单地选择
          文件版本. 内部合并工具集合了所有解决冲突的方式.</para>

      <!--
        <para>You've already reviewed the conflicting changes, so it's
          now time to resolve the conflicts.  The first command that
          should help you is the <quote>merge</quote> command
          (<userinput>m</userinput>) which is available starting with
          Subversion 1.8.  The command displays the conflicting
          areas and allows you to choose from a number of options to
          resolve the conflicts area-by-area:
         </para>
      -->
         <para>看完引起冲突的修改后, 接下来就要解决这些冲突. 我们要介绍的第
           一个命令是 <userinput>m</userinput> (merge), 从 Subversion 1.8 开
           始支持, 该命令允许用户从众多选项中选择一个来解决冲突:</para>

        <informalexample>
          <screen>
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: m
Merging 'Makefile'.
Conflicting section found during merge:
(1) their version (at line 24)                  |(2) your version (at line 24)
------------------------------------------------+------------------------------------------------
top_builddir = /bar                             |top_builddir = /foo
------------------------------------------------+------------------------------------------------
Select: (1) use their version, (2) use your version,
        (12) their version first, then yours,
        (21) your version first, then theirs,
        (e1) edit their version and use the result,
        (e2) edit your version and use the result,
        (eb) edit both versions and use the result,
        (p) postpone this conflicting section leaving conflict markers,
        (a) abort file merge and return to main menu:
</screen>
        </informalexample>

      <!--
        <para>As you can see, when you use the internal file merge tool,
          you can cycle through individual conflicting areas in the
          file and select various resolution options or postpone
          conflict resolution for selected conflicts.</para>
      -->
        <para>从上面可以看到, 使用内部文件合并工具时, 用户可以循环遍历文件中
          的每一个冲突区域, 对每一个冲突区域用户都可以选择一个不同的选项, 或者
          推迟解决该冲突.</para>

      <!--
        <para>However, if you wish to use an external editor to choose some
          combination of your local
          changes, you can use the <quote>edit</quote> command
          (<userinput>e</userinput>) to manually edit the file with
          conflict markers in a text editor (configured per the
          instructions in <xref linkend="svn.advanced.externaleditors"
          />).  After you've edited the file, if you're satisfied with
          the changes you've made, you can tell Subversion that the
          edited file is no longer in conflict by using
          the <quote>resolved</quote> command
          (<literal>r</literal>).</para>
      -->
        <para>如果用户想用一个外部编辑器来选择本地修改的某些组合, 此时可用
          用命令 <userinput>e</userinput> (edit) 来手动地编辑带有冲突标记的
          文件, 该命令会打开一个文本编辑器 (参考
          <xref linkend="svn.advanced.externaleditors"/>). 文件编辑完毕后,
          如果用户感到满意, 就要用命令 <userinput>r</userinput>
          (resolved) 告诉 Subversion 文件的冲突已经解决了.</para>

      <!--
        <para>Regardless of what your local Unix snob will likely tell
          you, editing the file by hand in your favorite text editor
          is a somewhat low-tech way of remedying conflicts (see
          <xref linkend="svn.tour.cycle.resolve.byhand" /> for a
          walkthrough).  For this reason, Subversion provides
          the <quote>launch</quote> resolution command
          (<userinput>l</userinput>) to fire up a fancy graphical
          merge tool instead (see
          <xref linkend="svn.advanced.externaldifftools.merge"
          />).</para>
      -->
      <para>不管别人怎么说, 使用文本编辑器编辑文件来解决冲突是一种比较低
        级的方法 (见 <xref linkend="svn.tour.cycle.resolve.byhand"/>), 因此,
        Subversion 提供了一个命令 <userinput>l</userinput> (launch) 来打开
        精美的图形化合并工具 (见
        <xref linkend="svn.advanced.externaldifftools.merge"/>).</para>

      <!--
        <para>There is also a pair of compromise options
          available.  The <quote>mine-conflict</quote>
          (<userinput>mc</userinput>)
          and <quote>theirs-conflict</quote>
          (<userinput>tc</userinput>) commands instruct Subversion to
          select your local changes or the server's incoming changes,
          respectively, as the <quote>winner</quote> for all conflicts
          in the file.  But, unlike the <quote>mine-full</quote>
          and <quote>theirs-full</quote> commands, these commands
          preserve both your local changes and changes received from
          the server in regions of the file where no conflict was
          detected.</para>
      -->
        <para>还有两个稍微折衷一点的选项, 命令 <userinput>mc</userinput>
          (mine-conflict) 和 <userinput>tc</userinput> (theirs-conflict)
          分别告诉 Subversion 选择用户的本地修改或从服务器收到的修改作为冲突
          获胜的一方. 但是和 <quote>mine-full</quote> 以及
          <quote>theirs-full</quote> 不同的是, 这两个命令会保留不产生冲突的
          本地修改和从服务器收到的修改.</para>

      <!--
        <para>Finally, if you decide that you don't need to merge any changes,
          but just want to accept one version of the file or the
          other, you can either choose your changes (a.k.a.
          <quote>mine</quote>) by using the <quote>mine-full</quote>
          command (<userinput>mf</userinput>) or choose theirs by using the
          <quote>theirs-full</quote> command
          (<userinput>tf</userinput>).</para>
      -->
        <para>最后, 如果用户决定只想使用本地修改, 或者是只使用从服务器收到
          的修改, 可以分别选择 <userinput>mf</userinput> (mine-full) 与
          <userinput>tf</userinput> (theirs-full).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.pending">

      <!--
        <title>Postponing conflict resolution</title>
      -->
        <title>推迟解决冲突</title>

        <para>
          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>resolution (解决)</secondary>
            <tertiary>postponing (推迟)</tertiary>
          </indexterm>
      <!--
          This may sound like an appropriate section for avoiding
          marital disagreements, but it's actually still about
          Subversion, so read on.  If you're doing an update and
          encounter a conflict that you're not prepared to review or
          resolve, you can type <userinput>p</userinput> to postpone
          resolving a conflict on a file-by-file basis when you run
          <userinput>svn update</userinput>.  If you know in advance
          that you don't want to resolve any conflicts interactively,
          you can pass the <option>- -non-interactive</option> option
          to <command>svn update</command>, and any file in conflict
          will be marked with a <computeroutput>C</computeroutput>
          automatically.</para>
      -->
        这节的标题看起来好像是在讲如何避免夫妻之间爆发冲突, 可实际上
          本节还是在介绍和 Subversion 相关的内容. 如果用户在更新时遇到了冲
          突, 但是还没有准备好立即解决, 这时可以选择 <userinput>p</userinput>
          来推迟解决. 如果用户早就准备好不想交互式地解决冲突, 可以给
          <command>svn update</command> 增加一个参数
          <option>--non-interactive</option>, 此时发生冲突的文件会被自动
          标记为 <computeroutput>C</computeroutput>.</para>

      <!--
        <para>Beginning with Subversion 1.8, an internal file merge
          tool allows you to postpone conflict resolution for certain
          conflicts, but resolve other conflicts.  Therefore, you can
          postpone conflict resolution area-by-area, not just on a
          file-to-file basis.</para>
      -->
        <para>从 Subversion 1.8 开始, 内部的文件合并工具允许用户推迟解决
          某些特定的冲突, 但仍然可以解决其他冲突. 于是, 用户可以以冲突
          区域为单位 (而不仅仅是以文件为单位) 来决定哪些冲突可以推迟解决.
        </para>

      <!--
        <para>The <computeroutput>C</computeroutput>
          (for <quote>Conflicted</quote>) means that the changes from the
          server overlapped with your own, and now you have to
          manually choose between them after the update has completed.
          When you postpone a conflict resolution,
          <command>svn</command> typically does three things to assist
          you in noticing and resolving that conflict:</para>
      -->
        <para><computeroutput>C</computeroutput> (<quote>Conflicted</quote>)
          表示来自服务器的修改和用户的本地修改有所重叠, 用户在更新完成后必须
          手动加以选择. 如果用户推迟解决冲突, <command>svn</command> 通常
          会从三个方面帮助用户解决冲突:</para>

        <itemizedlist>

          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>conflict markers (冲突标记)</secondary>
          </indexterm>

          <listitem>
      <!--
            <para>Subversion prints a <computeroutput>C</computeroutput>
              during the update and remembers that the file is in a
              state of conflict.</para>
      -->
            <para>如果在更新过程中产生了冲突, Subversion 就会为含有冲突的
              文件打印一个字符 <computeroutput>C</computeroutput>, 并记住
              该文件处于冲突状态.</para>
          </listitem>

          <listitem>
      <!--
            <para>If Subversion considers the file to be mergeable, it
              places <firstterm>conflict
              markers</firstterm>&mdash;special strings of text that
              delimit the <quote>sides</quote> of the
              conflict&mdash;into the file to visibly demonstrate the
              overlapping areas.  (Subversion uses the
              <literal>svn:mime-type</literal> property to decide whether a
              file is capable of contextual, line-based merging.  See
              <xref linkend="svn.advanced.props.special.mime-type"/>
              to learn more.)</para>
      -->
            <para>如果 Subversion 认为文件是支持合并的, 它就会把
              <firstterm>冲突标记</firstterm>
              (<firstterm>conflict markers</firstterm>)&mdash;一段给冲突划分
              边界的特殊文本&mdash;插入到文本中来显式地指出重叠区域
              (Subversion 使用属性 <literal>svn:mime-type</literal> 来判断
              一个文件是否支持基于行的合并, 见
              <xref linkend="svn.advanced.props.special.mime-type"/>).</para>
          </listitem>

          <listitem>
      <!--
            <para>For every conflicted file, Subversion places three
              extra unversioned files in your working copy:</para>
      -->
            <para>对每一个产生冲突的文件, Subversion 都会在工作副本中生成
              三个额外的文件, 这些文件不在版本控制的名单中:</para>

            <variablelist>

              <varlistentry>
                <term><filename>filename.mine</filename></term>
                <listitem>
      <!--
                  <para>This is the file as it existed in your working
                    copy before you began the update process.  It
                    contains any local modifications you had made to
                    the file up to that point.  (If Subversion
                    considers the file to be unmergeable,
                    the <filename>.mine</filename> file isn't created,
                    since it would be identical to the working
                    file.)</para>
      -->
                  <para>该文件的内容和用户执行更新操作前的文件内容相同, 它
                    包含了当时所有的本地修改 (如果 Subversion 认为该文件不
                    支持合并就不会创建 <filename>.mine</filename>).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><filename>filename.r<replaceable>OLDREV</replaceable>
                      </filename></term>
                <listitem>
      <!--
                  <para>This is the file as it existed in the
                    <literal>BASE</literal> revision&mdash;that is,
                    the unmodified revision of the file in your
                    working copy <emphasis>before</emphasis> you began
                    the update process&mdash;where
                    <replaceable>OLDREV</replaceable> is that base
                    revision number.</para>
      -->
                  <para>该文件的内容和版本号 <literal>BASE</literal> 对应
                    的文件内容相同, 也就是在执行更新操作前工作副本中未修改
                    的版本, <replaceable>OLDREV</replaceable> 是基础版本号.
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><filename>filename.r<replaceable>NEWREV</replaceable>
                      </filename></term>
                <listitem>
      <!--
                  <para>This is the file that your Subversion client
                    just received from the server via the update of
                    your working copy, where
                    <replaceable>NEWREV</replaceable> corresponds to
                    the revision number to which you were updating
                    (<literal>HEAD</literal>, unless otherwise
                    requested).</para>
      -->
                  <para>该文件的内容和从服务器收到的版本相同,
                    <replaceable>NEWREV</replaceable> 等于更新到的版本号
                    (如果没有额外指定的话, 就是 <literal>HEAD</literal>).
                  </para>
                </listitem>
              </varlistentry>

            </variablelist>
          </listitem>

        </itemizedlist>

      <!--
        <para>For example, Sally makes changes to the file
          <filename>sandwich.txt</filename>, but does not yet commit
          those changes.  Meanwhile, Harry commits changes to that
          same file.  Sally updates her working copy before committing
          and she gets a conflict, which she postpones:</para>
      -->
        <para>例如, Sally 修改了文件 <filename>sandwich.txt</filename>, 但
          是还没有提交. 同时, Harry 提交了同一文件的修改. 在提交前 Sally
          执行了更新操作, 结果产生了冲突, 她选择推迟解决冲突:</para>

        <informalexample>
          <screen>
$ svn update
Updating '.':
Conflict discovered in 'sandwich.txt'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: p
C    sandwich.txt
Updated to revision 2.
Summary of conflicts:
  Text conflicts: 1
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</screen>
        </informalexample>

    <!--
        <para>At this point, Subversion will <emphasis>not</emphasis>
          allow Sally to commit the file
          <filename>sandwich.txt</filename> until the three temporary
          files are removed:</para>
    -->
        <para>此时, 直到这三个临时文件被删除之前, Subversion 不会允许 Sally
          提交 <filename>sandwich.txt</filename>:</para>

        <informalexample>
          <screen>
$ svn commit -m "Add a few more things"
svn: E155015: Commit failed (details follow):
svn: E155015: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
</screen>
        </informalexample>

      <!--
        <para>If you've postponed a conflict, you need to resolve the
          conflict before Subversion will allow you to commit your
          changes.  You'll do this with the <command>svn
          resolve</command> command.  This command accepts
          the <option>- -accept</option> option, which allows you
          specify your desired approach for resolving the conflict.
          Prior to Subversion 1.8, the <command>svn resolve</command>
          command <emphasis>required</emphasis> the use of this option.
          Subversion now allows you to run the <command>svn
          resolve</command> command without that option.  When you do
          so, Subversion cranks up its interactive conflict resolution
          mechanism, which you can read about (if you haven't done so
          already) in the previous section,
          <xref linkend="svn.tour.cycle.resolve.resolve" />.  We'll
          take the opportunity in this section, though, to discuss
          the use of the <option>- -accept</option> option for
          conflict resolution.</para>
      -->
        <para>如果用户选择推迟解决冲突, 只有在冲突解决之后, Subversion 才
          会重新允许用户提交修改, 其中要用到的命令是
          <command>svn resolve</command>. 该命令接受一个
          <option>--accept</option> 选项, 它指明了用户想要如何解决冲突.
          在 Subversion 1.8 以前, <option>--accept</option> 是命令
          <command>svn resolve</command> 的必填选项, 但是现在它是可选的.
          如果不带 <option>--accept</option> 地执行
          <command>svn resolve</command>, Subversion 就会进入交互式地冲突
          解决步骤, 这部分内容我们已经在上一节&mdash;
          <xref linkend="svn.tour.cycle.resolve.resolve"/>&mdash;介绍过了.
          下面我们会介绍如何使用选项 <option>--accept</option>.</para>

      <!--
        <para>The <option>- -accept</option> option to the <command>svn
          resolve</command> command instructs Subversion to use one of
          its pre-packaged approaches to conflict resolution.  If
          you want Subversion to resolve the conflict using the
          version of the file that you last checked out before making
          your edits, use <option>- -accept=base</option>.  If you'd
          prefer instead to keep the version that contains only your
          edits, use <option>- -accept=mine-full</option>.  You can also
          select the version that your most recent update pulled from
          the server (discarding your edits entirely)&mdash;that's
          done using <option>- -accept=theirs-full</option>.  There
          are other <quote>canned</quote> resolution types, too.  See
          <xref linkend="svn.ref.svn.sw.accept" /> in
          <xref linkend="svn.ref.svn" /> for details.</para>
      -->
        <para>选项 <option>--accept</option> 指示 Subversion 使用预先定义
          好的几种方法之一来解决冲突. 如果用户想要用上一次检出时的版本,就
          写成 <option>--accept=base</option>; 如果用户只想保留自己的修改,
          就写成 <option>--accept=mine-full</option>; 如果用户只想保留从
          服务器收到的更新, 就写成 <option>--accept=theirs-full</option>.
          除了刚才介绍的几个, 还有其他一些选项值, 参考
          <xref linkend="svn.ref.svn"/> 的
          <xref linkend="svn.ref.svn.sw.accept"/>.</para>

      <!--
        <para>You aren't limited strictly to all-or-nothing options.
          If you want to pick and choose from your changes and the
          changes that your update fetched from the server, you can
          manually repair the working file, fixing up the conflicted
          text <quote>by hand</quote> (by examining and editing the
          conflict markers within the file), then tell Subversion to
          resolve the conflict by keeping the working file in its
          current state by running <command>svn resolve</command> with
          the <option>- -accept=working</option> option.</para>
      -->
        <para>如果用户想要自己选择哪些修改进入最终版本, 那就自己手动编辑
          文件, 修改冲突区域 (带有冲突标记的区域), 然后使用选项
          <command>--accept=working</command> 告诉 Subversion 把文件的
          当前内容作为冲突解决后的状态.</para>

      <!--
        <para><command>svn resolve</command> removes the three
          temporary files and accepts the version of the file that you
          specified.  After the command completes
          successfully&mdash;and assuming you didn't interactively
          choose to postpone resolution, of course&mdash;Subversion no
          longer considers the file to be in a state of
          conflict:</para>
      -->
        <para><command>svn resolve</command> 删除三个临时文件, 将用户指定的
          文件版本作为冲突解决后的最终版. 命令执行成功后 Subversion 不再认为
          文件处于冲突状态:</para>

        <informalexample>
          <screen>
$ svn resolve --accept working sandwich.txt
Resolved conflicted state of 'sandwich.txt'
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.byhand">
      <!--
        <title>Manual conflict resolution</title>
      -->
        <title>手动地解决冲突</title>

        <para>
          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>resolution (解决)</secondary>
            <tertiary>manual (手动地)</tertiary>
          </indexterm>
      <!--
          Manually resolving conflicts can be quite intimidating the
          first time you attempt it, but with a little practice, it
          can become as easy as falling off a bike.</para>
      -->
          第一次尝试手动解决冲突会让不少人感到紧张, 但只要多练几次, 就会像
          骑自行车一样简单.</para>

      <!--
        <para>Here's an example.  Due to a miscommunication, you and
          Sally, your collaborator, both edit the file
          <filename>sandwich.txt</filename> at the same time.  Sally
          commits her changes, and when you go to update your working
          copy, you get a conflict and you're going to have to edit
          <filename>sandwich.txt</filename> to resolve the conflict.
          First, let's take a look at the file:</para>
      -->
        <para>这里有一个例子. 由于沟通上的误会, 你和你的同事, Sally, 同时修改
          了 <filename>sandwich.txt</filename>, Sally 先提交了修改, 结果当你
          更新工作副本时发生了冲突, 现在你需要手动编辑文件来解决冲突. 首先先
          看一下发生冲突后的文件内容:</para>

        <informalexample>
          <screen>
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
</screen>
        </informalexample>

      <!--
        <para>The strings of less-than signs, equals signs, and
          greater-than signs are conflict markers and are not part of
          the actual data in conflict.  You generally want to ensure
          that those are removed from the file before your next
          commit.  The text between the first two sets of markers is
          composed of the changes you made in the conflicting
          area:</para>
      -->
        <para>分别由小于号, 等号和大于号组成的行是冲突标记, 它们不是冲突数据
          的一部分, 用户通常只需要确保在提交前把它们都删除掉即可. 前两个标记之
          间的文本是用户的本地修改.</para>

        <informalexample>
          <screen>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
</screen>
        </informalexample>

      <!--
        <para>The text between the second and third sets of conflict
          markers is the text from Sally's commit:</para>
      -->
        <para>后两个标记之间的内容是 Sally 提交的修改:</para>

        <informalexample>
          <screen>
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</screen>
        </informalexample>

      <!--
        <para>Usually you won't want to just delete the conflict
          markers and Sally's changes&mdash;she's going to be awfully
          surprised when the sandwich arrives and it's not what she
          wanted.  This is where you pick up the phone or walk across
          the office and explain to Sally that you can't get
          sauerkraut from an Italian deli.<footnote><para>And if you
          ask them for it, they may very well ride you out of town on
          a rail.</para></footnote>  Once you've agreed on the changes
          you will commit, edit your file and remove the conflict
          markers:</para>
      -->
        <para>通常情况下你不能直接删除冲突标记和 Sally 的修改&mdash;
          否则的话当她收到三明治时就会感到一头雾水, 此时你应该向她说明意大
          利熟食店不出售泡洋白菜丝. 假设 <filename>sandwich.txt</filename>
          修改完毕后的内容是:</para>
        <informalexample>
          <screen>
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
</screen>
        </informalexample>

      <!--
        <para>Now use <command>svn resolve</command>, and you're
          ready to commit your changes:</para>
      -->
        <para>使用命令 <command>svn resolve</command> 移除文件的冲突状态后,
          接下来就可以提交修改了:</para>

        <informalexample>
          <screen>
$ svn resolve --accept working sandwich.txt
Resolved conflicted state of 'sandwich.txt'
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
</screen>
        </informalexample>

      <!--
        <para>Naturally, you want to be careful that when using
          <command>svn resolve</command> you don't tell Subversion
          that you've resolved a conflict when you truly haven't.
          Once the temporary files are removed, Subversion will let
          you commit the file even if it still contains conflict
          markers.</para>
      -->
        <para>通常情况下, 如果用户还没有编辑好文件就不要用
          <command>svn resolve</command> 告诉 Subversion 你已经解决好了
          冲突, 因为临时文件一旦被删除, 即使文件中还含有冲突标记, Subversion
          依然会允许用户提交修改.</para>

      <!--
        <para>If you ever get confused while editing the conflicted
          file, you can always consult the three files that Subversion
          creates for you in your working copy&mdash;including your
          file as it was before you updated.  You can even use a
          third-party interactive merging tool to examine those three
          files.</para>
      -->
        <para>如果用户在编辑含有冲突的文件时感到困惑, 应该看一下 Subversion
          创建的那三个临时文件, 甚至可以用第三方的交互式文件合并工具来查看
          它们.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.theirsfull">
      <!--
        <title>Discarding your changes in favor of a newly fetched
          revision</title>
      -->
        <title>只使用从服务器收到的更新</title>
  
        <para>
          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>resolution (解决)</secondary>
            <tertiary>discarding local changes (丢弃本地修改)</tertiary>
          </indexterm>
      <!--
          If you get a conflict and decide that you want
          to throw out your changes, you can run <userinput>svn
          resolve - -accept theirs-full
          <replaceable>CONFLICTED-PATH</replaceable></userinput> and
          Subversion will discard your edits and remove the temporary
          files:</para>
      -->
        如果在更新时产生了冲突, 而你想要完全丢弃自己的修改, 就执行
        <userinput>svn resolve --accept theirs-full <replaceable>CONFLICTED-PATH
        </replaceable></userinput>, 此时 Subversion 就会丢弃用户的本地修改, 并
        删除临时文件:</para>

        <informalexample>
         <screen>
$ svn update
Updating '.':
Conflict discovered in 'sandwich.txt'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: p
C    sandwich.txt
Updated to revision 2.
Summary of conflicts:
  Text conflicts: 1
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ svn resolve --accept theirs-full sandwich.txt
Resolved conflicted state of 'sandwich.txt'
$
</screen>
       </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.revert">
      <!--
        <title>Punting: using svn revert</title>
      -->
        <title>使用 svn revert</title>

        <para>
          <indexterm>
            <primary>conflicts (冲突)</primary>
            <secondary>resolution (解决)</secondary>
            <tertiary>discarding local changes (丢弃本地修改)</tertiary>
          </indexterm>
      <!--
          If you decide that you want to throw out your changes
          and start your edits again (whether this occurs after a
          conflict or anytime), just revert your changes:</para>
      -->
        如果用户决定丢弃当前的所有修改 (无论是在冲突后, 还是在任何时候), 就
        用 <command>svn revert</command>:</para>

        <informalexample>
          <screen>
$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt
$
</screen>
        </informalexample>

      <!--
        <para>Note that when you revert a conflicted file, you don't
          have to use <command>svn resolve</command>.</para>
      -->
        <para>注意, 含有冲突的文件被回滚后不需要再对它使用
          <command>svn resolve</command>.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.commit">
      <!--
      <title>Commit Your Changes</title>
      -->
      <title>提交修改</title>

      <!--
      <para>Finally!  Your edits are finished, you've merged all
        changes from the server, and you're ready to commit your
        changes to the repository.</para>
      -->
      <para>终于, 所有的编辑都完成了, 从服务收到的更新也已合并完成, 现在你
        已经准备好向仓库提交修改.</para>

      <!--
      <para>The <command>svn commit</command> command sends all of
        your changes to the repository.  When you commit a change, you
        need to supply a log message describing your change.  Your log
        message will be attached to the new revision you create.  If
        your log message is brief, you may wish to supply it on the
        command line using the <option>- -message</option>
        (<option>-m</option>) option:</para>
      -->
      <para><command>svn commit</command> 把本地的所有修改发往仓库. 提交时
        用户需要输入一段日志来描述本次修改, 日志被附加到新的版本号上. 如果
        日志比较简短, 可以用选项 <option>--message</option>
        (<option>-m</option>) 直接在命令行上输入日志:</para>

      <informalexample>
        <screen>
$ svn commit -m "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</screen>
      </informalexample>

      <!--
      <para>However, if you've been composing your log message in some
        other text file as you work, you may want to tell Subversion
        to get the message from that file by passing its filename as
        the value of the <option>- -file</option> (<option>-F</option>)
        option:</para>
      -->
      <para>如果用户已经事先把日志写到了某个文本文件中, 希望 Subversion 在
        提交时直接从该文件中读取日志, 这可以通过选项 <option>--file</option>
        (<option>-F</option>) 实现:</para>

      <informalexample>
        <screen>
$ svn commit -F logmsg
Sending        sandwich.txt
Transmitting file data .
Committed revision 4.
</screen>
      </informalexample>

      <!--
      <para>If you fail to specify either the
        <option>- -message</option> (<option>-m</option>)
        or <option>- -file</option> (<option>-F</option>) option,
        Subversion will automatically launch your favorite editor (see
        the information on <literal>editor-cmd</literal> in
        <xref linkend="svn.advanced.confarea.opts.config"/>) for
        composing a log message.</para>
      -->
      <para>如果用户在提交时没有指定选项 <option>--message</option>
        (<option>-m</option>) 或 <option>--file</option>
        (<option>-F</option>), Subversion 就会自动打开用户指定的编辑器
        (见 <xref linkend="svn.advanced.confarea.opts.config"/> 的
        <literal>editor-cmd</literal>) 来编写日志.</para>
      <tip>
      <!--
        <para>If you're in your editor writing a commit message and
          decide that you want to cancel your commit, you can just
          quit your editor without saving changes.  If you've already
          saved your commit message, simply delete all the text, save
          again, and then abort:</para>
      -->
        <para>如果用户在编写日志时突然又不想提交了, 那就不保存地退出编辑
          器; 如果已经保存过, 那就删除全部的提交日志, 再保存一遍, 然后
          退出编辑器:</para>

        <informalexample>
          <screen>
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
(a)bort, (c)ontinue, (e)dit
a
$
</screen>
        </informalexample>
      </tip>

      <!--
      <para>The repository doesn't know or care whether your changes make
        any sense as a whole; it checks only to make sure nobody
        else has changed any of the same files that you did when you
        weren't looking. If somebody <emphasis>has</emphasis> done
        that, the entire commit will fail with a message informing you
        that one or more of your files are out of date:</para>
      -->
      <para>仓库不知道也不关心用户的提交是否有意义, 它只能确保没有人趁你不
        注意时修改了同一文件. 如果确实有人这么做了, 整个提交就会失败, 并打印
        一条错误消息说其中某些文件过时了:</para>

      <informalexample>
        <screen>
$ svn commit -m "Add another rule"
Sending        rules.txt
Transmitting file data .
svn: E155011: Commit failed (details follow):
svn: E155011: File '/home/sally/svn-work/sandwich.txt' is out of date
&hellip;
</screen>
      </informalexample>

    <!--
      <para>(The exact wording of this error message depends on the
        network protocol and server you're using, but the idea is the
        same in all cases.)</para>
    -->
      <para>(错误消息的具体内容取决于网络协议和服务器, 但是基本内容都是类似
        的.)</para>

      <!--
      <para>At this point, you need to run <userinput>svn
        update</userinput>, deal with any merges or conflicts that
        result, and then attempt your commit again.</para>
      -->
      <para>此时用户需要执行 <userinput>svn update</userinput>, 解决可能
        的冲突, 然后再次尝试提交.</para>

      <!--
      <para>That covers the basic work cycle for using Subversion.
        Subversion offers many other features that you can use
        to manage your repository and working copy, but most of your
        day-to-day use of Subversion will involve only the commands
        that we've discussed so far in this chapter.  We will,
        however, cover a few more commands that you'll use fairly
        often.</para>
      -->
      <para>本节介绍的内容覆盖了 Subversion 的基本工作周期. 为了方便用户
        使用仓库和工作副本, Subversion 还提供了很多特性, 但是在大部分情况下,
        Subversion 的日常使用只会用到我们目前所介绍的这些命令. 下面我们还将
        会介绍几个较常用到的命令.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.history">
      <!--
    <title>Examining History</title>
      -->
    <title>检查历史</title>

      <!--
    <para>Your Subversion repository is like a time machine.  It keeps
      a record of every change ever committed and allows you to
      explore this history by examining previous versions of files and
      directories as well as the metadata that accompanies them.  With
      a single Subversion command, you can check out the repository
      (or restore an existing working copy) exactly as it was at any
      date or revision number in the past.  However, sometimes you
      just want to <emphasis>peer into</emphasis> the past instead of
      <emphasis>going into</emphasis> it.</para>
      -->
    <para>Subversion 仓库就像一台时间机器, 它记录了用户提交的每一次修改,
      允许用户查看文件和目录以前的版本, 以及它们的元数据. 只要一个命令,
      用户就可以检出仓库在以前任意一个时间点或版本号的版本 (或者回滚工作
      副本的版本号). 不过, 有时候用户可能只是想看一下过去的历史,
      而不是想真正地回到过去.</para>

      <!--
    <para>Several commands can provide you with historical data from
      the repository:</para>
      -->
    <para>下面几个命令提供了检索历史数据的功能:</para>

      <variablelist>

        <varlistentry>
          <term><command>svn diff</command></term>
          <listitem>
      <!--
            <para>Shows line-level details of a particular change</para>
      -->
            <para>从行的级别上查看修改的内容</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn log</command></term>
          <listitem>
      <!--
            <para>Shows you broad information: log messages with date
              and author information attached to revisions and which
              paths changed in each revision</para>
      -->
            <para>和版本号绑定的日志消息, 及其日期, 作者, 以及受影响的文件
              路径.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn cat</command></term>
          <listitem>
      <!--
            <para>Retrieves a file as it existed in a particular
              revision number and displays it on your screen</para>
      -->
            <para>根据给定的版本号, 输出文件在该版本下的内容.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn annotate</command></term>
          <listitem>
      <!--
            <para>Retrieves a human-readable file as it existed in a
              particular revision number, displaying its contents in a
              tabular form with last-changed information attributed to
              each line of the file</para>
      -->
            <para>根据给定的版本号, 查看该版本下的文件的每一行的最后一
              次修改信息.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn list</command></term>
          <listitem>
      <!--
            <para>Displays the files in a directory for any given
              revision</para>
      -->
            <para>根据给定的版本号, 列出仓库在该版本下的文件与目录清单.</para>
          </listitem>
        </varlistentry>

      </variablelist>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.diff">
      <!--
      <title>Examining the Details of Historical Changes</title>
      -->
      <title>查看历史修订的细节</title>

      <!--
      <para>We've already seen <command>svn diff</command>
        before&mdash;it displays file differences in unified diff
        format; we used it to show the local modifications made to
        our working copy before committing to the repository.</para>
      -->
      <para>我们已经介绍过 <command>svn diff</command>&mdash;按照标准差异格式
        显示文件的变化, 前文我们是用它显示工作副本的本地修改.</para>

    <!--
      <para>In fact, it turns out that there are
        <emphasis>three</emphasis> distinct uses of <command>svn
        diff</command>:</para>
    -->
      <para>实际上, <command>svn diff</command> 有三种用法:</para>

      <itemizedlist>

        <listitem>
      <!--
          <para>Examining local changes</para>
      -->
          <para>查看本地修改</para>
        </listitem>

        <listitem>
      <!--
          <para>Comparing your working copy to the repository</para>
      -->
          <para>比较工作副本和仓库</para>
        </listitem>

        <listitem>
      <!--
          <para>Comparing repository revisions</para>
      -->
          <para>比较仓库的版本号</para>
        </listitem>

      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.local">
      <!--
        <title>Examining local changes</title>
      -->
        <title>查看本地修改</title>

      <!--
        <para>As we've seen, invoking <userinput>svn diff</userinput> with
          no options will compare your working files to the cached
          <quote>pristine</quote> copies in
          the <filename>.svn</filename> area:</para>
      -->
        <para>如果不带选项地执行 <userinput>svn diff</userinput>,
          命令就会拿文件的当前内容和存放在 <filename>.svn</filename> 中的原始
          文件作对比:</para>

        <informalexample>
          <screen>
$ svn diff
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.wcrepos">
      <!--
        <title>Comparing working copy to repository</title>
      -->
        <title>比较工作副本和仓库</title>

      <!--
        <para>If a single <option>- -revision</option>
          (<option>-r</option>) number is passed, your
          working copy is compared to the specified revision in the
          repository:</para>
      -->
        <para>如果带上选项 <option>--revision</option> (<option>-r</option>),
          命令就把工作副本和仓库中指定的版本号作对比:</para>

        <informalexample>
          <screen>
$ svn diff -r 3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.reposrepos">
      <!--
        <title>Comparing repository revisions</title>
      -->
        <title>比较仓库的版本号</title>

      <!--
        <para>If two revision numbers, separated by a colon, are
          passed via <option>- -revision</option>
          (<option>-r</option>), the two revisions are directly
          compared:</para>
      -->
        <para>如果用选项 <option>--revision</option> (<option>-r</option>)
          传递了一对用冒号隔开的版本号, 命令就会比较这两个版本号的差异.</para>

        <informalexample>
          <screen>
$ svn diff -r 2:3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</screen>
        </informalexample>

      <!--
        <para>A more convenient way of comparing one revision to the
          previous revision is to use the <option>- -change</option>
          (<option>-c</option>) option:</para>
      -->
        <para>如果要比较某个版本号与前一个版本号, 比较方便的做法是用选项
          <option>--change</option> (<option>-c</option>):</para>

        <informalexample>
          <screen>
$ svn diff -c 3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</screen>
        </informalexample>

      <!--
        <para>Lastly, you can compare repository revisions even when
          you don't have a working copy on your local machine, just by
          including the appropriate URL on the command line:</para>
      -->
        <para>最后, 即使本地机器上没有工作副本, <command>svn diff</command>
          也可以比较仓库的版本号, 方法是在命令行中指定 URL:</para>

        <informalexample>
          <screen>
$ svn diff -c 5 http://svn.example.com/repos/example/trunk/text/rules.txt
&hellip;
$
</screen>
        </informalexample>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.log">
      <!--
      <title>Generating a List of Historical Changes</title>
      -->
      <title>生成历史修改列表</title>

      <!--
      <para>To find information about the history of a file or
        directory, use the <command>svn log</command>
        command.  <command>svn log</command> will provide you with a
        record of who made changes to a file or directory, at what
        revision it changed, the time and date of that revision,
        and&mdash;if it was provided&mdash;the log message that accompanied
        the commit:</para>
      -->
      <para>为了查看某个文件或目录的历史修改信息, 使用命令
        <command>svn log</command>, 它显示的信息包括提交修改的作者, 版本号,
        时间和日期, 以及日志消息 (如果有的话):</para>

      <informalexample>
        <screen>
$ svn log
------------------------------------------------------------------------
r3 | sally | 2008-05-15 23:09:28 -0500 (Thu, 15 May 2008) | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | 2008-05-14 18:43:15 -0500 (Wed, 14 May 2008) | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | 2008-05-10 19:50:31 -0500 (Sat, 10 May 2008) | 1 line

Initial import
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>Note that the log messages are printed in
        <emphasis>reverse chronological order</emphasis> by default.
        If you wish to see a different range of revisions in a
        particular order or just a single revision, pass the
        <option>- -revision</option> (<option>-r</option>)
        option:</para>
      -->
      <para>注意, <command>svn log</command> 默认按照时间逆序来打印消息,
        如果用户只想查看某段范围内的日志, 或者是单个版本号的日志, 又或者是想
        改变打印顺序, 就带上选项 <option>--revision</option>
        (<option>-r</option>):</para>

      <table id="svn.tour.history.log.tbl-1">
      <!--
        <title>Common log requests</title>
      -->
        <title>常见的日志请求</title>
        <tgroup cols="2">
          <thead>
            <row>
      <!--
              <entry>Command</entry>
              <entry>Description</entry>
      -->
              <entry>命令</entry>
              <entry>描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><userinput>svn log -r 5:19</userinput></entry>
      <!--
              <entry>Display logs for revisions 5 through 19 in
                chronological order</entry>
      -->
              <entry>按照时间顺序打印从版本号 5 到 19 的日志</entry>
            </row>
            <row>
              <entry><userinput>svn log -r 19:5</userinput></entry>
      <!--
              <entry>Display logs for revisions 5 through 19 in
                reverse chronological order</entry>
      -->
              <entry>按照时间逆序打印从版本号 5 到 19 的日志</entry>
            </row>
            <row>
              <entry><userinput>svn log -r 8</userinput></entry>
      <!--
              <entry>Display logs for revision 8 only</entry>
      -->
              <entry>显示版本号 8 的日志</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <!--
      <para>You can also examine the log history of a single file or
        directory.  For example:</para>
      -->
      <para>也可以只查看单个文件或目录的日志, 例如:</para>

      <informalexample>
        <screen>
$ svn log foo.c
&hellip;
$ svn log http://foo.com/svn/trunk/code/foo.c
&hellip;
</screen>
      </informalexample>

      <!--
      <para>These will display log messages <emphasis>only</emphasis>
        for those revisions in which the named file (or directory)
        changed.</para>
      -->
      <para>上面的命令只会显示和 <filename>foo.c</filename> 相关的版本号的
        日志.</para>

      <sidebar>

      <!--
        <title>Why Does svn log Not Show Me What I
          Just Committed?</title>
      -->
        <title>为什么 svn log 没有显示我刚提交的日志?</title>

      <!--
        <para>If you make a commit and immediately type <userinput>svn
          log</userinput> with no arguments, you may notice that your
          most recent commit doesn't show up in the list of log
          messages.  This is due to a combination of the behavior of
          <command>svn commit</command> and the default behavior of
          <command>svn log</command>.  First, when you commit changes
          to the repository, <command>svn</command> bumps only the
          revision of files (and directories) that it commits, so
          usually the parent directory remains at the older revision
          (See
          <xref linkend="svn.basic.in-action.mixedrevs.update-commit"/>
          for an explanation of why).  <command>svn log</command> then
          defaults to fetching the history of the directory at its
          current revision, and thus you don't see the newly committed
          changes.  The solution here is to either update your working
          copy or explicitly provide a revision number to <command>svn
          log</command> by using the <option>- -revision</option>
          (<option>-r</option>) option.</para>
      -->
        <para>如果在提交之后马上不带参数地执行 <userinput>svn log</userinput>,
          用户就会发现输出的日志消息中没有包含最近的几次提交, 这种情况是由
          <command>svn commit</command> 和 <command>svn log</command> 的
          共同作用的结果. 首先, 用户向仓库提交修改时, <command>svn</command>
          只更新了被提交的文件和目录的版本号, 所以父目录依然是
          较旧的版本号 (原因见
          <xref linkend="svn.basic.in-action.mixedrevs.update-commit"/>),
          <command>svn log</command> 默认从目录的当前版本号开始获取历史消息,
          所以用户就看不到刚提交的日志. 解决办法是用
          <command>svn update</command> 更新工作副本, 或通过选项
          <option>--revision</option> (<option>-r</option>) 显式地向
          <command>svn log</command> 传递一个版本号.</para>

      </sidebar>

      <!--
      <para>If you want even more information about a file or
        directory, <command>svn log</command> also takes a
        <option>- -verbose</option> (<option>-v</option>) option.
        Because Subversion allows you to move and copy files and
        directories, it is important to be able to track path changes
        in the filesystem.  So, in verbose mode, <command>svn
        log</command> will include a list of changed paths in a
        revision in its output:</para>
      -->
      <para>如果用户想在日志消息中看到更多的细节, 就带上选项
        <option>--verbose</option> (<option>-v</option>). 因为 Subversion
        允许用户移动和复制文件或目录, 所以如果能在日志中看到文件路径的变化
        就方便多了. 带上选项 <option>--verbose</option> (<option>-r</option>)
        后, <command>svn log</command> 的输出中就会包含被修改的文件路径:</para>

      <informalexample>
        <screen>
$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2008-05-21 13:19:25 -0500 (Wed, 21 May 2008) | 1 line
Changed paths:
   M /trunk/code/foo.c
   M /trunk/code/bar.h
   A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para><command>svn log</command> also takes
        a <option>- -quiet</option> (<option>-q</option>) option, which
        suppresses the body of the log message.  When combined
        with <option>- -verbose</option> (<option>-v</option>), it
        gives just the names of the changed files.</para>
      -->
      <para><command>svn log</command> 还支持选项 <option>--quiet</option>
        (<option>-q</option>), 它会阻止打印日志消息主体, 如果和
        <option>--verbose</option> (<option>-v</option>) 一起使用,
        那么 <command>svn log</command> 只会打印被修改的文件路径.</para>

      <sidebar>
      <!--
        <title>Why Does svn log Give Me an Empty
          Response?</title>
      -->
        <title>为什么 svn log 什么都没输出?</title>

      <!--
        <para>After working with Subversion for a bit, most users will
          come across something like this:</para>
      -->
        <para>Subversion 用了一段时间后, 大多数用户可能会碰到下面这种情况:
        </para>

        <informalexample>
          <screen>
$ svn log -r 2
------------------------------------------------------------------------
$
</screen>
        </informalexample>

      <!--
        <para>At first glance, this seems like an error.  But recall
          that while revisions are repository-wide, <command>svn
          log</command> operates on a path in the repository.  If you
          supply no path, Subversion uses the current working
          directory as the default target.  As a result, if you're
          operating in a subdirectory of your working copy and attempt
          to see the log of a revision in which neither that directory
          nor any of its children was changed, Subversion will show you
          an empty log.  If you want to see what changed in that
          revision, try pointing <command>svn log</command> directly at
          the topmost URL of your repository, as in <userinput>svn log
          -r 2 ^/</userinput>.</para>
      -->
      <para>乍看起来好像是 Subversion 出错了, 但是别忘了版本号是整个
        仓库统一进行编号. <command>svn log</command> 针对仓库中的文件
        路径进行操作, 如果用户在执行命令时没有提供路径参数,
        <command>svn log</command> 就把当前工作副本作为默认目标. 于是,
        如果用户上在某个工作副本目录中查看某个版本号的日志, 而在这个版本
        号中, 当前工作目录及其子目录与子目录都没有被修改, 所以 Subversion
        什么都没打印. 如果确实想看该版本号的日志, 就把仓库的顶层 URL 作为
        参数传递给 <command>svn log</command>, 例如
        <userinput>svn log -r 2 ^/</userinput>.</para>

      </sidebar>

      <!--
      <para>As of Subversion 1.7, users of the Subversion command-line
        can also take advantage of a special output mode
        for <command>svn log</command> which integrates a difference
        report such as is generated by the <command>svn diff</command>
        command we introduced earlier.  When you invoke <command>svn
        log</command> with the <option>- -diff</option> option,
        Subversion will append to each revision log chunk in the log
        report a <command>diff</command>-style difference report.
        This is a very convenient way to see both the high-level, semantic
        changes and the line-based modifications of a revision all at
        the same time!</para>
      -->
      <para>从 Subversion 1.7 开始, 用户还可以让 <command>svn log</command>
        产生标准差异格式的输出, 就像 <command>svn diff</command>. 如果给
        <command>svn log</command> 加上选项 <option>--diff</option>,
        用户就可以在行的级别上看到本次修订的具体修改内容, 于是, 用户可以同
        时从高层的语义修改和底层的基于行的变化来查看文件的修改历史.</para>

      <!--
      <para>Beginning with Subversion 1.8, <command>svn log</command>
        accepts <option>- -search</option> and <option>- -search-and</option>
        options.  The options allow you to filter the output of
        <command>svn log</command> based on the search pattern you
        supply.  When using these options, a log message is shown
        only if a revision's author, date, log message text, or list
        of changed paths, matches the search pattern.</para>
      -->
      <para>从 Subversion 1.8 开始, <command>svn log</command> 支持选项
        <option>--search</option> 和 <option>--search-and</option>. 这两个
        选项允许用户指定搜索模式字符串, 从而过滤 <command>svn log</command>
        的输出: 只有当版本号的作者, 日期, 日志消息或被修改的文件路径与搜索
        模式匹配时, 才会输出该日志.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.browsing">
      <!--
      <title>Browsing the Repository</title>
      -->
      <title>浏览仓库</title>

      <!--
      <para>Using <command>svn cat</command> and <command>svn
        list</command>, you can view various revisions of files and
        directories without changing the working revision of your
        working copy.  In fact, you don't even need a working copy to
        use either one.</para>
      -->
      <para>利用 <command>svn cat</command> 和 <command>svn list</command>,
        用户可以查看任意一个版本号下的文件和目录, 而无须修改工作副本, 实际上,
        在使用这两个命令时甚至都不需要工作副本.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.cat">
      <!--
        <title>Displaying file contents</title>
      -->
        <title>显示文件的内容</title>

      <!--
        <para>If you want to examine an earlier version of a file and
          not necessarily the differences between two files, you can use
          <command>svn cat</command>:</para>
      -->
        <para>如果用户只想查看文件旧版本的内容, 可以用
          <command>svn cat</command>:</para>

        <informalexample>
          <screen>
$ svn cat -r 2 rules.txt
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth open
$
</screen>
        </informalexample>

      <!--
        <para>You can also redirect the output directly into a
          file:</para>
      -->
        <para>还可以把输出重定向到一个文件中:</para>

        <informalexample>
          <screen>
$ svn cat -r 2 rules.txt &gt; rules.txt.v2
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.annotate">
      <!--
        <title>Displaying line-by-line change attribution</title>
      -->
        <title>显示每一行的修改属性</title>

      <!--
        <para>Very similar to the <command>svn cat</command> command
          we discussed in the previous section is the <command>svn
          annotate</command> command.  This command also displays the
          contents of a versioned file, but it does so using a tabular
          format.  Each line of output shows not only a line of the
          file's content but also the username, the revision number
          and (optionally) the datestamp of the revision in which that
          line was last modified.</para>
      -->
        <para>和 <command>svn cat</command> 比较类似的命令是
          <command>svn annotate</command> 有点类似, 但是 <command>svn annotate
          </command> 的输出更丰富&mdash;除了文件的内容外, 还会输出每一行
          最后一次被修改时的作者, 版本号及其日期 (可选).</para>

      <!--
        <para>When used with a working copy file target, <command>svn
          annotate</command> will by default show line-by-line
          attribution of the file as it currently appears in the
          working copy.</para>
      -->
        <para>如果参数是工作副本中的文件, <command>svn annotate</command>
          会根据文件的当前内容输出每一行的属性:</para>

        <informalexample>
          <screen>
$ svn annotate rules.txt
     1      harry Be kind to others
     3      sally Freedom = Responsibility
     1      harry Everything in moderation
     -          - Chew with your mouth closed
     -          - Listen when others are speaking
</screen>
        </informalexample>

      <!--
        <para>Notice that for some lines, there is no attribution
          provided.  In this case, that's because those lines have
          been modified in the working copy's version of the file.  In
          this way, <command>svn annotate</command> becomes another
          way for you to see which lines in the file you have
          changed.  You can use the <literal>BASE</literal> revision
          keyword (see <xref linkend="svn.tour.revs.keywords" />) to
          instead see the unmodified form of the file as it resides
          in your working copy.</para>
      -->
        <para>在上面的例子里, 某些行的属性没有打印出来, 原因是这几行在工作
          副本中被修改了. 利用这个特点, 我们也可以通过 <command>svn annotate
          </command> 判断出文件的哪些行被修改了. 用户可以用版本号关键词
          <literal>BASE</literal> (见 <xref linkend="svn.tour.revs.keywords"/>)
          查看文件的未修改版本的输出:</para>

        <informalexample>
          <screen>
$ svn annotate rules.txt@BASE
     1      harry Be kind to others
     3      sally Freedom = Responsibility
     1      harry Everything in moderation
     1      harry Chew with your mouth open
</screen>
        </informalexample>

      <!--
        <para>The <option>- -verbose (-v)</option> option causes
          <command>svn annotate</command> to also include on each line
          the datestamp associated with that line's reported revision
          number.  (This adds a significant amount of width to each
          line of ouput, so we'll skip the demonstration here.)</para>
      -->
        <para>选项 <option>--verbose</option> (<option>-v</option>) 使得
          <command>svn annotate</command> 在输出中增加每一行的版本号的
          提交日期 (这会显著增加输出内容的宽度, 所以我们不在这里展示添加
          了选项 <option>--verbose</option> 后的运行效果).</para>

      <!--
        <para>As with <command>svn cat</command>, you can also
          ask <command>svn annotate</command> to display previous
          versions of the file.  This can be a handy trick when, after
          finding out who most recently modified a particular line of
          interest in the file, you then wish to see who modified the
          same line prior to that.</para>
      -->
        <para>和 <command>svn cat</command> 一样, <command>svn annotate
          </command> 也能针对文件的旧版本进行操作, 这个功能有时候会很有
          帮助&mdash;如果用户已经找到了文件中某一行的最后一次修改的版本号,
          他可能还想知道在此之前是谁最后一次修改了这一行:</para>

        <informalexample>
          <screen>
$ svn blame rules.txt -r 2
     1      harry Be kind to others
     1      harry Freedom = Chocolate Ice Cream
     1      harry Everything in moderation
     1      harry Chew with your mouth open
</screen>
        </informalexample>

      <!--
        <para>Unlike the <command>svn cat</command> command, the
          functionality of <command>svn annotate</command> is tied
          heavily to the idea of <quote>lines</quote> of text in a
          human-readable file.  As such, if you attempt to run the
          command on a file that Subversion has determined is
          <emphasis>not</emphasis> human-readable (per the file's
          <literal>svn:mime-type</literal> property&mdash;see <xref
          linkend="svn.advanced.props.special.mime-type" /> for
          details), you'll get an error message.</para>
      -->
        <para>和 <command>svn cat</command> 不同的是, <command>svn annotate
          </command> 的正常运行要求文件必须是人类可读的, 以行为单位的文本
          文件, 如果 Subversion 认为文件不是人类可读的 (根据文件的
          <literal>svn:mime-type</literal> 属性&mdash;见
          <xref linkend="svn.advanced.props.special.mime-type"/>),
          <command>svn annotate</command> 就输出一条错误消息:</para>

        <informalexample>
          <screen>
$ svn annotate images/logo.png
Skipping binary file (use --force to treat as text): 'images/logo.png'
$
</screen>
        </informalexample>

      <!--
        <para>As revealed in the error message, you can use
          the <option>- -force</option> option to disable this check
          and proceed with the annotation as if the file's contents
          are, in fact, human-readable and line-based.  Naturally, if
          you force Subversion to try to perform line-based annotation
          on a nontextual file, you'll get what you asked for: a
          screenful of nonsense.</para>
      -->
        <para>就像错误消息中提示的那样, 用户可以通过增加选项
          <option>--force</option> 来禁止 Subversion 去检查文件是否是人类
          可读的. 如果用户强制要求 <command>svn annotate</command> 去读取
          非人类可读的文件, 命令就会输出一堆混乱的信息:</para>

        <informalexample>
          <screen>
$ svn annotate images/logo.png --force
     6      harry \211PNG
     6      harry ^Z
     6      harry 
     7      harry \274\361\MI\300\365\353^X\300&hellip;
</screen>
        </informalexample>

        <tip>
      <!--
          <para>Depending on your mood at the time you execute this
            command and your reasons for doing so, you may find
            yourself typing <userinput>svn blame &hellip;</userinput>
            or <userinput>svn praise &hellip;</userinput> instead of
            using the canonical <command>svn annotate</command>
            command form.  That's okay&mdash;the Subversion developers
            anticipated as much, so those particular command aliases
            work, too!</para>
      -->
          <para>根据执行命令时的心情, 用户可能不会使用标准形式
            (<command>svn annotate</command>), 转而使用 <command>svn blame
            </command> 或 <command>svn praise</command>, 后面两种形式是
            标准形式的别名, 它们是完全等价的.</para>
        </tip>

      <!--
        <para>Finally, as with many of Subversion's informational
          commands, you can also reference files in your <command>svn
          annotate</command> command invocations by their repository
          URLs, allowing access to this information even when you
          don't have ready access to a working copy.</para>
      -->
        <para>和许多获取信息的命令一样, <command>svn annotate</command>
          也接受仓库的 URL 作为参数, 这样即使没有工作副本, 用户也可以照常
          执行命令.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.list">
      <!--
        <title>Listing versioned directories</title>
      -->
        <title>列出被版本控制的文件</title>

      <!--
        <para>The <command>svn list</command> command shows you what
          files are in a repository directory without actually
          downloading the files to your local machine:</para>
      -->
        <para>命令 <command>svn list</command> 可以列出仓库目录中的文件, 而
          不用把它们下载到本地:</para>

        <informalexample>
          <screen>
$ svn list http://svn.example.com/repo/project
README
branches/
tags/
trunk/
</screen>
        </informalexample>

    <!--
        <para>If you want a more detailed listing, pass the
          <option>- -verbose</option> (<option>-v</option>) flag to get
          output like this:</para>
    -->
        <para>如果想得到更详细的信息, 添加选项 <option>--verbose</option>
          (<option>-v</option>):</para>

        <informalexample>
          <screen>
$ svn list -v http://svn.example.com/repo/project
  23351 sally                 Feb 05 13:26 ./
  20620 harry            1084 Jul 13  2006 README
  23339 harry                 Feb 04 01:40 branches/
  23198 harry                 Jan 23 17:17 tags/
  23351 sally                 Feb 05 13:26 trunk/
</screen>
        </informalexample>

      <!--
        <para>The columns tell you the revision at which the file or
          directory was last modified, the user who modified it, the size
          if it is a file, the date it was last modified, and the item's
          name.</para>
      -->
        <para>从左到右分别表示文件或目录最后一次被修改时的版本号, 作者,
          文件大小 (仅针对文件), 日期以及文件或目录的名字.</para>

        <warning>
      <!--
          <para>The <userinput>svn list</userinput> command with no
            arguments defaults to the <emphasis>repository
            URL</emphasis> of the current working
            directory, <emphasis>not</emphasis> the local working copy
            directory.  After all, if you want a listing of your local
            directory, you could use just plain
            <command>ls</command> (or any reasonable non-Unixy
            equivalent).</para>
      -->
          <para>不带参数的 <command>svn list</command> 默认使用当前工作
            目录对应的仓库 URL 作为参数, 而非本地的工作副本目录. 毕竟, 如果
            用户想要列出本地目录中的文件, 应该使用 Shell 命令
            <command>ls</command> (或其他非 Unix 系统的等价命令).</para>
        </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.snapshots">
      <!--
      <title>Fetching Older Repository Snapshots</title>
      -->
      <title>获取老的仓库快照</title>

      <!--
      <para>In addition to all of the previous commands, you can use
        the <option>- -revision</option> (<option>-r</option>) option
        with <command>svn update</command> to take an entire working
        copy <quote>back in time</quote>:<footnote><para>See?  We told
        you that Subversion was a time
        machine.</para></footnote></para>
      -->
      <para>用户可以用带有选项 <option>--revision</option> (<option>-r</option>)
        的 <command>svn update</command> 命令, 把整个工作副本回退到旧版本:
        <footnote><para>看到了吗? 我们早就告诉过你 Subversion 是一台时间机器.
      </para></footnote></para>

      <informalexample>
        <screen>
# Make the current directory look like it did in r1729.
$ svn update -r 1729
Updating '.':
&hellip;
$
</screen>
      </informalexample>

      <tip>
      <!--
        <para>Many Subversion newcomers attempt to use the preceding
          <command>svn update</command> example to <quote>undo</quote>
          committed changes, but this won't work as you can't commit
          changes that you obtain from backdating a working copy if
          the changed files have newer revisions.  See <xref
          linkend="svn.branchmerge.basicmerging.resurrect"/> for a
          description of how to <quote>undo</quote> a commit.</para>
      -->
        <para>许多 Subversion 新手会尝试利用上面的
          <command>svn update</command>
          例子来 <quote>撤消</quote> (undo) 已经提交的修改, 但是这不可能
          实现, 因为如果被修改的文件的版本号比较旧, 那就无法成功提交.
          关于如何 <quote>撤消</quote> 提交请参考
          <xref linkend="svn.branchmerge.basicmerging.resurrect"/></para>
      </tip>

      <!--
      <para>If you'd prefer to create a whole new working copy from an
        older snapshot, you can do so by modifying the typical
        <command>svn checkout</command> command.  As with <command>svn
        update</command>, you can provide
        the <option>- -revision</option> (<option>-r</option>) option.
        But for reasons that we cover in
        <xref linkend="svn.advanced.pegrevs" />, you might instead want
        to specify the target revision as part of Subversion's
        expanded URL syntax.</para>
      -->
      <para>如果用户想以较老的快照为基础创建一个新的工作副本, 只要稍微修改
        一下 <command>svn checkout</command> 的命令行即可; 对于
        <command>svn update</command>, 可以给它添加一个选项
        <option>--revision</option> (<option>-r</option>). 由于
        <xref linkend="svn.advanced.pegrevs"/> 介绍的原因, 用户可能想
        把目标版本号作为 Subversion 扩展 URL 语法的一部分.</para>

      <informalexample>
        <screen>
# Checkout the trunk from r1729.
$ svn checkout http://svn.example.com/svn/repo/trunk@1729 trunk-1729
&hellip;
# Checkout the current trunk as it looked in r1729.
$ svn checkout http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729
&hellip;
$
</screen>
      </informalexample>

      <!--
      <para>Lastly, if you're building a release and wish to bundle up
        your versioned files and directories, you can use <command>svn
        export</command> to create a local copy of all or part of your
        repository without any <filename>.svn</filename>
        administrative directories included.  The basic syntax of this
        subcommand is identical to that of <command>svn
        checkout</command>:</para>
      -->
    <para>如果用户想构建一个发布版, 其中包含了所有的被版本控制的文件和
      目录, 命令 <command>svn export</command> 可以完成这项工作.
      <command>svn export</command> 在本地创建一份仓库的完整或部分副本,
      但是没有 <filename>.svn</filename> 目录. 命令的基本语法和
      <command>svn checkout</command> 相同:</para>

      <informalexample>
        <screen>
# Export the trunk from the latest revision.
$ svn export http://svn.example.com/svn/repo/trunk trunk-export
&hellip;
# Export the trunk from r1729.
$ svn export http://svn.example.com/svn/repo/trunk@1729 trunk-1729
&hellip;
# Export the current trunk as it looked in r1729. 
$ svn export http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729
&hellip;
$
</screen>
      </informalexample>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.cleanup">
    <!--
    <title>Sometimes You Just Need to Clean Up</title>
    -->
    <title>有时候你需要的只是清理一下</title>

    <!--
    <para>Now that we've covered the day-to-day tasks that you'll
      frequently use Subversion for, we'll review a few administrative
      tasks relating to your working copy.</para>
    -->
    <para>既然我们已经讲到了使用 Subversion 时经常碰到的日常工作, 现在将介绍
      一些和工作副本相关的管理性任务.</para>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.cleanup.disposal">
    <!--
      <title>Disposing of a Working Copy</title>
    -->
      <title>删除工作副本</title>

    <!--
      <para>Subversion doesn't track either the state or the existence of
        working copies on the server, so there's no server overhead to
        keeping working copies around.  Likewise, there's no need to
        let the server know that you're going to delete a working
        copy.</para>
    -->
      <para>服务端的 Subversion 不会跟踪工作副本的状态或存在情况, 所以工作
        副本不会影响服务器的工作负载. 同样, 删除工作副本时也不需要告诉服务
        器.</para>

    <!--
      <para>If you're likely to use a working copy again, there's
        nothing wrong with just leaving it on disk until you're ready
        to use it again, at which point all it takes is an
        <command>svn update</command> to bring it up to date and ready
        for use.</para>
    -->
      <para>如果用户下次可能还要用到工作副本, 那么在下次使用之前, 直接把工作
        副本留在磁盘上也不会产生什么问题, 不过在开始使用之前, 记得用
        <command>svn update</command> 更新一下工作副本.</para>

    <!--
      <para>However, if you're definitely not going to use a working
        copy again, you can safely delete the entire thing using
        whatever directory removal capabilities your operating system
        offers.  We recommend that before you do so you
        run <userinput>svn status</userinput> and review any files
        listed in its output that are prefixed with a
        <literal>?</literal> to make certain that they're not of
        importance.</para>
    -->
      <para>然而, 如果用户已经确定自己以后不会再用到工作副本, 为了节省磁盘
        空间, 你也可以用操作系统提供的删除命令把工作副本删除掉. 但是在删除
        之前我们建议执行一下 <command>svn status</command>, 然后查看带有前缀
        <literal>?</literal> 的列表中是否有重要的文件.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cleanup.interruption">
    <!--
      <title>Recovering from an Interruption</title>
    -->
      <title>从中断中恢复</title>

    <!--
      <para>When Subversion modifies your working copy&mdash;either
        your files or its own administrative state&mdash;it tries to do
        so as safely as possible.  Before changing the working copy,
        Subversion logs its intentions in a private <quote>to-do
        list</quote>, of sorts.  Next, it performs those actions to
        effect the desired change, holding a lock on the relevant part
        of the working copy while it works.  This prevents other
        Subversion clients from accessing the working copy mid-change.
        Finally, Subversion releases its lock and cleans up its
        private to-do list.  Architecturally, this is similar to a
        journaled filesystem.  If a Subversion operation is
        interrupted (e.g, if the process is killed or if the machine
        crashes), the private to-do list remains on disk.  This allows
        Subversion to return to that list later to complete any
        unfinished operations and return your working copy to a
        consistent state.</para>
    -->
      <para>当 Subversion 修改工作副本时&mdash;修改文件或文件的管理状态&mdash;
        它会尽量保证操作能够安全地执行. 在修改工作副本之前, Subversion 把
        它的意向操作记在一个私有的 <quote>待完成列表</quote> (to-do list)
        中, 然后开始执行操作, 在执行过程中 Subversion 会去获取工作副本中相
        关部分的锁, 这可以避免其他客户端在工作副本处于中间状态时对它进行
        访问, 最后, Subversion 释放锁并清理待完成列表. 从结构上来看, 它有点
        像日志文件系统. 如果 Subversion 的一个操作被中断了 (例如进程被杀死或
        机器崩溃), 待完成列表将保留在磁盘上, 这就允许 Subversion 后面可以再
        打开列表, 做完未完成的工作, 把工作副本恢复到一致的状态.</para>

    <!--
      <para>This is exactly what <command>svn cleanup</command> does:
        it searches your working copy and runs any leftover to-do
        items, removing working copy locks as it completes those
        operations.  If Subversion ever tells you that some part of
        your working copy is <quote>locked,</quote> run <command>svn
        cleanup</command> to remedy the problem.  The <command>svn
        status</command> command will inform you about administrative
        locks in the working copy, too, by displaying
        an <literal>L</literal> next to those locked paths:</para>
    -->
      <para>上面介绍的正是 <command>svn cleanup</command> 的功能:
        <command>svn cleanup</command> 在工作副本中搜索未完成的工作, 操作完成
        时移除工作副本的锁. 如果 Subversion 告诉你工作副本中的某些部分是被
        <quote>锁住</quote> 的, 执行 <command>svn cleanup</command> 就可以解决
        该问题. <command>svn status</command> 也会显示工作副本的加锁状态,
        被加锁的路径其左边有一字符 <literal>L</literal>:</para>

      <informalexample>
        <screen>
$ svn status
  L     somedir
M       somedir/foo.c
$ svn cleanup
$ svn status
M       somedir/foo.c
</screen>
      </informalexample>

    <!--
      <para>Don't confuse these working copy administrative locks with
        the user-managed locks that Subversion users create when using
        the lock-modify-unlock model of concurrent version control;
        see the sidebar
        <xref linkend="svn.advanced.locking.meanings"/> for
        clarification.</para>
    -->
      <para>不要把工作副本的管理锁和用户创建的锁相混淆, 后者是为了实现
        并发版本控制的 加锁-修改-解锁 模型, 见
        <xref linkend="svn.advanced.locking.meanings"/>.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.treeconflicts">
    <!--
    <title>Dealing with Structural Conflicts</title>
    -->
    <title>处理结构性冲突</title>
      
    <!--
    <para>So far, we have only talked about conflicts at the level of
      file content.  When you and your collaborators make overlapping
      changes within the same file, Subversion forces you to merge
      those changes before you can commit.<footnote><para>Well,
      you <emphasis>could</emphasis> mark files containing conflict
      markers as resolved and commit them, if you really wanted to.
      But this is rarely done in practice.</para></footnote></para>
    -->
    <para>到目前为止我们只在文件内容的级别上讨论冲突, 如果你和你的同事在
      同一文件上的修改相互重叠, 那么 Subversion 就会要求你在合并了这些修改
      之后才能提交. <footnote><para>当然, 你 <emphasis>可以</emphasis>
      把仍然含有冲突标记的文件标记为已解决并提交它们, 但是现实中几乎不
      会有人这么做.</para></footnote></para>
        
    <para>
      <indexterm>
        <primary>tree conflicts (目录冲突)</primary>
      </indexterm>
      <indexterm>
        <primary>conflicts (冲突)</primary>
        <secondary>tree (目录)</secondary>
        <see>tree conflicts (目录冲突)</see>
      </indexterm>
    <!--
      But what happens if your collaborators move or
      delete a file that you are still working on?  Maybe there was a
      miscommunication, and one person thinks the file should be
      deleted, while another person still wants to commit changes to
      the file.  Or maybe your collaborators did some refactoring,
      renaming files and moving around directories in the process.  If
      you were still working on these files, those modifications may
      need to be applied to the files at their new location.  Such
      conflicts manifest themselves at the directory tree structure
      level rather than at the file content level, and are known
      as <firstterm>tree conflicts</firstterm>.</para>
    -->
      如果其他人把你正在编辑的文件移动到其他地方或删除了, 那这时候又会发生
      什么事? 发生这种事的原因可能是同事之间沟通不及时, 一个人认为文件应该
      被删除, 而另一个人还想接着修改该文件, 也可能是你的同事想重新规划目录
      布局. 如果你正在编辑的文件已经移动到了其他位置, 那么提交的修改可能会
      应用到移动后的文件中. 这种冲突的级别是在目录树结构上, 而不是在文件的
      内容上, 称为 <firstterm>目录冲突</firstterm>
      (<firstterm>tree conflicts</firstterm>).</para>

    <sidebar>
    <!--
      <title>Tree conflicts prior to Subversion 1.6</title>
    -->
      <title>Subversion 1.6 以前的目录冲突</title>

    <!--
      <para>Prior to Subversion 1.6, tree conflicts could yield rather
        unexpected results.  For example, if a file was locally
        modified, but had been renamed in the repository,
        running <command>svn update</command> would make Subversion
        carry out the following steps:</para>
    -->
      <para>在 Subversion 1.6 以前的版本中, 目录冲突会产生意想不到的结果.
        例如, 如果一个文件在本地被修改了, 但是在仓库中被重命名了. 执行
        <command>svn update</command> 时 Subversion 会执行以下步骤:</para>

      <itemizedlist>
    <!--
        <listitem><para>Check the file to be renamed for local
          modifications.</para></listitem>
    -->
      <listitem><para>检查将要被重命名的文件.</para></listitem>

    <!--
        <listitem><para>Delete the file at its old location, and if it
          had local modifications, keep an on-disk copy of the file at
          the old location.  This on-disk copy now appears as an
          unversioned file in the working copy.</para></listitem>
    -->
      <listitem><para>删除重命名前的文件, 如果文件在本地被修改了, 就保留在
          磁盘上, 但不再是仓库或工作副本的一部分.</para></listitem>

    <!--
        <listitem><para>Add the file, as it exists in the repository,
          at its new location.</para></listitem>
    -->
      <listitem><para>添加重命名后的文件.</para></listitem>
      </itemizedlist>

    <!--
      <para>When this situation arises, there is the possibility that
        the user makes a commit without realizing that local
        modifications have been left in a now-unversioned file in the
        working copy, and have not reached the repository.  This gets
        more and more likely (and tedious) if the number of files
        affected by this problem is large.</para>
    -->
      <para>出现这种情况时, 用户可能还没有意识到有些修改被留在了未被跟踪的
        文件上, 如果这时候向服务器提交, 这些修改就不会被提交到仓库中. 如果
        文件很多, 出现这种情况的概率就会增大, 处理起来也会相当枯燥.</para>

    <!--
      <para>Since Subversion 1.6, this and other similar situations
        are flagged as conflicts in the working copy.</para>
    -->
      <para>从 Subversion 1.6 开始, 这种以及其他类似的情况都会被当作冲突
        看待.</para>

    </sidebar>

    <!--
    <para>As with textual conflicts, tree conflicts prevent a commit
      from being made from the conflicted state, giving the user the
      opportunity to examine the state of the working copy for
      potential problems arising from the tree conflict, and resolving
      any such problems before committing.</para>
    -->
    <para>和文件内容的冲突一样, 只有在目录冲突解决之后才能向仓库提交修改.
    </para>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.treeconflicts.example">
    <!--
      <title>An Example Tree Conflict</title>
    -->
      <title>目录冲突示例</title>

    <!--
      <para>Suppose a software project you were working on currently
        looked like this:</para>
    -->
      <para>假设有一个软件项目的代码目录结构如下所示:</para>

      <informalexample>
        <screen>
$ svn list -Rv svn://svn.example.com/trunk/
     13 harry                 Sep 06 10:34 ./
     13 harry              27 Sep 06 10:34 COPYING
     13 harry              41 Sep 06 10:32 Makefile
     13 harry              53 Sep 06 10:34 README
     13 harry                 Sep 06 10:32 code/
     13 harry              54 Sep 06 10:32 code/bar.c
     13 harry             130 Sep 06 10:32 code/foo.c
$
</screen>
      </informalexample>

    <!--
      <para>Later, in revision 14, your collaborator Harry renames the file
        <filename>bar.c</filename> to <filename>baz.c</filename>.
        Unfortunately, you don't realize this yet.  As it turns out,
        you are busy in your working copy composing a different set of
        changes, some of which also involve modifications
        to <filename>bar.c</filename>:</para>
    -->
      <para>后来, 在版本号 14, 你的同事 Harry 把 <filename>bar.c</filename>
        重命名为 <filename>baz.c</filename>, 但是你并不知情. 此时你正忙于
        编写另外一套修改, 其中就牵涉到 <filename>bar.c</filename>:</para>

      <informalexample>
        <screen>
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c	(revision 13)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/bar.c
===================================================================
--- code/bar.c	(revision 13)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$
</screen>
      </informalexample>

    <!--
      <para>You first realize that someone else has
        changed <filename>bar.c</filename> when your own commit
        attempt fails:</para>
    -->
      <para>提交失败时你开始意识到有人已经修改了 <filename>bar.c</filename>:
      </para>

      <informalexample>
        <screen>
$ svn commit -m "Small fixes"
Sending        code/bar.c
Transmitting file data .
svn: E155011: Commit failed (details follow):
svn: E155011: File '/home/svn/project/code/bar.c' is out of date
svn: E160013: File not found: transaction '14-e', path '/code/bar.c'
$
</screen>
      </informalexample>
<!-- XXX: That error message should be cleaned up! -->

    <!--
      <para>At this point, you need to run <command>svn update</command>.
        Besides bringing our working copy up to date so that you can
        see Harry's changes, this also flags a tree conflict so you
        have the opportunity to evaluate and properly resolve it.</para>
    -->
      <para>此时应该执行 <command>svn update</command>, 命令不仅把 Harry
        的修改同步到本地工作副本, 还产生了一个目录冲突:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
   C code/bar.c
A    code/baz.c
U    Makefile
Updated to revision 14.
Summary of conflicts:
  Tree conflicts: 1
$
</screen>
      </informalexample>

    <!--
      <para>In its output, <command>svn update</command> signifies tree
        conflicts using a capital C in the fourth output column.
        <command>svn status</command> reveals additional details of the
        conflict:</para>
    -->
      <para>在上面的例子中, <command>svn update</command> 在第四列放置一个
        大写字母 <literal>C</literal> 表示该条目有冲突.
        <command>svn status</command> 可以显示冲突的其他细节:</para>

      <informalexample>
        <screen>
$ svn status
M       code/foo.c
A  +  C code/bar.c
      >   local edit, incoming delete upon update
Summary of conflicts:
  Tree conflicts: 1
$
</screen>
      </informalexample>

    <!--
      <para>Note how <filename>bar.c</filename> is automatically
        scheduled for re-addition in your working copy, which
        simplifies things in case you want to keep the file.</para>
    -->
      <para>注意 <filename>bar.c</filename> 如何又被自动地添加到工作副本中,
        如果用户想保留 <filename>bar.c</filename>, 就不需要再额外执行一次
        <command>svn add</command>.</para>

    <!--
      <para>Because a move in Subversion is implemented as a copy
        operation followed by a delete operation, and these two
        operations cannot be easily related to one another during an
        update, all Subversion can warn you about is an incoming
        delete operation on a locally modified file.  This delete
        operation <emphasis>may</emphasis> be part of a move, or it
        could be a genuine delete operation.  Determining exactly what
        semantic change was made to the repository is
        important&mdash;you want to know just how your own edits fit
        into the overall trajectory of the project.  So read log
        messages, talk to your collaborators, study the line-based
        differences&mdash;do whatever you must do&mdash;to determine
        your best course of action.</para>
    -->
      <para>由于 Subversion 是用一个复制操作和一个删除操作实现移动, 而且在
        更新时很难将这两个操作联系在一起, 所以 Subversion 的警告信息只是说
        在本地被修改的文件已经在仓库中被删除了, 这个删除可能是移动操作的一
        部分, 也可能就是一次单纯的删除操作. 准确地判断仓库在语义上发生了什
        么变化显得尤为重要&mdash;只有这样才能让自己的修改适应项目的整体
        轨迹. 为了弄清楚冲突发生的原因, 你可以阅读日志, 和同事沟通, 在行的
        级别上查看修改等.</para>

    <!--
      <para>In this case, Harry's commit log message tells you what
        you need to know.</para>
    -->
      <para>在这个例子里, Harry 的提交日志提供了所需要的信息.</para>

      <informalexample>
        <screen>
$ svn log -r14 ^/trunk
------------------------------------------------------------------------
r14 | harry | 2011-09-06 10:38:17 -0400 (Tue, 06 Sep 2011) | 1 line
Changed paths:
   M /Makefile
   D /code/bar.c
   A /code/baz.c (from /code/bar.c:13)

Rename bar.c to baz.c, and adjust Makefile accordingly.
------------------------------------------------------------------------
$
</screen>
      </informalexample>

    <!--
      <para><command>svn info</command> shows the URLs of the items
        involved in the conflict.  The <emphasis>left</emphasis> URL
        shows the source of the local side of the conflict, while
        the <emphasis>right</emphasis> URL shows the source of the
        incoming side of the conflict.  These URLs indicate where you
        should start searching the repository's history for the change
        which conflicts with your local change.</para>
    -->
      <para><command>svn info</command> 显示了冲突条目的 URL.
        <emphasis>左边</emphasis> (<emphasis>left</emphasis>) 的 URL 显示了
        冲突的本地端来源, <emphasis>右边</emphasis>
        (<emphasis>right</emphasis>) 的 URL 显示了冲突的服务器端来源, 这些
        URL 指出了我们应该从哪个版本号开始搜索导致冲突的修改.</para>

      <informalexample>
        <screen>
$ svn info code/bar.c
Path: code/bar.c
Name: bar.c
URL: http://svn.example.com/svn/repo/trunk/code/bar.c
&hellip;
Tree conflict: local edit, incoming delete upon update
  Source  left: (file) ^/trunk/code/bar.c@4
  Source right: (none) ^/trunk/code/bar.c@5

$
</screen>
      </informalexample>

    <!--
      <para><filename>bar.c</filename> is now said to be the victim of
        a tree conflict.  It cannot be committed until the conflict is
        resolved:</para>
    -->
      <para><filename>bar.c</filename> 已经成为目录冲突的受害者, 在冲突解决
        之前无法提交:</para>

      <informalexample>
        <screen>
$ svn commit -m "Small fixes" 
svn: E155015: Commit failed (details follow):
svn: E155015: Aborting commit: '/home/svn/project/code/bar.c' remains in confl
ict
$
</screen>
      </informalexample>

    <!--
      <para>To resolve this conflict, you must either agree or
        disagree with the move that Harry made.</para>
    -->
      <para>为了解决这个冲突, 用户要么同意, 要么不同意 Harry 提交的重命名
        修改.</para>

    <!--
      <para>If you agree with the move, your <filename>bar.c</filename>
        is superfluous.  You'll want to delete it and mark the tree
        conflict as resolved.  But wait:  you made changes to that
        file!  Before deleting <filename>bar.c</filename>, you need to
        decide if the changes you made to it need to be applied
        elsewhere, for example to the new <filename>baz.c</filename>
        file where all of <filename>bar.c</filename>'s code now lives.
        Let's assume that your changes do need to <quote>follow the
        move</quote>.  Subversion isn't smart enough to do this work
        for you<footnote><para>In some cases, Subversion 1.5 and 1.6
        <emphasis>would</emphasis> actually handle this for you, but
        this somewhat hit-or-miss functionality was removed in
        Subversion 1.7.</para></footnote>, so you need to migrate your
        changes manually.</para>
    -->
      <para>如果用户同意重命名, 那么 <filename>bar.c</filename> 就成了多余的
        了, 你可能想要删除 <filename>bar.c</filename> 并把目录冲突标记为已
        解决, 但是请等一下, 文件上还有你的修改! 在删除
        <filename>bar.c</filename> 之前你必须决定它上面的修改是否需要应用到
        其他地方, 比如重命名后的文件 <filename>baz.c</filename>. 不妨假设你
        的修改需要 <quote>跟随重命名</quote> (follow the move), 但是 Subversion
        还没有聪明到能够替你完成这件工作<footnote><para>在某些情况下,
            Subversion 1.5 和 1.6 <emphasis>会</emphasis> 替你完成这件事, 但
            这种有点随意的功能已经在 Subversion 1.7 被移除了.</para>
        </footnote>, 所以你必须手动地迁移修改.</para>

    <!--
      <para>In our example, you could manually re-make your change
        to <filename>bar.c</filename> pretty easily&mdash;it was,
        after all, a single-line change.  That's not always the case,
        though, so we'll show a more scalable approach.  We'll first
        use <command>svn diff</command> to create a patch file.  Then
        we'll edit the headers of that patch file to point to the new
        name of our renamed file.  Finally, we re-apply the modified
        patch to our working copy.</para>
    -->
      <para>在我们例子里, 你完全可以手动地再修改一次
        <filename>baz.c</filename>&mdash;毕竟只修改了一行, 但是这种做法只适用
        于修改很少的情况, 我们再介绍一种更具有通用性的方法. 先用
        <command>svn diff</command> 创建一个补丁文件, 然后修改补丁文件的头
        部信息, 使其指向重命名后的文件, 最后再应用修改后的补丁.</para>

      <informalexample>
        <screen>
$ svn diff code/bar.c > PATCHFILE
$ cat PATCHFILE
Index: code/bar.c
===================================================================
--- code/bar.c	(revision 14)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$ ### Edit PATCHFILE to refer to code/baz.c instead of code/bar.c
$ cat PATCHFILE
Index: code/baz.c
===================================================================
--- code/baz.c	(revision 14)
+++ code/baz.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$ svn patch PATCHFILE
U         code/baz.c
$
</screen>
      </informalexample>

    <!--
      <para>Now that the changes you originally made
        to <filename>bar.c</filename> have been successfully
        reproduced in <filename>baz.c</filename>, you can
        delete <filename>bar.c</filename> and resolve the conflict,
        instructing the resolution logic to accept what is currently
        in the working copy as the desired result.</para>
    -->
      <para>现在 <filename>bar.c</filename> 上的修改已经成功地转移到了
        <filename>baz.c</filename> 上, 用户现在可以删除
        <filename>bar.c</filename> 并告诉 Subversion 把工作副本的当前内容
        作为冲突解决的结果.</para>

      <informalexample>
        <screen>
$ svn delete --force code/bar.c
D         code/bar.c
$ svn resolve --accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
M       code/baz.c
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c  (revision 14)
+++ code/foo.c  (working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/baz.c
===================================================================
--- code/baz.c  (revision 14)
+++ code/baz.c  (working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$
</screen>
      </informalexample>

        <!--
      <para>But what if you do not agree with the move?  Well, in that
        case, you can delete <filename>baz.c</filename> instead, after
        making sure any changes made to it after it was renamed are
        either preserved or not worth keeping.  (Do not forget to also
        revert the changes Harry made to <filename>Makefile</filename>.)
        Since <filename>bar.c</filename> is already scheduled for
        re-addition, there is nothing else left to do, and the
        conflict can be marked resolved:</para>
    -->
      <para>但是如果你不同意重命名, 那又该如何? 如果用户已经确定
        <filename>baz.c</filename> 上的修改已经进行了保存或者可以丢弃, 那也可以
        直接删除 <filename>baz.c</filename> (别忘了撤消 Harry 对
        <filename>Makefile</filename> 的修改). 因为
        <filename>bar.c</filename> 已经准备好添加到仓库中, 所以接下来只需
        要把冲突标记为已解决即可:</para>

      <informalexample>
        <screen>
$ svn delete --force code/baz.c
D         code/baz.c
$ svn resolve --accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
A  +    code/bar.c
D       code/baz.c
M       Makefile
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c	(revision 14)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/bar.c
===================================================================
--- code/bar.c	(revision 14)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
Index: code/baz.c
===================================================================
--- code/baz.c	(revision 14)
+++ code/baz.c	(working copy)
@@ -1,4 +0,0 @@
-const char *bar(void)
-{
-    return "Me neither!\n";
-}
Index: Makefile
===================================================================
--- Makefile	(revision 14)
+++ Makefile	(working copy)
@@ -1,2 +1,2 @@
 foo: 
-	$(CC) -o $@ code/foo.c code/baz.c
+	$(CC) -o $@ code/foo.c code/bar.c
</screen>
      </informalexample>

    <!--
      <para>You've now resolved your first tree conflict!  You can
        commit your changes and tell Harry during tea break about all
        the extra work he caused for you.</para>
    -->
      <para>恭喜, 你已经解决了你的第一个目录冲突! 现在你可以提交修改,
        并告诉 Harry 由于他的修改, 你做了很多额外的工作.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.summary">
    <!--
    <title>Summary</title>
    -->
    <title>小结</title>

    <!--
      <para>Now we've covered most of the Subversion client commands.
        Notable exceptions are those dealing with branching and
        merging (see <xref linkend="svn.branchmerge"/>) and properties (see
        <xref linkend="svn.advanced.props"/>).  However, you may want to
        take a moment to skim through <xref linkend="svn.ref.svn"/> to
        get an idea of all the different commands that Subversion
        has&mdash;and how you can use them to make your work
        easier.</para>
    -->
      <para>本章我们介绍了 Subversion 客户端的大部分命令, 剩下的命令中比较
        重要的几个主要用于分支与合并 (见 <xref linkend="svn.branchmerge"/>),
        以及属性 (见 <xref linkend="svn.advanced.props"/>). 然而, 你可能想
        快速浏览一下 <xref linkend="svn.ref.svn"/>, 看看 Subversion 到底提供
        了多少个命令, 这些命令又如何帮助你提高工作效率.</para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
