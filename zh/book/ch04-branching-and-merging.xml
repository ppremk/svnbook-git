<!-- -*- sgml -*- -->

<chapter id="svn.branchmerge">
      <!--
  <title>Branching and Merging</title>
      -->
  <title>分支与合并</title>

  <blockquote>
      <!--
    <attribution>Confucius</attribution>
      -->
    <attribution>孔子</attribution>
    <para><quote>君子务本
      (It is upon the Trunk that a gentleman works.)</quote></para>
  </blockquote>

      <!--
  <para>Branching and merging are fundamental aspects of version
    control, simple enough to explain conceptually but offering just
    enough complexity and nuance to merit their own chapter in this
    book.  Herein, we'll introduce you to the general ideas behind
    these operations as well as Subversion's somewhat unique approach
    to them.  If you've not familiarized yourself with Subversion's
    basic concepts (found in <xref linkend="svn.basic"/>), we
    recommend that you do so before reading this chapter.</para>
      -->
  <para>分支与合并是版本控制的基础功能, 从概念上解释非常简单, 但是它的复杂性
    和各种细微差别值得我们用整整一章进行介绍. 我们将会介绍这些操作背后的基本
    思想, 以及 Subversion 在实现上的某些独特之处. 如果读者对 Subversion 的基本
    概念 (见 <xref linkend="svn.basic"/>) 还不了解, 在阅读本章之前建议读者先
    了解它们.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
      <!--
    <title>What's a Branch?</title>
      -->
    <title>什么是分支</title>

      <!--
    <para>Suppose it's your job to maintain a document for a division
      in your company&mdash;a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>
      -->
    <para>假设你的工作是为公司的某个部门维护文档&mdash;比如说一本手册. 一天,
      另一个部门也请你替他们维护同一份文档, 但需要根据他们的部门情况, 对手册的
      某些部分作一些修改.</para>

      <!--
    <para>What do you do in this situation?  You do the obvious: make
      a second copy of your document and begin maintaining the two
      copies separately.  As each department asks you to make small
      changes, you incorporate them into one copy or the other.</para>
      -->
    <para>对于这种情况你应该怎么处理? 最容易想到的做法是为另一个部门创建一份
      文档的副本, 然后单独地对这两份文档进行维护. 每当部门要求对文档进行修改
      时, 你就把修改写到相应的文档里.</para>

      <!--
    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they differ only in
      small, specific ways.</para>
      -->
    <para>你应该会经常对两个副本做相同的修改, 比如说你在第一个副本时发现了一
      个打字错误, 同样的错误在第二个副本里也应该存在, 毕竟两份文档的大部分内容
      都是一样的.</para>

    <para>
      <indexterm>
        <primary>branches (分支)</primary>
      </indexterm>
      这是分支的基本概念&mdash;顾名思义, 它是一条独立存在的开发线, 如果回溯地
      足够深, 将会看到它和其他分支共享相同的历史. 一个分支的生命总是开始于复
      制操作, 从那儿开始产生自己的历史 (见 
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>
      <!--
      This is the basic concept of a branch&mdash;namely,
      a line of development that exists independently of another line,
      yet still shares a common history if you look far enough back in
      time.  A branch always begins life as a copy of something, and
      moves on from there, generating its own history (see
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>
      -->

    <figure id="svn.branchmerge.whatis.dia-1">
      <title>分支示意图</title>
      <graphic fileref="images/ch04dia1.png"/>
    </figure>

      <!--
    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>
      -->
    <para>Subversion 提供了很多命令用于帮助用户维护文件与目录的并行分支, 这些
      命令允许你通过复制来创建分支, 并记住这些副本之间是有关的. 它们还可以帮助
      你把一个分支的修改复制到其他分支上. 最后, 它们可以把工作副本的某些部分
      映射到不同的分支上, 这样你就可以在日常工作中 <quote>混合搭配</quote>
      不同的开发线.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
      <!--
    <title>Using Branches</title>
      -->
    <title>使用分支</title>

      <!--
    <para>At this point, you should understand how each commit creates
      a new state of the filesystem tree (called a <quote>revision</quote>)
      in the repository.  If you don't, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>
      -->
    <para>阅读到这里, 读者应该理解了每一次提交是如何创建一个新的文件系统树
      状态 (称为 <quote>版本号</quote>), 如果还不理解, 读者应该回去阅读
      <xref linkend="svn.basic.in-action.revs"/> 的内容.</para>

      <!--
    <para>Let's revisit the example from
      <xref linkend="svn.basic"/>.  Remember that you and your
      collaborator, Sally, are sharing a repository that contains two
      projects, <filename>paint</filename> and
      <filename>calc</filename>.  Notice that in <xref
      linkend="svn.branchmerge.using.dia-1"/>, however, each project
      directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>
      -->
    <para>再次回顾 <xref linkend="svn.basic"/> 的例子: 你和你的同事&mdash;Sally
      &mdash;共享一个包含了两个项目的仓库, 这两个项目是 <filename>paint</filename>
      和 <filename>calc</filename>. 如
      <xref linkend="svn.branchmerge.using.dia-1"/> 所示, 每一个项目都包含了
      子目录 <filename>trunk</filename> 和 <filename>branches</filename>. 读
      者很快就会明白如此布局的原因.</para>

    <figure id="svn.branchmerge.using.dia-1">
      <!--
      <title>Starting repository layout</title>
      -->
      <title>仓库的起始布局</title>
      <graphic fileref="images/ch04dia2.png"/>
    </figure>

      <!--
    <para>As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>
      -->
    <para>假设 Sally 和你都有一份 <quote>calc</quote> 项目的工作副本, 更确切
      地说, 你们每个人都有一份 <filename>/calc/trunk</filename> 的工作副本.
      项目的所有材料都放在子目录 <filename>trunk</filename> 内, 而不是直接放到
      <filename>/calc</filename> 里, 因为开发团队把
      <filename>/calc/trunk</filename> 作为开发 <quote>主线</quote>
      (main line).</para>

      <!--
    <para>Let's say that you've been given the task of implementing a
      large software feature.  It will take a long time to write, and
      will affect all the files in the project.  The immediate problem
      is that you don't want to interfere with Sally, who is in the
      process of fixing small bugs here and there.  She's depending on
      the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit by bit, you'll surely break
      things for Sally (and other team members as well).</para>
      -->
    <para>现在团队要求你为软件项目实现一个比较大的特性, 这项工作的时间会比较
      长, 而且会影响到项目内的所有文件. 首先想到的第一个问题是你不想干扰 Sally
      &mdash;她目前正在解决软件的几个小问题. Sally 的工作依赖于这样一个事实,
      那就是项目的最新版 (存放在 <filename>/calc/trunk</filename>) 总是可用的.
      如果你开始一点一点地提交你的修改, 那肯定会影响到 Sally 的工作, 甚至包括
      团队内的其他成员.</para>

      <!--
    <para>One strategy is to crawl into a hole: you can stop sharing
      information for a week or two, gutting and reorganizing all the
      files in your private working copy but not committing or
      updating until you're completely finished with your task.  There
      are a number of problems with this, though.  First, it's not
      very safe.  Should something bad happen to your working copy or
      computer, you risk losing all your changes.  Second, it's not
      very flexible.  Unless you manually replicate your changes
      across different working copies or computers, you're stuck trying
      to make your changes in a single working copy.  Similarly, it's
      difficult to share your work-in-progress with anyone else.  A
      common software development <quote>best practice</quote> is to
      allow your peers to review your work as you go.  If nobody sees
      your intermediate commits, you lose potential feedback and may
      end up going down the wrong path for weeks before another person
      on your team notices.  Finally, when you're finished with all
      your changes, you might find it very difficult to merge your
      completed work with the rest of the company's main body of code.
      Sally (or others) may have made many other changes in the
      repository that are difficult to incorporate into your working
      copy when you eventually run <command>svn update</command> after
      weeks of isolation.</para>
      -->
    <para>一种可能的办法是在你完成全部的修改之前, 不向仓库提交修改, 也不更新
      工作副本, 这种情况会持续几周, 但是这会产生很多问题. 首先这不太安全, 如果
      你的工作副本或机器遭到破坏, 之前所有的工作都会白费. 第二, 不够灵活, 除非
      你手动地把你的修改复制到其他工作副本或机器中, 否则的话你就只能在一个固定
      的工作副本上工作, 如果要把半成员品分享给其他人也很麻烦. 一种比较良好的
      软件工程做法是允许团队中的其他成员审查你的修改, 如果别人不能看到你在中间
      阶段的提交, 你将得不到别人的反馈, 甚至在错误的方向上努力多日, 直到别人
      注意到你的工作. 最后, 当你完成所有的修改时, 你可能会发现很难把你的修改
      合并到仓库里. Sally (或其他人) 可能在你工作的过程中向仓库提交了很多修改,
      几周后, 当你最终执行 <command>svn update</command> 时, 这些修改很难合并
      到你的工作副本里.</para>

      <!--
    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      not-yet-completed work frequently without interfering with
      others' changes and while still selectively sharing information
      with your collaborators.  You'll see exactly how this works as
      we continue.</para>
      -->
    <para>更好的做法是在仓库中创建一个属于你自己的分支 (或一条开发线), 这样
      你就可以保存尚未完成的工作, 也不会干扰到其他人, 还可以与其他人分享你的
      工作进度. 下面我们将会介绍具体的步骤.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
      <!--
      <title>Creating a Branch</title>
      -->
      <title>创建分支</title>

      <!--
      <para>Creating a branch is very simple&mdash;you make a copy of
        your project tree in the repository using the <command>svn
        copy</command> command.  Since your project's source code is
        rooted in the <filename>/calc/trunk</filename> directory, it's
        that directory that you'll copy.  Where should the new
        copy live?  Wherever you wish.  The repository location in
        which branches are stashed is left by Subversion as a matter
        of project policy.  Finally, your branch will need a name to
        distinguish it from other branches.  Once again, the name you
        choose is unimportant to Subversion&mdash;you can use whatever
        name works best for you and your team.</para>
      -->
      <para>创建分支非常简单&mdash;就是用命令 <command>svn copy</command> 在
        仓库中为项目目录树创建一个副本. 因为项目的源代码放在
        <filename>/calc/trunk</filename>, 所以你要复制的就是这个目录.
        那么新副本应该
        放在哪里? 分支在仓库里的存放位置由项目自己来决定. 最后, 你的分支需要
        一个名字, 用于和其他分支区分开. 分支的名字对 Subversion 而言并不重要
        &mdash;你可以根据工作的特点为分支取一个你认为最好的名字.</para>

      <!--
      <para>Let's assume that your team (like most) has a policy of
        creating branches in the <filename>branches</filename>
        directory that is a sibling of the project's trunk
        (the <filename>/calc/branches</filename> directory in our
        scenario).  Lacking inspiration, you settle
        on <literal>my-calc-branch</literal> as the name you wish to
        give your branch.  This means that you'll create a new
        directory, <filename>/calc/branches/my-calc-branch</filename>,
        which begins its life as a copy
        of <filename>/calc/trunk</filename>.</para>
      -->
      <para>假设团队规定分支存放在目录 <filename>branches</filename> 内 (这是
        最常见的情况), 而 <filename>branches</filename> 是项目主干的兄弟目录
        (在我们这个例子里, 存放分支的目录就是 <filename>/calc/branches
          </filename>). 虽然没什么创意, 但你还是想把新的分支叫做 <literal>
          my-calc-branch</literal>, 这就意味着你将会创建一个新目录
        <filename>/calc/branches/my-calc-branch</filename>, 新目录的生命周期
        以 <filename>/calc/trunk</filename> 的副本作为开始.</para>

      <para>
        <indexterm>
          <primary>copying (复制)</primary>
          <secondary>remote copies (远程复制)</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>branches (分支)</primary>
          <secondary>creating (创建)</secondary>
          </indexterm>
          读者应该已经见过如何在工作副本中用命令 <command>svn copy</command>
          复制出一个新文件或目录, 除了工作副本, 它还可以完成 <firstterm>远程复制
          </firstterm> (<firstterm>remote copy</firstterm>)&mdash;复制操作会
          立刻提交到仓库中, 产生一个新的版本号, 完全不需要工作副本的参与. 从
          命令的形式上看, 只是从一个 URL 中复制出新的一个:</para>
      <!--
          You may already have seen <command>svn
        copy</command> used to copy one file to another within a
        working copy.  But it can also be used to do
        a <firstterm>remote copy</firstterm>&mdash;a copy that
        immediately results in a newly committed repository revision
        and for which no working copy is required at all.  Just copy
        one URL to another:</para>
      -->

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/my-calc-branch \
           -m "Creating a private branch of /calc/trunk."

Committed revision 341.
$
</screen>
      </informalexample>

      <!--
      <para>This command causes a near-instantaneous commit in the
        repository, creating a new directory in revision 341.  The new
        directory is a copy of <filename>/calc/trunk</filename>.  This
        is shown in <xref linkend="svn.branchmerge.using.create.dia-1"
        />.<footnote><para>Subversion does not support copying between
        different repositories.  When using URLs with <command>svn
        copy</command> or <command>svn move</command>, you can only
        copy items within the same repository.</para></footnote>  While
        it's also possible to create a branch by using <command>svn
        copy</command> to duplicate a directory within the working
        copy, this technique isn't recommended.  It can be quite slow,
        in fact!  Copying a directory on the client side is a
        linear-time operation, in that it actually has to duplicate
        every file and subdirectory within that working copy directory
        on the local disk.  Copying a directory on the server,
        however, is a constant-time operation, and it's the way most
        people create branches.  In addition, this practice raises the
        possibility of copying mixed-revision working copies.  This isn't
        inherently dangerous, but can cause unnecessary complications later
        during merging.  If you do choose to create a branch by copying a
        working copy path, you should be sure the source directory has no
        local modifications and is not at mixed-revisions.</para>
      -->
      <para>上面的命令立刻在仓库中产生了一次提交, 在版本号 341 创建了一个新
        目录, 它是目录 <filename>/calc/trunk</filename> 的拷贝, 如图
        <xref linkend="svn.branchmerge.using.create.dia-1"/> 所示.
        <footnote><para>Subversion 不支持在不同的仓库间复制, 当命令
            <command>svn copy</command> 和 <command>svn move</command> 的参数
            带有 URL 时, 这些 URL 必须都在同一个仓库内.</para></footnote>
        当然, 使用 <command>svn copy</command> 复制工作副本里的目录来创建分支
        也是可以的, 但我们不推荐这种做法, 因为可能会很慢. 在客户端复制目录是
        一个线性时间复杂度的操作, 实际上它需要递归地复制目录内的每一个文件和
        子目录, 这些文件和子目录都存放在本地磁盘上. 而远程复制是一个时间
        复杂度为常量的操作, 大多数用户都是采用这种方式创建分支. 另外, 工作副
        本中的目录可能含有混合的版本号, 虽然不会产生有害的影响, 但是在合并时
        可能会产生不必要的麻烦. 如果用户选择通过复制工作副本中的目录来创建
        分支, 在复制前应该确保被复制的目录不含有本地修改和混合的版本号.</para>
            
      <figure id="svn.branchmerge.using.create.dia-1">
      <!--
        <title>Repository with new copy</title>
      -->
        <title>创建了分支后的仓库</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
      <!--
        <title>Cheap Copies</title>
      -->
        <title>廉价拷贝</title>

      <!--
        <para>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&mdash;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're an experienced Unix user, you'll recognize this as
          the same concept behind a hard link.  As further changes are
          made to files and directories beneath the copied directory,
          Subversion continues to employ this hard link concept where
          it can.  It duplicates data only when it is necessary to
          disambiguate different versions of objects.</para>
      -->
        <para>Subversion 的设计非常特殊, 用户复制一个目录时, 不必担心仓库会
          增长过大&mdash;实际上 Subversion 不会复制任何数据, 作为替代, 它
          创建了一个新的目录项, 将其指向一个 <emphasis>已存在</emphasis> 的
          目录树. 如果你是一名有经验的 Unix 用户, 马上就能看出来这和硬链接是
          同样的概念. 随着文件和目录的修改不断增多, Subversion 会继续尽可能地
          利用这种硬链接思想, 只有在必要时 (消除对象的不同版本之间的歧义) 才会
          真正地复制数据.</para>

      <!--
        <para>This is why you'll often hear Subversion users talk
          about <quote>cheap copies.</quote>  It doesn't matter how
          large the directory is&mdash;it takes a very tiny, constant
          amount of time and space to make a copy of it.  In fact,
          this feature is the basis of how commits work in Subversion:
          each revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's web site and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>
      -->
        <para>你会经常听到 Subversion 用户谈论 <quote>廉价拷贝</quote>. 无论
          目录有多大, Subversion 都只需要一段极小的, 常量的时间和空间就能完成
          复制操作. 实际上, 这个特性也是 Subversion 处理提交操作的基础: 每一
          个版本号都是前一个版本号的 <quote>廉价拷贝</quote>, 只有少数几项
          被修改了. (关于这部分的更多内容, 请登录到 Subversion 官网, 阅读
          Subversion 设计文档中的 <quote>冒泡 (bubble up)</quote> 方法).</para>

      <!--
        <para>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and in space.  If you create a branch
          entirely within the repository (by running <userinput>svn copy
          <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput>),
          it's a quick, constant-time operation.  Make branches as
          often as you want.</para>
      -->
        <para>当然, 这些复制和共享数据的内部机制对用户而言都是透明的, 他们只能
          看到目录被复制了. 我们的重点是复制在时间和空间上都很廉价, 如果用户是
          在仓库内创建分支 (通过执行命令 <userinput>svn copy <replaceable>URL1
          </replaceable> <replaceable>URL2</replaceable></userinput>), 操作消耗
          的时间是常量的, 而且非常快. 只要用户有需要, 可以随意地创建分支.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <!--
      <title>Working with Your Branch</title> 
      -->
      <title>在分支上工作</title> 

      <!--
      <para>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>
      -->
      <para>创建完分支后, 用户就可以检出它的工作副本, 然后开始工作:</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A    my-calc-branch/doc
A    my-calc-branch/src
A    my-calc-branch/doc/INSTALL
A    my-calc-branch/src/real.c
A    my-calc-branch/src/main.c
A    my-calc-branch/src/button.c
A    my-calc-branch/src/integer.c
A    my-calc-branch/Makefile
A    my-calc-branch/README
Checked out revision 341.

$
</screen>
      </informalexample>

      <!--
      <para>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't see them when she
        updates, because her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternative way of
        creating a working copy of a branch.)</para>
      -->
      <para>和其他工作副本相比, 这个工作副本并没有什么特别的地方, 它只不过是映射
        到了仓库的另一个目录. 而 Sally 在更新时将不会看到在这个工作副本里提
        交的修改, 因为她的工作副本映射的是 <filename>/calc/trunk</filename>.
        (记得看一下本章后面的 <xref linkend="svn.branchmerge.switchwc"/>, 它是
        创建分支工作副本的另一种办法)</para>

      <!--
      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>
      -->
      <para>假设分支创建后又过了一周, 期间提交了下面这些修改:</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>,
            which creates revision 342.</para>
      -->
          <para>在版本号 342 修改了文件
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>
          </para>
        </listitem>
        <listitem>
      <!--
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>,
            which creates revision 343.</para>
      -->
          <para>在版本号 343 修改了文件
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>
          </para>
        </listitem>
        <listitem>
      <!--
          <para>Sally makes a change to
            <filename>/calc/trunk/src/integer.c</filename>, which creates
            revision 344.</para>
      -->
          <para>Sally 在版本号 344 修改了文件
            <filename>/calc/trunk/src/integer.c</filename>.</para>
        </listitem>
      </itemizedlist>

      <!--
      <para>Now two independent lines of development (shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>) are happening on
        <filename>integer.c</filename>.</para>
      -->
      <para>现在, 文件 <filename>integer.c</filename> 产生了两条独立的开发线,
        如 <xref linkend="svn.branchmerge.using.work.dia-1"/> 所示.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
      <!--
        <title>The branching of one file's history</title>
      -->
        <title>一个文件历史的分叉</title>
        <graphic width="4.81in" depth="2.18in" fileref="images/basic-branch.png" />
      </figure>

      <!--
      <para>Things get interesting when you look at the history of
        changes made to your copy of <filename>integer.c</filename>:</para>
      -->
      <para>当用户查看文件 <filename>integer.c</filename> 副本的修改历史时, 事
        情开始变得有趣起来:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -v src/integer.c
------------------------------------------------------------------------
r343 | user | 2013-02-15 14:11:09 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch/src/integer.c

* integer.c:  frozzled the wazjub.
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look at what happens when Sally runs the same
        command on her copy of the file:</para>
      -->
      <para>注意到 Subversion 在追溯分支 <literal>my-calc-branch</literal>
        中的文件 <filename>integer.c</filename> 的历史时, 即使到达了创建分支
        的时间点, 也仍然会继续往下追踪. 在历史中显示的是分支被创建的事件, 这
        是因为当 <filename>/calc/trunk/</filename> 中所有的文件都被复制时,
        自然也就复制了 <filename>integer.c</filename>. 现在再看一下 Sally 在
        她的副本上执行同样的命令会输出什么内容:</para>

      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/integer.c
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Refactor the bazzle functions.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch copy was made in revision
        341, the files used to be the same file.  That's why you and
        Sally both see the changes made between revisions 8 and
        154.</para>
      -->
      <para>Sally 看到了她提交的版本号 344, 但没有看到版本号 343. 对 Subversion
        而言, 这两个提交影响的是存放在仓库中不同位置上的不同文件, 而
        Subversion 的输出 <emphasis>确实</emphasis> 表明了这两个文件共享一段
        相同的历史&mdash;在创建分支 (版本号 341) 之前, 它们是同一个文件.
        也就是因为这个原因, 所以你和 Sally 都能看到版本号 8 到版本号 154 的提交
        历史.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
      <!--
      <title>The Key Concepts Behind Branching</title> 
      -->
      <title>分支背后的关键概念</title>

      <!--
      <para>You should remember two important lessons
        from this section.  First, Subversion has no internal concept
        of a branch&mdash;it knows only how to make copies.  When you
        copy a directory, the resultant directory is only
        a <quote>branch</quote> because <emphasis>you</emphasis>
        attach that meaning to it.  You may think of the directory
        differently, or treat it differently, but to Subversion it's
        just an ordinary directory that happens to carry some extra
        historical information.</para>
      -->
      <para>在阅读完这一节后, 读者应该牢记以下两点. 第一, 在 Subversion 内部是
        没有分支这个概念的&mdash;它只知道如何复制. 当用户复制一个目录时, 产生
        的新目录被称为 <quote>分支</quote> 完全是用户赋予它的意义, 用户也可以
        从其他角度看待它, 但是对于 Subversion 而言, 它只是一个含有额外历史信息
        的普通目录.</para>

      <!--
      <para>Second, because of this copy mechanism, Subversion's
        branches exist as <emphasis>normal filesystem
        directories</emphasis> in the repository.  This is different
        from other version control systems, where branches are
        typically defined by adding
        extra-dimensional <quote>labels</quote> to collections of
        files.  The location of your branch directory doesn't matter
        to Subversion.  Most teams follow a convention of putting all
        branches into a <filename>/branches</filename> directory, but
        you're free to invent any policy you wish.</para>
      -->
      <para>第二, Subversion 的分支作为 <emphasis>普通的文件系统目录</emphasis>
        存在于仓库中, 这和其他版本控制系统不太一样, 其他版本控制系统创建分支的
        典型做法是为文件集添加处于额外维度的 <quote>标签</quote>. Subversion
        不关心分支目录的存放位置, 但是大多数开发团队都遵循传统做法: 把所有的
        分支都放在 <filename>branches/</filename> 目录内, 当然, 用户也可以制订
        自己的策略.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.basicmerging">
      <!--
    <title>Basic Merging</title>
      -->
      <title>基本合并</title>

      <!--
    <para>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the trunk, or main line of development.</para>
      -->
    <para>现在你和 Sally 并行地在两个分支上进行开发: 你在自己的私有分支上工作,
      Sally 在项目的主干 (开发主线) 上工作.</para>

      <!--
    <para>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>
      -->
    <para>如果项目有很多开发人员, 大多数人都会检出主干的工作副本. 如果有人需要
      完成一个长期的修改, 而这个修改的中间成果很可能会扰乱主干, 那么比较标准
      的做法是为它创建一个私有分支, 把修改都提交到这个分支上, 直到所有的相关
      工作都完成为止.</para>

      <!--
    <para>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>
      -->
    <para>有了分支后, 好消息是你和 Sally 的工作不会互相干扰, 但坏消息是分支
      容易偏离主干过远. 记住, <quote>缓慢爬行</quote> 策略的问题是当你完成
      分支上的工作时, 把分支上的修改合并到主干上而不产生大量的冲突, 几乎是不
      可能的.</para>

    <para>
      <indexterm>
        <primary>merging (合并)</primary>
      </indexterm>
      因此在工作的过程中, 你和 Sally 会继续分享修改, 哪些修改值得分享完全由你
      来决定, Subversion 允许用户有选择地在分支之间 <quote>复制</quote> 修改.
      当你在分支上的工作全部完成时, 分支上的整个修改集合就可以被复制到主干上.
      用 Subversion 的行话来讲, 把一个分支上的修改复制到其他分支上&mdash; 这
      种操作称为 <firstterm>合并</firstterm> (<firstterm>merging</firstterm>),
      完成这种操作的命令是 <command>svn merge</command>.</para>
      <!--
      Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <firstterm>merging</firstterm>, and
      it is performed using various invocations of the <command>svn
      merge</command> subcommand.</para>
      -->

      <!--
    <para>In the examples that follow, we're assuming that both your
      Subversion client and server are running Subversion 1.8 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won't track changes
      automatically, forcing you to use painful manual methods to
      achieve similar results.  That is, you'll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/> later
      in this chapter), and take special care to keep track of what's
      already been merged and what hasn't.  For this reason,
      we <emphasis>strongly</emphasis> recommend that you make sure your
      client and server are at least at version 1.5.</para>
      -->
    <para>在下面的例子里, 我们假设 Subversion 客户端和服务器端的版本都是 1.8
      或更新的版本. 如果客户端或服务器端的版本小于 1.5, 事情就会变得很复杂:
      旧版的 Subversion 不会自动跟踪修改, 这就迫使用户必须手工实现类似的效果,
      而这种过程相对来说比较痛苦, 具体来说, 用户必须按照合并语法, 详细地指定
      被复制的版本号范围 (见本章后面的
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>), 而且还要注
      意哪些修改已经合并, 哪些没有. 因此, 我们 <emphasis>强烈</emphasis> 建
      议用户不要使用 1.5 版本之前的 Subversion 客户端与服务器端.</para>

    <sidebar id="svn.branchmerge.basicmerging.mergetracking">
      <!--
      <title>Merge Tracking</title>
      -->
      <title>合并跟踪</title>
      <para>
        <indexterm>
          <primary>merge tracking (合并跟踪)</primary>
        </indexterm>
        Subversion 1.5 增加了 <firstterm>合并跟踪</firstterm> (<firstterm>
          merge tracking</firstterm>) 特性, 在引入这个特性之前, 为了跟踪合并,
        要求用户手工执行一些笨拙的操作, 或使用外部工具, 后面发布的 Subversion
        在合并跟踪上增加了很多功能, 也修复了很多问题, 所以我们才建议读者总是
        使用最新版的 Subversion, 无论是在客户端, 还是在服务器端. 记住, 即使
        服务器端的版本是 1.5-1.7, 你仍然可以使用 1.8 版的客户端, 这对于合并
        跟踪来说非常重要, 因为与合并跟踪有关的绝大多数功能增强和问题修复都是在
        客户端实现.</para>
      <!--
        Subversion 1.5 introduced the
        <firstterm>merge tracking</firstterm> feature to Subversion.
        Prior to this feature keeping track of merges required cumbersome
        manual procedures or the use of external tools. Subsequent
        releases of Subversion introduced many enhancements and bug
        fixes to merge tracking, which is why we recommend using the
        most recent versions for both your server and client.  Keep in
        mind that even if your server is running 1.5-1.7, you can still
        use a 1.8 client.  This is particularly important with regard to merge
        tracking, because the overwhelming majority of fixes and enhancements
        to it are on the client side.</para>
      -->
    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.changesets">
      <!--
      <title>Changesets</title>
      -->
      <title>变更集</title>

      <para>
        <indexterm>
          <primary>changesets (变更集)</primary>
        </indexterm>
        在继续之前, 我们需要提醒读者后面的内容会经常讨论到 <quote>修改</quote>.
        对版本控制系统有经验的用户经常混用 <quote>修改</quote> (change) 和
        <quote>变更集</quote> (changeset) 这两个概念, 但我们必须弄清楚
        Subversion 是怎么理解 <firstterm>变更集</firstterm> (<firstterm>
          changeset</firstterm>) 的.</para>
      <!--
        Before we proceed further, we should warn you that there's
        a lot of discussion of <quote>changes</quote> in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms <quote>change</quote>
        and <quote>changeset</quote> interchangeably, and we should
        clarify what Subversion understands as
        a <firstterm>changeset</firstterm>.</para>
      -->

      <!--
      <para>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let's say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</para>
      -->
      <para>每个人对变更集的理解似乎都有所不同, 至在变更集对版本控制系统的
        意义上都有不同的期待. 从我们的角度来说, 变更集只是一个带有独特的名
        字的修改集合. 修改可能包括文件的修改, 目录结构的修改, 或元数据的修改.
        更一般的说, 变更集只是带有名字的补丁.</para>

      <!--
      <para>In Subversion, a global revision
        number <replaceable>N</replaceable> names a tree in the
        repository: it's the way the repository looked after the
        <replaceable>N</replaceable>th commit.  It's also the name of
        an implicit changeset: if you compare
        tree <replaceable>N</replaceable> with
        tree <replaceable>N</replaceable>-1, you can derive the exact
        patch that was committed.  For this reason, it's easy to think
        of revision <replaceable>N</replaceable> as not just a tree,
        but a changeset as well.  If you use an issue tracker to
        manage bugs, you can use the revision numbers to refer to
        particular patches that fix bugs&mdash;for example,
        <quote>this issue was fixed by r9238.</quote> Somebody
        can then run <userinput>svn log -r 9238</userinput> to read about
        the exact changeset that fixed the bug, and run
        <userinput>svn diff -c 9238</userinput> to see the patch itself.
        And (as you'll see shortly)
        Subversion's <command>svn merge</command> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <userinput>-c 9238</userinput>
        to <command>svn merge</command> would merge changeset r9238
        into your working copy.</para>
      -->
      <para>在 Subversion 中, 一个全局的版本号 <replaceable>N</replaceable>
        确定了仓库中的一棵目录树: 它是仓库在第 <replaceable>N</replaceable>
        次提交后的样子. 同时它还确定了一个隐式的变更集: 如果用户对目录树
        <replaceable>N</replaceable> 和 <replaceable>N</replaceable>-1 进行
        比较, 就可以得到与第 <replaceable>N</replaceable> 次提交对应的补丁.
        正因为如此, 版本号 <replaceable>N</replaceable> 不仅可以表示一棵
        目录树, 还可以表示一个变更集. 如果用户使用了一个问题跟踪系统来管理
        问题, 用户就可以使用版本号指代修复问题的特定补丁&mdash;例如,
        <quote>这个问题在 r9238 中解决</quote>, 然后其他人就可以执行
        <userinput>svn log -r 9238</userinput> 查看修复问题的提交日志, 再用
        <userinput>svn diff -c 9238</userinput> 查看补丁的具体内容. Subversion
        命令 <command>svn merge</command> 也可以使用版本号作为参数 (读者马上就
        会看到). 通过指定参数, 用户可以把一个分支上的特定的变更集合并到另一个
        分支上: 为 <command>svn merge</command> 添加参数 <userinput>-c 9238
      </userinput> 就可以把变更集 r9238 合并到你的工作副本里.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync">
      <!--
      <title>Keeping a Branch in Sync</title>
      -->
      <title>保持分支同步</title>

      <para>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>sync merges (同步合并)</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>merge</tertiary>
        </indexterm>
        继续我们的例子, 假设自从你开始在自己的私有分支上工作后, 时间过了一周,
        你要添加的新特性还未完成, 但你知道在你工作的同时, 团队里的其他人会
        继续向项目的主干 <filename>/trunk</filename> 提交修改. 最好把主干上
        的修改复制到你自己的分支上, 以便确保他们的修改能够与你的分支契合, 这可
        以通过 <firstterm>自动同步合并</firstterm> (<firstterm>automatic
          sync merge</firstterm>) 完成, 自动同步合并的目的是为了让分支与祖先
        分支上的修改保持同步.
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>automatic (自动的)</secondary>
        </indexterm> <quote>自动</quote> 合并的意思是用户只需要提供
        合并所需的最小信息 (也就是合并的源以及被合并的工作副本目标), 至于哪些
        修改需要合并则交由 Subversion 决定&mdash;在自动合并中, 不需要通过
        选项 <option>-r</option> 或 <option>-c</option> 向 <command>svn merge
      </command> 传递变更集.</para>

      <!--
        Continuing with our running example, let's suppose
        that a week has passed since you started working on your
        private branch.  Your new feature isn't finished yet, but at
        the same time you know that other people on your team continue
        to make important changes in the
        project's <filename>/trunk</filename>.  It's in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  This is done
        by performing an <firstterm>automatic sync merge</firstterm>&mdash;a
        merge operation designed to bring your branch up to date with
        any changes made to its ancestral parent branch since your
        branch was created.
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>automatic</secondary>
        </indexterm> An <quote>automatic</quote> merge is simply
        one in which you provide the bare minimum of information required
        for a merge (i.e. a single merge source and a working copy target)
        and let Subversion determine which changes need merging&mdash;no
        changesets are passed to <command>svn merge</command> via the
        <option>-r</option> or <option>-c</option> options in an automatic
        merge.</para>
      -->

      <tip>
      <!--
        <para>Frequently keeping your branch in sync with the main
          development line helps prevent <quote>surprise</quote>
          conflicts when the time comes for you to fold your changes
          back into the trunk.</para>
      -->
        <para>经常保持分支与开发主线同步可以降低分支被合并到主干上时发生冲突
          的概率.</para>
      </tip>

      <!--
      <para>Subversion is aware of the history of your branch and
        knows when it split away from the trunk.  To perform a sync
        merge, first make sure your working copy of the branch
        is <quote>clean</quote>&mdash;that it has no local
        modifications reported by <command>svn status</command>.  Then
        simply run:</para>
      -->
      <para>Subversion 知道分支的历史, 也知道它是在什么时候从主干上分离出来.
        为了执行一个同步合并, 首先要确保分支的工作副本是 <quote>干净的</quote>
        &mdash;也就是没有本地修改. 然后只需要执行:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn merge ^/calc/trunk
--- Merging r341 through r351 into '.':
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
--- Recording mergeinfo for merge of r341 through r351 into '.':
 U   .
 $
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>properties (属性)</primary>
          <secondary>svn:mergeinfo</secondary>
          </indexterm>
          命令 <userinput>svn merge <replaceable>URL</replaceable></userinput>
          告诉 Subversion 把 <replaceable>URL</replaceable> 上的所有未被合并
          的修改都合并到当前工作副本上 (在典型的情况下, 也就是你的工作副本的
          根目录). 注意到我们用的是带有脱字符 (<literal>^</literal>) 的语法
          <footnote><para>脱字符语法在 1.6 加入</para></footnote>, 这样我们
          就不用输入完整的主干 URL 地址. 还要注意输出信息中的 <quote>
            Recording mergeinfo for merge&hellip;</quote>, 这是说合并正在
          更新属性 <literal>svn:mergeinfo</literal>, 我们会在本章后面的
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> 介绍
          <literal>svn:mergeinfo</literal>.
        </para>
      <!--
          This basic syntax&mdash;<userinput>svn merge
        <replaceable>URL</replaceable></userinput>&mdash;tells
        Subversion to merge all changes which have not been previously
        merged from the URL to the current working directory (which is
        typically the root of your working copy).  Notice that we're
        using the caret (<literal>^</literal>)
        syntax<footnote><para>This was introduced in svn
        1.6.</para></footnote> to avoid having to type out the
        entire <filename>/trunk</filename> URL.  Also note
        the <quote>Recording mergeinfo for merge&hellip;</quote>
        notification.  This tells you that the merge is updating
        the <literal>svn:mergeinfo</literal> property. We'll discuss
        both this property and these notifications later in this
        chapter, in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>
      -->

      <tip>
        <para>
          <indexterm>
            <primary>mergeinfo (合并信息)</primary>
          </indexterm>
          在本书及其他地方 (包括 Subversion 邮件列表, 讨论合并跟踪的文章等),
          你会经常听到一个术语 <firstterm>合并信息</firstterm>
          (<firstterm>mergeinfo</firstterm>), 其实它就是
          属性 <literal>svn:mergeinfo</literal> 的缩写.</para>
      <!--
          In this book and elsewhere (Subversion mailing
          lists, articles on merge tracking, etc.) you will frequently
          come across the term <firstterm>mergeinfo</firstterm>. This
          is simply shorthand for the <literal>svn:mergeinfo</literal>
          property.</para>
      -->
      </tip>

      <sidebar>
      <!--
        <title>Keeping a Branch in Sync Without Merge Tracking</title>
      -->
        <title>在无需跟踪合并的情况下保持分支同步</title>

      <!--
        <para>You may not always be able to use Subversion's merge
          tracking feature, perhaps because your server is running
          Subversion 1.4 or earlier or you must use an older client.
          In such a scenario, you can of course still perform merges,
          but Subversion will need you to manually do many of the historical
          calculations that it automatically does on your behalf when the
          merge tracking feature is available.</para>
      -->
        <para>用户可能无法使用 Subversion 的合并跟踪特性, 也许是因为服务器端
          的版本过老, 也许是客户端过老. 这时候用户仍然可以执行合并操作, 但
          Subversion 需要用户手工完成历史计算工作, 这些工作在支持合并跟踪的
          版本中是自动完成的.</para>

      <!--
        <para>To replicate the most recent trunk changes you need to
          perform sync merges the <quote>old-fashioned</quote>
          way&mdash;by specifying ranges of revisions you wish to
          merge.</para>
      -->
        <para>为了复制主干上最近的修改, 你需要按照 <quote>老式</quote> 的方法
          执行同步合并&mdash;指定你想合并的版本号范围.</para>

      <!--
        <para>Using the ongoing example, you know that you branched
          <filename>/calc/trunk</filename> to 
          <filename>/calc/branches/my-calc-branch</filename> in revision
          341:</para>
      -->
        <para>继续使用前面的例子, 用户已经知道从
          <filename>/calc/trunk</filename> 创建分支
          <filename>/calc/branches/my-calc-branch</filename> 的版本号
          是 341:</para>

        <informalexample>
          <screen>
$ svn log -v -r341
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
</screen>
        </informalexample>

      <!--
        <para>When you are ready to synchronize your branch with the
          ongoing changes from trunk, you specify the starting
          revision as the revision of <filename>/calc/trunk</filename>
          which the branch was copied from and the ending revision as
          the youngest change on <filename>/calc/trunk</filename>.  You
          can find the latter with the <command>svn log</command> command
          with the <option>-r</option> set to <literal>HEAD</literal>:</para>
      -->
        <para>如果你已经准备好把主干的修改同步到分支上, 首先指定
          <filename>/calc/trunk</filename> 被复制时的版本号作为起始版本号,
          然后把 <filename>/calc/trunk</filename> 上最年轻的修改指定为结束
          版本号, 后者可以通过 <userinput>svn log -rHEAD</userinput>
          找到:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r340:351
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
</screen>
        </informalexample>

      <!--
        <para>After any conflicts have been resolved, you can commit
          the merged changes to your branch.  Now, to avoid
          accidentally trying to merge these same changes into your
          branch again in the future, you'll need to record the fact
          that you've already merged them.  But where should that
          record be kept?  One of the simplest places to record this
          information is in the log message for the commit of the
          merge:</para>
      -->
        <para>解决掉可能会出现的冲突后, 就可以把合并后的修改提交到你的分支上.
          现在, 为了避免以后再浪费时间合并已经合并过的修改, 用户最好把这次
          合并的版本号范围记录下来, 但是应该把它们记在哪里比较好? 最直接的地
          方就是这次合并的提交日志消息:</para>

        <informalexample>
          <screen>
$ svn ci -m "Sync the my-calc-branch with ^/calc/trunk through r351."
&hellip;
</screen>
        </informalexample>

      <!--
        <para>The next time you sync
          <filename>/calc/branches/my-calc-branch</filename>  with
          <filename>/calc/trunk</filename> you repeat this process, except
          that the starting revision is the <emphasis>youngest</emphasis>
          revision that's already been merged in from the trunk.
          If you've been keeping good records of your merges in the
          commit log messages, you should be able to determine what
          that youngest revision was by reading the revision logs
          associated with your branch.  Once you know your starting
          revision, you can perform another sync merge:</para>
      -->
        <para>在下一次把 <filename>/calc/branches/my-calc-branch</filename>
          向 <filename>/calc/trunk</filename> 同步时, 步骤是一样的, 除了把
          起始版本号改成已经合并过的 <emphasis>最年轻的</emphasis> 版本号.
          如果用户在提交日志里记录了关于合并的信息, 就可以很方便地在提交日
          志消息里找到起始版本号. 起始版本号确定后, 就可以再次执行同步合并:
        </para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------
r959 | sally | 2013-03-5 7:30:21 -0500 (Tue, 05 Mar 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r351:959
&hellip;
</screen>
        </informalexample>

      </sidebar>

      <!--
      <para>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</para>
      -->
      <para>执行完上面的例子后, 分支的工作副本就包含了本地修改, 而且这些修改
        都是创建完分支后, 主干上的修改的副本:</para>

      <informalexample>
        <screen>
$ svn status
 M      .
M       Makefile
M       doc/INSTALL
M       src/button.c
M       src/real.c
</screen>
      </informalexample>

      <!--
      <para>At this point, the wise thing to do is look at the changes
        carefully with <command>svn diff</command>, and then build and
        test your branch.  Notice that the current working directory
        (<quote><filename>.</filename></quote>) has also been
        modified; <command>svn diff</command> shows that
        its <literal>svn:mergeinfo</literal> property has been created.
        </para>
      -->
        <para>这时候比较明智的操作是使用 <command>svn diff</command> 查看修
          改的内容, 并构建测试分支里的代码. 注意当前工作目录 (<quote><filename>
              .</filename></quote>) 也被修改了, <command>svn diff</command>
          显示它新增了 <literal>svn:mergeinfo</literal> 属性.</para>

      <informalexample>
        <screen>
$ svn diff --depth empty .
Index: .
===================================================================
--- .   (revision 351)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /calc/trunk:r341-351
</screen>
      </informalexample>

      <!--
      <para>
        This new property is important merge-related metadata
        that you should <emphasis>not</emphasis> touch, since it is
        needed by future <command>svn merge</command> commands.
        (We'll learn more about this metadata later in the
        chapter.)</para>
      -->
      <para>这个属性是非常重要的与合并相关的元数据, 用户 <emphasis>不</emphasis>
        应该直接修改它的值, 因为后面的 <command>svn merge</command> 会用到该
        属性 (关于合并元数据的更多内容, 我们稍后就会进行介绍).</para>

      <!--
      <para>After performing the merge, you might also need to resolve
        some conflicts&mdash;just as you do with <command>svn
        update</command>&mdash;or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <emphasis>syntactic</emphasis> conflicts doesn't mean there
        aren't any <emphasis>semantic</emphasis> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <userinput>svn revert . -R</userinput> (which
        will undo all local modifications) and starting a
        long <quote>what's going on?</quote> discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</para>
      -->
      <para>执行完合并后, 可能会有冲突需要处理&mdash;就像执行完 <command>
          svn update</command> 那样&mdash;或者可能还需要进行一些小修改, 保证
        合并的结果是正确的 (记住, 没有 <emphasis>语法</emphasis> 冲突并不表
        示没有 <emphasis>语义</emphasis> 冲突!). 如果合并后产生了很多问题,
        用户总是可以用 <userinput>svn revert . -R</userinput> 撤消本地的所有
        修改, 然后就可以和同事讨论 <quote>怎么回事</quote>. 如果一切都很顺利,
        用户就可以把修改提交到仓库里:</para>

      <informalexample>
        <screen>
$ svn commit -m "Sync latest trunk changes to my-calc-branch."
Sending        .
Sending        Makefile
Sending        doc/INSTALL
Sending        src/button.c
Sending        src/real.c
Transmitting file data ....
Committed revision 352.
</screen>
      </informalexample>

      <!--
      <para>At this point, your private branch is now <quote>in
        sync</quote> with the trunk, so you can rest easier knowing
        that as you continue to work in isolation, you're not drifting
        too far away from what everyone else is doing.</para>
      -->
      <para>现在, 用户的私有分支就和主干 <quote>同步</quote> 了, 用户也就不用
        担心自己的工作和其他人的相差太远.</para>

      <sidebar>
      <!--
        <title>Why Not Use Patches Instead?</title>
      -->
        <title>为何不用补丁?</title>

      <!--
        <para>A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use <command>svn patch</command> or the
          operating system's <command>patch</command> command to
          accomplish the same job?  For example:</para>
      -->
        <para>Unix 用户可能会想: 何必要用 <command>svn merge</command>, 为什
          么不直接使用 <command>svn patch</command> 或操作系统的 <command>
            patch</command> 命令完成同样的工作? 例如:</para>

        <informalexample>
          <screen>
$ cd my-calc-branch

$ svn diff -r 341:351 ^/calc/trunk > my-patch-file

$ svn patch my-patch-file
U         doc/INSTALL
U         src/real.c
U         src/button.c
U         Makefile
</screen>
        </informalexample>

      <!--
        <para>In this particular example, there really isn't much
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's able to tweak file contents only.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <command>patch</command> program
          notice changes to properties.  If Sally's change had,
          say, added a new directory, the output of <command>svn
          diff</command> wouldn't have mentioned it at
          all.  <command>svn diff</command> outputs only the limited
          patch format, so there are some ideas it simply can't
          express.  Even Subversion's own <command>svn patch</command>
	  subcommand, while more flexible than the <command>patch</command>
	  program, still has
          similar limitations.</para>
      -->
        <para>对于这个例子而言, <command>svn merge</command> 与 <command>
            svn patch</command>, <command>patch</command> 相比, 的确没什么区
          别, 但 <command>svn merge</command> 拥有 <command>patch</command>
          所不具备的功能. <command>patch</command> 可使用的补丁格式很有限,
          它只能修改文件内容, 却无法表示 <emphasis>目录结构</emphasis> 的变化,
          例如文件和目录的添加, 删除或移动, <command>patch</command> 也不能
          识别属性的修改. 如果 Sally 添加了一个新目录, <command>svn diff
          </command> 的输出也体现不出这一修改. <command>svn diff</command> 的
          输出格式也有限制, 所以它也无法表示某些修改. 即使是 Subversion 自己的
          <command>svn patch</command> 命令 (比操作系统的 <command>patch
          </command> 命令灵活得多) 也有类似的限制.</para>

      <!--
        <para>The <command>svn merge</command> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven't been merged
          yet.</para>
      -->
        <para>而命令 <command>svn merge</command> 通过直接修改工作副本来表示
          目录结构和属性上的变化. 更重要的是 <command>svn merge</command> 会
          把已经复制到分支上的修改记录下来, 从而 Subversion 可以精确地知道
          每个位置都存在着哪些修改 (见
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>). 这个特性
          使得分支是可管理的, 否则的话用户必须手工记录哪些修改已经合并, 哪些
          没有.</para>

      </sidebar>

      <!--
      <para>Suppose that another week has passed.  You've committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you want to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</para>
      -->
      <para>假设又过去了一周, 你在自己的分支上提交了更多的修改, 而你的同事也
        在不断地修改主干. 再一次, 你想把主干上的修改合并到自己的分支上, 于是
        执行下面的命令:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk
svn: E195020: Cannot merge into mixed-revision working copy [352:357]; try up\
dating first
$
</screen>
      </informalexample>

      <!--
      <para>Well that was unexpected!  After making changes to your
        branch over the past week you now find yourself with a working
        copy that contains a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs"/>).  With Subversion
        1.7 and later, the <command>svn merge</command>
        subcommand disables merges into mixed-revision working copies
        by default.  Without going into too much detail, this is
        because of limitations in the way merges are tracked by the
        <literal>svn:mergeinfo</literal> property (see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details).  These limitations mean that merges into
        mixed-revision working copies can result in unexpected text
        and tree conflicts.<footnote><para>The <command>svn
        merge</command> subcommand
        option <option>- -allow-mixed-revisions</option> allows you to
        override this prohibition, but you should only do so if you
        understand the ramifications and have a good reason for
        it.</para></footnote>  We don't want any needless conflicts, so
        we update the working copy and then reattempt the
        merge.</para>
      -->
      <para>这种情况可能不在用户的预料之中! 在自己的分支了工作了一周后, 用户
        发现工作副本包含了混合的版本号 (见
        <xref linkend="svn.basic.in-action.mixedrevs"/>). 1.7 及之后版本的
        <command>svn merge</command> 在默认情况下禁止向含有混合版本号的工作
        副本合并, 简单来说, 这是属性 <literal>svn:mergeinfo</literal> 合并跟踪
        方式的限制导致的 (见
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>), 这些限制意味
        着向一个含有混合版本号的工作副本合并将导致无法预料的内容与目录冲突
        <footnote><para>命令 <command>svn merge</command> 的选项
            <option>--allow-mixed-revisions</option> 允许用户关闭这个限制,
            但是这样做的前提是用户必须理解可能的后果, 以及动机要足够充分.
        </para></footnote>. 我们不希望产生任何不必要的冲突, 所以先更新工作副
        本, 然后再尝试合并.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
At revision 361.

$ svn merge ^/calc/trunk
--- Merging r352 through r361 into '.':
U    src/real.c
U    src/main.c
--- Recording mergeinfo for merge of r352 through r361 into '.':
 U   .
</screen>
      </informalexample>

      <!--
      <para>Subversion knows which trunk changes you previously
        replicated to your branch, so it carefully replicates only
        those changes you don't yet have.  And once again, you build,
        test, and <command>svn commit</command> the local modifications
        to your branch.</para>
      -->
      <para>Subversion 知道主干上的哪些修改已经合并到了分支上, 所以它只会合并
        那些未合并过的主干修改. 如果构建和测试都没有问题, 用户就可以用
        <command>svn commit</command> 把分支的修改提交到仓库里.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync.subtree">
      <!--
      <title>Subtree Merges and Subtree Mergeinfo</title>
      -->
      <title>子目录合并与子目录合并信息</title>
      <para>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>subtree merge (子目录合并)</secondary>
        </indexterm>
        <indexterm>
          <primary>mergeinfo (合并信息)</primary>
          <secondary>subtree mergeinfo (子目录合并信息)</secondary>
        </indexterm>
        在本章的大部分例子中, 被合并的目标都是分支 (见
        <xref linkend="svn.branchmerge.whatis"/>) 的根目录, 虽然这是最常见的
        情况, 但是偶尔也需要直接合并分支的子目录, 这种类型的合并称为
        <firstterm>子目录合并</firstterm>
        (<firstterm>subtree merge</firstterm>), 它的合并信息也相应地称为
        <firstterm>子目录合并信息</firstterm> (<firstterm>subtree mergeinfo
        </firstterm>). 子目录合并和子目录合并信息其实并没有什么特别的地方,
        唯一需要注意的一点是: 一个分支上完整的合并记录可能不仅仅记录在分支根
        目录的合并信息里, 可能还要查看子目录的合并信息才能得到完整的合并信息.
        幸运的是 Subversion 会替用户完成这些操作, 用户几乎不需要直接参与,
        用一个简单的例子解释一下:</para>
      <!--
        In most of the examples in this chapter the
        merge target is the root directory of a branch (see
        <xref linkend="svn.branchmerge.whatis"/>). While this is a
        best practice, you may occasionally need to merge directly
        to some child of the branch root. This type of merge is
        called a <firstterm>subtree merge</firstterm> and the
        mergeinfo recorded to describe it is called
        <firstterm>subtree mergeinfo</firstterm>. There is nothing
        special about subtree merges or subtree mergeinfo.  In fact
        there is really only one important point to keep in mind
        about these concepts: the complete record of merges to a
        branch may not be contained solely in the mergeinfo on the
        branch root.  You may have to consider subtree mergeinfo
        to get a full accounting.  Fortunately Subversion does this
        for you and rarely will you need to concern yourself with
        it.  A brief example will help explain:</para>
      -->

      <informalexample>
        <screen>
# We need to merge r958 from trunk to branches/proj-X/doc/INSTALL,
# but that revision also affects main.c, which we don't want to merge:
$ svn log --verbose --quiet -r 958 ^/
------------------------------------------------------------------------
r958 | bruce | 2011-10-20 13:28:11 -0400 (Thu, 20 Oct 2011)
Changed paths:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
------------------------------------------------------------------------

# No problem, we'll do a subtree merge targeting the INSTALL file
# directly, but first take a note of what mergeinfo exists on the
# root of the branch:
$ cd branches/proj-X

$ svn propget svn:mergeinfo --recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652

# Now we perform the subtree merge, note that merge source
# and target both point to INSTALL:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
--- Merging r958 into 'doc/INSTALL':
U    doc/INSTALL
--- Recording mergeinfo for merge of r958 into 'doc/INSTALL':
 G   doc/INSTALL

# Once the merge is complete there is now subtree mergeinfo on INSTALL:
$ svn propget svn:mergeinfo --recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652
Properties on 'doc/INSTALL':
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# What if we then decide we do want all of r958? Easy, all we need do is
# repeat the merge of that revision, but this time to the root of the
# branch, Subversion notices the subtree mergeinfo on INSTALL and doesn't
# try to merge any changes to it, only the changes to main.c are merged:
$ svn merge ^/subversion/trunk . -c 958
--- Merging r958 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r958 into '.':
 U   .
--- Eliding mergeinfo from 'doc/INSTALL':
 U   doc/INSTALL
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>mergeinfo (合并信息)</primary>
          <secondary>elision (省略)</secondary>
        </indexterm>
        你可能会感到奇怪, 为什么上面的例子里我们只合并了 r958, 但
        <filename>INSTALL</filename> 却含有 r651-652 的合并信息, 这是由于合并
        信息的继承性, 合并信息的继承性我们会在
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>
        介绍. 另外还要注意 <filename>doc/INSTALL</filename> 上的子目录合并信息
        被移除了, 或者说被 <quote>省略</quote> 了, 这被称为 <firstterm>合并信息
          省略</firstterm> (<firstterm>mergeinfo elision</firstterm>), 当
        Subversion 检测到多余的子目录合并信息时, 就会发生这种现象.</para>
      <!--
        You might be wondering
        why <filename>INSTALL</filename> in the above example has
        mergeinfo for r651-652, when we only merged r958. This is
        due to mergeinfo inheritance, which we'll cover in the
        sidebar
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
        />.  Also note that the subtree mergeinfo on
        <filename>doc/INSTALL</filename> was removed, or
        <quote>elided</quote>.  This is called
        <firstterm>mergeinfo elision</firstterm> and it occurs
        whenever Subversion detects redundant subtree mergeinfo.</para>
      -->

      <tip>
      <!--
        <para>Prior to Subversion 1.7, merges unconditionally updated
          <emphasis>all</emphasis> of the subtree mergeinfo under the
          target to describe the merge. For users with a lot of subtree
          mergeinfo this meant that relatively <quote>simple</quote>
          merges (e.g. one which applied a diff to only a single file)
          resulted in changes to every subtree with mergeinfo, even
          those that were not parents of the affected path(s). This
          caused some level of confusion and frustration. Subversion 1.7
          and later addresses this problem by only updating the mergeinfo
          on subtrees which are parents of the paths modified by the merge
          (i.e. paths changed, added, or deleted by application of the
          difference, see
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          The one exception to this behavior regards the actual merge
          target; the merge target's mergeinfo is always updated to
          describe the merge, even if the applied difference made no
          changes.</para>
      -->
        <para>在 Subversion 1.7 版之前, 合并操作会无条件地更新目标所有的子
          目录合并信息, 对于拥有大量子目录合并信息的用户而言, 即使是相对比较
          简单的合并 (例如只合并了一个文件), 也会影响所有子目录的合并信息,
          甚至包括那些不是受影响路径的父目录的目录, 在某种程度上会让人感到
          困惑和沮丧. Subversion 1.7 以及之后的版本解决了这个问题, 方法是只
          更新受影响路径 (也就是通过应用差异而被修改, 添加或删除的路径, 见
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>)
          的父目录的子目录合并信息, 有一个例外是目标的合并信息
          总是会被更新, 即使被应用的差异不会产生任何修改.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.reintegrate">
      <!--
      <title>Reintegrating a Branch</title>
      -->
      <title>重新整合分支</title>

      <!--
      <para>What happens when you finally finish your work, though?
        Your new feature is done, and you're ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch into sync with the trunk again, just as you've been
        doing all along<footnote><para>Since Subversion 1.7 you don't
        absolutely have to do all your sync merges to the root of your
        branch as we do in this example.  <emphasis>If</emphasis> your
        branch is effectively synced via a series of subtree
        merges then the reintegrate will work, but ask yourself, if the
        branch is effectively synced, then why are you doing subtree
        merges? Doing so is almost always needlessly
        complex.</para></footnote>:</para>
      -->
  <para>如果用户完成了分支上的所有工作, 也就是说新特性已经完成, 你已经准备好
    把分支合并到主干上 (这样的话团队中的其他成员就可以分享你的工作成果), 合并
    的步骤很简单, 首先把分支与主干同步, 就像之前做过的那样<footnote><para>
        从 Subversion 1.7 开始, 用户并非一定要像例子中演示的那样, 每次都将分支
        的根目录与主
        干进行同步. <emphasis>如果</emphasis> 分支已经通过一系列的子目录合并,
        在效果上已经实现了与主干的同步, 后面的再整合合并也可以正常工作. 但是请
        读者扪心自问, 如果分支在效果上已经同步了, 那为什么还要再做子目录合并呢?
        此时再做子目录合并只会带来无谓的复杂性.</para>
  </footnote></para>

      <informalexample>
        <screen>
$ svn up # (make sure the working copy is up to date)
Updating '.':
At revision 378.

$ svn merge ^/calc/trunk
--- Merging r362 through r378 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r362 through r378 into '.':
 U   .

$ # build, test, ...

$ svn commit -m "Final merge of trunk changes to my-calc-branch."
Sending        .
Sending        src/main.c
Transmitting file data .
Committed revision 379.
</screen>
      </informalexample>

      <para>现在, 使用 <command>svn merge</command> 把分支上的修改合并到主干
        上, 这种类型的合并称为
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>reintegrate merges (自动再整合合并)</secondary>
        </indexterm> <quote>自动再整合</quote> (automatic reintegrate) 合并,
        在执行合并之前, 用户需要一份 <filename>/calc/trunk</filename> 的工作
        副本, 可以用 <command>svn checkout</command> 或
        <command>svn switch</command> (见
        <xref linkend="svn.branchmerge.switchwc" />) 获取.</para>
      <!--
      <para>Now, use <command>svn merge</command> subcommand to automatically
        replicate your branch changes back into the trunk.  This type of
        merge is called an
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>reintegrate merges</secondary>
        </indexterm> <quote>automatic reintegrate</quote> merge.  You'll need
        a working copy of <filename>/calc/trunk</filename>.  You can get one
        by doing an <command>svn checkout</command>, dredging up an old trunk
        working copy from somewhere on your disk, or
        using <command>svn switch</command> (see
        <xref linkend="svn.branchmerge.switchwc" />).</para>
      -->

      <tip>
      <!--
        <para>The term <quote>reintegrating</quote> comes from the
          <command>merge</command> option <option>- -reintegrate</option>.
          This option is deprecated in Subversion 1.8 (which automatically
          detects when a reintegrate merge is needed), but is required
          for Subversion 1.5 through 1.7 clients when performing reintegrate
          merges.</para>
      -->
        <para>术语 <quote>再整合</quote> 来自子命令 <command>merge</command>
          的选项 <option>--reintegrate</option>. 该选项在 Subversion 1.8 被
          废弃 (1.8 可以自动检测什么时候才需要执行再整合合并), 但是 1.5 到
          1.7 版的 Subversion 客户端在执行再整合合并时都要求提供该选项.</para>
      </tip>

      <!--
      <para>Your trunk working copy cannot have any local edits, switched
        paths, or contain a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs" />).  While
        these are typically best practices for merging anyway, they
        are <emphasis>required</emphasis> for automatic reintegrate
        merges.</para>
      -->
      <para>在合并分支前, 主干的工作副本不能含有本地修改, 已切换的路径, 或混合
        的版本号 (见 <xref linkend="svn.basic.in-action.mixedrevs" />), 这种状
        态不仅会带来很多方便, 而且是自动再整合合并所要求的.</para>

      <!--
      <para>Once you have a clean working copy of the trunk, you're
        ready to merge your branch back into it:</para>
      -->
      <para>一旦准备好了一个整洁的主干工作副本, 用户就可以把分支合并到主干上了:
      </para>

      <informalexample>
        <screen>
$ pwd
/home/user/calc-trunk

$ svn update
Updating '.':
At revision 379.

$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
U    src/real.c
U    src/main.c
U    Makefile
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .

$ # build, test, verify, ...

$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        Makefile
Sending        src/main.c
Sending        src/real.c
Transmitting file data ...
Committed revision 380.
</screen>
      </informalexample>

      <!--
      <para>Congratulations, your branch-specific changes have now
        been merged back into the main line of development.  Notice that
        the automatic reintegrate merge did a different sort of work than
        what you've done up until now.  Previously, we were
        asking <command>svn merge</command> to grab the <quote>next
        set</quote> of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 341:351 from
        <filename>/calc/trunk</filename> to
        <filename>/calc/branches/my-calc-branch</filename>;
        later on, it continues by merging the next contiguously
        available range, 351:361.  When doing the final sync, it
        merges the range 361:378.</para>
      -->
      <para>恭喜, 你在分支上提交的修改现在都已经合并到了开发主线. 应该注意的
        是和你到目前为止所做的合并操作相比, 自动再整合合并所做的工作不太一样.
        之前我们是要求 <command>svn merge</command> 从另一条开发线 (主干) 上
        抓取下一个变更集, 然后把变更集复制到另一条开发线 (你的私有分支) 上.
        这种操作非常直接, Subversion 每一次都知道如何从一次停止的地方开始.
        在我们前面讲过的例子里, Subversion 第一次是把
        <filename>/calc/trunk </filename> 的 r341-351 合并到
        <filename>/calc/branches/my-calc-branch</filename>, 后来它就继续合并
        下一段范围, r351-361, 在最后一次同步, 它又合并了 r361-378.</para>

      <!--
      <para>When merging <filename>/calc/branches/my-calc-branch</filename>
        back to the <filename>/calc/trunk</filename>, however, the
        underlying mathematics are quite different.  Your feature
        branch is now a mishmash of both duplicated trunk changes and
        private branch changes, so there's no simple contiguous range
        of revisions to copy over.  By using an automatic merge, you're
        asking Subversion to carefully replicate <emphasis>only</emphasis>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</para>
      -->
      <para>然而, 在把 <filename>/calc/branches/my-calc-branch</filename>
        合并到 <filename>/calc/trunk</filename> 时, 其底层的数学行为是非常
        不一样的. 特性分支现在已经是同时包含了主干修改和分支私有修改的大杂烩,
        所以没办法简单地复制一段连续的版本号范围. 通过使用自动再整合合并,
        你是在要求
        Subversion 只复制那些分支特有的修改 (具体的实现方式是比较最新版的分支
        与主干, 最终得到的差异就是分支所特有的修改).</para>

      <!--
      <para>Keep in mind that the automatic reintegrate merges only support
        the use case described above.  Because of this narrow focus, in
        addition to the requirements previously mentioned (up-to-date working
        copy <footnote><para>Automatic reintegrate merges are allowed if the
        target is a shallow checkout
        (see <xref linkend="svn.advanced.sparsedirs"/>) but any paths
        affected by the diff which are <quote>missing</quote> due to the
        sparse working copy will be skipped&mdash;this is probably
        <emphasis>not</emphasis> what you intended!</para></footnote>
        with no mixed-revisions, switched paths or local changes) it will not
        function in combination with most of the other
        <command>svn merge</command> options. You'll get an error if you
        use any non-global options but these: <option>- -accept</option>,
        <option>- -dry-run</option>, <option>- -diff3-cmd</option>,
        <option>- -extensions</option>, or <option>- -quiet</option>.</para>
      -->
      <para>始终记住自动再整合合并只支持上面描述的使用案例, 由于这个狭隘的
        重点, 除了前面提到的要求 (最新的工作副本 <footnote><para>自动再整合合
            并也支持目标是浅检出的目录 (见
            <xref linkend="svn.advanced.sparsedirs"/>), 但是如果受影响的路径
            由于目录是稀疏的, 而不出现在工作副本中, 那么该路径就会被忽略&mdash;
            这可能 <emphasis>不是</emphasis> 用户想要的结果!</para></footnote>
        , 不含有混合的版本号, 已切换的路径或本地修改) 外, <command>svn merge
        </command> 的大部分选项都会使它不能正常工作, 如果用户用到了除
        <option>--accept</option>, <option>--dry-run</option>, <option>
          --diff3-cmd</option>, <option>--extensions</option>, <option>--quiet
      </option> 之外的其他非全局选项, 将会得到一个错误.</para>

      <!--
      <para>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</para>
      -->
      <para>既然你的私有分支已经合并到了主干上, 现在就可以把它删除了:</para>

      <informalexample>
        <screen>
$ svn delete ^/calc/branches/my-calc-branch \
             -m "Remove my-calc-branch, reintegrated with trunk in r381."
&hellip;
</screen>
      </informalexample>

      <!--
      <para>But wait!  Isn't the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <filename>/calc/branches</filename> directory, its
        existence is still an immutable part of the repository's
        history.  A simple <command>svn log</command> command on
        the <filename>/calc/branches</filename> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>
      -->
      <para>不过, 分支的历史不是很重要吗? 如果有人想查看分支的每一次修改,
        审查特性的演变怎么办? 不用担心, 虽然你的分支在
        <filename>/calc/branches</filename> 再也看不到了, 但是它在仓库的历史
        里依然存在. 在 <filename>/calc/branches</filename> 的 URL 上执行
        一个简单的 <command>svn log</command>, 就可以看到分支的全部历史.
        你的分支甚至可以某一时刻复活, 你期待吗 (见
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>

      <!--
      <para>If you choose not to delete your branch after reintegrating
        it to the trunk you may continue to perform sync merges from the
        trunk and then reintegrate the branch again<footnote><para>Only
        Subversion 1.8 supports this reuse of a feature branch.  Earlier
        versions require some special handling before a feature branch
        can be reintegrated more than once.  See the earlier version of
        this chapter for more information: <ulink
        url="http://svnbook.red-bean.com/en/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. If you do this, only the changes made on your
        branch after the first reintegrate are merged to the trunk.</para>
      -->
      <para>分支被合并到主干后, 如果选择不删除分支, 你可能会继续从主干同步
        修改, 然后再次重新整合分支 <footnote><para>只有 Subversion 1.8 允许
        这样重用一个特性分支. 较早的版本要求一个特性分支在被多次重新整合
        之前, 需要一些特殊的处理, 更多的信息参见本书较早的版本:
        <ulink
        url="http://svnbook.red-bean.com/en/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. 如果你这样做了, 那么只有第一次重新整合之后发生的
        修改 才会被合并到主干上.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.mergeinfo">
      <!--
      <title>Mergeinfo and Previews</title>
      -->
      <title>合并信息和预览</title>

      <para>
        <indexterm>
          <primary>mergeinfo (合并信息)</primary>
          <secondary>property (属性)</secondary>
        </indexterm>
        Subversion 跟踪变更集的基本机制&mdash;也就是判断哪些修改已经合并到哪些
        分支上&mdash;是在版本化的属性中记录数据. 更确切地说, 与合并相关的数据
        记录在文件和目录的 <literal>svn:mergeinfo</literal> 属性中. (如果读者
        还不了解 Subversion 的属性, 见 <xref linkend="svn.advanced.props"/>.)
      </para>
      <!--
        The basic mechanism Subversion uses to track
        changesets&mdash;that is, which changes have been merged to
        which branches&mdash;is by recording data in versioned
        properties.  Specifically, merge data is tracked in
        the <literal>svn:mergeinfo</literal> property attached to
        files and directories.  (If you're not familiar with
        Subversion properties, see <xref linkend="svn.advanced.props"
        />.)</para>
      -->

      <!--
      <para>You can examine the mergeinfo property, just like any other
        versioned property:</para>
      -->
      <para>你可以像查看其他属性那样, 查看属性 <literal>svn:mergeinfo</literal>
        :</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn pg svn:mergeinfo -v
Properties on '.':
  svn:mergeinfo
    /calc/trunk:341-378
</screen>
      </informalexample>

      <warning>
      <!--
        <para>While it is possible to
          modify <literal>svn:mergeinfo</literal> just as you might
          any other versioned property, we strongly discourage doing
          so unless you <emphasis>really</emphasis> know what you're
          doing.</para>
      -->
        <para>虽然你可以像修改其他属性那样修改 <literal>svn:mergeinfo</literal>,
          但我们强烈建议你不要这么做, 除非你真地知道自己在做什么.</para>
      </warning>

      <tip>
      <!--
        <para>The amount of <literal>svn:mergeinfo</literal> on a single
          path can get quite large, as can the output of a
          <command>svn propget - -recursive</command> or
          <command>svn proplist - -recursive</command> when dealing with
          large amounts of subtree mergeinfo. See
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>
          . The formatted output produced by the
          <option>- -verbose</option> option with either of these
          subcommands is often very helpful in these cases.</para>
      -->
        <para>在单个路径上的 <literal>svn:mergeinfo</literal> 数量可以变得
          非常庞大, <command>svn propget --recursive</command> 和
          <command>svn proplist --recursive</command> 在处理大量的子目录合并
          信息时, 命令的输出也会很多 (见
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>).
          为了减少输出的内容, 比较常用的方法是为命令添加选项
          <option>--verbose</option>.</para>
      </tip>

      <!--
      <para>The <literal>svn:mergeinfo</literal> property is
        automatically maintained by Subversion whenever you
        run <command>svn merge</command>.  Its value indicates which
        changes made to a given path have been replicated into the
        directory in question.  In our previous example, the path
        which is the source of the merged changes is
        <filename>/calc/trunk</filename> and the directory which has
        received the changes is
        <filename>/calc/branches/my-calc-branch</filename>.
        Earlier versions of Subversion maintained the
        <literal>svn:mergeinfo</literal> property silently. You could
        still detect the changes, after a merge completed, with the
        <command>svn diff</command> or <command>svn status</command>
        subcommands, but the merge itself gave no indication when it
        changed the <literal>svn:mergeinfo</literal> property. In
        Subversion 1.7 and later this is no longer true as there are
        several notifications to alert you when a merge updates the
        <literal>svn:mergeinfo</literal> property. These notifications
        all begin with <quote>- - - Recording mergeinfo for</quote>
        and appear at the end of the merge.  Unlike other merge
        notifications, these don't describe the application of a
        difference to a working copy
        (see <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        but instead describe "housekeeping" changes made to keep
        track of what was merged.</para>
      -->
      <para>当用户执行 <command>svn merge</command> 时, Subversion 就会自动
        更新属性 <literal>svn:mergeinfo</literal>, 属性的值指出了给定路径上
        的哪些修改已经复制到目录上. 在我们之前的例子里, 修改的来源是
        <filename>/calc/trunk</filename>, 被合并的目录是 <filename>
          /calc/branches/my-calc-branch</filename>. 旧版的 Subversion 会悄无
        声息地维护属性 <literal>svn:mergeinfo</literal>, 合并后, 用户仍然可
        以用命令 <command>svn diff</command> 或 <command>svn status</command>
        查看合并产生的修改, 但是当合并操作修改属性 <literal>svn:mergeinfo
        </literal> 时不会显示任何提示信息. 而 Subversion 1.7 及以后的版本就
        不再这样了, 当合并操作更新属性 <literal>svn:mergeinfo</literal> 时,
        Subversion 会给出一些提示信息. 这些提示信息都是以
        <literal>--- Recording mergeinfo for</literal> 开始, 在合并的末尾输出.
        不像其他的合并提示信息, 这些信息不是在描述差异被应用到工作副本 (见
        <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>), 而是在描述
        为了跟踪合并而产生的 <quote>家务</quote> 变化.</para>

      <!--
      <para>Subversion also provides a subcommand, <command>svn
        mergeinfo</command>, which is helpful in seeing the merge
        relationships between two branches; specifically which changesets
        a directory has absorbed or which changesets it's still eligible
        to receive.  The latter gives a sort of preview of which changes a
        subsequent <command>svn merge</command> operation would replicate
        to your branch.  By default, <command>svn mergeinfo</command> gives
        an graphical overview of the relationship between to branches.
        Returning to our earlier example, we use the subcommand to analyze
        the relationship between <filename>/calc/trunk</filename> and
        <filename>/calc/branches/my-calc-branch</filename>:</para>
      -->
      <para>Subversion 提供了子命令 <command>svn mergeinfo</command>, 用于查看
        两个分支间的合并关系, 特别是查看目录吸收了哪些变更集, 或者查看哪些变
        更集它是有资格吸收的, 后者提供了一种预览, 预览随后的 <command>
          svn merge</command> 命令将会复制哪些修改到分支上. 在默认情况下,
        <command>svn mergeinfo</command> 将会输出两条分支之间的关系的图形化
        概览. 回到我们先前的例子, 用命令 <command>svn mergeinfo</command>
        分析 <filename>/calc/trunk</filename> 和
        <filename>/calc/branches/my-calc-branch</filename> 之间的关系:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn mergeinfo ^/calc/trunk
    youngest common ancestor
    |         last full merge
    |         |        tip of branch
    |         |        |         repository path

    340                382
    |                  |
  -------| |------------         calc/trunk
     \          /
      \        /
       --| |------------         calc/branches/my-calc-branch
              |        |
              379      382
</screen>
      </informalexample>

      <!--
      <para>The diagram shows that <filename>/calc/branches/my-calc-branch
      </filename> was copied from <filename>/calc/trunk@340</filename> and
      that most recent automatic merge was the reintegrate merge we made
      from the branch to the trunk in r380.  Notice that the diagram does
      <emphasis>not</emphasis> show the four automatic sync merges we made
      in revisions 352, 362, 372, and 379.  Only the most recent automatic
      merge, in either direction<footnote><para>By <quote>direction</quote>
      we mean either trunk-to-branch (automatic sync) or branch-to-trunk
      (automatic reintegrate) merges.</para></footnote>, is shown.  This
      default output is useful for obtaining an overview of the merges
      between two branches, but to see the specific revisions which were
      merged we use the <option>- -show-revs=merged</option> option:</para>
      -->
    <para>图中显示了 <filename>/cal/branches/my-calc-branch</filename> 拷贝
      自 <filename>/calc/trunk@340</filename>, 最近的一次自动合并是从分支到
      主干的自动再整合合并, 在版本号 380. 注意到图中 <emphasis>没有</emphasis>
      显示我们在版本号 352, 362, 372 和 379 执行的自动同步合并, 在每个
      方向上只显示了最近的自动合并 <footnote><para>这里的 <quote>方向</quote>
          指的是从主干到分支 (自动同步) 或从分支到主干 (自动再整合) 的合并.
      </para></footnote> 这种默认输出对于获取两个分支之间的合并概览非常有用,
      如果想要清楚地看到分支上合并了哪些版本号, 就增加选项 <option>
        --show-revs=merged</option>:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs merged
r344
r345
r346
&hellip;
r366
r367
r368
</screen>
      </informalexample>

      <!--
      <para>Likewise, to see which changes are eligible to merge from the
        trunk to the branch we can use the <option>- -show-revs=eligible
        </option> option:</para>
      -->
        <para>同样地, 为了查看分支可以从主干上合并哪些修改, 就用选项 <option>
            --show-revs=eligible</option>:</para>
      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r380
r381
r382
</screen>
      </informalexample>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.operativerevs">
      <!--
        <title>Operative and Inoperative Merge Revisions</title>
      -->
        <title>可实施与不可实施的版本号</title>

      <!--
        <para>The revision lists produced by the <option>- -show-revs
          </option> option include only revisions which made (or would make)
          changes when merged.  So while we have merged a contiguous range of
          revisions (i.e. r341-378) from <filename>/calc/trunk</filename> to
          <filename>/calc/branches/my-calc-branch</filename>, only the
          revisions listed with the <option>- -show-revs=merged</option> option
          actually represent changes made on <filename>/calc/trunk</filename>.
          These revisions are described as <quote>operative</quote>
          revisions as regards merging, not to be confused with the
          operative revision used with the <option>-r</option> option, see
          <xref linkend="svn.advanced.pegrevs"/>.  Not suprisingly, the
          revisions in the range r341-378 that are <emphasis>not</emphasis>
          listed as merged are termed <quote>inoperative</quote> revisions.
        </para>
      -->
        <para>选项 <option>--show-revs</option> 列出的版本号只包含了在合并时
          (将) 会产生实际修改的版本号, 所以说当用户从
          <filename>/calc/trunk</filename>
          合并一段连续的版本号 (例如 r341-378) 到 <filename>
            /calc/branches/my-calc-branch</filename> 时, 只有那些包含在选项
          <option>--show-revs=merged</option> 输出的列表中的版本号才真正地含
          有针对 <filename>/cal/trunk</filename> 的修改, 对于合并而言, 这些
          版本号被称为 <quote>可实施的版本号</quote>, 注意不要和选项
          <option>-r</option> 使用的实施版本号搞混, 实施版本号见
          <xref linkend="svn.advanced.pegrevs"/>. 反之, r341-378 中未出现在
          选项 <option>--show-revs=merged</option> 输出列表中的版本号被称
          为 <quote>不可实施的版本号</quote>.</para>
      </sidebar>

      <!--
      <para>The <command>svn mergeinfo</command> command requires
        a <quote>source</quote> URL (where the changes come
        from), and takes an optional <quote>target</quote> URL (where
        the changes merge to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we're querying our
        branch working copy, the command assumes we're interested in
        receiving changes to <filename>/calc/branches/my-calc-branch
        </filename> from the specified trunk URL.</para>
      -->
        <para>命令 <command>svn mergeinfo</command> 需要一个 <quote>源</quote>
          URL (修改的来源), 接受一个可选的 <quote>目标</quote> URL (合并修改
          的目标). 如果没有指定目标 URL, 命令就把当前工作目录当成目标. 在上面
          的例子里, 因为我们要查询的是分支工作副本, 命令假定我们想知道的是主干
          URL 上的哪些修改可以合并到 <filename>/calc/branches/my-calc-branch
        </filename>.</para>

      <!--
      <para>Since Subversion 1.7, the
        <command>svn mergeinfo</command> subcommand can also account for
        subtree mergeinfo and non-inheritable mergeinfo.  It accounts for
        subtree mergeinfo by use of the <option>- -recursive</option> or
        <option>- -depth</option> options, while non-inheritable mergeinfo
        is considered by default.</para>
      -->
      <para>从 Subversion 1.7 开始, <command>svn mergeinfo</command> 也可以
        描述子目录合并信息和不可继承的合并信息. 为了描述子目录合并信息, 要加
        上选项 <option>--recursive</option> 或 <option>--depth</option>,
        而不可继承的合并信息本来就会被考虑到.</para>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.inheritance">
      <!--
        <title>Mergeinfo Inheritance</title>
      -->
        <title>合并信息继承</title>

        <para>
          <indexterm>
            <primary>mergeinfo (合并信息)</primary>
            <secondary>inheritance (继承)</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo (合并信息)</primary>
            <secondary>explicit (显式的)</secondary>
          </indexterm>
          如果某个路径具有属性 <literal>svn:mergeinfo</literal>, 我们就说它
          含有 <firstterm>显式的合并信息</firstterm> (<firstterm>explicit
            mergeinfo</firstterm>). 显式的合并信息不仅描述了合并到属性所在的
          目录上的修改, 还描述了目录的子文件和子目录 (因为子文件和子目录继承了
          父目录的合并信息), 例如:</para>
      <!--
          When a path has
          the <literal>svn:mergeinfo</literal> property set on it we
          say it has <firstterm>explicit mergeinfo</firstterm>.  This
          explicit mergeinfo describes not only what changes were
          merged into that particular directory, but also all the
          children of that directory (because those children inherit
          the mergeinfo of their parent path).  For example:</para>
      -->

        <informalexample>
          <screen>
# What explicit mergeinfo exists on a branch?
$ svn propget svn:mergeinfo ^/branches/proj-X --recursive
/trunk:651-652

# What children does proj-X have?
$ svn list --recursive ^/branches/proj-X
doc/
doc/INSTALL
README
src/main.c

# Ask what revs were merged to a file with no explicit mergeinfo
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

      <!--
        <para>Notice from our first subcommand that only the root of
          <filename>/branches/proj-X</filename> has any explicit
          mergeinfo.  However, when we use
          <command>svn mergeinfo</command> to ask what was merged to
          <filename>/branches/proj-X/src/main.c</filename> it reports
          that the two revisions described in the explicit mergeinfo
          on <filename>/branches/proj-X</filename> were merged.  This is
          because <filename>/branches/proj-X/src/main.c</filename>, having
          no explicit mergeinfo of its own, inherits the mergeinfo from
          its nearest parent with explicit mergeinfo,
          <filename>/branches/proj-X</filename>.</para>
      -->
        <para>执行的第一个命令中, 只有 <filename>/branches/proj-X</filename>
          的根目录含有显式的合并信息, 然而, 如果我们用 <command>svn mergeinfo
            </command> 询问哪些修改被合并到
            <filename>/branches/proj-X/src/main.c</filename>, 命令报告有两个
            版本号被合并到 <filename>/branches/proj-X/src/main.c</filename>,
            而这两个版本号也出现在 <filename>/branches/proj-X</filename> 显式
            的合并信息中. 这是因为
            <filename>/branches/proj-X/src/main.c</filename> 没有属于它自己的
            显式合并信息, 它的合并信息继承自最近的, 含有显式合并信息的父目录,
            也就是 <filename>/branches/proj-X</filename>.</para>

      <!--
        <para>There are two cases in which mergeinfo is not inherited.
          First, if a path has explicit mergeinfo, then it never inherits
          mergeinfo. Another way to think of this is that explicit
          mergeinfo is always a complete record of the merges to a given
          path. Once it exists it overrides any mergeinfo that path might
          otherwise inherit. The second way is when dealing with
          non-inheritable mergeinfo, a special type of explicit mergeinfo
          that applies <emphasis>only</emphasis> to the directory on which
          the <literal>svn:mergeinfo</literal> property is set (and it's
          only directories, non-inheritable mergeinfo is never set on
          files). For example:</para>
      -->
        <para>在两种情况下, 合并信息不会被继承. 第一种情况是如果一个路径含有显式
          的合并信息, 该路径就不会继承任何合并信息, 我们可以这样理解: 一个路径
          上的显式合并信息总是一个完整的合并记录. 一旦存在显式的合并信息, 它就
          会覆盖路径可能从其他地方继承而来的合并信息. 第二种情况是合并信息本
          身是不可
          继承的, 这种特殊类型的合并信息 <emphasis>只能</emphasis> 应用到设置了
          属性 <literal>svn:mergeinfo</literal> 的目录上 (不可继承的合并信息不
          能设置在文件上), 例如:</para>

        <informalexample>
          <screen>
# The '*' decorator indicates non-inheritable mergeinfo
$ svn propget svn:mergeinfo ^/branches/proj-X
/trunk:651-652,758*

# Revision 758 is non-inheritable, but still applies to the path it is
# set on. Here the '*' decorator signals that r758 is only partially
# merged from trunk. 
$ svn mergeinfo ^/trunk ^/branches/proj-X --show-revs merged
651
652
758*

# Revision 758 is not reported as merged because it is non-inheritable
# and applies only to ^/trunk
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

      <!--
        <para>You might never have to think about mergeinfo inheritance
          or encounter non-inheritable mergeinfo in your own repository.
          A discussion of the full ramifications of mergeinfo inheritance
          are beyond the scope of this book.  If you have more questions
          check out some of the references mentioned in
          <xref linkend="svn.branchmerge.advanced.finalword"/></para>
      -->
        <para>在你自己的仓库中, 你可能永远不需要考虑合并信息的继承, 也不会遇到
          不可继承的合并信息. 关于合并信息继承的完整讨论已经超出了本书的范围,
          如果读者还有问题没有想明白, 可以阅读
          <xref linkend="svn.branchmerge.advanced.finalword"/> 列出的参考资料.
        </para>
      </sidebar>

      <!--
      <para>Let's say we have a branch with both subtree and
        non-inheritable mergeinfo:</para>
      -->
      <para>假设有一个分支同时包含了子目录合并信息和不可继承的合并信息:</para>

        <informalexample>
          <screen>
$ svn pg svn:mergeinfo -vR
# Non-inheritable mergeinfo
Properties on '.':
  svn:mergeinfo
    /calc/trunk:354,385-388*
# Subtree mergeinfo
Properties on 'Makefile':
  svn:mergeinfo
    /calc/trunk/Makefile:354,380
</screen>
        </informalexample>

      <!--
      <para>From the above mergeinfo we see that r385-388 has only been
        merged into the root of the branch, but not any of the root's
        children.  We also see that r380 has only been merged to
        <filename>Makefile</filename>.
        When we use <command>svn mergeinfo</command> with the
        <option>- -recursive</option> option to see what has been merged
        from <filename>/calc/trunk</filename> to this branch, we see three
        revisions are flagged with the <literal>*</literal> marker:</para>
      -->
      <para>从合并信息中可以看到 r385-388 只被合并到了分支的根目录上, 但不
        包括任何一个子文件. 还可以看到 r380 只被合并到了 <filename>Makefile
        </filename> 上. 如果用带上选项 <option>--recursive</option> 的
        <command>svn mergeinfo</command> 查看从 <filename>/calc/trunk</filename>
        那里合并了哪些版本号到这个分支上, 我们可以看到其中三个版本号带有星号
        标记:</para>
      
        <informalexample>
          <screen>
$ svn mergeinfo -R --show-revs=merged ^/calc/trunk .
r354
r380*
r385
r386
r387*
r388*
</screen>
        </informalexample>

      <!--
      <para>The <literal>*</literal> indicates revisions that are only
        <emphasis>partially</emphasis> merged to the target in question
        (the meaning is the same if we are checking for eligible
        revisions).  What this means in this example is that if we tried
        to merge r380, r387, or r388 from <filename>^/trunk</filename> then
        more changes would result. Likewise, because r354, r385 and r386 are
        <emphasis>not</emphasis> flagged with a <literal>*</literal>,
        we know that re-merging those revisions would have no result.
        <footnote><para>This is a good example of inoperative merge
        revisions.</para></footnote></para>
      -->
  <para>星号 <literal>*</literal> 表示该版本号只是被 <emphasis>部分地</emphasis>
    合并到目标上 (对于 <literal>--show-revs=eligible</literal>, 其星号的意义是
    相同的). 对于这个例子而言, 它的意思是说如果我们尝试从
    <filename>^/trunk</filename> 合并 r380, r387 或 r388, 将会产生更多的修改.
    同样地, 因为 r354, r385 和 r386 <emphasis>没有</emphasis> 被星号标记,
    所以再次合并这些版本号将不会产生任何修改. <footnote><para>这是不可实施的
        合并版本号的好例子.</para></footnote></para>

      <!--
      <para>Another way to get a more precise preview of a merge
        operation is to use the <option>- -dry-run</option>
        option:</para>
      -->
      <para>获取合并预览的另一种办法是使用选项 <option>--dry-run</option>:
      </para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk paint-feature-branch --dry-run
--- Merging r290 through r383 into 'paint-feature-branch':
U    paint-feature-branch/src/palettes.c
U    paint-feature-branch/src/brushes.c
U    paint-feature-branch/Makefile

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>
      </informalexample>

      <!--
      <para>The <option>- -dry-run</option> option doesn't actually
        apply any local changes to the working copy.  It shows only
        status codes that <emphasis>would</emphasis> be printed in a
        real merge.  It's useful for getting a <quote>high-level</quote>
        preview of the potential merge, for those times
        when running <command>svn diff</command> gives too much
        detail.</para>
      -->
      <para>选项 <option>--dry-run</option> 不会真正地去修改工作副本, 它只会
        输出一个真正的合并操作 <emphasis>将会</emphasis> 输出的信息. 如果嫌
        <command>svn diff</command> 的输出过于详细, 就可以用这个选项获得一个
        比较 <quote>高层的</quote> 合并预览.</para>

      <tip>
      <!--
        <para>After performing a merge operation, but before
          committing the results of the merge, you can use
          <userinput>svn diff - -depth=empty <replaceable>
          /path/to/merge/target</replaceable></userinput> to see only the
          changes to the immediate target of your merge.  If your merge
          target was a directory, only property differences are displayed.
          This is a handy way to see the changes to the
          <literal>svn:mergeinfo</literal> property recorded by the
          merge operation, which will remind you about what you've
          just merged.</para>
      -->
        <para>执行完合并, 但是在提交之前, 可以用 <userinput>svn diff
            --depth=empty <replaceable>/path/to/merge/target</replaceable>
          </userinput> 查看被合并的直接目标的修改, 如果被合并的目标是目录,
          那么命令就只会输出属性的修改. 这是查看合并后属性
          <literal>svn:mergeinfo</literal> 的变化的简便方法, 从属性的
          变化中可以看到这次合并合并了哪些版本号.</para>
      </tip>

      <!--
      <para>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <command>svn merge</command>
        isn't an inherently risky thing (unless you've made local
        modifications to your working copy&mdash;but we already
        stressed that you shouldn't merge into such an
        environment).  If you don't like the results of the merge,
        simply run <userinput>svn revert . -R</userinput> to revert
        the changes from your working copy and retry the command with
        different options.  The merge isn't final until you
        actually <command>svn commit</command> the results.</para>
      -->
      <para>当然, 预览合并的最佳方法是执行合并. 记住, 执行 <command>svn merge
        </command> 并不是一个危险的操作 (除非在合并前, 工作副本含有本地修改,
        但我们已经强调过不要在这种情况下执行合并). 如果你不喜欢合并的结果,
        执行 <userinput>svn revert . -R</userinput> 就可以撤消合并产生的修改.
        只有在执行了 <command>svn commit</command> 后, 合并的结果才会被提交到
        仓库中.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.undo">
      <!--
      <title>Undoing Changes</title>
      -->
      <title>撤消修改</title>

      <!--
      <para>An extremely common use for <command>svn merge</command>
        is to roll back a change that has already been committed.
        Suppose you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made back in revision 392, which changed
        several code files, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference.  (You can do this by
        specifying <option>- -revision 392:391</option>, or by an
        equivalent <option>- -change -392</option>.)</para>
      -->
      <para>人们经常使用 <command>svn merge</command> 撤消已经提交的修改.
        假设你正开心地在 <filename>/calc/trunk</filename> 的工作副本上工作,
        突然发现版本号 392 提交的修改是完全错误的, 它就不应该被提交. 此时你可
        以用 <command>svn merge</command> 在工作副本中 <quote>撤消</quote>
        版本号 392 的修改, 然后把用于撤消 r392 的修改提交到仓库中. 你所要做
        的只是指定一个 <emphasis>逆</emphasis> 差异 (对于这个例子而言, 指定
        逆差异的命令行参数是 <literal>--revision 392:391</literal> 或
        <literal>--change -392</literal>).</para>


      <informalexample>
        <screen>
$ svn merge ^/calc/trunk . -c-392
--- Reverse-merging r392 into '.':
U    src/real.c
U    src/main.c
U    src/button.c
U    src/integer.c
--- Recording mergeinfo for reverse merge of r392 into '.':
 U   .

$ svn st
M       src/button.c
M       src/integer.c
M       src/main.c
M       src/real.c

$ svn diff
&hellip;
# verify that the change is removed
&hellip;

$ svn commit -m "Undoing erroneous change committed in r392."
Sending        src/button.c
Sending        src/integer.c
Sending        src/main.c
Sending        src/real.c
Transmitting file data ....
Committed revision 399.
</screen>
      </informalexample>

      <!--
      <para>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <option>-r</option> option, you can ask <command>svn
        merge</command> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset r392 to our working copy
        <emphasis>backward</emphasis>.</para>
      -->
      <para>我们以前说过, 可以把版本号当成一个特定的变更集, 通过选项 <option>
          -r</option>, 可以要求 <command>svn merge</command> 向工作副本应用一
        个特定的变更集, 或一段变更集范围. 在上面这个例子里, 我们是要求
        <command>svn merge</command> 把变更集 r392 的逆修改应用到工作副本上.
      </para>

      <!--
      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>
      -->
      <para>记住, 像这样撤消修改和其他 <command>svn merge</command> 操作一样,
        用户应该用 <command>svn status</command> 和 <command>svn diff</command>
        确认修改的内容正是心里所期望的那样, 检查没问题后再用 <command>svn
          commit</command> 提交. 提交后, 在 <literal>HEAD</literal> 上就再也看
        不到 r392 的修改.</para>

      <!--
      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 392.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 392 and
        398, she'll still see the bad change, right?</para>
      -->
      <para>读者可能在想: 好吧, 其实并没有真正地撤消提交, 版本号 392 的修改仍然
        存在于历史中, 如果有人检出了版本在 r392 到 r398 之间的
        <filename>calc</filename>, 他就会看到错误的修改, 对吧?</para>

      <!--
      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from the <literal>HEAD</literal> revision.  The
        original change still exists in the repository's history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.<footnote><para>The
        Subversion project has plans, however, to someday implement a
        command that would accomplish the task of permanently deleting
        information.  In the meantime, see
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a
        possible workaround.</para></footnote></para>
      -->
  <para>说得没错, 当我们谈论 <quote>删除</quote> 一个修改时, 我们实际上说得是
    把修改从版本号 <literal>HEAD</literal> 中删除, 原始的修改仍然存在于仓库中
    的历史中. 在大多数时候, 这种做法已经足够好了, 毕竟大多数人只对项目的
    <literal>HEAD</literal> 感兴趣. 然而, 在少数情况下, 用户可能真地需要把
    提交从仓库的历史中完全擦除 (可能是不小心提交了一份机密文档). 这做起来并不
    容易, 因为 Subversion 的设计目标之一是不能丢失任何一个修改, 版本号是以其他
    版本号为基础的不可修改的目录树, 从历史中删除一个版本号将会产生多米诺骨牌
    效应, 使后面的版本号产生混乱, 甚至可能会使所有的工作副本失效.<footnote>
      <para>Subversion 已经计划在未来的某一天, 能够实现永久地删除提交历史,
        但在 Subversion 实现之前, 可以从
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> 找到变通
        办法.</para></footnote></para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.resurrect">
      <!--
      <title>Resurrecting Deleted Items</title>
      -->
      <title>恢复已删除的文件</title>

      <!--
      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote></para>
      -->
    <para>版本控制系统的一大好处是信息永远不会丢失. 即使你删除了一个文件或
      目录, 虽然在版本号 <literal>HEAD</literal> 中已经看不到被删除的文件,
      但它们在早先的版本中仍然存在. 新用户经常问的一个问题是 <quote>怎样才
        能找回以前的文件或目录?</quote></para>

      <!--
      <para>The first step is to define
        exactly <emphasis>which</emphasis> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        is defined by a specific coordinate pair.  (Remember the
        <quote>peg revision</quote>
        syntax&mdash;foo.c@224&mdash;mentioned back in
        <xref linkend="svn.advanced.pegrevs"/>.)</para>
      -->
      <para>第一步是准确地指定你想要恢复的是哪一项条目. 一种比较形象的比喻是
        把仓库中的每个对象都想像成一个二维坐标, 第一个坐标是特定的版本号目录
        树, 第二个坐标是目录内的路径, 于是文件或目录的每一个版本都可以由一对
        坐标唯一地确定.</para>

      <!--
      <para>First, you might need to use <command>svn log</command> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <userinput>svn log - -verbose</userinput>
        in a directory that used to contain your deleted item.  The
        <option>- -verbose</option> (<option>-v</option>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).  If you know that
        the item in question was recently deleted you might also use
        the <option>- -limit</option> option to keep the log output brief
        enough to examine manually.</para>
      -->
      <para>首先, 用户可能要用 <command>svn log</command> 找到他想恢复的二维
        坐标, 比较好的策略是在曾经含有被删除的项目的目录中运行
        <userinput>svn log --verbose</userinput>, 选项
        <option>--verbose</option> (<option>-v</option>) 显示了在每个版本号中
        被修改的所有项目, 你所要做的就是找到那个删除了文件或目录的版本号. 用户
        可以依靠自己的肉眼寻找, 也可以借助其他工具 (例如 <command>grep
        </command>) 扫描 <command>svn log</command> 的输出. 如果用户已经知道
        待恢复的项目是在最近的提交中才被删除, 那还可以用选项 <option>--limit
      </option> 限制 <command>svn log</command> 的输出.</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn log -v --limit 3
------------------------------------------------------------------------
r401 | sally | 2013-02-19 23:15:44 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/main.c

Follow-up to r400: Fix typos in help text.
------------------------------------------------------------------------
r400 | bill | 2013-02-19 20:55:08 -0500 (Tue, 19 Feb 2013) | 4 lines
Changed paths:
   M /calc/trunk/src/main.c
   D /calc/trunk/src/real.c

* calc/trunk/src/main.c: Update help text.

* calc/trunk/src/real.c: Remove this file, none of the APIs
  implemented here are used anymore.
------------------------------------------------------------------------
r399 | sally | 2013-02-19 20:05:14 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/button.c
   M /calc/trunk/src/integer.c
   M /calc/trunk/src/main.c
   M /calc/trunk/src/real.c

Undoing erroneous change committed in r392.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 400.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        399.</para>
      -->
      <para>在上面的例子里, 我们假设要找的文件是
        <filename>real.c</filename>, 通过查看父目录的日志, 可以看到
        <filename>real.c</filename> 是在版本号 400 被删除. 因此, <filename>
          real.c</filename> 的最后一个版本就是紧挨着 400 的前一个版本号, 也
        就是说你要从版本号 399 中恢复 <filename>/calc/trunk/real.c</filename>.
      </para>

      <!--
      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>
      -->
      <para>这本来是最难的地方&mdash;调研. 既然已经知道了要复原的是哪个项目,
        接下来你有两个选择.</para>

      <!--
      <para>One option is to use <command>svn merge</command> to apply
        revision 400 <quote>in reverse.</quote> (We already
        discussed how to undo changes in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.)  This
        would have the effect of re-adding <filename>real.c</filename>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <literal>HEAD</literal>.</para>
      -->
      <para>其中一个选择是使用 <command>svn merge</command> <quote>反向</quote>
        应用版本号 400 (我们已经在 <xref
          linkend="svn.branchmerge.basicmerging.undo"/> 介绍了如何撤消修改).
        命令的效果是把 <filename>real.c</filename> 重新添加到工作副本里, 提交
        后, 文件将重新出现在版本号 <literal>HEAD</literal> 中.</para>

      <!--
      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 400 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>main.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 400 and
        then <command>svn revert</command> the local modifications to
        <filename>main.c</filename>, but this technique doesn't
        scale well.  What if 90 files were changed in revision
        400?</para>
      -->
      <para>然而对于我们这个例子而言, 可能并不是最好的办法. 反向应用版本号
        400 不仅会添加 <filename>real.c</filename>, 从版本号 400 的提交日志
        可以看到, 反向应用还会撤消 <filename>main.c</filename> 的某些修改,
        这应该不是用户想要的效果. 当然, 你也可以在逆合并完 r400 后, 再手动地
        对 <filename>main.c</filename> 执行 <command>svn revert</command>.
        但这种解决办法可扩展性不好, 如果有 90 个文件在 r400 中被修改了, 难道
        也要一个个地执行 <command>svn revert</command> 吗?</para>

      <!--
      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather to use the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>
      -->
      <para>第二种选择的目的性更强, 不使用 <command>svn merge</command>, 而是
        用 <command>svn copy</command> 从仓库中复制特定的版本号与路径 <quote>
          坐标</quote> 到工作副本里:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ./real.c
A         real.c

$ svn st
A  +    real.c

# Commit the resurrection.
&hellip;
</screen>
      </informalexample>

      <!--
      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history.</quote>  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 399.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <emphasis>without</emphasis>
        maintaining a historical link to the old file, this technique
        works just as well:</para>
      -->
      <para>状态输出中的加号表示这个项目不仅仅是新增的, 而且还带有历史信息,
        Subversion 知道它是从哪里复制来的. 以后对 <filename>real.c</filename>
        执行 <command>svn log</command> 将会遍历到 r399 之前的历史, 也就是说
        <filename>real.c</filename> 并不是真正的新文件, 它是已删除的原始文件
        的后继, 通常这就是用户想要的效果. 然而, 如果你不想维持文件以前的历史,
        还可以下面的方法恢复文件:</para>

      <informalexample>
        <screen>
$ svn cat ^/calc/trunk/src/real.c@399 &gt; ./real.c

$ svn add real.c
A         real.c

# Commit the resurrection.
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn't
        have to happen in your working copy&mdash;it can happen
        entirely in the repository:</para>
      -->
      <para>虽然我们的例子都是在演示如何恢复被删除的文件, 但同样的技术也可以
        用在恢复目录上. 另外, 恢复被删除的文件不仅可以发生在工作副本中, 还可
        直接发生在仓库中:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ^/calc/trunk/src/real.c \
           -m "Resurrect real.c from revision 399."

Committed revision 402.

$ svn up
Updating '.':
A    real.c
Updated to revision 402.
</screen>
      </informalexample>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.advanced">
      <!--
    <title>Advanced Merging</title>
      -->
    <title>高级合并</title>

      <!--
    <para>Here ends the automated magic.  Sooner or later, once you
      get the hang of branching and merging, you're going to have to
      ask Subversion to merge <emphasis>specific</emphasis> changes
      from one place to another.  To do this, you're going to
      have to start passing more complicated arguments to <command>svn
      merge</command>.  The next section describes the fully expanded
      syntax of the command and discusses a number of common
      scenarios that require it.</para>
      -->
    <para>一旦用户开始频繁地使用分支与合并, 很快就会要求 Subversion 把一个
      <emphasis>特定的</emphasis> 的修改从一个地方合并到另一个地方. 为了完成
      这项工作, 用户要给 <command>svn merge</command> 传递更多的参数, 下一节
      将对命令的语法进行完整地介绍, 同时还将讨论它们的典型应用场景.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.cherrypicking">
      <!--
      <title>Cherrypicking</title>
      -->
      <title>精选</title>

      <para>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>cherrypicking (精选)</secondary>
        </indexterm>
        和术语 <quote>变更集</quote> 一样, 术语 <firstterm>精选</firstterm>
        (<firstterm>cherrypicking</firstterm>) 也经常出现在版本控制系统中.
        精选指的是这样一种操作: 从分支中挑选 <emphasis>一个</emphasis> 特定的
        变更集, 将其复制到其他地方. 精选也可以指这样一种操作: 将一个特定的变更集
        集合 (不一定是连续的) 从一个分支复制到另一个分支上. 这和典型的合并
        场景相反 (典型的合并场景是自动合并下一段版本号范围).</para>
      <!--
        Just as the term <quote>changeset</quote> is often used in
        version control systems, so is the term
        <firstterm>cherrypicking</firstterm>.  This word refers to
        the act of choosing <emphasis>one</emphasis> specific
        changeset from a branch and replicating it to another.
        Cherrypicking may also refer to the act of duplicating a
        particular set of (not necessarily contiguous!) changesets
        from one branch to another.  This is in contrast to more
        typical merging scenarios, where the <quote>next</quote>
        contiguous range of revisions is duplicated
        automatically.</para>
      -->

      <!--
      <para>Why would people want to replicate just a single change?
        It comes up more often than you'd think.  For example, let's
        assume you've created a new feature branch <filename>
        /calc/branches/my-calc-feature-branch</filename> copied from
        <filename>/calc/trunk</filename>:</para>
      -->
      <para>为什么会有人只想复制单独的一个修改? 这种情况要比你想像的更常发生,
        假设你从 <filename>/calc/trunk</filename> 创建了一个特性分支
        <filename>/calc/branches/my-calc-feature-branch</filename>:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/new-calc-feature-branch -v -r403
------------------------------------------------------------------------
r403 | user | 2013-02-20 03:26:12 -0500 (Wed, 20 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/new-calc-feature-branch (from /calc/trunk:402)

Create a new calc branch for Feature 'X'.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>At the water cooler, you get word that Sally made an interesting
        change to <filename>main.c</filename> on the trunk.
        Looking over the history of commits to the trunk, you see that
        in revision 413 she fixed a critical bug that directly
        impacts the feature you're working on.  You might not be ready
        to merge all the trunk changes to your branch just yet, but
        you certainly need that particular bug fix in order to continue
        your work.</para>
      -->
      <para>在饮水机接水时, 你听说 Sally 向主干上的 <filename>main.c</filename>
        提交了一个很重要的修改, 通过查看主干的提交历史, 你发现在版本号 413,
        Sally 修正了一个很严重的错误, 而这个错误也会影响你正在开发的新特性.
        你的分支可能还没有准备好合并主干上的所有修改, 但是为了能让工作继续
        下去, 你确实需要 r413 的修改.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/trunk -r413 -v
------------------------------------------------------------------------
r413 | sally | 2013-02-21 01:57:51 -0500 (Thu, 21 Feb 2013) | 3 lines
Changed paths:
   M /calc/trunk/src/main.c

Fix issue #22 'Passing a null value in the foo argument
of bar() should be a tolerated, but causes a segfault'.
------------------------------------------------------------------------

$ svn diff ^/calc/trunk -c413
Index: src/main.c
===================================================================
--- src/main.c  (revision 412)
+++ src/main.c  (revision 413)
@@ -34,6 +34,7 @@
&hellip;
# Details of the fix
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Just as you used <command>svn diff</command> in the prior
        example to examine revision 413, you can pass the same option
        to <command>svn merge</command>:</para>
      -->
      <para>就像上面例子中的 <command>svn diff</command> 查看 r413 那样,
        你也可以向 <command>svn merge</command> 传递相同的选项:</para>

      <informalexample>
        <screen>
$ cd new-calc-feature-branch

$ svn merge ^/calc/trunk -c413
--- Merging r413 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r413 into '.':
 U   .

$ svn st
 M      .
M       src/main.c
</screen>
      </informalexample>

      <!--
      <para>You can now go through the usual testing procedures before
        committing this change to your branch.  After the commit,
        Subversion updates the <literal>svn:mergeinfo</literal> on your
        branch to reflect that r413 was been merged to the branch.  This
        prevents future automatic sync merges from attempting to merge
        r413 again.  (Merging the same change to the same branch almost
        always results in a conflict!) Notice also the mergeinfo <literal>
        /calc/branches/my-calc-branch:341-379</literal>.  This was
        recorded during the earlier reintegrate merge to <filename>
        /calc/trunk</filename> from the <filename>
        /calc/branches/my-calc-branch</filename> branch which we made in
        r380.  When we created the <filename>my-calc-branch</filename>
        branch in r403, this mergeinfo was carried along with the copy.
        </para>
      -->
        <para>如果测试后没什么问题, 就可以把修改提交到仓库中. 提交后, Subversion
          更新分支属性 <literal>svn:mergeinfo</literal>, 以反映 r413 已经合并到
          分支中, 这可以避免今后自动同步合并时再去合并 r413 (在同一分支内多次
          合并同一修改通常会导致冲突). 还要注意合并信息
          <literal>/calc/branches/my-calc-branch:341-379</literal>, 这条信息
          是早先 <filename>/calc/trunk</filename> 在 r380 再整合合并
          <filename>/calc/branches/my-calc-branch</filename> 时记录的, 当我们
          在 r403 创建分支 <filename>my-calc-feature-branch</filename> 时,
          这条合并信息也被一并复制.</para>

      <informalexample>
        <screen>
$ svn pg svn:mergeinfo -v
Properties on '.':
  svn:mergeinfo
    /calc/branches/my-calc-branch:341-379
    /calc/trunk:413
</screen>
      </informalexample>

      <!--
      <para>Notice too that the <command>mergeinfo</command> doesn't list r413
        as "eligible" to merge, because it's already been merged:</para>
      -->
      <para>从下面 <command>mergeinfo</command> 的输出中可以看到, r413 并没有
        被列为可合并的版本号, 这是因为它已经被合并了:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r404
r405
r406
r407
r409
r410
r411
r412
r414
r415
r416
&hellip;
r455
r456
r457
</screen>
      </informalexample>

      <!--
      <para>The preceding means that when the time finally comes to do an
        automatic sync merge, Subversion breaks the merge into two parts.
        First it merges all eligible merges up to revision 412.  Then it
        merges all eligible revisions from revisions 414 to the <literal>HEAD
        </literal> revision.  Because we already cherrypicked r413, that
        change is skipped:</para>
      -->
      <para>上面的输出表示当分支要自动同步合并主干时, Subversion 将把合并分成
        两步进行, 第一步是合并所有可合并的修改, 直到 r412, 第二步是从 r414 开始
        合并所有可合并的修改, 直到 <literal>HEAD</literal>. 因为我们已经合并了
        r413, 所以它会被跳过:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk
--- Merging r403 through r412 into '.':
U    doc/INSTALL
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
--- Merging r414 through r458 into '.':
G    doc/INSTALL
G    src/main.c
G    src/integer.c
G    Makefile
--- Recording mergeinfo for merge of r403 through r458 into '.':
 U   .
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>backporting (回植)</secondary>
        </indexterm>
        将一个新版本上的修改 <firstterm>回植</firstterm> (<firstterm>
          backporting</firstterm>) 到另一个分支可能是精选修改最常见的需求,
        例如, 当开发团队在维护软件的 <quote>发布分支</quote> 时, 就会经常遇到
        这种情况 (见
        <xref linkend="svn.branchmerge.commonpatterns.release"/>.)</para>
      <!--
        This use case of replicating
        (or <firstterm>backporting</firstterm>) bug fixes from one
        branch to another is perhaps the most popular reason for
        cherrypicking changes; it comes up all the time, for example,
        when a team is maintaining a <quote>release branch</quote> of
        software.  (We discuss this pattern in
        <xref linkend="svn.branchmerge.commonpatterns.release"/>.)</para>
      -->

      <warning>
      <!--
        <para>Did you notice how, in the last example, the merge
          invocation merged two distinct ranges?
          The <command>svn merge</command> command applied
          two independent patches to your working copy to skip over
          changeset 413, which your branch already contained.  There's
          nothing inherently wrong with this, except that it has the
          potential to make conflict resolution trickier.  If the
          first range of changes creates conflicts,
          you <emphasis>must</emphasis> resolve them interactively for
          the merge process to continue and apply the second range of
          changes.  If you postpone a conflict from the first wave of
          changes, the whole merge command will bail out with an error
          message and you must resolve the conflict before running the
          merge a second time to get the remainder of the changes.</para>
      -->
        <para>在上面的例子里, 读者是否注意到了 Subversion 如何合并两个不同的版
          本号范围? <command>svn merge</command> 为了跳过变更集 413 (分支已经包
          含了变更集 413), 向工作副本应用了两个独立的补丁, 这么做除了可能会使
          冲突更难解决之外, 本身并没有什么不对的地方. 如果第一段修改范围产生了
          冲突, 那么只有在冲突解决后才能接着应用第二段修改范围. 如果在出现冲突
          后, 用户选择推迟解决冲突, 那么命令 <command>svn merge</command>
          将会报错退出, 在第二次运行合并命令之前, 用户必须解决冲突.</para>
      </warning>

      <!--
      <para>A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in <xref linkend="svn.ref.svn"/> for details, or ask
        <command>svn help</command>.  For example, <command>svn
        merge</command> requires a working copy path as a target, that is,
        a place where it should apply the generated patch.  If the
        target isn't specified, it assumes you are trying to perform
        one of the following common operations:</para>
      -->
      <para>提醒一句: <command>svn diff</command> 和 <command>svn merge
        </command> 在概念上非常类似, 但在很多情况下它们使用不同的语法, 详情
        见 <xref linkend="svn.ref.svn"/>. 比如说 <command>svn merge</command>
        要求一个工作副本路径作为被合并的操作目标, 如果没有指定, 命令就假设是以
        下两种情况之一:</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>You want to merge directory changes into your current
            working directory.</para>
      -->
          <para>被合并的是当前工作目录.</para>
        </listitem>
        <listitem>
      <!--
          <para>You want to merge the changes in a specific file into
            a file by the same name that exists in your current working
            directory.</para>
      -->
          <para>用户想把特定文件上的修改合并到当前工作目录的同名文件上.</para>
        </listitem>
      </itemizedlist>

      <!--
      <para>If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first
        case and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a
        file by the same name) exists in your current working
        directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>
      -->
      <para>如果用户在合并目录时没有指定目标路径, <command>svn merge</command>
        就认为是第一种情况, 尝试把修改合并到当前工作目录. 如果是合并文件, 并
        且这个文件 (或者说名字相同的文件) 在当前工作目录中存在, <command>svn
          merge</command> 就认为是第二种情况, 尝试把修改合并到具有相同名字的
        本地文件上.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.advancedsyntax">
      <!--
      <title>Merge Syntax: Full Disclosure</title>
      -->
      <title>合并语法详解</title>

      <!--
      <para>You've now seen some examples of the <command>svn
        merge</command> command, and you're about to see several more.
        If you're feeling confused about exactly how merging works,
        you're not alone.  Many users (especially those new to version
        control) are initially perplexed about the proper syntax of
        the command and about how and when the feature should be
        used.  But fear not, this command is actually much simpler
        than you think!  There's a very easy technique for
        understanding exactly how <command>svn merge</command>
        behaves.</para>
      -->
      <para>读者已经见过了 <command>svn merge</command> 的几个例子, 后面还会
        看到几个, 如果你对合并的工作原理感到疑惑, 不用太过自责, 你不是唯一
        一个有这种感觉的人. 很多用户 (特别是版本控制的新手) 一开始都会被命令
        的语法和适用它们的场景搞蒙. 其实这个命令比你想像中的要简单很多, 有一
        个非常简单的办法可以帮助你理解 <command>svn merge</command> 如何工作.
      </para>

      <!--
      <para>The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that some sort of mysterious
        blending of data is going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>
      -->
      <para>困惑主要来自命令的 <emphasis>名字</emphasis>. 术语 <emphasis>合并
        </emphasis> (<emphasis>merge</emphasis>) 在某种程度上表示分支被组合起
        来, 或者说有一些神秘的混合数据正在产生. 事实并非如此, 命令更恰当的名
        字是 <emphasis>svn diff-and-apply</emphasis>, 因为新名字恰当地描述了
        合并过程中所发生的事情: 比较两个仓库目录, 然后把差异应用到工作副本上.
      </para>

      <!--
      <para>If you're using <command>svn merge</command> to do basic
        copying of changes between branches, an automatic merge will
        generally do the right thing.  For example, a command such as the
        following,</para>
      -->
      <para>如果你是用 <command>svn merge</command> 在分支之间复制修改, 那么
        通常情况下自动合并会工作得很好. 例如下面的命令</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/some-branch
</screen>
      </informalexample>

      <!--
      <para>will attempt to duplicate any changes made
        on <filename>some-branch</filename> into your current working
        directory, which is presumably a working copy that shares some
        historical connection to the branch.  The command is smart
        enough to only duplicate changes that your working copy
        doesn't yet have.  If you repeat this command once a week, it
        will only duplicate the <quote>newest</quote> branch changes
        that happened since you last merged.</para>
      -->
      <para>尝试把分支 <filename>some-branch</filename> 上的修改合并到当前
        的工作目录上 (假定当前目录是工作副本或工作副本的一部分, 而且和
        <filename>some-branch</filename> 有历史上的联系), 命令只会合并当前
        目录还没有的修改. 如果用户在一周后再执行相同的命令, 命令就只会复制在
        上一次合并后新出现的修改.</para>

      <!-- TODO -->
      <!--
      <para>If you choose to use the <command>svn merge</command>
        command in all its full glory by giving it specific revision
        ranges to duplicate, the command takes three main
        arguments:</para>
      -->
      <para>如果用户想通过指定被复制的版本号范围, 最大程度地使用
        <command>svn merge</command>, 则命令接受三个参数:</para>

      <orderedlist>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>left side (左侧)</secondary>
        </indexterm>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>right side (右侧)</secondary>
        </indexterm>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>target (目标)</secondary>
        </indexterm>

        <listitem>
      <!--
          <para>An initial repository tree (often called the
            <firstterm>left side</firstterm> of the comparison)</para>
      -->
          <para>一个初始的仓库目录 (通常被叫作比较的 <firstterm>左侧</firstterm>
            (<firstterm>left side</firstterm>))</para>
        </listitem>
        <listitem>
      <!--
          <para>A final repository tree (often called the
            <firstterm>right side</firstterm> of the
            comparison)</para>
      -->
          <para>一个最终的仓库目录 (通常被叫作比较的 <firstterm>右侧</firstterm>
            (<firstterm>right side</firstterm>)</para>
        </listitem>
        <listitem>
      <!--
          <para>A working copy to accept the differences as local
            changes (often called the <firstterm>target</firstterm> of
            the merge)</para>
      -->
          <para>接受差异的工作副本 (通常被叫作合并的 <firstterm>目标</firstterm>
            (<firstterm>target</firstterm>))</para>
        </listitem>
      </orderedlist>

      <!--
      <para>Once these three arguments are specified, then the two trees
        are compared and the differences applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>
      -->
    <para>这三个参数一旦指定, Subversion 就比较两个仓库目录, 将比较产生的差异
      作为本地修改应用到目标工作副本. 命令执行结束后, 得到的结果和用户手工编
      辑文件或执行各种命令 (例如 <command>svn add</command> 和 <command>svn
        delete</command>) 得到的效果是等价的. 如果合并的结果没什么问题, 用户
      就可以把它们提交到仓库中, 如果用户不喜欢合并的结果, 只要用 <command>
        svn revert</command> 就可以撤消所有的修改.</para>

      <!--
      <para>The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>
      -->
      <para><command>svn merge</command> 允许用户灵活地指定这三个参数, 下面是
        一些例子:</para>

      <informalexample>
        <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>
      </informalexample>

      <!--
      <para>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax is used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>2-URL</secondary>
        </indexterm> This type of merge is referred to (for obvious
        reasons) as a <quote>2-URL</quote> merge. The last syntax shows
        how the working copy argument is optional; if omitted, it
        defaults to the current directory.</para>
      -->
        <para>第一种语法显式地指定了三个参数; 如果被比较的是同一 URL 的两个不同
        版本号, 可以像第二种语法那样简写,
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>2-URL (二路 URL)</secondary>
        </indexterm>
        这种类型的合并称为 <quote>二路 URL
        </quote> 合并 (原因显而易见); 第三种语法说明工作副本参数是可选的,
        如果省略工作副本参数, 默认是当前工作目录.</para>

      <!--
      <para>While the first example shows the <quote>full</quote>
        syntax of <command>svn merge</command>, use it
        very carefully;  it can result in merges which do not record
        any <literal>svn:mergeinfo</literal> metadata at all.  The
        next section talks a bit more about this.</para>
      -->
      <para>虽然第一个例子展示了 <command>svn merge</command> 的 <quote>完整
        </quote> 语法, 但使用时要小心, 它会导致 Subversion 不去更新元数据
        <literal>svn:mergeinfo</literal>, 下一节将对此进行更详细的介绍.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.nomergedata">
      <!--
      <title>Merges Without Mergeinfo</title>
      -->
      <title>没有合并信息的合并</title>

      <!--
      <para>Subversion tries to generate merge metadata whenever it
        can, to make future invocations of <command>svn
        merge</command> smarter.  There are still situations, however,
        where <literal>svn:mergeinfo</literal> data is not created or
        changed.  Remember to be a bit wary of these scenarios:</para>
      -->
      <para>如果可能的话, Subversion 都会去尝试生成合并的元数据, 从而帮助后面
        调用的 <command>svn merge</command> 更加智能, 但在某些情况下, <literal>
          svn:mergeinfo</literal> 既不会被创建, 也不会被更新, 对这些情况要稍
        微注意一点:</para>

      <variablelist>
        <varlistentry>
      <!--
          <term>Merging unrelated sources</term>
      -->
          <term>合并不相关的源</term>
          <listitem>
      <!--
            <para>If you ask <command>svn merge</command> to compare
              two URLs that aren't related to each other, a patch is
              still generated and applied to your working copy, but
              no merging metadata is created.  There's no common
              history between the two sources, and
              future <quote>smart</quote> merges depend on that common
              history.</para>
      -->
            <para>如果用户要求 Subversion 去比较两个完全不相关的 URL, 那么
              Subversion 仍然会生成补丁并应用到工作副本上, 但不会创建或更新
              合并元数据. 因为两个源之间没有公共的历史, 而将来的 <quote>智能
            </quote> 合并需要这些公共历史.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
      <!--
          <term>Merging from foreign repositories</term>
      -->
          <term>合并外部仓库</term>
          <listitem>
      <!--
            <para>While it's possible to run a command such
              as <userinput>svn merge -r 100:200
              <replaceable>http://svn.foreignproject.com/repos/trunk</replaceable></userinput>,
              the resultant patch also lacks any historical merge
              metadata.  At the time of this writing, Subversion has no
              way of representing different repository URLs within
              the <literal>svn:mergeinfo</literal> property.</para>
      -->
            <para>虽然执行这样一条命令&mdash;<userinput>svn merge -r 100:200
                <replaceable>http://svn.foreignproject.com/repos/trunk
              </replaceable></userinput>&mdash;是可以的, 但生成的补丁依然缺少
              合并元数据. 在撰写本书时, Subversion 还不支持在属性 <literal>
                svn:mergeinfo</literal> 内表示多个不同仓库的 URL.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
      <!--
          <term>Using <option>- -ignore-ancestry</option></term>
      -->
          <term>使用<option>--ignore-ancestry</option></term>
          <listitem>
      <!--
            <para>If this option is passed to <command>svn
              merge</command>, it causes the merging logic to
              mindlessly generate differences the same way
              that <command>svn diff</command> does, ignoring any
              historical relationships.  We discuss this later in this
              chapter in
              <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
      -->
            <para>如果向命令 <command>svn merge</command> 传递选项 <option>
                --ignore-ancestry</option>, 这将导致 <command>svn merge
              </command> 按照和 <command>svn diff</command> 相同的方式生成
              不含有历史的差异, 更多的内容将在
              <xref linkend="svn.branchmerge.advanced.ancestry"/> 介绍.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
      <!--
          <term>Applying reverse merges from a target's natural history</term>
      -->
          <term>反向合并目标的修改历史</term>
          <listitem>
      <!--
            <para>Earlier in this chapter
              (<xref linkend="svn.branchmerge.basicmerging.undo"/>) we
              discussed how to use <command>svn merge</command> to
              apply a <quote>reverse patch</quote> as a way of rolling
              back changes.  If this technique is used to undo a
              change to an object's personal history (e.g., commit r5
              to the trunk, then immediately roll back r5
              using <userinput>svn merge . -c -5</userinput>), this
              sort of merge doesn't affect the recorded
              mergeinfo.<footnote><para>Interestingly, after rolling
              back a revision like this, we wouldn't be able to
              reapply the revision using <userinput>svn merge . -c
              5</userinput>, since the mergeinfo would already list r5
              as being applied.  We would have to use
              the <option>- -ignore-ancestry</option> option to make
              the merge command ignore the existing
              mergeinfo!</para></footnote></para>
      -->
        <para>在本章的 <xref linkend="svn.branchmerge.basicmerging.undo"/> 我们
          介绍了如何使用 <command>svn merge</command> 应用一个 <quote>逆补丁
          </quote>, 从而回滚已提交的修改. 如果使用这项技术撤消某个对象的已
          提交的修改 (例如在主干上提交了 r5, 之后又马上用 <userinput>svn
            merge . -c -5</userinput> 撤消 r5 的修改), 这种类型的合并也不会更新
          合并信息.<footnote><para>有趣的是, 像这样撤消一个版本号的修改后,
              我们就不能再用 <userinput>svn merge . -c 5</userinput> 重新合并
              r5, 因为合并信息记录的是 r5 已经合并过了. 为了忽略合并信息,
              必须加上选项 <option>--ignore-ancestry</option></para></footnote>
        </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <!-- TODO: We might need to introduce a glossary of merge
                 tracking terms into this chapter.  Here we use
                 "mergeinfo" to help defined "natural history", but
                 we've not really defined "mergeinfo" either.  -->

      <sidebar id="svn.branchmerge.nomergedata.impicit.mergeinfo">
      <!--
        <title>Natural History and Implicit Mergeinfo</title>
      -->
        <title>自然历史和隐式合并信息</title>

        <para>
          <indexterm>
            <primary>mergeinfo (合并信息)</primary>
            <secondary>implicit (隐式的)</secondary>
          </indexterm>
          <indexterm>
            <primary>natural history (自动历史)</primary>
            <see>mergeinfo (合并信息), implicit (隐式的)</see>
          </indexterm>
          在讨论
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>
          时我们说过, 如果在一个路径上设置了属性 <literal>svn:mergeinfo
          </literal>, 我们就说这个路径含有 <quote>显式的</quote> 合并信息, 与
          些相对, 一个路径上可以有 <quote>隐式的</quote> 合并信息. 隐式的合并
          信息 (或 <firstterm>自然历史</firstterm> (<firstterm>natural
            history</firstterm>)) 仅仅是把路径自己的历史 (见
          <xref linkend="svn.tour.history" />) 解释成合并信息. 虽然隐式的合
          并信息在很大程度上只是一个实现上的细节, 但在理解合并跟踪上很有帮助.
        </para>
      <!--
          As we mentioned earlier when discussing
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>,
          a path that has the
          <literal>svn:mergeinfo</literal> property set on it is said to
          have <quote>explicit</quote> mergeinfo.  Yes, this implies a
          path can have <quote>implicit</quote> mergeinfo, too!  Implicit
          mergeinfo, or <firstterm>natural history</firstterm>, is
          simply a path's own history (see
          <xref linkend="svn.tour.history" />) interpreted as mergeinfo.
          While implicit mergeinfo is largely
          an implementation detail, it can be a useful abstraction for
          understanding merge tracking behavior.</para>
      -->

      <!--
        <para>Let's say you created <filename>^/trunk</filename> in
          revision 100 and then later, in revision 201,
          created <filename>^/branches/feature-branch</filename> as
          a copy of <filename>^/trunk@200</filename>.  The natural
          history of <filename>^/branches/feature-branch</filename>
          contains all the repository paths and revision ranges
          through which the history of the new branch has ever
          passed:</para>
      -->
        <para>如果说用户在 r100 创建了 <filename>^/trunk</filename>, 在 r201
          基于 <filename>^/trunk@200</filename> 创建了 <filename>
            ^/branches/feature-branch</filename>, 则
          <filename>^/branches/feature-branch</filename> 的自然历史包含了该
          分支历史曾经经历过的所有仓库路径与版本号:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201
</literallayout>
        </informalexample>

      <!--
        <para>With each new revision added to the repository, the
          natural history&mdash;and thus, implicit mergeinfo&mdash;of
          the branch continues to expand to include those revisions
          until the day the branch is deleted.  Here's what the
          implicit mergeinfo of our branch would look like when
          the <literal>HEAD</literal> revision of the repository had
          grown to 234:</para>
      -->
        <para>随着仓库中新的版本号的出现, 分支的自然历史&mdash;即隐式的合
          并信息&mdash;也在不断地包含这些版本号, 直到分支被删除的那天. 当
          仓库的 <literal>HEAD</literal> 增长到 234 时, 下面的例子展示了
          分支的隐式合并信息:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201-234
</literallayout>
        </informalexample>

      <!--
        <para>Implicit mergeinfo does not actually show up in the
          <literal>svn:mergeinfo</literal> property, but Subversion
          acts as if it does.  This is why if you check out
          <filename>^/branches/feature-branch</filename> and then
          run <userinput>svn merge ^/trunk -c 58</userinput> in the
          resulting working copy, nothing happens.  Subversion knows
          that the changes committed to <filename>^/trunk</filename>
          in revision 58 are already present in the target's natural
          history, so there's no need to try to merge them again.
          After all, avoiding repeated merges of
          changes <emphasis>is</emphasis> the primary goal of
          Subversion's merge tracking feature!</para>
      -->
        <para>隐式的合并信息不会显示在属性 <literal>svn:mergeinfo</literal> 中,
          但 Subversion 会表现得好像它确实把隐式的合并信息放到了 <literal>
            svn:mergeinfo</literal> 里, 所以说当用户检出 <filename>
            ^/branches/feature-branch</filename>, 然后执行 <userinput>svn merge
            ^/trunk -c 58</userinput>, 却什么也不会发生. 这是因为 Subversion
          知道提交到 <filename>^/trunk</filename> 的 r58 已经存在于目标的自然
          历史里, 也就没必要再合并一次, 毕竟避免重复的合并
          <emphasis>是</emphasis> Subversion 合并跟踪特性的主要目标!</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.mergeconflicts">
      <!--
      <title>More on Merge Conflicts</title>
      -->
      <title>关于合并冲突的更多内容</title>

      <!--
      <para>Just like the <command>svn update</command> command,
        <command>svn merge</command> applies changes to your working
        copy.  And therefore it's also capable of creating
        conflicts.  The conflicts produced by <command>svn
          merge</command>, however, are sometimes different, and this
        section explains those differences.</para>
      -->
      <para>和 <command>svn update</command> 类似, <command>svn merge</command>
        也是向工作副本应用修改, 因此难免会产生冲突. 然而与 <command>svn
          update</command> 相比, 由 <command>svn merge</command> 产生的冲突有
        点不同, 本节就是介绍这些不同之处.</para>

      <!--
      <para>To begin with, assume that your working copy has no
        local edits.  When you <command>svn update</command> to a
        particular revision, the changes sent by the server
        always apply <quote>cleanly</quote> to your working copy.
        The server produces the delta by comparing two trees: a
        virtual snapshot of your working copy, and the revision tree
        you're interested in.  Because the left hand side of the
        comparison is exactly equal to what you already have, the
        delta is guaranteed to correctly convert your working copy
        into the right hand tree.</para>
      -->
      <para>在开始前假设用户的工作副本不含有本地修改, 当用户执行 <command>svn
          update</command>, 把工作副本更新到某个特定的版本号时, 从服务器接收
        的修改总能 <quote>干净地</quote> 应用到工作副本上. 服务器生成差异的
        方式是比较两棵目录树: 一个是工作副本的虚拟快照, 另一个是用户指定的版本
        号所对应的目录树. 因为比较的左侧等价于工作副本, 所以生成的差异总能保证
        正确地把工作副本更新到右侧.</para>

      <!--
      <para>But <command>svn merge</command> has no such guarantees
        and can be much more chaotic: the advanced user can ask the
        server to compare <emphasis>any</emphasis> two trees at all,
        even ones that are unrelated to the working copy!  This means
        there's large potential for human error.  Users will sometimes
        compare the wrong two trees, creating a delta that doesn't
        apply cleanly. The <command>svn merge</command> subcommand does
        its best to apply as much of the delta as possible, but some
        parts may be impossible. A common sign that you merged the wrong
        delta is unexpected tree conflicts:</para>
      -->
      <para>但是 <command>svn merge</command> 没有这种保证, 而且冲突可能会更
        混乱: 高级用户可以要求服务器比较 <emphasis>任意</emphasis> 两个目录树,
        即使目录树和工作副本并不相关! 这就意味着有很大的可能产生人为错误.
        用户有时候会比较两个错误的目录树, 导致生成的差异不能被干净地应用到工
        作副本上. 命令 <command>svn merge</command> 会尽可能多地把修改应用到
        工作副本, 但某些修改可能根本就无法应用成功. 合并错误的常见现象是出现了
        意想不到的目标冲突:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk -r104:115
--- Merging r105 through r115 into '.':
   C doc
   C src/button.c
   C src/integer.c
   C src/real.c
   C src/main.c
--- Recording mergeinfo for merge of r105 through r115 into '.':
 U   .
Summary of conflicts:
  Tree conflicts: 5

$ svn st
 M      .
!     C doc
      >   local dir missing, incoming dir edit upon merge
!     C src/button.c
      >   local file missing, incoming file edit upon merge
!     C src/integer.c
      >   local file missing, incoming file edit upon merge
!     C src/main.c
      >   local file missing, incoming file edit upon merge
!     C src/real.c
      >   local file missing, incoming file edit upon merge
Summary of conflicts:
  Tree conflicts: 5
</screen>
      </informalexample>

      <!--
      <para>In the previous example, it might be the case that
        <filename>doc</filename> and the four <filename>*.c</filename>
        files all exist in both snapshots of the
        branch being compared.  The resultant delta wants to change
        the contents of the corresponding paths in your working copy,
        but those paths don't exist in the working copy.  Whatever the
        case, the preponderance of tree conflicts most likely means that
        the user compared the wrong two trees or that you are merging to
        the wrong working copy target; both are classic signs of user
        error.  When this happens, it's easy to recursively revert all
        the changes created by the merge
        (<userinput>svn revert . - -recursive</userinput>), delete any
        unversioned files or directories left behind after the
        revert, and rerun <command>svn merge</command> with the
        correct arguments.</para>
      -->
      <para>在上面的例子里, 从现象来看, 被比较的目录 <filename>doc</filename>
        和 4 个 <filename>*.c</filename> 文件在分支的两个快照中都存在, 生成的
        差异想去修改工作副本中对应路径上的文件内容. 但这些路径在工作副本中都
        不存在. 无论真实的情况是什么, 产生目录冲突最可能的原因是用户比较了两
        个错误的目录树, 或者是差异被应用到了错误的工作副本&mdash;这两种都是
        用户最常犯的错误. 当错误发生时, 最简单的办法就是递归地撤消由合并产生
        的所有本地修改 (<userinput>svn revert . --recursive</userinput>),
        删除可能残留的未被版本控制的文件和目录, 然后再用正确的参数执行
        <command>svn merge</command>.</para>

      <!--
      <para>Also keep in mind that a merge into a working copy with no
        local edits can still produce text conflicts.</para>
      -->
      <para>还要注意, 即使在向不含有本地修改的工作副本合并, 仍有可能产生
        内容冲突.</para>

      <informalexample>
        <screen>
$ svn st

$ svn merge ^/paint/trunk -r289:291
--- Merging r290 through r291 into '.':
C    Makefile
--- Recording mergeinfo for merge of r290 through r291 into '.':
 U   .
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'Makefile'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: p

$ svn st
 M      .
C       Makefile
?       Makefile.merge-left.r289
?       Makefile.merge-right.r291
?       Makefile.working
Summary of conflicts:
  Text conflicts: 1
</screen>
      </informalexample>

      <!--
      <para>How can a conflict possibly happen?  Again, because the user
        can request <command>svn merge</command> to define and apply any
        old delta to the working copy, that delta may contain textual
        changes that don't cleanly apply to a working file, even if
        the file has no local modifications.</para>
      -->
      <para>为什么会发生这种冲突呢? 因为用户可以要求 <command>svn merge
        </command> 定义并应用任意一个老差异到工作副本中, 而这个差异所包含的
        修改可能不能被干净地应用到文件中, 即使这个文件不含有本地修改.</para>


      <!--
      <para>Another small difference between <command>svn
        update</command> and <command>svn merge</command> is the names
        of the full-text files created when a conflict happens.  In
        <xref linkend="svn.tour.cycle.resolve"/>, we saw that an
        update produces files named
        <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename>, and
        <filename>filename.rNEWREV</filename>.  When <command>svn
        merge</command> produces a conflict, though, it creates three
        files named <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename>, and
        <filename>filename.merge-right.rNEWREV</filename>.  In this case,
        the terms <quote>merge-left</quote> and <quote>merge-right</quote>
        are describing which side of the double-tree comparison the file
        came from, <quote>rOLDREV</quote> describes the revision of the
        left side, and <quote>rNEWREV</quote> the revision of the right
        side. In any case, these differing names help you distinguish
        between conflicts that happened as a result of an  update and
        ones that happened as a result of a merge.</para>
      -->
      <para><command>svn update</command> 和 <command>svn merge</command> 的另
        一个不同点是当冲突发生时, 新创建的文件的名字. 在
        <xref linkend="svn.tour.cycle.resolve"/> 我们已经看到更新操作可能会
        创建形如 <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename> 和 <filename>filename.rNEWREV
        </filename>. 的新文件. 当 <command>svn merge</command> 发生冲突时, 它会
        创建 3 个形如 <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename> 和
        <filename>filename.merge-right.rNEWREV</filename> 的新文件. 模式中的
        <quote>merge-left</quote> 和 <quote>merge-right</quote> 分别指出了文件
        来自比较的左侧和右侧, <quote>rOLDREV</quote> 描述了左侧的版本号, 而
        <quote>rNEWREV</quote> 描述了右侧的版本号. 无论是 <command>svn update
        </command>, 还是 <command>svn merge</command>, 这些文件名都可以帮助
        用户分辨冲突的来源.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.blockchanges">
      <!--
      <title>Blocking Changes</title>
      -->
      <title>拦截修改</title>

      <!--
      <para>Sometimes there's a particular changeset that you don't
        want automatically merged.  For example, perhaps your
        team's policy is to do new development work on
        <filename>/trunk</filename>, but is more conservative about
        backporting changes to a stable branch you use for releasing
        to the public.  On one extreme, you can manually cherrypick
        single changesets from the trunk to the branch&mdash;just the
        changes that are stable enough to pass muster.  Maybe things
        aren't quite that strict, though; perhaps most of the time
        you just let <command>svn merge</command>
        automatically merge most changes from trunk to branch.  In
        this case, you want a way to mask a few specific changes
        out, that is, prevent them from ever being automatically
        merged.</para>
      -->
      <para>有时候, 用户可能不想让某个特定的变更集被自动合并, 比如说你所在的
        团队的开发策略是在 <filename>/trunk</filename> 完成新的开发工作, 但
        是, 在向稳定分支回植修改时非常保守, 因为稳定分支是面向发布的分支.
        在比较极端的情况下, 你可以手动地从主干精选修改&mdash;只精选那些足够
        稳定的修改&mdash;再合并到分支上. 不过实际做起来可能没这么严格, 大多数时
        候你只想让 <command>svn merge</command> 把主干的大多数修改自动合并
        到分支上, 这时候就需要一种方法能够屏蔽掉一些特定的变更集, 阻止它们
        被自动合并.</para>

      <!--
      <para>To block a changeset you must make Subversion believe that the
        change has <emphasis>already</emphasis> been merged.  To do this,
        invoke the merge subcommand with the <option>- -record-only</option>
        option.  The option makes Subversion record mergeinfo as if it had
        actually performed the merge, but no difference is actually
        applied:</para>
      -->
      <para>为了拦截一个变更集, 必须让 Subversion 认为变更集 <emphasis>已经
        </emphasis> 被合并了. 为了实现这点, 在执行 <command>svn merge</command>
        时添加选项 <option>--record-only</option>, 该选项使得 Subversion 更新
        合并信息, 就好像它真得执行了合并, 但实际上文件内容并没有被修改.</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn merge ^/calc/trunk -r386:388 --record-only
--- Recording mergeinfo for merge of r387 through r388 into '.':
 U   .

# Only the mergeinfo is changed
$ svn st
 M      .

$ svn pg svn:mergeinfo -vR
Properties on '.':
  svn:mergeinfo
    /calc/trunk:341-378,387-388

$ svn commit -m "Block r387-388 from being merged to my-calc-branch."
Sending        .

Committed revision 461.
</screen>
      </informalexample>

      <!--
      <para>Since Subversion 1.7, <option>- -record-only</option>
        merges are transitive.  This means that, in addition to recording
        mergeinfo describing the blocked revision(s), any
        <literal>svn:mergeinfo</literal> property differences in the
        merge source are also applied.  For example, let's say we want to
        block the 'paint-python-wrapper' feature from ever being merged from
        <filename>^/paint/trunk</filename> to the
        <filename>^/paint/branches/paint-1.0.x</filename> branch.  We know
        the work on this feature was done on its own branch, which was
        reintegrated to <filename>/paint/trunk</filename> in revision
        465:</para>
      -->
      <para>从 Subversion 1.7 开始, 带有选项 <option>--record-only</option>
        的合并是传递的, 这就意味着除了在被合并的目标上记录被拦截的合并信息外,
        源的 <literal>svn:mergeinfo</literal> 属性上的任意修改都会被应用到目
        标的 <literal>svn:mergeinfo</literal> 属性上. 举例来说, 我们想要拦截
        <filename>^/paint/trunk</filename> 上与特性 'paint-python-wrapper' 
        有关的修改被合并到分支 <filename>^/paint/branches/paint-1.0.x</filename>
        上. 我们已经知道特性 'paint-python-wrapper' 已经在自己的分支上开发完成,
        并且在 r465 合并到了 <filename>/paint/trunk</filename> 上:</para>
      
      <informalexample>
        <screen>
$ svn log -v -r465 ^/paint/trunk
------------------------------------------------------------------------
r465 | joe | 2013-02-25 14:05:12 -0500 (Mon, 25 Feb 2013) | 1 line
Changed paths:
   M /paint/trunk
   A /paint/trunk/python (from /paint/branches/paint-python-wrapper/python:464)

Reintegrate Paint Python wrapper.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>Because revision 465 was a reintegrate merge we know
        that mergeinfo was recorded describing the merge:</para>
      -->
      <para>因为 r465 是一个再整合合并, 所以我们知道描述合并的信息被
        记录了下来:</para>

      <informalexample>
        <screen>
$ svn diff ^/paint/trunk --depth empty -c465
Index: .
===================================================================
--- .   (revision 464)
+++ .   (revision 465)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
</screen>
      </informalexample>

      <!--
      <para>Now simply blocking merges of revision 465 from
        <filename>/paint/trunk</filename> isn't foolproof since someone could
        merge r462:464 directly from
        <filename>/paint/branches/paint-python-wrapper</filename>.
        Fortunately the transitive nature
        of <option>- -record-only</option> merges prevents this; the
        <option>- -record-only</option> merge
        applies the <literal>svn:mergeinfo</literal> diff from
        revision 465, thus blocking merges of that change directly from
        <filename>/paint/trunk</filename> <emphasis>and</emphasis> indirectly
        from <filename>/paint/branches/paint-python-wrapper</filename>:
        </para>
      -->
        <para>如果只是简单地拦截 <filename>/paint/trunk</filename> 的 r465 并
          不能确保万无一失, 因为其他人可能会直接从
          <filename>/paint/branches/paint-python-wrapper</filename> 合并
          r462:464, 幸运的是选项 <option>--record-only</option> 的传递性质
          可以防止这种情况发生. 选项 <option>--record-only</option> 把 r465
          生成的 <literal>svn:mergeinfo</literal> 差异应用到工作副本上, 从而
          拦截住来自 <filename>/paint/trunk</filename>直接合并和 <filename>
            /paint/branches/paint-python-wrapper</filename> 的间接合并.</para>

      <informalexample>
        <screen>
$ cd paint/branches/paint-1.0.x

$ svn merge ^/paint/trunk --record-only -c465
--- Merging r465 into '.':
 U   .
--- Recording mergeinfo for merge of r465 into '.':
 G   .

$ svn diff --depth empty
Index: .
===================================================================
--- .   (revision 462)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
   Merged /paint/trunk:r465

$ svn ci -m "Block the Python wrappers from the first release of paint."
Sending        .

Committed revision 466.
</screen>
      </informalexample>

      <!--
      <para>Now any subsequent attempts to merge the feature to <filename>
        /paint/trunk</filename> are inoperative:</para>
      -->
    <para>现在, 无论怎么尝试从 <filename>/paint/trunk</filename> 合并特性都
      不会产生任何实际的效果.</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465
--- Recording mergeinfo for merge of r465 into '.':
 U   .

$ svn st # No change!

$ svn merge ^/paint/branches/paint-python-wrapper -r462:464
--- Recording mergeinfo for merge of r463 through r464 into '.':
 U   .

$ svn st  # No change!

$
</screen>
      </informalexample>

      <!--
      <para>If at a later time you realize that you actually <emphasis>do
        </emphasis> need the blocked feature merged to <filename>/paint/trunk
        </filename> you have a couple of choices.  You can reverse merge r466,
        (the revision you blocked the feature), as we discussed in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.  Once you commit
        that change you can repeat the merge of r465 from <filename>
        /paint/trunk</filename>.  Alternatively, you can simply repeat the
        merge of r465 from <filename>/paint/trunk</filename> using the
        <option>- -ignore-ancestry</option> option, which will cause the merge
        to disregard any mergeinfo and simply apply the requested diff, see
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
      -->
      <para>如果以后用户意识到自己实际上 <emphasis>需要</emphasis> 被拦截的
        修改, 那么有两种选择. 一种是用户可以撤消 r466, 撤消的方法见
        <xref linkend="svn.branchmerge.basicmerging.undo"/>, 把撤消 r466 的修
        改提交后, 用户就可以再次从 <filename>/paint/trunk</filename> 合并 r465.
        另一种是在合并 r465 时带上选项 <option>--ignore-ancestry</option>,
        这将导致命令 <command>svn merge</command> 忽略合并信息, 直接应用所
        请求的差异, 见 <xref linkend="svn.branchmerge.advanced.ancestry"/>.
      </para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465 --ignore-ancestry
--- Merging r465 into '.':
A    python
A    python/paint.py
 G   .
</screen>
      </informalexample>

      <!--
      <para>Blocking changes with <option>- -record-only</option>
        works, but it's also a little bit
        dangerous.  The main problem is that we're not clearly
        differentiating between the ideas of <quote>I already have
        this change</quote> and <quote>I don't have this change, but
        don't currently want it.</quote> We're effectively lying to
        the system, making it think that the change was previously
        merged.  This puts the responsibility on you&mdash;the
        user&mdash;to remember that the change wasn't actually merged,
        it just wasn't wanted.  There's no way to ask Subversion for a
        list of <quote>blocked changelists.</quote> If you want to
        track them (so that you can unblock them someday) you'll need
        to record them in a text file somewhere, or perhaps in an
        invented property.</para>
      -->
      <para>使用 <option>--record-only</option> 有一点危险, 因为我们经常无
        法分辨什么时候是 <quote>我已经包含了这个修改</quote>, 什么时候是
        <quote>我没有这个修改, 但目前还不想要它</quote>. 使用 <option>
          --record-only</option> 实际上是在向 Subversion 撒谎, 让它以为修改
        已经被合并了. 记住修改是否被真正地合并是用户的责任, Subversion 无法
        回答 <quote>有哪些修改被拦截了</quote> 这样的问题. 如果用户想跟踪
        被拦截的修改 (以后可能会放开对它们的拦截), 就要自己找地方记录, 例如
        记在某个文本文件上, 或自定义的属性里.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.logblame">
      <!--
      <title>Merge-Sensitive Logs and Annotations</title>
      -->
      <title>对合并敏感的日志与注释</title>

      <!--
      <para>One of the main features of any version control system is
        to keep track of who changed what, and when they did it.
        The <command>svn log</command> and <command>svn
        blame</command> subcommands are just the tools for this: when
        invoked on individual files, they show not only the history of
        changesets that affected the file, but also exactly which user
        wrote which line of code, and when she did it.</para>
      -->
      <para>任意一个版本控制系统都需要支持的一项特性是能够查看是谁, 在什么时
        候, 修改了什么地方, Subversion 完成这些功能的命令是 <command>svn
          log</command> 和 <command>svn blame</command>. 在单独的文件上执行
        这两个命令时, 它们不仅会显示影响文件的变更集历史, 还可以精确地指出
        每一行是哪个用户在什么时候修改的.</para>

      <!--
      <para>When changes start getting replicated between branches,
        however, things start to get complicated.  For example, if you
        were to ask <command>svn log</command> about the history of
        your feature branch, it would show exactly every revision that ever
        affected the branch:</para>
      -->
      <para>然而, 当修改在分支间复制时, 事情开始变得复杂起来. 比如说用
        <command>svn log</command> 查询特性分支的历史, 命令将会显示所有影响
        过分支的版本号:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn log -q
------------------------------------------------------------------------
r461 | user | 2013-02-25 05:57:48 -0500 (Mon, 25 Feb 2013)
------------------------------------------------------------------------
r379 | user | 2013-02-18 10:56:35 -0500 (Mon, 18 Feb 2013)
------------------------------------------------------------------------
r378 | user | 2013-02-18 09:48:28 -0500 (Mon, 18 Feb 2013)
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
r7 | bill | 2013-01-17 16:49:36 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
r3 | bill | 2013-01-17 09:07:04 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>But is this really an accurate picture of all the changes
        that happened on the branch?  What's left out here is
        the fact that revisions 352, 362, 372 and 379 were actually the
        results of merging changes from the trunk.  If you look at one
        of these logs in detail, the multiple trunk changesets that
        comprised the branch change are nowhere to be seen:</para>
      -->
      <para>但是这些日志完整地刻画了分支上的所有修改吗? 输出中没有明确指出的是
        r352, r362, r372 和 r379 其实是从主干合并修改的结果. 如果你详细地查看
        这几个日志将会发现我们没办法看到构成分支修改的多个主干变更集:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v
------------------------------------------------------------------------
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>We happen to know that this merge to the branch was
        nothing but a merge of trunk changes.  How can we see those
        trunk changes as well?  The answer is to use the
        <option>- -use-merge-history</option> (<option>-g</option>)
        option.  This option expands those <quote>child</quote>
        changes that were part of the merge.</para>
      -->
      <para>我们知道被合并的修改来自主干, 那么如何同时查看主干上的这些修改
        历史? 答案是使用选项 <option>--use-merge-history</option> (<option>-g
      </option>), 展开被合并的 <quote>子</quote> 修改.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v -g
------------------------------------------------------------------------
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
------------------------------------------------------------------------
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/real.c
Merged via: r352

Trunk work on calc project.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r345 | sally | 2013-02-15 16:51:17 -0500 (Fri, 15 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/Makefile
   M /calc/trunk/src/integer.c
Merged via: r352

Trunk work on calc project.
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c
Merged via: r352

Refactor the bazzle functions.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>By making the log operation use merge history, we see not
        just the revision we queried (r352), but also the other revisions
        that came along on the ride with it&mdash;Sally's work on trunk.
        This is a much more complete picture of history!</para>
      -->
      <para>为 <command>svn log</command> 增加选项 <option>--use-merge-history
        </option> (<option>-g</option>), 我们不仅可以看到 r352, 还可以看到通过
        r352 从主干合并到分支的提交, 这些提交是 Sally 在主干上的工作. 这才是历
        史的更完整的刻画!</para>

      <!--
      <para>The <command>svn blame</command> command also takes the
        <option>- -use-merge-history</option> (<option>-g</option>)
        option.  If this option is neglected, somebody looking at
        a line-by-line annotation of <filename>src/button.c</filename> may
        get the mistaken impression that you were responsible for a
        particular change:</para>
      -->
      <para>命令 <command>svn blame</command> 也支持选项 <option>
          --use-merge-history</option> (<option>-g</option>), 如果在执行命令时
        没有带上该选项, 在查看 <filename>src/button.c</filename> 每一行的修改注释
        时, 用户可能会对修改的负责人产生错误的印象:</para>

      <informalexample>
        <screen>
$ svn blame src/button.c
&hellip;
   352    user    retval = inverse_func(button, path);
   352    user    return retval;
   352    user    }
&hellip;
</screen>
      </informalexample>

      <!--
      <para>And while it's true that you did actually commit those
        three lines in revision 352, two of them were actually written
        by Sally back in revision 348 and were brought into your branch
        via a sync merge:</para>
      -->
      <para>用户 <literal>user</literal> 的确在 r352 提交了这 3 行修改, 但其中
        2 行实际上来自 Sally 在 r348 的修改, 它们通过同步合并被合并到了分支中:
      </para>

      <informalexample>
        <screen>
$ svn blame button.c -g
&hellip;
G    348    sally   retval = inverse_func(button, path);
G    348    sally   return retval;
     352    user    }
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Now we know who to <emphasis>really</emphasis> blame for
        those two lines of code!</para>
      -->
      <para>现在我们知道了是谁应该 <emphasis>真正地</emphasis> 为这 2 行修改
        负责!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.ancestry">
      <!--
      <title>Noticing or Ignoring Ancestry</title>
      -->
      <title>关注或忽略祖先</title>

      <para>
        <indexterm>
          <primary>ancestry (祖先)</primary>
        </indexterm>
        如果与 Subversion 开发人员交谈, 你可能会经常听到一个术语: <firstterm>
          祖先</firstterm> (<firstterm>ancestry</firstterm>). 这个术语描述了
        仓库中两个对象间的一种关系: 如果它们之间是相关的, 那么其中一个对象就
        是另一个对象的祖先.</para>
      <!--
        When conversing with a Subversion developer, you
        might very likely hear reference to the term
        <firstterm>ancestry</firstterm>.  This word is used to
        describe the relationship between two objects in a
        repository: if they're related to each other, one
        object is said to be an ancestor of the other.</para>
      -->

      <!--
      <para>For example, suppose you commit revision 100, which
        includes a change to a file <filename>foo.c</filename>.
        Then <filename>foo.c@99</filename> is an
        <quote>ancestor</quote> of <filename>foo.c@100</filename>.
        On the other hand, suppose you commit the deletion of
        <filename>foo.c</filename> in revision 101, and then add a
        new file by the same name in revision 102.  In this case,
        <filename>foo.c@99</filename> and
        <filename>foo.c@102</filename> may appear to be related
        (they have the same path), but in fact are completely
        different objects in the repository.  They share no history
        or <quote>ancestry.</quote></para>
      -->
      <para>比如说你在 r100 提交了文件 <filename>foo.c</filename> 的修改,
        那么 <filename>foo.c@99</filename> 就是 <filename>foo.c@100</filename>
        的一个 <quote>祖先</quote>. 另一方面, 如果你在 r101 删除了文件
        <filename>foo.c</filename>, 然后在 r102 又提交了一个具有相同名字的文件,
        虽然从名字上看, <filename>foo.c@99</filename> 和 <filename>foo.c@102
        </filename> 是相关的, 但实际上它们是两个完全不相关的对象, 只是碰巧名
        字相同罢了, 它们之间不共享历史或 <quote>祖先</quote>.</para>

      <!--
      <para>The reason for bringing this up is to point out an
        important difference between <command>svn diff</command> and
        <command>svn merge</command>.  The former command ignores
        ancestry, while the latter command is quite sensitive to it.
        For example, if you asked <command>svn diff</command> to
        compare revisions 99 and 102 of <filename>foo.c</filename>,
        you would see line-based diffs; the <command>diff</command>
        command is blindly comparing two paths.  But if you asked
        <command>svn merge</command> to compare the same two objects,
        it would notice that they're unrelated and first attempt to
        delete the old file, then add the new file;  the output would
        indicate a deletion followed by an add:</para>
      -->
      <para>介绍 <quote>祖先</quote> 是为了说明 <command>svn diff</command>
        和 <command>svn merge</command> 之间的一个重要区别. <command>svn diff
        </command> 会忽略祖先, 而 <command>svn merge</command> 对祖先非常敏感.
        举例来说, 如果用户要求 <command>svn diff</command> 去比较 <filename>
          foo.c</filename> 在 r99 和 r102 时的版本, 命令将会盲目地比较这两个
        版本, 并输出以行为单位的差异. 但是如果用户要求 <command>svn merge
        </command> 去比较相同的两个对象, 它将会注意到两个对象之间是不相关的,
        于是先删除旧文件, 再添加新文件, 从命令的输出信息可以看得很清楚:</para>

      <informalexample>
        <screen>
D    foo.c
A    foo.c
</screen>
      </informalexample>

      <!--
      <para>Most merges involve comparing trees that are ancestrally
        related to one another; therefore, <command>svn
        merge</command> defaults to this behavior.  Occasionally,
        however, you may want the <command>merge</command> command to
        compare two unrelated trees.  For example, you may have
        imported two source-code trees representing different vendor
        releases of a software project (see
        <xref linkend="svn.advanced.vendorbr"/>).  If you ask
        <command>svn merge</command> to compare the two trees, you'd
        see the entire first tree being deleted, followed by an add
        of the entire second tree!  In these situations, you'll want
        <command>svn merge</command> to do a path-based comparison
        only, ignoring any relations between files and directories.
        Add the <option>- -ignore-ancestry</option> option to your
        <command>merge</command> command, and it will behave just
        like <command>svn diff</command>.  (And conversely, the
        <option>- -notice-ancestry</option> option will cause
        <command>svn diff</command> to behave like the
        <command>svn merge</command> command.)</para>
      -->
      <para>大多数合并操作都会涉及比较两个在历史上相关的目录树, 因此 <command>
          svn merge</command> 就把这种情况当成默认条件. 然而, 在少数情况下用户
        可能希望 <command>svn merge</command> 去比较两个不相关的目录树. 比如说
        用户导入了两份源代码, 分别表示软件的两个不同的供应商发布版 (见
        <xref linkend="svn.advanced.vendorbr"/>), 如果用户要求 <command>
          svn merge</command> 去比较这两个目录树, 将会看到第一个目录树被整
        体删除, 然后再整体添加第二个目录树. 对于这种情况, 用户其实是希望
        <command>svn merge</command> 只做基于路径的比较, 完全忽略文件和目录
        之间的任何关系. 添加选项 <option>--ignore-ancestry</option> 后,
        <command>svn merge</command> 的行为将变得和 <command>svn diff</command>
        一样. (反之, 添加 <command>--notice-ancestry</command> 后, 命令
        <command>svn diff</command> 的行为将变得和 <command>svn merge</command>
        一样)</para>

      <tip>
        <para>
        <indexterm>
          <primary>merge tracking (合并跟踪)</primary>
          <secondary>disabling (禁止)</secondary>
        </indexterm>
        属性 <option>--ignore-ancestry</option> 还会禁止
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>, 这就
        意味着当 <command>svn merge</command> 确定应该合并哪些版本号时,
        它就不会考虑, 也不会更新 <literal>svn:mergeinfo</literal>.</para>
      <!--
        The <option>- -ignore-ancestry</option> option also disables
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This means that <literal>svn:mergeinfo</literal> is not considered
        when <command>svn merge</command> is determining what revisions
        to merge, nor is <literal>svn:mergeinfo</literal> recorded to
        describe the merge.</para>
      -->
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.moves">
      <!--
      <title>Merges and Moves</title>
      -->
      <title>合并与移动</title>

      <!--
      <para>A common desire is to refactor source code, especially
        in Java-based software projects.  Files and directories are
        shuffled around and renamed, often causing great disruption
        to everyone working on the project.  Sounds like a perfect
        case to use a branch, doesn't it?  Just create a branch,
        shuffle things around, and then merge the branch back to the
        trunk, right?</para>
      -->
      <para>开发人员的一个常见需求是对代码进行重构, 特别是基于 Java 的软件
        项目. 文件和目录被移来移去, 经常会给项目的开发人员造成困扰. 听起来是
        不是觉得这种场景很适合使用分支? 创建一个分支, 尽管在分支里随意折腾,
        最后再把分支合并到主干上就行了, 对吗?</para>

      <!--
      <para>Alas, this scenario doesn't work so well right now and
        is considered one of Subversion's current weak spots.  The
        problem is that Subversion's <command>svn merge</command>
        command isn't as robust as it should be, particularly when
        dealing with copy and move operations.</para>
      -->
      <para>可惜, 现实情况还没有这么理想, 这是 Subversion 目前还有待完善的地方.
        其中的问题是 Subversion 的命令 <command>svn merge</command> 并没有人们
        期望中的那样健壮, 尤其是在处理复制和移动操作时.</para>

      <!--
      <para>When you use <command>svn copy</command> to duplicate a
        file, the repository remembers where the new file came from,
        but it fails to transmit that information to the client which
        is running <command>svn update</command> or <command>svn
        merge</command>.  Instead of telling the client, <quote>Copy
        that file you already have to this new location,</quote> it
        sends down an entirely new file.  This can lead to
        problems, particularly tree conflicts in the case of renames,
        which involve not only the new copy, but a deletion of the old
        path&mdash;a lesser-known fact about Subversion is that
        it lacks <quote>true renames</quote>&mdash;the <command>svn
        move</command> command is nothing more than an aggregation
        of <command>svn copy</command> and <command>svn
        delete</command>.</para>
      -->
    <para>使用 <command>svn copy</command> 复制一个文件时, 仓库记住了新文件的
      来源, 但这项信息并不会传递给正在执行 <command>svn update</command> 或
      <command>svn merge</command> 的客户端. 仓库不会告诉客户端 <quote>把
        工作副本中已有的这个文件复制到另一个位置</quote>, 相反, 它会向客户端下发
      一个全新的
      文件. 这可能会导致问题, 尤其是和重命名有关的目录冲突. 重命名不仅涉及到
      一个新的副本, 还涉及到删除一个旧路径&mdash;一个不为人知的事实是
      Subversion 没有 <quote>直正的重命名</quote>&mdash;<command>svn move
        </command> 只不过是 <command>svn copy</command> 和 <command>svn delete
    </command> 的组合而已.</para>

      <!--
      <para>For example, suppose that you want to make some changes on
        your private branch <filename>/calc/branch/my-calc-branch
        </filename>.  First you perform an automatic sync merge with
        <filename>/calc/trunk</filename> and commit that in r470:</para>
      -->
      <para>比如说用户想对自己的私有分支 <filename>/calc/branch/my-calc-branch
        </filename> 做一些修改, 首先用户和 <filename>/calc/trunk</filename>
        做了一个自动同步合并, 并在 r470 提交了合并:</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn merge ^/calc/trunk
--- Merging differences between repository URLs into '.':
U    doc/INSTALL
A    FAQ
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
 U   .
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .

$ svn ci -m "Sync all changes from ^/calc/trunk through r469."
Sending        .
Sending        Makefile
Sending        README
Sending        FAQ
Sending        doc/INSTALL
Sending        src/main.c
Sending        src/button.c
Sending        src/integer.c
Transmitting file data ....
Committed revision 470.
</screen>
      </informalexample>

      <!--
      <para>Then you rename <filename>integer.c</filename> to <filename>
        whole.c</filename> in r471 and then make some edits to the same
        file in r473.  Effectively you've created a new file in your branch
        (that is a copy of the original file plus some edits) and deleted
        the original file.  Meanwhile, back on <filename>/calc/trunk
        </filename>, Sally has committed some improvements of her own to
        <filename>integer.c</filename> in r472:</para>
      -->
      <para>然后用户在 r471 把 <filename>integer.c</filename> 重命名为
        <filename>whole.c</filename>, 又在 r473 修改了 <filename>whole.c
        </filename>. 从效果上来看等价于创建了一个新文件 (原文件的副本再加上
        一些修改), 再删除原文件. 同时在 <filename>/calc/trunk</filename>,
        Sally 在 r472 提交了 <filename>integer.c</filename> 的修改:</para>

      <informalexample>
        <screen>
$ svn log -v -r472 ^/calc/trunk
------------------------------------------------------------------------
r472 | sally | 2013-02-26 07:05:18 -0500 (Tue, 26 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Trunk work on integer.c.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <!--
      <para>Now you decide to merge your branch back to the trunk.
        How will Subversion combine the rename and edits you made
        with Sally's edits?</para>
      -->
      <para>现在用户打算把自己的分支上的工作合并到主干上, 你觉得 Subversion
        会如何组合你和 Sally 的修改?</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
   C src/integer.c
 U   src/real.c
A    src/whole.c
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .
Summary of conflicts:
  Tree conflicts: 1

$ svn st
 M      .
      C src/integer.c
      >   local file edit, incoming file delete upon merge
 M      src/real.c
A  +    src/whole.c
Summary of conflicts:
  Tree conflicts: 1
</screen>
      </informalexample>

      <!--
      <para>The answer is that Subversion <emphasis>won't</emphasis>
        combine those changes, but rather raises a tree conflict<footnote>
        <para>If Sally hadn't made her change in r472, then Subversion would
        notice that <filename>integer.c</filename> in the
        target working copy is identical to <filename>integer.c</filename>
        in the left-side of the merge and would allow your rename to
        succeed without a tree conflict:</para>
        <informalexample>
          <screen>
$ svn merge ^/calc/branches/my-calc-branch
- - - Merging differences between repository URLs into '.':
 U   src/real.c
A    src/whole.c
D    src/integer.c
- - - Recording mergeinfo for merge between repository URLs into '.':
 U   .
</screen>
      </informalexample></footnote>because it needs your help
        to figure out what part of your changes and what part of Sally's
        changes should ultimately end up in <filename>whole.c</filename>
        or even if the rename should take place at all!</para>
      -->
      <para>实际情况是 Subversion <emphasis>不会</emphasis> 把这些修改组合起来,
        而是产生一个目录冲突<footnote><para>如果 Sally 没有提交 r472 的修改,
            那么 Subversion 将会注意到目标工作副本的 <filename>integer.c
            </filename> 和合并左端的 <filename>whole.c</filename> 其实是同一
            个文件, 此时合并将会成功, 不会有冲突产生:</para>
        <informalexample>
          <screen>
$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
 U   src/real.c
A    src/whole.c
D    src/integer.c
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .
</screen>
      </informalexample></footnote> 因为 Subversion 需要用户帮它算出你和
      Sally 的哪些修改应该留在 <filename>whole.c</filename> 上, 或者是重命
      名操作是否应该保留.</para>

      <!--
      <para>You will need to resolve this tree conflict before committing
        the merge and this may require some manual intervention on your
        part, see <xref linkend="svn.tour.treeconflicts"/>.  The moral of
        this story is that until Subversion improves, be careful about
        merging copies and renames from one branch to another and when you
        do, be prepared for some manual resolution.</para>
      -->
      <para>用户解决完目录冲突后才能提交, 这可能需要人工介入, 见
        <xref linkend="svn.tour.treeconflicts"/>. 我们举这个例子的目的是提醒
        用户, 在 Subversion 改良之前, 要小心对待从一个分支合并复制和重命名操
        作到另一个分支, 如果确实这样做了, 要做好解决目录冲突的准备.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.pre1.5clients">
      <!--
      <title>Preventing Naïve Clients from Committing Merges</title>
      -->
      <title>禁止不支持合并跟踪的客户端</title>

      <!--
      <para>If you've just upgraded your server to Subversion 1.5 or
        later, there's a risk that pre-1.5 Subversion
        clients can cause problems with
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This is because pre-1.5 clients don't support this feature;
        when one of these older clients performs <command>svn
        merge</command>, it doesn't modify the value of
        the <literal>svn:mergeinfo</literal> property at all.  So the
        subsequent commit, despite being the result of a merge,
        doesn't tell the repository about the duplicated
        changes&mdash;that information is lost.  Later on,
        when <quote>merge-aware</quote> clients attempt automatic
        merging, they're likely to run into all sorts of conflicts
        resulting from repeated merges.</para>
      -->
      <para>如果用户只是把服务器端升级到 Subversion 1.5 及以后的版本, 那么 1.5
        版之前的客户端在
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/> 方面会产生
        问题, 这是因为 1.5 版之前的客户端不支持这项特性. 当旧版客户端执行
        <command>svn merge</command> 时, 命令不会去更新属性
        <literal>svn:mergeinfo</literal>, 因此, 随后的提交虽然是合并的结果, 但
        关于被复制的修改的信息不会告诉给服务器&mdash;这些信息就此丢失. 以后,
        如果新版客户端执行自动合并, 很可能会因为合并重复的修改而产生大量冲突.
      </para>

      <!--
      <para>If you and your team are relying on the merge-tracking
        features of Subversion, you may want to configure your
        repository to prevent older clients from committing changes.
        The easy way to do this is by inspecting
        the <quote>capabilities</quote> parameter in
        the start-commit hook script.  If the
        client reports itself as having <literal>mergeinfo</literal>
        capabilities, the hook script can allow the commit to start.
        If the client doesn't report that capability, have the hook
        deny the commit.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> gives an
        example of such a hook script:</para>
      -->
      <para>如果你和你的团队非常依赖 Subversion 的合并跟踪特性, 你可能需要对
        仓库进行配置, 使得仓库禁止旧客户端提交修改. 最简单的配置方法是在
        start-commit 钩子脚本里检查参数 <quote>capabilities
        </quote>, 如果客户端反映它支持 <literal>mergeinfo</literal> 功能,
        钩子脚本就允许客户端提交, 否则的话就禁止该客户端提交修改,
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> 给出了
        钩子脚本 <literal>start-commit</literal> 的一个示例:</para>

      <example id="svn.branchmerge.advanced.hook-ex1">
      <!--
        <title>Merge-tracking gatekeeper start-commit hook script</title>
      -->
        <title>合并跟踪的看门狗&mdash;钩子脚本 start-commit</title>

        <programlisting>
#!/usr/bin/env python
import sys

# The start-commit hook is invoked immediately after a Subversion txn is
# created and populated with initial revprops in the process of doing a
# commit. Subversion runs this hook by invoking a program (script, 
# executable, binary, etc.) named 'start-commit' (for which this file
# is a template) with the following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] USER         (the authenticated user attempting to commit)
#   [3] CAPABILITIES (a colon-separated list of capabilities reported
#                     by the client; see note below)
#   [4] TXN-NAME     (the name of the commit txn just created)

capabilities = sys.argv[3].split(':')
if "mergeinfo" not in capabilities:
  sys.stderr.write("Commits from merge-tracking-unaware clients are "
                   "not permitted.  Please upgrade to Subversion 1.5 "
                   "or newer.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>

      <!--
      <para>For more information about hook scripts, see
        <xref linkend="svn.reposadmin.hooks" />.</para>
      -->
      <para>关于钩子脚本的更多信息, 见 <xref linkend="svn.reposadmin.hooks" />.
      </para>

    </sect2>
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.finalword">
      <!--
      <title>The Final Word on Merge Tracking</title>
      -->
      <title>关于合并跟踪的最后一点内容</title>

      <!--
      <para>The bottom line is that Subversion's merge-tracking
        feature has an complex internal implementation, and
        the <literal>svn:mergeinfo</literal> property is the only
        window the user has into the machinery.</para>
      -->
      <para>最后要说的是 Subversion 的合并跟踪特性有一个复杂的内部实现, 而
        属性 <literal>svn:mergeinfo</literal> 是用户了解合并跟踪内部机制的
        唯一窗口.</para>

      <!--
      <para>How and when mergeinfo is recorded by a merge can sometimes
        be difficult to understand.  Furthermore, the management of
        mergeinfo metadata has a whole set of taxonomies and behaviors
        around it, such as <quote>explicit</quote> versus <quote>implicit
        </quote> mergeinfo, <quote>operative</quote>
        versus <quote>inoperative</quote> revisions, specific
        mechanisms of mergeinfo <quote>elision,</quote> and
        even <quote>inheritance</quote> from parent to child
        directories.</para>
      -->
      <para>记录合并信息的时机和方式有时候会很难理解, 另外, 合并信息元数据的
        管理也分成了很多种类型, 例如 <quote>显式</quote> 与 <quote>隐式</quote>
        的合并信息, <quote>可实施</quote> 与 <quote>不可实施</quote> 的版本号,
        <quote>省略</quote> 合并信息的特定机制, 以及从父目录到子目录的 <quote>
          继承</quote>.</para>

      <!--
      <para>We've chosen to only briefly cover, if at all, these detailed
        topics for a couple of reasons.  First, the level of detail is
        overwhelming for a typical user.  Second, and more
        importantly, the typical user <emphasis>doesn't</emphasis> need
        to understand these concepts; typically they remain in the
        background as implementation details.  All that said, if you
        enjoy this sort of thing, you can get a fantastic overview in a
        paper posted at CollabNet's website: <ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>
      -->
    <para>我们决定只对这些主题进行简单的介绍, 原因有以下几点. 首先对于一个普
      通用户来说, 细节过于复杂; 第二, 普通用户 <emphasis>不需要</emphasis>
      完全理解这些概念, 实现上的细节对他们而言是透明的. 如果读者有兴趣, 可以
      阅读 CollabNet 的一篇文章: <ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>

      <!--
      <para>For now, if you want to steer clear of the complexities of
        merge tracking, we recommend that you follow these simple best
        practices:</para>
      -->
      <para>如果读者只想尽量避开合并跟踪的复杂性, 我们有以下建议:</para>

      <itemizedlist>
        <listitem>
      <!--
          <para>For short-term feature branches, follow the simple
            procedure described throughout
            <xref linkend="svn.branchmerge.basicmerging"/>.</para>
      -->
          <para>如果是短期的特性分支, 遵循
            <xref linkend="svn.branchmerge.basicmerging"/> 描述的步骤.</para>
        </listitem>
        <listitem>
      <!--
          <para>Avoid subtree merges and subtree mergeinfo. Perform
            merges only on the root of your branches, not on
            subdirectories or files (see <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>)
            .</para>
      -->
          <para>避免子目录合并与子目录合并信息, 只在分支的根目录执行合并,
            而不是在分支的子目录或文件上执行合并 (见 <xref
              linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>).
          </para>
        </listitem>
        <listitem>
      <!--
          <para>Don't ever edit the <literal>svn:mergeinfo</literal>
            property directly; use <command>svn
            merge</command> with the <option>- -record-only</option> option
            to effect a desired change to the metadata (as demonstrated in
            <xref linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
      -->
          <para>不要直接修改属性 <literal>svn:mergeinfo</literal>, 而是用
            带有选项 <option>--record-only</option> 的命令 <command>svn merge
            </command> 向属性施加期望的修改, 见
            <xref linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
        </listitem>
        <listitem>
      <!--
          <para>Your merge target should be a working copy which
            represents the root of a <emphasis>complete</emphasis> tree
            representing a <emphasis>single</emphasis> location in the
            repository at a single point in time:
      -->
            <para>被合并的目标应该是一个工作副本, 代表了一个 <emphasis>完整的
              </emphasis> 目录的根, 这个目录则代表了某一时刻, 仓库的一个单一
              位置:
            <itemizedlist>
              <listitem>
      <!--
                <para>Update before you merge!  Don't use the <option>
                - -allow-mixed-revisions</option> option to merge into
                mixed-revision working copies.</para>
      -->
              <para>在合并前更新! 不要使用选项 <option>--allow-mixed-revisions
              </option> 去合并含有混合版本号的工作副本.</para>
              </listitem>
              <listitem>
      <!--
                <para>Don't merge to targets with <quote>switched</quote>
                subdirectories (as described next in
                <xref linkend="svn.branchmerge.switchwc"/>).</para>
      -->
              <para>不要合并带有 <quote>已切换的</quote> 子目录的目标 (在
                <xref linkend="svn.branchmerge.switchwc"/> 介绍).</para>
              </listitem>
              <listitem>
      <!--
                <para>Avoid merges to targets with sparse directories.
                  Likewise, don't merge to depths other than
                  <option>- -depth=infinity</option></para>
      -->
                <para>避免合并含有稀疏目录的目标, 类似地, 也不要合并深度不是
                  <option>--depth=infinity</option> 的目标.</para>
              </listitem>
              <listitem>
      <!--
                <para>Be sure you have read access to all of the merge
                  source and read/write access to all of the merge
                  target.</para>
      -->
                <para>确保你对合并的源具有读权限, 对被合并的目标具有读写权限.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>

      <!--
      <para>Of course sometimes you may need to violate some of these
        best practices.  Don't worry if you need to, just be sure you
        understand the ramifications of doing so.</para>
      -->
      <para>当然, 有时候你并不能完全按照上面所说的要求去做, 此时也不用担心, 只
        要你知道这样做的后果就行.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
      <!--
    <title>Traversing Branches</title>
      -->
    <title>遍历分支</title>

      <!--
    <para>The <command>svn switch</command> command transforms an
      existing working copy to reflect a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut.  In one of our earlier examples,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>
      -->
    <para>命令 <command>svn switch</command> 切换一个已有的工作副本, 使其映射
      到另一个不同的分支. 虽然在使用分支时, 该命令并不是必须的, 但它提供了很
      方便的快捷键. 在一个我们讲过的例子里, 当用户创建完私有分支后, 检出了该
      分支的工作副本. 现在用户多了一种选择, 用命令 <command>svn switch</command>
      把 <filename>/calc/trunk</filename> 的工作副本映射到新创建的分支:</para>

    <informalexample>
      <screen>
$ cd calc
$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk
Relative URL: ^/calc/trunk
$ svn switch ^/calc/branches/my-calc-branch
U    integer.c
U    button.c
U    Makefile
Updated to revision 341.
$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
Relative URL: ^/calc/branches/my-calc-branch
$
</screen>
    </informalexample>

      <!--
    <para><quote>Switching</quote> a working copy that has no local
      modifications to a different branch results in the working copy
      looking just as it would if you'd done a fresh checkout of the
      directory.  It's usually more efficient to
      use this command, because often branches differ by only a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>
      -->
    <para><quote>切换</quote> 一个不含有本地修改的工作副本到另一个分支, 最终
      得到的工作副本就像是从分支上检出的一样. 使用 <command>svn switch</command>
      切换分支通常会更有效率, 因为分支之间的差异通常很小, 服务器只需要发送一
      小部分数据, 就可以让工作副本映射到一个新的分支.</para>

      <!--
    <para>The <command>svn switch</command> command also takes a
      <option>- -revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the
      <literal>HEAD</literal> of the branch.</para>
      -->
    <para><command>svn switch</command> 支持选项 <option>--revision</option>
      (<option>-r</option>), 因此用户还可以把工作副本切换到分支的其他版本, 并
      非只能是 <literal>HEAD</literal>.</para>

      <!--
    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, and contain multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>
      -->
    <para>当然, 绝大多数项目都要比例子里的 <filename>calc</filename> 复杂得多,
      而且包含非常多的子目录, Subversion 用户在使用分支时经常遵循一些固定的
      步骤:</para>

    <orderedlist>
      <listitem>
      <!--
        <para>Copy the project's entire <quote>trunk</quote> to a new
          branch directory.</para>
      -->
        <para>把项目的整个 <quote>主干</quote> 复制到一个新的分支目录.</para>
      </listitem>
      <listitem>
      <!--
        <para>Switch only <emphasis>part</emphasis> of the trunk
          working copy to mirror the branch.</para>
      -->
        <para>只把主干工作副本的 <quote>一部分</quote> 进行切换, 以映射到另一
          个分支.</para>
      </listitem>
    </orderedlist>

      <!--
    <para>In other words, if a user knows that the branch work needs
      to happen on only a specific subdirectory, she uses
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, the user can continue to
      receive normal <quote>trunk</quote> updates to most of her
      working copy, but the switched portions will remain immune
      (unless someone commits a change to her branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote>&mdash;not only can working copies contain a
      mixture of working revisions, but they can also contain a
      mixture of repository locations as well.</para>
      -->
    <para>换句话说, 如果用户知道分支的工作只需要在某个特定的子目录内完成, 他
      就可以用 <command>svn switch</command>, 只把这个子目录切换到分支上
      (用户甚至可以只切换一个文件!). 通过这种方式, 用户可以继续接收正常的
      <quote>主干</quote> 更新到大部分的工作副本, 但不会更新已切换的部分 (除
      非有人向分支提交了修改). 这个特性给 <quote>混合的工作副本</quote>
      添加了新的一个维度&mdash;工作副本不仅可以包含混合的版本号, 甚至可以包含
      混合的仓库位置.</para>

    <tip>
      <!--
      <para>Typically switched subdirectories share common ancestry with
        the location which is switched <quote>away</quote> from.  However
        <command>svn switch</command> can switch a subdirectory to mirror
        a repository location which it shares no common ancestry with.
        To do this you need to use the
        <option>- -ignore-ancestry</option> option.
    </para>
      -->
    <para>典型情况下, 已切换的子目录和 <quote>被切换走的</quote> 目录共享相同
      的祖先, 但 <command>svn switch</command> 也可以把子目录切换到一个不与
      原目录共享祖先的仓库位置, 方法是加上选项 <option>--ignore-ancestry
    </option>.</para>
    </tip>

      <!--
    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes are still
      applied as a single, atomic change to the repository.</para>
      -->
    <para>即使工作副本内包含了大量的已切换的子目录, 这些子目录来自仓库中不同
      位置, 那么工作副本仍然可以正常工作. 更新工作副本时, 各个子目录也会收到
      正确的修改; 提交时, 本地修改仍然作为一个单一的原子修改, 被提交到仓库中.
    </para>

      <!--
    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that feature is planned for the
      future.<footnote><para>You <emphasis>can</emphasis>, however,
      use <command>svn relocate</command> if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See <xref linkend="svn.ref.svn.c.relocate"/> in
      <xref linkend="svn.ref.svn"/> for more information and an
      example.</para></footnote></para>
      -->
    <para>注意, 虽然 Subversion 允许工作副本映射不同的仓库位置, 但这些位置必须
      在 <emphasis>同一个</emphasis> 仓库中. Subversion 还不支持跨仓库的交互,
      但以后可能会添加这一特性.<footnote><para>然而, 如果服务器的 URL 发生了
          改变, 而用户不想丢掉已有的工作副本, 那就可以用 <command>svn relocate
          </command>, 更多的信息和例子, 见 <xref linkend="svn.ref.svn"/>
          的 <xref linkend="svn.ref.svn.c.relocate"/></para></footnote></para>

    <tip>
      <!--
      <para>Administrators who need to change the URL of a repository
        which is accessed via HTTP are encouraged to add to
        their <filename>httpd.conf</filename> configuration file a
        permanent redirect from the old URL location to the new one
        (via the <literal>RedirectPermanent</literal> directive).
        Subversion clients will generally display the new repository
        URL in error messages generated when the user attempts to use
        working copies which still reflect the old URL location.  Since
        Subversion 1.7 clients will go a step further,
        automatically relocating the working copy to the new
        URL.</para>
      -->
      <para>如果管理员需要修改仓库的 URL, 而仓库是通过 HTTP 进行访问, 那么强烈
        建议管理员在配置文件 <filename>httpd.conf</filename> 添加一个永久的
        重定向 (通过配置项 <literal>RedirectPermanent</literal>), 将旧的 URL
        重定向至新的 URL, 这样的话, 当用户仍然使用旧的 URL 访问仓库时,
        Subversion 客户端就会在错误信息中显示仓库的新 URL. 从 Subversion 1.7
        开始, 客户端可以自动地把工作副本重定向至新的 URL.</para>
    </tip>

    <sidebar>
      <!--
      <title>Switches and Updates</title>
      -->
      <title>切换与更新</title>

      <!--
      <para>Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> looks the
        same?  The switch command is actually a superset of the update
        command.</para>
      -->
      <para>不知道读者有没有注意到 <command>svn switch</command> 和 <command>
          svn update</command> 的输出看起来好像是一样的? <command>svn switch
      </command> 实际上是 <command>svn update</command> 的超集.</para>

      <!--
      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        latter command always compares two identical repository
        paths.</para>
      -->
      <para>执行 <command>svn update</command> 是在要求仓库比较两个目录树,
        仓库比较后, 向客户端发送差异. <command>svn switch</command> 和
        <command>svn update</command> 的唯一差别是后者永远是在比较同一个
        仓库路径.</para>

      <!--
      <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch directory in the
        <literal>HEAD</literal> revision.</para>
      -->
      <para>也就是说如果有一个 <filename>/calc/trunk</filename> 的工作副本,
        <command>svn update</command> 总是自动地比较 <filename>/calc/trunk
          </filename> 的工作副本与 <literal>HEAD</literal> 的 <filename>
          /calc/trunk</filename>. 如果你把工作副本切换到另一个分支,
        <command>svn switch</command> 就把 <filename>/calc/trunk</filename>
        的工作副本与 <emphasis>另一个</emphasis> 处于版本号 <literal>HEAD
      </literal> 的分支目录进行比较.</para>

      <!--
      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
      -->
      <para>换句话说, 工作副本用 <command>svn update</command> 在时间上移动,
        用 <command>svn switch</command> 在时间 <emphasis>和</emphasis> 空间
        上移动.</para>
    </sidebar>

      <!--
    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.</para>
      -->
    <para>因为 <command>svn switch</command> 本质上是
      <command>svn update</command> 的一个变种, 所以它有着和
      <command>svn update</command> 相同的行为: 从服务器接收更新时, 工作副本
      的本地修改将被保留.</para>

    <tip>
      <!--
      <para>Have you ever found yourself making some complex edits (in
        your <filename>/trunk</filename> working copy) and suddenly
        realized, <quote>Hey, these changes ought to be in their own
        branch?</quote> There is a great two step technique to do
        this:</para>
      -->
      <para>读者是否遇到过这种情形: 在 <filename>/trunk</filename> 的工作副本
        中做了一些复杂的修改, 结果却发现这些修改应该有一个自己的分支, 这时候
        用户可以这样做:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \
           -m "Create branch 'newbranch'."
Committed revision 353.
$ svn switch ^/calc/branches/newbranch
At revision 353.
</screen>
      </informalexample>

      <!--
      <para>The <command>svn switch</command> command, like
        <command>svn update</command>, preserves your local edits.  At
        this point, your working copy is now a reflection of the newly
        created branch, and your next <command>svn commit</command>
        invocation will send your changes there.</para>
      -->
      <para>和 <command>svn update</command> 一样, <command>svn switch</command>
        保留了本地修改. 现在你的工作副本已经映射到了新创建的分支, 如果后面执行
        了 <command>svn commit</command>, 修改将会被提交上新创建的分支中.
      </para>
    </tip>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
      <!--
    <title>Tags</title>
      -->
    <title>标签</title>

    <para>
      <indexterm>
        <primary>tags (标签)</primary>
      </indexterm>
      另一个常见的版本控制概念是标签. 标签是项目的一个 <quote>快照</quote>,
      它在 Subversion 中到处都是, 因为每一个版本号都对应着提交后, 文件系统的
      一个快照.</para>
      <!--
      Another common version control concept is a tag.  A tag is
      just a <quote>snapshot</quote> of a project in time.  In
      Subversion, this idea already seems to be everywhere.  Each
      repository revision is exactly that&mdash;a snapshot of the
      filesystem after each commit.</para>
      -->

      <!--
    <para>However, people often want to give more human-friendly names
      to tags, such as <literal>release-1.0</literal>.  And they want
      to make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release 1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>
      -->
    <para>然而, 用户经常想给标签取一个更人性化的名字, 例如 <literal>release-1.0
      </literal>, 而且用户只想对文件系统的某个子目录做快照, 毕竟人们更容易记住
      项目的发布版 1.0 是版本号为 4822 的特定子目录.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <!--
      <title>Creating a Simple Tag</title>
      -->
      <title>创建简单的标签</title>

      <!--
      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, make a copy of it:</para>
      -->
      <para>创建标签的命令是 <command>svn copy</command>. 如果用户想为
        处于 <literal>HEAD</literal> 的 <filename>/calc/trunk</filename>
        创建一个快照, 就执行:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
           -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 902.
</screen>
      </informalexample>

      <!--
      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If
        it doesn't, you can create it using <command>svn
        mkdir</command>.)  After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the <filename>/trunk</filename> directory
        looked in the <literal>HEAD</literal> revision at the time you
        made the copy.  Of course, you might want to be more precise
        about exactly which revision you copy, in case somebody else
        may have committed changes to the project when you weren't
        looking.  So if you know that revision 901 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 901</option> to
        the <command>svn copy</command> command.</para>
      -->
      <para>这个例子假设目录 <filename>/calc/tags</filename> 已经存在 (如果不
        存在, 就先用 <command>svn mkdir</command> 创建它). 复制完成后, 新目录
        <filename>release-1.0</filename> 就成为了
        <filename>/calc/trunk</filename> 在复制那一刻的永久快照. 当然, 用户也
        可以指定被复制的版本号, 避免其他在用户没有觉察的时候, 向仓库提交了新
        的修改. 如果说用户已经知道版本号为 901 的
        <filename>/calc/trunk</filename> 正是自己想要的快照, 就给命令
        <command>svn copy</command> 添加选项 <option>-r 901</option>.</para>

      <!--
      <para>But wait a moment: isn't this tag creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>
      -->
      <para>请等一下, 这和创建分支的步骤不是一样的吗? 事实上的确如此. 对于
        Subversion 而言, 标签和分支没有区别, 它们都是通过命令 <command>
          svn copy</command> 创建的目录. 之所以把复制出的目录叫作 <quote>标签
        </quote> 的唯一原因是 <emphasis>用户</emphasis> 已经决定把该目录看成
        标签&mdash;只要没有人往标签提交修改, 它就永远保持创建时的样子. 如果用户
        在创建标签后, 往标签提交了新的修改, 那么从用户的角度来看, 它就变成了
        一个分支.</para>

      <!--
      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy.  (That is, make sure
        they know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags area (see
        <xref linkend="svn.serverconfig"/>).  The paranoid approach,
        however, isn't usually necessary.  If a user accidentally
        commits a change to a tag directory, you can simply undo the
        change as discussed in the previous section.  This is version
        control, after all!</para>
      -->
      <para>如果读者是仓库的管理员, 那么你有 2 种标签管理方法. 第 1 种是
        <quote>放任不管</quote>: 作为一种项目管理策略, 一开始便规定好标签
        的存放位置, 确保所有用户都知道如何对待他们复制的目录 (也就是确保他们不
        会向标签提交修改). 第 2 种更具有强制性: 使用和 Subversion 配合的
        访问控制脚本, 禁止任何人在标签区提交修改, 除了创建新的标签 (见
        <xref linkend="svn.serverconfig"/>). 第 2 种方法通常是没有必要的, 因
        为如果用户不小心向标签提交了修改, 总是可以用之前介绍的方法, 撤消已经
        提交的修改.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <!--
      <title>Creating a Complex Tag</title>
      -->
      <title>创建复杂的标签</title>

      <!--
      <para>Sometimes you may want a <quote>snapshot</quote> that is
        more complicated than a single directory at a single
        revision.</para>
      -->
      <para>有时候, 用户可能需要更复杂的 <quote>快照</quote>, 它不仅仅是单独
        版本号下的单个目录.</para>

      <!--
      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn
        update</command> with the <option>-r</option> option
        liberally), by switching files and directories to particular
        branches (making use of <command>svn switch</command>), or
        even just by making a bunch of local changes.  When you're
        done, your working copy is a hodgepodge of repository
        locations from different revisions.  But after testing, you
        know it's the precise combination of data you need to
        tag.</para>
      -->
      <para>举个例子, 假设你的项目比我们的 <filename>calc</filename> 庞大得
        多: 项目内包含了大量的文件与目录. 在工作过程中, 你可能需要创建一个
        含有指定特性和问题修正的工作副本, 创建的方式可以是选择性地把文件或
        目录退回到指定的版本 (使用带有选项 <option>-r</option> 的
        <command>svn update</command> 命令), 把文件和目录切换到特定的分支
        (通过命令 <command>svn switch</command>), 甚至是一连串的本地修改.
        创建完毕后, 你的工作副本就变成了一个大杂烩, 但是在测试后, 你确定这
        正是你想要创建标签的目标.</para>

      <!--
      <para>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (see <xref linkend="svn.ref.svn.c.copy"/> in <xref
        linkend="svn.ref.svn"/>), including the ability to copy a
        working copy tree to the repository:</para>
      -->
      <para>是时候创建快照了, 但复制 URL 在这里不起作用. 对于这种情况, 用户
        想要的是在仓库中, 为当前状态下的工作副本创建一个快照. 幸运的是
        <command>svn copy</command> 的 4 种用法中 (见 <xref
          linkend="svn.ref.svn"/> 的 <xref linkend="svn.ref.svn.c.copy"/>),
        包含了把工作副本复制到仓库中的能力:</para>

      <informalexample>
        <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \
           -m "Tag my existing working copy state."

Committed revision 940.
</screen>
      </informalexample>

      <!--
      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, URLs,
        local changes, and all.</para>
      -->
      <para>现在, 仓库中就出现了一个新目录 <filename>/calc/tags/mytag
        </filename>, 它是当前工作副本的快照&mdash;混合的版本号, URL, 本地修改
        等.</para>

      <!--
      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        directory or symlink changes), you can
        use <command>svn copy</command> to <quote>upload</quote> your
        working copy to a private area of the repository.  Your
        collaborator can then either check out a verbatim copy of your
        working copy or use <command>svn merge</command> to receive
        your exact changes.</para>
      -->
      <para>有些用户已经发现了这个特性的其他一些用法. 有时候用户的工作副本
        可能包含了一堆本地修改, 他想让其他用户审查一下, 但这次不是用
        <command>svn diff</command> 生成并发送补丁 (<command>svn diff</command>
        无法体现目录或符号链接的变化), 而是用 <command>svn copy</command> 把
        当前状态下的工作副本 <quote>上传</quote> 到仓库中的适当位置, 例如你的
        私有目录, 然后其他用户就可以用 <command>svn checkout</command> 逐字
        拷贝你的工作副本, 或者用 <command>svn merge</command> 接收你做出的修改.
      </para>

      <!--
      <para>While this is a nice method for uploading a quick snapshot
        of your working copy, note that this is <emphasis>not</emphasis>
        a good way to initially create a branch.  Branch creation should
        be an event unto itself, and this method conflates the creation
        of a branch with extra changes to files, all within a single revision.
        This makes it very difficult (later on) to identify a single
        revision number as a branch point.</para>
      -->
      <para>虽然这是上传工作副本快照的好办法, 但要注意的是这 <emphasis>不是
        </emphasis> 一个创建分支的好办法, 创建分支应该是它本身的事件, 而这种
        方法创建的分支混合了额外的修改, 分支的创建和修改都在一个单独的版本号
        里, 这样的话我们以后就难确定哪一个版本号才是分支点.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
      <!--
    <title>Branch Maintenance</title>
      -->
    <title>分支维护</title>

      <!--
    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>
      -->
    <para>读者可能已经注意到 Subversion 非常灵活. 因为 Subversion 实现分支和
      标签的底层机制是相同的 (目录复制), 而且分支和标签都是以普通的目录出现
      在文件系统中, 很多人觉得自己被 Subversion 吓到了: 这简直就是
      <emphasis>过于</emphasis> 灵活了. 本节将介绍一些与管理相关的建议.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <!--
      <title>Repository Layout</title>
      -->
      <title>仓库布局</title>

      <!--
      <para>There are some standard, recommended ways to organize the
        contents of a repository.  Most people create a
        <filename>trunk</filename> directory to hold the <quote>main
        line</quote> of development, a <filename>branches</filename>
        directory to contain branch copies, and
        a <filename>tags</filename> directory to contain tag copies.
        If a repository holds only one project, often people create
        these top-level directories:</para>
      -->
      <para>有一些标准的方式用于组织仓库内容. 大多数用户用目录 <filename>trunk
          </filename> 存放开发 <quote>主线</quote>, 用目录 <filename>branches
        </filename> 存放分支, 用目录 <filename>tags</filename> 存放标签. 如果
        一个仓库只存放一个项目, 人们通常会创建这些顶层目录:</para>

      <informalexample>
        <literallayout>
/
   trunk/
   branches/
   tags/
</literallayout>
      </informalexample>

      <!--
      <para>If a repository contains multiple projects, admins
        typically index their layout by project.  See <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>, but here's an example of such a
        layout:</para>
      -->
      <para>如果在一个仓库中包含了多个项目, 通常根据项目索引它们的布局, 关
        于 <quote>项目根目录</quote> 的更多内容, 见 <xref
          linkend="svn.reposadmin.projects.chooselayout"/>, 下面就是一个典型的,
        包含了多个项目的仓库布局:</para>

      <informalexample>
        <literallayout>
/
   paint/
      trunk/
      branches/
      tags/
   calc/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <!--
      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>
      -->
      <para>当然, 用户也可以完全忽略这些常见的布局, 按照实际需要定义仓库的
        布局. 记住, 无论你怎么选择, 仓库布局并非一成不变, 用户可以在任何时候
        重新组织仓库的布局. 因为分支和标签都是普通目录, 所以用户可以随心所欲地
        用命令 <command>svn move</command> 移动或重命名它们. 从一种布局切换到
        另一种布局只是服务器端的一系列移动而已, 如果你不喜欢当前的仓库布局,
        可以任意修改目录结构.</para>

      <!--
      <para>Remember, though, that while moving directories is
        easy to do, you need to be considerate of other users as well.
        Your juggling can disorient users with existing
        working copies.  If a user has a working copy of a particular
        repository directory and your <command>svn move</command>
        subcommand removes the path from the latest revision, then
        when the user next runs <command>svn update</command>, she is
        told that her working copy represents a path that no
        longer exists.  She is then forced to <command>svn
        switch</command> to the new location.</para>
      -->
    <para>记住, 虽然移动目录很容易操作, 但你仍然需要考虑其他用户. 把目录调
      来调去可能会让其他用户感到迷惑, 如果有个用户的工作副本所对应的仓库目录
      被其他用户用 <command>svn move</command> 移动其他地方去了, 那么用户下
      次执行 <command>svn update</command> 时, 就会被告知工作副本对对应的仓库
      目录已经不存在了, 他必须用 <command>svn switch</command> 把工作副本切换
      到仓库中的另一个位置.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <!--
      <title>Data Lifetimes</title>
      -->
      <title>数据的寿命</title>

      <!--
      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>
      -->
      <para>Subversion 模型具有的另一个优良特性是分支和标签的寿命是有限的,
        就像一个普通的被版本控制的条目. 比如说用户最终在自己的分支中完成了工
        作, 当分支上所有的修改都被合并到 <filename>/calc/trunk</filename> 后,
        就没必要再在仓库中保留自己的分支了.</para>

      <informalexample>
        <screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 474.
</screen>
      </informalexample>

      <tip>
      <!--
        <para>Recall from the previous section that if the repository
          location your working copy refers to is deleted, then when
          you try to update you will receive an error:</para>
      -->
        <para>上一小节刚刚讲过, 如果工作副本所对应的仓库路径已经被删除了, 此时
          再更新工作副本将会收到错误:</para>
        <informalexample>
          <screen>
$ svn up
Updating '.':
svn: E160005: Target path '/calc/branches/my-calc-branch' does not exist
</screen>
        </informalexample>

      <!--
        <para>All you need to do in this situation is switch your working
          copy to a location that still exits:</para>
      -->
        <para>对于这种情况, 你所需要做的就是把工作副本切换到仓库中仍然存在的
          其他路径:</para>

        <informalexample>
          <screen>
$ svn sw ^/calc/trunk
D    src/whole.c
 U   src/real.c
A    src/integer.c
 U   .
Updated to revision 474.
</screen>
        </informalexample>
      </tip>

      <!--
      <para>And now your branch is gone.  Of course, it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you can still see
        your old branch.</para>
      -->
      <para>现在你的分支就消失了, 当然并非永远地消失: 分支只是在 <literal>HEAD
        </literal> 上看不到了. 如果用 <command>svn checkout</command>,
        <command>svn switch</command> 或 <command>svn list</command> 查看较
        早的版本号, 仍然可以看到你的旧分支.</para>

      <!--
      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy</command> to copy it from the old
        revision:</para>
      -->
      <para>如果浏览已删除的目录还不够, 你还可能把它们再恢复回来. 在 Subversion
        中恢复数据非常容易, 如果用户想把一个已删除的目录或文件恢复到 <literal>
          HEAD</literal> 中, 只需要用 <command>svn copy</command> 把它从旧
        版中复制出来即可:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/branches/my-calc-branch@473 \
           ^/calc/branches/my-calc-branch \
           -m "Restore my-calc-branch."

Committed revision 475.
</screen>
      </informalexample>

      <!--
      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side by side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>
      -->
      <para>在我们的例子里, 分支的寿命相对较短: 创建分支的目的可能是为了
        修正一个问题, 或实现一个新的特性. 当任务完成后, 分支也就走到了生命的
        尽头. 在软件开发过程中, 长期同时存在两条 <quote>主要的</quote> 分支并
        不少见, 比如说现在要发布 <filename>calc</filename> 的稳定版本, 而开发
        人员知道要花几个月的时间才能把潜在的问题修复殆尽, 也不想向稳定版添加
        新特性, 所以你决定创建一个 <quote>稳定</quote> 分支, 表示不想做过多的
        修改:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/stable-1.0 \
           -m "Creating stable branch of calc project."

Committed revision 476.
</screen>
      </informalexample>

      <!--
      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        cherrypicks bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.  We'll
        discuss this more in the next section.</para>
      -->
      <para>现在开发人员可以自由地向 <filename>/calc/trunk</filename> 添加最
        前沿的 (或实验性的) 新特性, 同时达成一个约定: 只有修复问题的修改才能
        提交到 <filename>/calc/branches/stable-1.0</filename>. 也就是说, 当人
        们在主干上工作的同时, 精选修复问题的修改提交到稳定分支上. 即使在稳定
        分支发布后, 开发人员很可能也会维护很长一段时间&mdash;只要你还在为客户
        支持这一发布版. 我们将会在下节介绍更多的相关内容.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonpatterns">
      <!--
    <title>Common Branching Patterns</title>
      -->
    <title>常见的分支模式</title>

      <!--
    <para>There are many different uses for branching and <command>svn
        merge</command>, and this section describes the most
        common.</para>
      -->
      <para>分支和 <command>svn merge</command> 有着非常丰富的用法, 本节介绍
        其中最常见的几种.</para>

      <!--
    <para>Version control is most often used for software
      development, so here's a quick peek at two of the most common
      branching/merging patterns used by teams of programmers.  If
      you're not using Subversion for software development, feel
      free to skip this section.  If you're a software developer
      using version control for the first time, pay close attention,
      as these patterns are often considered best practices by
      experienced folk.  These processes aren't specific to
      Subversion; they're applicable to any version control system.
      Still, it may help to see them described in Subversion
      terms.</para>
      -->
    <para>版本控制最经常用在软件开发领域, 所以本节先介绍 2 种在开发人员中最
      常见的分支/合并模式. 如果读者使用 Subversion 不是为了软件开发, 尽管跳过
      本节, 如果你是第一次使用版本控制工具的软件开发人员, 请集中注意力, 因为
      这些模式经常被经验丰富的程序员看成是最佳的做法. 本节的内容不仅限于
      Subversion, 它们同样适用于其他版本控制系统, 使用 Subversion 的术语进行
      描述更有助于用户理解.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.release">
      <!--
      <title>Release Branches</title>
      -->
      <title>发布分支</title>

      <!--
      <para>Most software has a typical life cycle: code, test,
        release, repeat.  There are two problems with this process.
        First, developers need to keep writing new features while
        quality assurance teams take time to test supposedly stable
        versions of the software.  New work cannot halt while the
        software is tested.  Second, the team almost always needs to
        support older, released versions of software; if a bug is
        discovered in the latest code, it most likely exists in
        released versions as well, and customers will want to get
        that bug fix without having to wait for a major new
        release.</para>
      -->
      <para>大多数软件都有一个典型的生命周期: 编码, 测试, 发布, 如此循环往复.
        这个过程有两个问题. 首先开发人员需要不断地往软件添加新特性, 同时质保
        团队也会不断地测试稳定版, 开发与测试是同时进行的. 第二, 开发团队通常
        需要支持已发布的旧版, 如果在最新版发现了一个问题, 那么旧的发布版很
        可能也有同样的问题, 客户更希望直接修复这个问题, 而不是等待新的版本发
        布.</para>

      <!--
      <para>Here's where version control can help.  The typical
        procedure looks like this:</para>
      -->
      <para>版本控制工具可以帮助开发人员解决这些问题, 典型的步骤是:</para>

      <orderedlist>

        <listitem>
      <!--
          <para><emphasis>Developers commit all new work to the
            trunk.</emphasis>  Day-to-day changes are committed to
            <filename>/trunk</filename>: new features, bug fixes, and
            so on.</para>
      -->
          <para><emphasis>开发人员把所有的新工作都提交到主干上.</emphasis> 把
            每天的修改&mdash;包含新特性, 问题修复等&mdash;都提交到
            <filename>/trunk</filename>.</para>
        </listitem>
        <listitem>
      <!--
          <para><emphasis>The trunk is copied to a
            <quote>release</quote> branch.</emphasis>  When the team
            thinks the software is ready for release (say, a 1.0
            release), <filename>/trunk</filename> might be copied to
            <filename>/branches/1.0</filename>.</para>
      -->
          <para><emphasis>复制主干到 <quote>发布</quote> 分支.</emphasis>
            如果团队认为软件已经准备好发布 (例如发布版 1.0), 可能会复制
            <filename>/trunk</filename> 到 <filename>/branches/1.0</filename>.
          </para>
        </listitem>
        <listitem>
      <!--
          <para><emphasis>Teams continue to work in
            parallel.</emphasis>  One team begins rigorous testing of
            the release branch, while another team continues new work
            (say, for version 2.0) on <filename>/trunk</filename>.  If
            bugs are discovered in either location, fixes are cherrypicked
            back and forth as necessary.  At some point, however, even
            that process stops.  The branch is <quote>frozen</quote>
            for final testing right before a release.</para>
      -->
          <para><emphasis>团队继续并行工作.</emphasis> 一个团队开始对发布分支
            进行严格的测试, 其他团队继续在 <filename>/trunk</filename> 上开发
            新的工作 (例如版本 2.0). 如果有问题出现 (无论是在 <filename>
              /trunk</filename>, 还是发布分支), 修复问题, 并把修改精选到拥有
            相同问题的分支上. 但是这个过程有时候也会停止, 例如为了发布测试而
            <quote>冻结</quote> 分支.</para>
        </listitem>
        <listitem>
      <!--
          <para><emphasis>The branch is tagged and
            released.</emphasis>  When testing is complete,
            <filename>/branches/1.0</filename> is copied to
            <filename>/tags/1.0.0</filename> as a reference
            snapshot.  The tag is packaged and released to
            customers.</para>
      -->
          <para><emphasis>为分支打标签并发布.</emphasis> 当测试结束, <filename>
              /branches/1.0</filename> 被复制到 <filename>/tags/1.0.0
          </filename>, 标签被打包并交付给客户.</para>
        </listitem>
        <listitem>
      <!--
          <para><emphasis>The branch is maintained over
            time.</emphasis>  While work continues
            on <filename>/trunk</filename> for version 2.0, bug fixes
            continue to be ported from <filename>/trunk</filename> to
            <filename>/branches/1.0</filename>.  When enough
            bug fixes have accumulated, management may decide to do a
            1.0.1 release: <filename>/branches/1.0</filename> is
            copied to <filename>/tags/1.0.1</filename>, and the tag
            is packaged and released.</para>
      -->
          <para><emphasis>继续维护分支.</emphasis> 当团队在主干上为版本 2.0
            工作时, 修复问题的修改从 <filename>/trunk</filename> 回植到
            <filename>/branches/1.0</filename>. 如果修改积累得足够多了, 团队
            可能决定发布 1.0.1: <filename>/branches/1.0</filename> 被复制到
            <filename>/tags/1.0.1</filename>, 标签被打包并交付给客户.</para>
        </listitem>

      </orderedlist>

      <!--
      <para>This entire process repeats as the software matures:
        when the 2.0 work is complete, a new 2.0 release branch is
        created, tested, tagged, and eventually released.  After
        some years, the repository ends up with a number of release
        branches in <quote>maintenance</quote> mode, and a number
        of tags representing final shipped versions.</para>
      -->
      <para>整体过程随着软件的成长而不断重复: 当版本 2.0 完成时, 创建了一个新
        的 2.0 发布分支, 再对该分支进行测试, 打标签并发布. 几年后, 仓库拥有
        了大量的处于 <quote>维护</quote> 状态的发布分支, 以及代表了最终交付
        版的标签.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.feature">
      <!--
      <title>Feature Branches</title>
      -->
      <title>特性分支</title>

      <para>
        <indexterm>
          <primary>branches (分支)</primary>
          <secondary>feature branches (特性分支)</secondary>
        </indexterm>
        <firstterm>特性分支</firstterm> (<firstterm>feature branch</firstterm>)
        是分支的一种类型, 它曾是本章的主要例子 (在这个例子中, 你在分支上工作,
        而 Sally 在 <filename>/trunk</filename> 上工作). 这是一个临时分支, 为了完成一
        个复杂的修改, 在完成前不能影响 <filename>/trunk</filename> 的稳定性.
        与发布分支不同 (发布分支可能需要永远支持), 特性分支被创建后, 使用一
        段时间, 被合并到主干后就会被删除&mdash;它们的寿命是很有限的.</para>
      <!--
        A <firstterm>feature branch</firstterm> is the sort of
        branch that's been the dominant example in this chapter (the
        one you've been working on while Sally continues to work on
        <filename>/trunk</filename>).  It's a temporary branch created
        to work on a complex change without interfering with the
        stability of <filename>/trunk</filename>.  Unlike release
        branches (which may need to be supported forever), feature
        branches are born, used for a while, merged back to the trunk,
        and then ultimately deleted.  They have a finite span of
        usefulness.</para>
      -->

      <!--
      <para>Again, project policies vary widely concerning exactly
        when it's appropriate to create a feature branch.  Some
        projects never use feature branches at all: commits to
        <filename>/trunk</filename> are a free-for-all.  The
        advantage to this system is that it's simple&mdash;nobody
        needs to learn about branching or merging.  The disadvantage
        is that the trunk code is often unstable or unusable.  Other
        projects use branches to an extreme: no change is
        <emphasis>ever</emphasis> committed to the trunk directly.
        Even the most trivial changes are created on a short-lived
        branch, carefully reviewed, and merged to the trunk.  Then
        the branch is deleted.  This system guarantees an
        exceptionally stable and usable trunk at all times, but at
        the cost of tremendous process overhead.</para>
      -->
      <para>在什么样的情况下才需要创建一个特性分支&mdash;对于这个问题, 不同的
        项目, 其策略也不尽相同. 有些项目甚至根本就不使用特性分支: <filename>
          /trunk</filename> 的提交就是一场大混战. 不使用特性分支的好处是操作
        简单&mdash;开发人员不用了解分支或合并. 缺点是主干上的代码会经常处于不
        可用状态. 还有些项目过度使用分支: 没有一个修改是直接提交到主干上的,
        即使是非常简单的修改, 也要创建一个短期分支, 认真地审查修改后再合并到
        主干, 然后再删除分支. 这样做保证了主干上的代码总是可用的, 但代价就是
        极大的过程开销.</para>

      <!--
      <para>Most projects take a middle-of-the-road approach.  They
        commonly insist that <filename>/trunk</filename> compile and
        pass regression tests at all times.  A feature branch is
        required only when a change requires a large number of
        destabilizing commits.  A good rule of thumb is to ask this
        question: if the developer worked for days in isolation and
        then committed the large change all at once (so that
        <filename>/trunk</filename> were never destabilized), would it
        be too large a change to review?  If the answer to that
        question is <quote>yes,</quote> the change should be
        developed on a feature branch.  As the developer commits
        incremental changes to the branch, they can be easily reviewed
        by peers.</para>
      -->
      <para>大多数项目走的是 <quote>中间路线</quote>. 他们通常会坚持主干上的
        代码应该总是可编译的, 而且通过了所有的回归测试. 只有当修改含有大量不
        稳定的提交时, 才会创建特性分支. 一条很好的经验法则是: 让一个程序员
        单独工作几天, 然后一次性提交所有修改 (于是 <filename>/trunk</filename>
        总是可用的), 如果这个提交所包含的修改过于庞大, 以致于无法审查, 那就
        应该在特性分支中完成开发, 然后再合并到主干上. 因为每次提交到分支上的
        修改相对较小, 它们可以轻易地被同行审议.</para>

      <!--
      <para>Finally, there's the issue of how to best keep a feature
        branch in <quote>sync</quote> with the trunk as work
        progresses.  As we mentioned earlier, there's a great risk to
        working on a branch for weeks or months; trunk changes may
        continue to pour in, to the point where the two lines of
        development differ so greatly that it may become a nightmare
        trying to merge the branch back to the trunk.</para>
      -->
      <para>最后, 是如何保持分支与主干 <quote>同步</quote>. 我们之前已经警告
        过, 如果连续地在分支上工作几周, 甚至几个月, 同时主干上也有新的提交
        出现, 一直到两条开发线之间出现非常大的差异, 此时再把分支合并到主干
        上可能会成为一场恶梦.</para>

      <!--
      <para>This situation is best avoided by regularly running an
        automatic merge from trunk to the branch.  Make up a policy:
        once a week, merge the last week's worth of trunk changes to
        the branch.</para>
      -->
      <para>解决问题最好的办法是定期从主干自动合并到分支, 可以定一个标准,
        比如一周合并一次.</para>

      <!--
      <para>When you are eventually ready to merge the
        <quote>synchronized</quote> feature branch back to the trunk,
        begin by doing a final automatic merge of the latest trunk
        changes to the branch.  When that's done, the latest versions
        of branch and trunk are absolutely identical except for
        your branch changes.  You can then run an automatic reintegrate
        merge from the branch back to the trunk:</para>
      -->
      <para>当用户终于准备好把 <quote>同步的</quote> 特性分支合并到主干上时,
        最后再为特性分支做一次自动同步合并, 合并后分支和主干就是一样的了 (除
        了分支特有的修改). 然后再执行自动再整合合并, 把分支合并到主干上.</para>

      <informalexample>
        <screen>
$ cd trunk-working-copy

$ svn update
Updating '.':
At revision 1910.

$ svn merge ^/calc/branches/mybranch
--- Merging differences between repository URLs into '.':
U    real.c
U    integer.c
A    newdirectory
A    newdirectory/newfile
 U   .
&hellip;
</screen>
      </informalexample>

      <!--
      <para>Another way of thinking about this pattern is that your
        weekly sync of trunk to branch is analogous to running
        <command>svn update</command> in a working copy, while the
        final merge step is analogous to running <command>svn
        commit</command> from a working copy.  After all, what else
        <emphasis>is</emphasis> a working copy but a very shallow
        private branch?  It's a branch that's capable of
        storing only one change at a time.</para>
      -->
      <para>这种分支模式的另一种理解方式是: 每周从主干向分支的同步就像在工作
        副本中执行 <command>svn update</command>, 最后从分支到主干的合并就像
        在工作副本中执行 <command>svn commit</command>. 毕竟, 工作副本就像是
        一个非常浅的私有分支, 一次只能保存一个修改.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
      <!--
    <title>Vendor Branches</title>
      -->
    <title>供方分支</title>

    <para>
      <indexterm>
        <primary>branches (分支)</primary>
        <secondary>vendor branches (供方分支)</secondary>
      </indexterm>
      软件开发过程中可能会遇到这样一种情况, 用户所维护的代码依赖其他人的数据,
      通常来说, 项目会要求所依赖的数据尽量处于最新状态, 但不能影响稳定性.
      只要某个团队所维护的数据会对另一个团队产生直接的影响, 这种场景就会一直
      存在.</para>
      <!--
      As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&mdash;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</para>
      -->

      <!--
    <para>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see <xref linkend="svn.developer.usingapi.apr" />).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <quote>bleeding edge</quote> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</para>
      -->
    <para>比如说软件开发人员所开发的应用程序会用到一个第三方函数库, Subversion
      和 Apache Portable Runtime (APR) 的关系即是如此, 见
      <xref linkend="svn.developer.usingapi.apr"/>. 为了实现可移植性,
      Subversion 的源代码依赖于 APR 函数库, 在 Subversion 的早期阶段, 项目
      总是紧紧追随 APR 的 API 更新. 现在 Subversion 和 APR 都已经进入成熟期,
      所以 Subversion 只使用 APR 经过充分测试的稳定版 API.</para>

      <!--
    <para>Now, if your project depends on someone else's information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions of
      that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <quote>pin down</quote> specific
      versions of that information to some location in your own
      working copy (see <xref linkend="svn.advanced.externals"
      />).</para>
      -->
  <para>如果你的项目依赖其他人的数据, 有若干种方式可以用来同步这些数据. 其中
    最麻烦的一种是以口头或书面的方式通知项目的所有成员, 将项目所需的第三方数
    据更新到某个特定版本. 如果第三方数据使用 Subversion 进行管理, 就可以利用
    Subversion 的外部定义, 快速地将第三方数据更新到特定版本, 并存放在工作
    副本中 (见 <xref linkend="svn.advanced.externals"/>).</para>

      <!--
    <para>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</para>
      -->
    <para>有时候用户可能需要使用自己的版本控制系统去维护第三方代码的定制化
      修改. 回到软件开发的例子中, 程序员可能需要修改第三方函数库, 以满足自己
      的特殊需求. 这些定制化修改可能包括新功能或问题修正, 直到成为第三方函数
      库的官方修改之前, 它们只在内部维护. 或者这些定制化修改永远不会发送给函数
      库的官方维护人员, 它们只是为了满足项目的需求而单独存在.</para>

      <!--
    <para>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</para>
      -->
    <para>现在你面临一种非常有趣的情况. 你的项目可以使用几种分离的方式存放
      第三方数据的定制化修改, 比如说使用补丁文件, 或文件和目录的成熟的替代
      版本. 但是维护人员很快就会感到头疼,
      因此迫切需要一种机制, 能够方便地把你的定制化修改应用到第三方代码上, 并
      且当第三方代码更新时能够迫使开发人员重新生成这些修改.</para>

    <para>
      <indexterm>
        <primary>vendor drop (供方物资)</primary>
      </indexterm>
      解决办法是使用 <firstterm>供方分支</firstterm> (<firstterm>vendor
        branches</firstterm>). 供方分支是一个存在于你自己的版本控制系统中的
      目录, 包含了由第三方提供的数据. 被项目吸收的每一个供方数据版本都称为
      一个 <firstterm>供方物资</firstterm> (<firstterm>vendor
        drop</firstterm>).</para>
      <!--
      The solution to this problem is to
      use <firstterm>vendor branches</firstterm>.  A vendor branch is
      a directory tree in your own version control system that
      contains information provided by a third-party entity, or
      vendor.  Each version of the vendor's data that you decide to
      absorb into your project is called a <firstterm>vendor
      drop</firstterm>.</para>
      -->

      <!--
    <para>Vendor branches provide two benefits.  First, by storing the
      currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need
      to question whether they have the right version of the vendor's
      data.  They simply receive that correct version as part of their
      regular working copy updates.  Second, because the data lives in
      your own Subversion repository, you can store your custom
      changes to it in-place&mdash;you have no more need of an
      automated (or worse, manual) method for swapping in your
      customizations.</para>
      -->
    <para>供方分支有两个好处. 首先, 通过在自己的版本控制系统中存放当前支持
      的供方物资, 你就可以确认项目成员不必再担心他们是否使用了供方数据的正确
      版本, 只需要更新工作副本, 他们就可以得到供方数据的正确版本. 第二, 因为
      供方数据使用 Subversion 进行管理, 所以用户可以方便地在仓库中存放自己的
      定制化修改, 而无需再使用某种自动的 (或手动的) 方法对定制化修改进行换
      入换出.</para>

      <!--
    <para>Unfortunately, there is no single best way to manage vendor
      branches in Subversion.  The flexibility of the system offers
      several different approaches, each of which has its advantages
      and disadvantages, and none of which can be clearly considered
      a <quote>silver bullet</quote> for the problem.  We'll cover a
      few of these approaches at a high level in the following
      sections, using the common example of a software project which
      depends on a third-party library.</para>
      -->
    <para>不幸的是, 在 Subversion 中并不存在一种管理供方分支的最佳方法. 系统
      的灵活性提供了多种不同的管理方法, 每一种都有各自的优缺点, 没有一种方法
      可以当成 <quote>万能钥匙</quote>. 在下面几节里,
      我们将从较高的层面介绍其中几种方法, 所使用的例子也是依赖第三方函数库的
      典型示例.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
      <!--
      <title>General Vendor Branch Management Procedure</title>
      -->
      <title>通常的供方分支管理过程</title>

      <!--
      <para>Maintaining customizations to a third-party library
        involves three data sources: the version of the third-party
        library upon which your modifications were last based, the
        customized version (that is, the actual vendor branch) of that
        library which is used by your project, and any new version of
        the vendor's library to which you may be hoping to upgrade.
        TODO
        Managing the vendor branch (which should live within your
        source code repository per our definition of the thing), then,
        essentially boils down to performing merge operations (in the
        general sense).  But different teams take different approaches
        to the other data sources&mdash;the pristine versions of the
        third-party library code.  Thus, there are likewise different
        specific ways to perform the requisite merges.</para>
      -->
      <para>维护第三方函数库的定制化修改会牵涉到 3 个数据源: 最新版的定制化
        修改所基于的第三方函数库的版本, 项目所使用的定制化版本 (即实际上的
        供方分支), 以及第三方函数库的新版本. 于是, 管理供方分支 (供方分支应
        存放在用户自己的代码仓库中) 本质上可以归结为
        执行合并操作 (指的是一般意义上的合并), 但是其他开发团队可能会对其他
        数据源&mdash;第三方函数库代码的全新版本&mdash;采取不同的策略, 所以说
        同样存在几种不同的方法去执行合并操作.</para>

      <!--
      <para>Strictly speaking, there are a couple of different ways
        that those merges can be performed in the general sense.  For
        the sake of simplicity and with the goal of at least providing
        <emphasis>something</emphasis> concrete in this section of the
        book, we'll assume that there is but a single vendor branch
        which is upgraded to each successive new release of the
        third-party library by receiving updates that describe the
        differences between the current and new pristine versions of
        that library.</para>
      -->
      <para>严格来说, 有几种不同的方式用来执行这些合并操作, 为简单起见, 也为了
        向读者展示一些具体的东西, 我们假设只有一个供方分支, 每当第三方函数库
        发布新版本时, 通过应用当前版本与最新版之间的差异, 将分支更新到新的发
        布版本.</para>

      <note>
      <!--
        <para>Another approach is to create new vendor branches for
          each successive pristine library version, applying the
          differences between the current pristine library and the
          customized version thereof (from the current vendor branch)
          to the new branch.  There's nothing wrong with that
          approach&mdash;we just don't feel compelled to document
          every legitimate possibility in this space.</para>
      -->
        <para>另一种办法是为第三方函数库的每一个新版本都创建一个新的供方分支,
          并将当前原版函数库与定制版本 (来自当前的供方分支) 之间的差异应用到新
          的分支上. 这种方法并没有什么问题&mdash;我们只是觉得没必要在这里介绍
          所有的可能性.</para>
      </note>

      <!--
      <para>The following sections examine how to create and manage a
        vendor branch in a few different scenarios.  In the examples
        which follow, we'll assume that the third-party library is
        called libcomplex, and that we will be implementing a vendor
        branch based on libcomplex 1.0.0 which lives in our repository
        at <filename>^/vendor/libcomplex-custom</filename>.  We'll
        then look at how we can upgrade to libcomplex 1.0.1 while
        still preserving our customizations to the library.</para>
      -->
      <para>下面几节介绍了在几种不同的场景中, 如何创建并管理供方分支. 在下面
        的例子里, 我们假设第三方函数库的名字是 libcomplex, 当前供方分支所基于
        的版本是 libcomplex 1.0.0, 分支的位置是
        <filename>^/vendor/libcomplex-custom</filename>. 稍后读者将会看到如何
        把供方分支升级到 libcomplex 1.0.1, 同时保留定制化修改.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.foreign-repos">
      <!--
      <title>Vendor Branches from Foreign Repositories</title>
      -->
      <title>来自外部仓库的供方分支</title>

      <!--
      <para>Let's look first at a vendor branch management approach
        that is possible when the original third-party library is
        itself Subversion-accessible.  For the sake of the example,
        we'll assume that the libcomplex library we previously
        discussed is developed in a publicly accessible Subversion
        repository, and that its developers use sane release
        procedures which include the creation of tags for each stable
        release version.</para>
      -->
      <para>先来看第一种管理供方分支的方法, 该方法的适用条件是第三方函数库
        可以通过 Subversion 进行访问. 为了方便说明, 我们假设函数库 libcomplex
        存放在可以公开访问的 Subversion 仓库中, 而且函数库的开发人员也使用了
        通常的发布步骤, 即为每一个稳定的发布版创建一个标签.</para>

      <para>
        <indexterm>
          <primary>merging (合并)</primary>
          <secondary>foreign repository merges (外部仓库合并)</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository merges (外部仓库合并)</primary>
          <see>merging (合并), foreign repository merges (外部仓库合并)</see>
        </indexterm>
        <indexterm>
          <primary>copying (复制)</primary>
          <secondary>foreign repository copies (外部仓库复制)</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository copies (外部仓库复制)</primary>
          <see>copying (复制), foreign repository copies (外部仓库复制)</see>
        </indexterm>
        从 Subversion 1.5 开始, <command>svn merge</command> 支持
        <firstterm>外部仓库合并</firstterm> (<firstterm>foreign repository
          merges</firstterm>), 也就是合并的源与目标属于不同的仓库. 与旧版相
        比, Subversion 1.8 的 <command>svn copy</command> 的行为有所变化:
        如果从外部仓库复制目录到工作副本中, 得到的目录将被工作副本收录, 等待
        添加到仓库中. 这个特性叫做 <firstterm>外部仓库复制</firstterm>
        (<firstterm>foreign repository copy</firstterm>), 我们将用它引导供方
        分支.</para>
      <!--
        Since Subversion 1.5, <command>svn merge</command>
        has been able to perform so-called <firstterm>foreign
        repository merges</firstterm>, where the sources of the merge
        live in a different repository than the repository from which
        the merge target working copy was checked out.  And in
        Subversion 1.8, the behavior of <command>svn copy</command>
        was changed so that when you perform a copy from a foreign
        repository into an existing working copy, the resulting tree
        is incorporated into that working copy and scheduled for
        addition.  It's this <firstterm>foreign repository
        copy</firstterm> functionality that we'll use to bootstrap our
        vendor branch.</para>
      -->

      <!--
      <para>So let's create our vendor branch.  We'll begin by
        creating a placeholder directory for all such vendor branches
        in our repository, and then checking out a working copy of
        that location.</para>
      -->
      <para>现在开始创建我们的供方分支. 一开始先在仓库中创建一个存放所有供方
        分支的目录, 然后检出该目录的工作副本.</para>

      <informalexample>
        <screen>
$ svn mkdir http://svn.example.com/projects/vendor \
            -m "Create a container for vendor branches."
Committed revision 1160.
$ svn checkout http://svn.example.com/projects/vendor \
               /path/to/vendor
Checked out revision 1160.
$
</screen>
      </informalexample>

      <!--
      <para>Now, we'll take advantage of Subversion's foreign
        repository copy support to get an exact copy of libcomplex
        1.0.0&mdash;including any Subversion properties stored on its
        files and directories&mdash;from the vendor repository.</para>
      -->
      <para>利用 Subversion 的外部仓库复制特性, 从供方仓库获取 libcomplex
        1.0.0 的一份副本&mdash;包括文件和目录上所有的 Subversion 属性.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn copy http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
           libcomplex-custom
--- Copying from foreign repository URL 'http://svn.othervendor.com/repos/lib\
complex/tags/1.0.0':
A    libcomplex-custom
A    libcomplex-custom/README
A    libcomplex-custom/LICENSE
&hellip;
A    libcomplex-custom/src/code.c
A    libcomplex-custom/tests
A    libcomplex-custom/tests/TODO
$ svn commit -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1161.
$
</screen>
      </informalexample>

      <note>
      <!--
        <para>If you happen to be using an older version of
          Subversion, the closest available approximation of the new
          foreign repository copy support in <command>svn
          copy</command> is to instead import (via <command>svn
          import</command>) a working copy of the vendor's tag,
          including the <option>- -no-auto-props</option>
          and <option>- -no-ignore</option> options so that the
          complete tree and any of its versioned properties are
          accurately replicated in your own repository.</para>
      -->
        <para>如果用户使用的 Subversion 版本较旧, 不支持外部仓库复制, 那么与
          此最类似的替代操作是导入 (通过命令 <command>svn import</command>)
          供方标签的工作副本, 导入时需要加上选项 <option>--no-auto-props
          </option> 和 <option>--no-ignore</option>, 这样才能保证目录及其
          所有的属性都能被完整地导入到你的仓库中.</para>
      </note>

      <!--
      <para>Now that we have a vendor branch based on libcomplex 1.0.0,
        we can begin making the customizations to libcomplex required
        for our purposes, committing them directly to the vendor
        branch we've created.  And of course, we can begin using
        libcomplex in our own application.</para>
      -->
      <para>有了基于 libcomplex 1.0.0 的供方分支后, 我们就可以开始对 libcomplex
        进行定制化修改, 然后提交到分支上, 并且可以开始在自己的应用程序中使用
        修改后的 libcomplex.</para>

      <!--
      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  Here is where Subversion's
        foreign repository merge operation is useful.  We have in our
        vendor branch the original libcomplex 1.0.0 plus our
        customizations to it.  What we need now is to get the set of
        changes the vendor has made between 1.0.0 and 1.0.1 into our
        vendor branch, ideally without clobbering our own
        customizations.  This is precisely what the 2-URL form of
        the <command>svn merge</command> command is for.</para>
      -->
      <para>一段时间后, 官方发布了 libcomplex 1.0.1, 查看新版的修改日志后, 我
        们决定把自己的供方分支也升级到 1.0.1, 这时候需要用到 Subversion 的
        外部仓库合并. 当前的供方分支是原始的 libcomplex 1.0.0 再加上我们的定
        制化修改, 现在我们需要把原始的 1.0.0 与 1.0.1 之间的差异应用到供方分
        支, 最理想的情况是被应用的差异不会影响到我们的定制化修改. 合并操作需要
        使用 二路 URL 形式的 <command>svn merge</command>.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn merge http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
            http://svn.othervendor.com/repos/libcomplex/tags/1.0.1 \
            libcomplex-custom
--- Merging differences between foreign repository URLs into '.':
U    libcomplex-custom/src/code.h
C    libcomplex-custom/src/code.c
U    libcomplex-custom/README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'libcomplex-custom/src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: 
</screen>
      </informalexample>

      <!--
      <para>As you can see, <command>svn merge</command> has merged
        the changes required to make libcomplex 1.0.0 look like
        libcomplex 1.0.1 into our working copy.  In our example, it has
        even noticed and flagged a conflict on one file.   It seems
        the vendor modified a region of one of the files we also
        customized.  Subversion safely detects this conflict, and
        gives us the opportunity to resolve it so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  (See <xref linkend="svn.tour.cycle.resolve" />
        for more on resolving conflicts of this sort.)</para>
      -->
      <para>可以看到, <command>svn merge</command> 把 libcomplex 1.0.0 升级
        到 1.0.1 的修改合并到了我们的工作副本. 在例子中, 有一个文件发生了冲突,
        应该是供方修改的区域与我们的定制化修改有所重叠. Subversion 安全地检测
        到了冲突, 并询问我们如何解决, 使得定制化修改在 libcomplex 1.0.1 上仍然
        有效. (关于冲突解决, 见 <xref linkend="svn.tour.cycle.resolve"/>).
      </para>

      <!--
      <para>Once we've resolved the conflicts and performed any
        testing or review we need, we can commit the changes to our
        vendor branch.</para>
      -->
      <para>冲突一旦解决, 并且测试和审查都没有问题后, 就可以提交到供方分支上.
      </para>

      <informalexample>
        <screen>
$ svn status libcomplex-custom
M       libcomplex-custom/src/code.h
M       libcomplex-custom/src/code.c
M       libcomplex-custom/README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-custom
Sending        libcomplex-custom/README
Sending        libcomplex-custom/src/code.h
Sending        libcomplex-custom/src/code.c
Transmitting file data ...
Committed revision 1282.
$
</screen>
      </informalexample>

      <!--
      <para>That, in a nutshell, is how to manage vendor branches when
        the original source is Subversion-accessible.  There are some
        notable shortcomings, though.  First, foreign repository
        merges are not automatically tracked by Subversion itself like
        same-repository merges are.  This means the burden falls to
        the user to know which merges have been performed on their
        vendor branch, and just how to construct the next merge when
        upgrading that branch.  Also, as is the case for all of
        Subversion's merge support, renames in the merge sources can
        cause no small amount of complication and frustration.
        Unfortunately, at this time, we don't have a particularly
        solid recommendation to offer to alleviate that pain.</para>
      -->
      <para>这就是当供方源是 Subversion 仓库时, 管理供方分支的方式. 这种方式
        有几个值得注意的缺点, 首先, 外部仓库合并不能像同一仓库那样自动跟踪,
        这就意味着必须由用户记住供方分支已经做过哪些合并, 以及下次升级时如何
        构造合并. 另外&mdash;对于其他形式的合并同样适用&mdash;源的重命名操作
        会造成不小的麻烦, 不幸的是目前并没有有效的办法缓解这个问题.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.mirrored-sources">
      <!--
      <title>Vendor Branches from Mirrored Sources</title>
      -->
      <title>来自镜像源的供方分支</title>

      <!--
      <para>In the previous section
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) we
        looked at how to implement and maintain a vendor branch when
        the vendor drops are accessible via Subversion, which is the
        ideal scenario when it comes to vendor branches.  Subversion
        is pretty good at handling merges of stuff that's been
        Subversion-managed.  Unfortunately, it's not always the case
        that third-party libraries are publicly accessible via
        Subversion.  Many times, a project depends on a library which
        is delivered via only non-Subversion mechanisms, such as a
        source code release distribution tarball.  In such
        circumstances, we strongly recommend that you do all you can
        to get that non-Subversion information into Subversion as
        cleanly as possible.  So let's examine an approach to vendor
        branches in which the third-party library's various releases
        are mirrored within our own repository.</para>
      -->
      <para>在上一节
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) 我们介绍了
        当供方物资可通过 Subversion 进行访问时如何实现与维护供方分支. 这是
        一种比较理想的情况, 因为 Subversion 非常擅长处理由它进行管理的数据
        的合并. 不幸的是, 并不是所有的第三方函数库都可以通过 Subversion 进行
        访问. 很多时候, 项目所依赖的函数库是通过非 Subversion 机制交付的,
        例如源代码的发布版压缩包. 对于这种情况, 我们强烈建议用户在把非
        Subversion 信息导入 Subversion 时, 尽量保持干净. 下面我们将介绍另一
        种供方分支管理方法, 其中第三方函数库的发布版将以镜像的方式存放在我
        们的仓库中.</para>

      <!--
      <para>Setting up the vendor branch the first time is pretty
        simple, really.  For our example, we'll assume that libcomplex
        1.0.0 is delivered via the common tarball mechanism.  To
        create our vendor branch, we'll first get the contents of the
        libcomplex 1.0.0 tarball into our repository as a read-only
        (by convention only) vendor tag of sorts.</para>
      -->
      <para>首次创建供方分支非常简单, 对于我们的例子而言, 假设 libcomplex
        1.0.0 是以代码压缩包的形式发布. 为了创建供方分支, 首先把 libcomplex
        1.0.0 的压缩包解压到我们的仓库中, 作为一个只读 (只是一种惯例)
        的供方标签.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.0.tar.gz
libcomplex-1.0.0/
libcomplex-1.0.0/README
libcomplex-1.0.0/LICENSE
&hellip;
libcomplex-1.0.0/src/code.c
libcomplex-1.0.0/tests
libcomplex-1.0.0/tests/TODO
$ svn import libcomplex-1.0.0 \
             http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
             --no-ignore --no-auto-props \
             -m "Import libcomplex 1.0.0 sources."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1160.
$
</screen>
      </informalexample>

      <!--
      <para>Note that in our example, we used
        the <option>- -no-ignore</option> option during import so that
        Subversion is sure to pick up every file in the vendor drop
        and not to omit any of them.  We also supply
        the <option>- -no-auto-props</option> option so that our client
        doesn't manufacture property information which isn't present
        in the vendor drop.<footnote><para>Technically, we could let
        the auto-props feature do its thing, but the key to making
        that work well is ensuring that each vendor drop gets
        identical auto-prop treatment.</para></footnote>.</para>
      -->
  <para>注意, 在导入时我们为命令增加了选项 <option>--no-ignore</option>, 这样
    Subversion 就不会遗漏任意一个文件或目录, 同时还增加了选项
    <option>--no-auto-props</option>, 这样的话, Subversion 客户端就不会生成
    供方物资中原本没有的属性信息.<footnote><para>严格来说, 可以允许自动属性
        工作, 但其中的关键问题是确保每一个供方物资都能得到相同的对待.</para>
  </footnote></para>
       
      <!--
      <para>Now that the first vendor release drop is present in our
        repository, we can create our vendor branch from it just as we
        would create any other branch&mdash;using <command>svn
        copy</command>.</para>
      -->
    <para>供方发布物资进入我们的仓库后, 接下来就可以用
      <command>svn copy</command> 创建供方分支.</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-custom \
           -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Committed revision 1161.
$
</screen>
      </informalexample>

      <!--
      <para>Okay.  At this point we have a vendor branch based on
        libcomplex 1.0.0.  We are now poised to begin making the
        customizations to libcomplex required for our
        purposes&mdash;committing them directly to the vendor branch
        we've created&mdash;and then to start using our customized
        libcomplex in our own application.</para>
      -->
      <para>现在, 我们拥有了基于 libcomplex 1.0.0 的供方分支, 接下来就可以按照
        项目的需要, 对 libcomplex 进行定制化修改&mdash;修改完成后直接提交到
        刚创建的供方分支里&mdash;然后再在自己的项目中使用定制过的 libcomplex.
      </para>

      <!--
      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  In order to perform that
        upgrade on our branch, we need to essentially apply the same
        set of changes the vendor has made between 1.0.0 and 1.0.1 to
        our vendor branch without clobbering our own customizations.
        The safest way to perform that application is to first get
        libcomplex 1.0.1 into our repository <emphasis>as a delta
        against the libcomplex 1.0.0 code in our
        repository</emphasis>.  Afterwards, we'll use the 2-URL form
        of the <command>svn merge</command> command to replicate those
        same changes into our vendor branch.</para>
      -->
      <para>一段时间后, 发布了 libcomplex 1.0.1. 通过查看修改日志, 我们打算
        把供方分支升级到新版. 为了升级供方分支, 我们需要把 1.0.0 和 1.0.1
        之间的差异应用到供方分支中, 而且不能影响定制化修改. 完成这项操作最
        案例的方式是先把 libcomplex 1.0.1 <emphasis>作为 libcomplex 1.0.0
          的增量版本</emphasis> 导入到我们的仓库中, 然后使用 二路 URL 形式的
        <command>svn merge</command>, 把差异应用到供方分支中.</para>

      <!--
      <para>As it turns out, there are several different approaches we
        can take to to get libcomplex 1.0.1 into our repository in the
        right way.<footnote><para>Using another <command>svn
        import</command> operation would be
        an <emphasis>incorrect</emphasis> approach, as the libcomplex
        1.0.0 and 1.0.1 branches would not have any common
        ancestry.</para></footnote>  The approach we'll describe here
        is relatively rudimentary, but it will serve our illustrative
        needs.</para>
      -->
      <para>事实证明, 有多种方式都可以正确地把 libcomplex 1.0.1 添加到仓库中.
        <footnote><para>不正确的做法是再使用一次 <command>svn import</command>,
            因为这将导致 libcomplex 1.0.0 和 libcomplex 1.0.1 不含有共同的祖
            先.</para></footnote> 我们在这里介绍的方法相对比较原始, 但作为说明
        已经足够了.</para>

      <!--
      <para>Remember, we want our mirror of the libcomplex 1.0.1
        vendor drop to share ancestry with our 1.0.0 vendor drop,
        which will produce the best results later when we need to
        merge the changes between those drops to our vendor branch.
        So we'll start by creating a libcomplex-1.0.1 branch as copy
        of our previously created libcomplex-1.0.0 <quote>vendor
        tag</quote>&mdash;a copy which will eventually become a
        replica of libcomplex 1.0.1.</para>
      -->
      <para>记住, 我们希望 libcomplex 1.0.1 在我们这儿的镜像能和 1.0.0 的镜像
        共享祖先, 这样的话在把它们之间的差异合并到供方分支时, 能产生最好的效果.
        于是, 首先通过复制 <quote>供方标签</quote> libcomplex-1.0.0 创建分支
        libcomplex-1.0.1&mdash;它最终将变成 libcomplex-1.0.1 的副本.</para>
        
      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
           -m "Setup a construction zone for libcomplex 1.0.1."
Committed revision 1282.
$
</screen>
      </informalexample>

      <!--
      <para>What we need now is to make a working copy of our
        libcomplex-1.0.1 branch, and then to make it actually look
        like libcomplex 1.0.1.  To do this, we'll take advantage of
        the fact that <command>svn checkout</command> can overlay an
        existing directory and, if the <option>- -force</option> option
        is provided, do so in manner that allows the differences
        between the checked-out tree and the target tree that the
        checkout overlayed to remain as local modifications in the new
        working copy.</para>
      -->
      <para>现在我们需要检出分支 libcomplex-1.0.1 的工作副本, 然后把工作副本
        中的代码升级到 1.0.1. 为了完成这些操作, 我们将利用这样一个事实, 就是
        <command>svn checkout</command> 可以覆盖已存在的目录, 并且如果提供了
        选项 <option>--force</option>, 那么检出的目录和被覆盖的目标目录之间
        的差异将作为本地修改, 留在工作副本中.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.1.tar.gz
libcomplex-1.0.1/
libcomplex-1.0.1/README
libcomplex-1.0.1/LICENSE
&hellip;
libcomplex-1.0.1/src/code.c
libcomplex-1.0.1/tests
libcomplex-1.0.1/tests/TODO
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
               libcomplex-1.0.1 \
               --force
E    libcomplex-1.0.1/README
E    libcomplex-1.0.1/LICENSE
E    libcomplex-1.0.1/INSTALL
&hellip;
E    libcomplex-1.0.1/src/code.c
E    libcomplex-1.0.1/tests
E    libcomplex-1.0.1/tests/TODO
Checked out revision 1282.
$ svn status libcomplex-1.0.1
M       libcomplex-1.0.1/src/code.h
M       libcomplex-1.0.1/src/code.c
M       libcomplex-1.0.1/README
$
</screen>
      </informalexample>

      <!--
      <para>As you can see, after checking out what was really
        libcomplex 1.0.0 atop the libcomplex 1.0.1 exploded tarball,
        we are left with a working copy that contains local
        modifications&mdash;those modifications required to morph our
        previous vendor release drop into our new one.</para>
      -->
      <para>可以看到, 在 libcomplex 1.0.1 的目录中检出 libcomplex 1.0.0 的
        代码, 将得到一个包含了本地修改的工作副本&mdash;正是这些修改, 把
        libcomplex 1.0.0 升级到 libcomplex 1.0.1.</para>

      <!--
      <para>Admittedly, this is a pretty simple example.  The changes
        required to perform this particular upgrade involved merely
        content changes to existing files.  In reality, new versions
        of third-party libraries might also add or remove files or
        directories, might rename files or directories, and so on.  In
        those situations, it can be much more challenging to morph the
        new vendor tag into a state where it accurately reflects the
        vendor drop it claims to reflect.  We'll leave the details of
        such transformations as an exercise to the
        reader.<footnote><para>Here's a hint, though: <userinput>svn
        add - -force /path/to/working-copy - -no-ignore
        - -no-auto-props</userinput> is super handy for adding any new
        vendor drop items to version control in this
        situation.</para></footnote></para>
      -->
  <para>的确, 这是一个非常简单的例子, 升级操作只涉及到已有文件的修改. 在实际
    工作中, 第三方函数库的新版修改可能还包括添加或删除文件 (目录), 重命名文
    件或目录等. 在这种情况下, 把供方标签升级到新版会困难得多, 作为训练, 具体
    的升级过程将留给读者完成.<footnote><para>提示: <userinput>svn
          add --force /path/to/working-copy --no-ignore
          --no-auto-props</userinput> 可以方便地把任意一个新的供方物资条目
        添加到仓库中.</para></footnote></para>

      <!--
      <para>However we make it happen, once our new vendor tag working
        copy is reconciled with the original source distribution, we
        can commit those changes to our repository.</para>
      -->
      <para>不管怎么, 我们成功地把供方标签的工作副本升级到了 libcomplex 1.0.1,
        然后提交修改.</para>

      <informalexample>
        <screen>
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-1.0.1
Sending        libcomplex-1.0.1/README
Sending        libcomplex-1.0.1/src/code.h
Sending        libcomplex-1.0.1/src/code.c
Transmitting file data ...
Committed revision 1283.
$
</screen>
      </informalexample>

      <!--
      <para>We're finally ready to upgrade our vendor branch.
        Remember, our goal is to get the changes made by the vendor
        between the 1.0.0 and 1.0.1 releases of their library into our
        vendor branch.  There is where a 2-URL <command>svn
        merge</command> operation, applied to a working copy of our
        vendor branch, comes into play.</para>
      -->
      <para>我们终于准备好了升级供方分支. 记住, 我们的目标是把原始的 1.0.1
        和 1.0.0 之间的差异应用到供方分支中. 下面展示了如何使用 二路 URL 形式的
        <command>svn merge</command> 去更新供方分支的工作副本.</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-custom \
               libcomplex-custom
E    libcomplex-custom/README
E    libcomplex-custom/LICENSE
E    libcomplex-custom/INSTALL
&hellip;
E    libcomplex-custom/src/code.c
E    libcomplex-custom/tests
E    libcomplex-custom/tests/TODO
Checked out revision 1283.
$ cd libcomplex-custom
$ svn merge ^/vendor/libcomplex-1.0.0 \
            ^/vendor/libcomplex-1.0.1
--- Merging differences between repository URLs into '.':
U    src/code.h
C    src/code.c
U    README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: 
</screen>
      </informalexample>

      <!--
      <para>As you can see, <command>svn merge</command> has merged
        the requisite changes into our working copy, flagging a
        conflict where the vendor modified the same region of one of
        the files as we did during our customizations.  Subversion
        detects this conflict, and gives us the opportunity to resolve
        it (using the methods described in
        <xref linkend="svn.tour.cycle.resolve" />) so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  Once we've resolved the conflicts and performed
        any testing or review we need, we can commit the changes to
        our vendor branch.</para>
      -->
      <para>可以看到, <command>svn merge</command> 将必要的修改合并到工作副本
        上, 并将修改区域重叠的文件标记为冲突. Subversion 检测到冲突后, 将允许
        用户解决冲突 (使用 <xref linkend="svn.tour.cycle.resolve" /> 介绍的方
        法), 使得我们的定制化修改在 libcomplex 1.0.1 中仍能正常工作. 冲突一旦
        解决, 并且审查与测试后都没出现什么问题, 就可以提交了.</para>

      <informalexample>
        <screen>
$ svn status
M       src/code.h
M       src/code.c
M       README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1."
Sending        README
Sending        src/code.h
Sending        src/code.c
Transmitting file data ...
Committed revision 1284.
$
</screen>
      </informalexample>

      <!--
      <para>Our vendor branch upgrade is complete.  And the next time
        we need to upgrade that branch, we'll follow the same
        procedure we used to upgrade it this time.</para>
      -->
      <para>到此为止, 供方分支的升级工作就算完成了. 如果将来还要再次升级, 仍然
        可以按照本节介绍的步骤进行操作.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.when">
      <!--
    <title>To Branch or Not to Branch?</title>
      -->
    <title>分支, 还是不分支?</title>

      <!--
    <para>To branch or not to branch&mdash;that is an interesting
      question.  This chapter has provided thus far a pretty deep dive
      into the waters of branching and merging, topics which have
      historically been the premier source of Subversion user
      confusion.  As if the rote actions involved in branching and
      branch management aren't sometimes tricky enough, some users get
      hung up on deciding whether they need to branch at all.  As
      you've learned, Subversion can handle common branching and
      branch management scenarios.  So, the decision of whether or not
      to branch a project's history is rarely a technical one.
      Rather, the social impact of the decision often carries more
      weight.  Let's examine some of the benefits and costs of using
      branches in a software project.</para>
      -->
    <para>分支还是不分支&mdash;这是一个有趣的问题. 本章非常深入地介绍了与分支
      和合并有关的知识, 这两者通常是 Subversion 用户困惑的主要来源. 虽然在分支
      的创建和管理中, 需要生搬硬套的内容并不复杂, 但是有些用户经常就是否需要创
      建分支而犹豫不决. 读者已经看到, Subversion 可以处理常见的分支管理场景,
      所以说决定是否需要为项目创建分支在技术上几乎不会产生什么影响, 它的社会
      影响反而占据更大的比重. 下面介绍一些在软件项目中使用分支的好处和代价.
    </para>

      <!--
    <para>The most obvious benefit of working on a branch is
      isolation.  Changes made to the branch don't affect the other
      lines of development in the project; changes made to those other
      lines don't affect the branch.  In this way, a branch can serve
      as a great place to experiment with new features, complex bug
      fixes, major code rewrites, and so on.  No matter how much stuff
      Sally breaks on her branch, Harry and the rest of the team can
      continue with their work unhindered outside the branch.</para>
      -->
    <para>使用分支最明显的好处是隔离性. 提交到分支上的修改不会影其他的开发线,
      提交到其他开发线的修改也不会影响分支. 利用这点, 开发人员就能安全地在分支
      上开发新特性, 对复杂的问题进行修正, 对代码进行重写等. 无论 Sally 在自己
      的分支上怎么折腾, Harry 和团队的其他人都可以不受阻碍地继承他们的工作.
    </para>

      <!--
    <para>Branches also provide a great way to organize related
      changes into readily identifiable collections.  For example, the
      changes which comprise the complete solution to a particular bug
      might be a list of non-sequential revision numbers.  You might
      describe them in human language as <quote>revisions 1534, 1543,
      1587 and 1588</quote>.  You'd probably reproduce those numbers
      manually (or otherwise) in the issue tracker artifact which
      tracks the bug.  When porting the bug fix to other product
      versions, you'd need to make sure to port all those revisions.
      But had those changes been made on a unique branch, you'd find
      yourself referring only to that branch by its name in
      conversation, in issue tracker comments, and when porting
      changes.</para>
      -->
    <para>利用分支, 我们可以把相关的修改都组织到一个容易识别的集合中, 比如说修
      正某个问题的修改可能由多次提交组成, 这些提交的版本号不是连续的. 用户可能
      会用人类容易理解的语言描述它们: "版本号 1534, 1543, 1587 和 1588", 很可
      能还要在问题跟踪系统中再手工地生成这些号码. 如果修正问题的修改需要被移植
      到其他版本中, 则开发人员还要确保不会遗漏任何一个版本号. 但是, 如果把这些
      修改都提交到一个独一无二的分支中, 那么在问题跟踪系统或移植修改时, 只需要
      引用分支的名字就能确定是哪些提交.</para>

      <!--
    <para>The unfortunate downside of branches, though, is that the
      very isolation that makes them so
      useful <emphasis>can</emphasis> be at odds with the
      collaborative needs of the project team.  Depending on the work
      habits of your project peers, changes made to branches might not
      get the kind of constructive review, criticism, and testing that
      changes made to the main line of development do.  The isolation
      of a branch can encourage users to forsake certain version
      control <quote>best practices</quote>, leading to version
      history which is difficult to review <foreignphrase>post
      facto</foreignphrase>.  Developers on long-lived branches
      sometimes need to work extra hard to ensure that the
      evolutionary direction of their isolated copy of the codebase is
      in harmony with the direction their peers are steering the main
      code lines.  Now, these drawbacks might be less of an issue for
      true exploratory branches aimed at experimenting with the future
      of a codebase with no expectation of reintegrating the results
      TODO
      back into the main development lines&mdash;mere policy needn't
      be a vision-killer!  But the simple fact remains that projects
      generally benefit from an orderly approach to version control
      where code and code changes enjoy the review and comprehension
      of more than one team member.</para>
      -->
    <para>然而, 使用分支的缺点是它的隔离性 <emphasis>会</emphasis> 与团队的
      协作需求相抵触. 取决于同事的工作习惯, 提交到分支上的修改可能不像主线上
      的修改那样, 得到非常充分的讨论, 审查与测试. 分支的隔离性会鼓励用户抛弃
      版本控制的 <quote>最佳做法</quote>, 导致版本历史难以在事后进行审查.
      在长期存在的分支上工作的开发人员有时候需要付出额外的努力, 以确保分支的
      演化方向与同事的保持一致. 对于有些分支而言, 这些缺点都不算是问题, 因为
      它们只是试探性的分支, 仅仅是在尝试代码库未来的发展方向, 将来不会被整合
      到主线上. 但是有一个简单的
      事实不容忽视, 那就是代码及其修改如果能得到更多人的审查与理解, 那么对项目
      而言通常是有好处的.</para>

      <!--
    <para>That's not to say that there are no technical penalties to
      branching.  Pardon us while we <quote>go meta</quote> for a bit
      here.  If you think about it, every time you checkout a
      Subversion working copy, you're creating a branch of sorts of
      your project.  It's a special sort of branch.  It lives only on
      your client machine; not in the repository.  You synchronize
      this branch with changes made in the repository
      using <command>svn update</command>&mdash;which acts almost like
      a special-cased, simplified form of an <command>svn
      merge</command> command.<footnote><para>Actually, you
      <emphasis>could</emphasis> use <userinput>svn merge
      -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>
      in your working copy to quite literally merge in all the
      repository changes since your last update if really wanted
      to!</para></footnote> You effectively reintegrate your branch
      each time you run <command>svn commit</command>.  So, in that
      special sense, Subversion users deal with branches and merges
      all the time.  Given the similarities between updating and
      merging, it's no surprise, then, that the areas in which
      Subversion seems to have the most shortcomings&mdash;namely,
      handling file and directory renames and dealing with tree
      conflicts in general&mdash;are problematic for both
      the <command>svn update</command> and <command>svn
      merge</command> operations.  Unfortunately, <command>svn
      merge</command> has a harder time of it precisely because of the
    TODO
      fact that, for every way in which <command>svn update</command>
      is a special-cased, simplified kind of generic merge operation,
      a true Subversion merge is neither special-cased nor simplified.
      For this reason, merges perform much more slowly than updates,
      require explicit tracking (via
      the <literal>svn:mergeinfo</literal> property we've discussed in
      this chapter) and history-crunching arithmetic, and generally
      offer more opportunities for something to go awry.</para>
      -->
    <para>并不是说使用分支在技术上一点坏处都没有. 如果我们从更抽象的层次来
      看待分支, 就会发现
      每次检出仓库的工作副本, 从某种意义上来说其实就是在创建分支, 这只是分支
      的一种特殊类型, 它只存在于客户端主机, 不在仓库里, 用 <command>svn
        update</command> 把仓库的修改同步到分支上&mdash;非常像特殊情况下的,
      简化版的 <command>svn merge</command>;<footnote><para>实际上, 你
          <emphasis>可以</emphasis> 在工作副本中用 <userinput>svn merge
            -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>,
          逐字地把仓库中的自从上一次更新后的修改合并到工作副本.</para>
      </footnote> <command>svn commit</command> 等效于重新整合分支. 所以说从
      这个角度来看, Subversion 用户其实一直都在和分支与合并打交道. 不用对
      更新与合并之间的相似性过于惊讶, Subversion 短处最集中的地方&mdash;也就是
      对文件和目录重命名的处理, 以及目录冲突的处理&mdash;都会给 <command>svn
        update</command> 和 <command>svn merge</command> 造成麻烦. 不幸的是
      <command>svn merge</command> 的麻烦更大, 一个真正的合并操作既不针对特殊
      情况, 也不简单. 由于这个原因, 合并操作执行起来比更新更慢, 还要求显式的跟
      踪 (通过本章讨论过的属性 <literal>svn:mergeinfo</literal>) 和历史分析计
      算, 而且出错的机会也更多.</para>

      <!--
    <para>To branch or not to branch?  Ultimately, that depends on
      what your team needs in order to find that sweet balance of
      collaboration and isolation.</para>
      -->
    <para>分支, 还是不分支? 归根结底还要看开发团队如何把握协作与隔离之间的
      平衡.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
      <!--
    <title>Summary</title>
      -->
    <title>小结</title>

      <!--
    <para>We covered a lot of ground in this chapter.  We
      discussed the concepts of tags and branches and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We showed how
      to use <command>svn merge</command> to copy changes from one
      branch to another or roll back bad changes.  We went over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>
      -->
    <para>这一章我们讲了很多. 首先介绍了标签和分支的概念, 并说明了 Subversion
      如何通过 <command>svn copy</command> 复制目录来实现这两个功能. 然后展示
      了如何使用 <command>svn merge</command> 把修改从一个分支复制到另一个分支
      上, 或回退错误的修改. 再然后介绍了如何使用 <command>svn switch</command>
      创建具有混合位置的工作副本. 最后我们讨论了如何管理分支的组织与生存周期.
    </para>

      <!--
    <para>Remember the Subversion mantra: branches and tags are cheap.
      So don't be afraid to use them when needed!</para>
      -->
    <para>记住, Subversion 的分支和标签是很廉价的, 所以当你需要时请尽管使用!
    </para>

      <!--
    <para>As a helpful reminder of all the operations we discussed,
      here is handy reference table you can consult as
      you begin to make use of branches.</para>
      -->
    <para>为了方便读者, 下面的表格总结了与分支有关的常见操作及其对应的命令.
    </para>

    <table id="svn.branchmerge.summary.tbl-1">
      <!--
      <title>Branching and merging commands</title>
      -->
      <title>分支与合并命令</title>
      <tgroup cols="2">
        <thead>
          <row>
      <!--
            <entry>Action</entry>
            <entry>Command</entry>
      -->
            <entry>操作</entry>
            <entry>命令</entry>
          </row>
        </thead>
        <tbody>
          <row>
      <!--
            <entry>Create a branch or tag</entry>
      -->
            <entry>创建一个分支或标签</entry>
            <entry><userinput>svn copy <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
      <!--
            <entry>Switch a working copy to a branch or tag</entry>
      -->
            <entry>把工作副本切换到另一个分支或标签</entry>
            <entry><userinput>svn switch <replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
      <!--
            <entry>Synchronize a branch with trunk</entry>
      -->
            <entry>将分支与主干同步</entry>
            <entry><userinput>svn merge <replaceable>trunkURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
      <!--
            <entry>See merge history or eligible changesets</entry>
      -->
            <entry>查看合并历史或可合并的变更集</entry>
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
          </row>

          <row>
      <!--
            <entry>Merge a branch back into trunk</entry>
      -->
            <entry>将分支合并至主干</entry>
            <entry><userinput>svn merge <replaceable>branchURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Merge one specific change</entry>
      -->
            <entry>合并一个特定的修改</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Merge a range of changes</entry>
      -->
            <entry>合并一段范围的修改</entry>
            <entry><userinput>svn merge -r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Block a change from automatic merging</entry>
      -->
            <entry>从自动合并中拦截某个特定的修改</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> --record-only <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Preview a merge</entry>
      -->
            <entry>合并预览</entry>
            <entry><userinput>svn merge <replaceable>URL</replaceable> --dry-run</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Abandon merge results</entry>
      -->
            <entry>放弃合并的结果</entry>
            <entry><userinput>svn revert -R .</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Resurrect something from history</entry>
      -->
            <entry>从历史中恢复文件</entry>
            <entry><userinput>svn copy <replaceable>URL</replaceable>@<replaceable>REV</replaceable> <replaceable>localPATH</replaceable></userinput></entry>
          </row>

          <row>
      <!--
            <entry>Undo a committed change</entry>
      -->
            <entry>撤消已提交的修改</entry>
            <entry><userinput>svn merge -c -<replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Examine merge-sensitive history</entry>
      -->
            <entry>查看对合并敏感的历史</entry>
            <entry><userinput>svn log -g; svn blame -g</userinput></entry>
          </row>

          <row>
      <!--
            <entry>Create a tag from a working copy</entry>
      -->
            <entry>从工作副本创建一个标签</entry>
            <entry><userinput>svn copy . <replaceable>tagURL</replaceable></userinput></entry>
          </row>

          <row>
      <!--
            <entry>Rearrange a branch or tag</entry>
      -->
            <entry>重新安排分支或标签的布局</entry>
            <entry><userinput>svn move <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
      <!--
            <entry>Remove a branch or tag</entry>
      -->
            <entry>删除分支或标签</entry>
            <entry><userinput>svn delete <replaceable>URL</replaceable></userinput></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->


