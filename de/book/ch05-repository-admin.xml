<!-- -*- sgml -*- -->

<chapter id="svn.reposadmin">
<!--
  <title>Repository Administration</title>
-->
  <title>Verwaltung des Projektarchivs</title>

<!--
  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>
-->
  <para>Das Subversion-Projektarchiv ist die zentrale Lagerhalle für
    Ihre versionierten Daten. In dieser Rolle kann es sich aller Liebe
    und Zuneigung des Administrators gewiss sein. Obwohl das
    Projektarchiv an sich im Allgemeinen wenig Pflege erfordert, ist es
    wichtig, zu wissen, wie es angemessen konfiguriert und gepflegt
    wird, um etwaige Probleme zu vermeiden und bestehende Probleme
    sicher aufzulösen.</para>

<!--
  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use various
    related tools provided with Subversion.  We'll address some common
    questions and mistakes and give some suggestions on how to arrange
    the data in the repository.</para>
-->
  <para>In diesem Kapitel werden wir erörtern, wie ein
    Subversion-Projektarchiv aufgesetzt und konfiguriert wird. Wir werden
    auch über die Projektarchiv-Pflege reden und Beispiele dafür geben,
    wann und wie die verschiedenen mit Subversion mitgelieferten
    Werkzeuge verwendet werden. Wir werden einige verbreitete Fragen
    und Fehler besprechen und Vorschläge unterbreiten, wie die Daten
    im Projektarchiv organisiert werden können.</para>

<!--
  <para>If you plan to access a Subversion repository only in the role
    of a user whose data is under version control (i.e., via a
    Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,<footnote><para>This may sound really prestigious
    and lofty, but we're just talking about anyone who is interested
    in that mysterious realm beyond the working copy where everyone's
    data hangs out.</para></footnote> this chapter is for you.</para>
-->
  <para>Falls Sie vorhaben, das Projektarchiv lediglich in der Rolle
    eines Anwenders zu verwenden, der seine Daten unter
    Versionskontrolle stellen möchte (d.h., über einen
    Subversion-Client), können Sie dieses Kapitel vollständig
    überspringen. Wenn Sie jedoch ein
    Subversion-Projektarchiv-Administrator sind oder werden wollen,
    <footnote><para>Das hört sich vielleicht prestigeträchtig und
    hochmütig an, doch wir meinen lediglich jeden, der an diesem
    mysteriösen Bereich hinter der Arbeitskopie interessiert ist, wo
    sich alle Daten befinden.</para></footnote> dann ist dieses
    Kapitel für Sie gemacht.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
<!--
    <title>The Subversion Repository, Defined</title>
-->
    <title>Das Subversion Projektarchiv, Definition</title>

<!--
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective&mdash;how a repository looks and
      acts with respect to non-Subversion tools&mdash;and from a
      logical perspective&mdash;dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>
-->
    <para>Bevor wir uns in das weite Feld der Projektarchiv-Verwaltung
      begeben, wollen wir definieren, was ein Projektarchiv ist. Wie
      sieht es aus? Wie fühlt es sich an? Trinkt es seinen Tee heiß
      oder mit Eis, gesüßt oder mit Zitrone? Als Administrator wird
      von Ihnen erwartet, dass Sie den Aufbau eines Projektarchivs sowohl
      auf der physischen Betriebssystemebene verstehen &ndash; wie sich
      ein Subversion-Projektarchiv aussieht und wie es sich gegenüber
      Nicht-Subversion-Werkzeugen verhält &ndash; als auch aus einer
      logischen Perspektive &ndash; wie Daten
      <emphasis>innerhalb</emphasis> des Projektarchivs repräsentiert
      werden.</para>

<!--
    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>
-->
    <para>Mit den Augen eines typischen Datei-Browsers (wie Windows
      Explorer) oder von kommandozeilen-orientierten
      Dateisystem-Navigationswerkzeugen ist das Subversion-Projektarchiv
      bloß ein weiteres gewöhnliches Verzeichnis voller Zeugs. Es gibt
      einige Unterverzeichnisse mit Konfigurationsdateien, die für
      Menschen lesbar sind, einige Unterverzeichnisse mit weniger
      lesbaren Dateien usw. Wie in anderen Bereichen des
      Subversion-Designs, wird auch hier viel Wert auf Modularität
      gesetzt, und hierarchische Organisation wird vollgepfropftem
      Chaos vorgezogen. Ein flacher Blick in ein typisches Projektarchiv
      aus praxisbezogener Sicht reicht aus, um die grundlegenden
      Komponenten des Projektarchivs zu offenbaren.</para>

    <informalexample>
      <screen>
$ ls repos
conf/  db/  format  hooks/  locks/  README.txt
</screen>
    </informalexample>

<!--
    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology&mdash;detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>
-->
    <para>Hier ist ein schneller, oberflächlicher Überblick über das,
      was Sie in diesem Verzeichnisauflistung sehen. (Verzetteln Sie sich
      nicht mit den Fachausdrücken &ndash; eine detaillierte
      Behandlung dieser Komponenten erfolgt an anderer Stelle in
      diesem und in anderen Kapiteln.)</para>

    <variablelist>
      <varlistentry>
        <term>conf/</term>
        <listitem>
<!--
          <para>This directory is a container for configuration
            files.</para>
-->
          <para>Dieses Verzeichnis beinhaltet Konfigurationsdateien.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db/</term>
        <listitem>
<!--
          <para>This directory contains the data store for all of your
            versioned data.<footnote><para>Strictly speaking,
            Subversion doesn't dictate that the versioned data live
            here, and there are known (albeit proprietary) alternative
            backend storage implementations which do not, in fact,
            store data in this directory.</para></footnote></para>
-->
          <para>Dieses Verzeichnis beinhaltet den Datenspeicher für
            all Ihre versionierten Daten.<footnote><para>Streng
            genommen schreibt Subversion nicht vor, dass die
            versionierten Daten hier abgelegt sind und es sind
            alternative (wenn auch proprietäre) Speicher-Back-Ends
            bekannt, die Daten tatsächlich nicht in diesem Verzeichnis
            speichern.</para></footnote></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
<!--
          <para>This file describes the repository's internal
            organizational scheme.  (As it turns out,
            the <filename>db/</filename> subdirectory sometimes also
            contains a <filename>format</filename> file which
            describes only the contents of that subdirectory and which
            is not to be confused with this file.)</para>
-->
          <para>Diese Datei beschreibt das Organisationsschema des
            Projektarchivs. (Wie es sich herausstellt, beinhaltet das
            Verzeichnis <filename>db/</filename> manchmal auch eine
            Datei <filename>format</filename>, die nur den Inhalt
            dieses Verzeichnisses beschreibt und nicht mit dieser
            Datei verwechselt werden sollte.)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks/</term>
        <listitem>
<!--
          <para>This directory contains hook script templates and
            hook scripts, if any have been installed.</para>
-->
          <para>Dieses Verzeichnis beinhaltet Hook-Skript-Vorlagen und
            Hook-Skripte, sofern welche installiert worden
            sind.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks/</term>
        <listitem>
<!--
          <para>Subversion uses this directory to house repository
            lock files, used for managing concurrent access to the
            repository.</para>
-->
          <para>Subversion verwendet dieses Verzeichnis, um
            Sperrdateien des Subversion-Projektarchivs unterzubringen,
            die benutzt werden, um gleichzeitigen Zugriff auf das
            Projektarchiv zu verwalten.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
<!--
          <para>This is a brief text file containing merely a notice
            to readers that the directory they are looking in is a
            Subversion repository.</para>
-->
          <para>Dies ist eine kurze Textdatei, die bloß eine
            Mitteilung für die Leser enthält, dass das Verzeichnis, in
            das sie schauen, ein Subversion-Projektarchiv ist.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
<!--
      <para>

        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activities</secondary>
        </indexterm>Prior to Subversion 1.5, the on-disk repository
        structure also always contained a <filename>dav</filename>
        subdirectory. <filename>mod_dav_svn</filename> used this
        directory to store information about
        WebDAV <firstterm>activities</firstterm>&mdash;mappings of
        high-level WebDAV protocol concepts to Subversion commit
        transactions.  Subversion 1.5 changed that behavior, moving
        ownership of the activities directory, and the ability to
        configure its location, into <filename>mod_dav_svn</filename>
        itself.  Now, new repositories will not necessarily have
        a <filename>dav</filename> subdirectory
        unless <filename>mod_dav_svn</filename> is in use and hasn't
        been configured to store its activities database elsewhere.
        See <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" />
        for more information.</para>
-->
      <para>
        <indexterm>
          <primary>WebDAV</primary>
          <secondary>Aktivitäten</secondary>
        </indexterm>Vor Subversion 1.5 besaß die Projektarchiv-Struktur auf
        der Festplatte ein Unterverzeichnis <filename>dav</filename>.
        <filename>mod_dav_svn</filename> verwendete dieses
        Verzeichnis, um Informationen über WebDAV
        <firstterm>Aktivitäten</firstterm> zu speichern &ndash;
        Abbildungen von High-Level WebDAV Protokoll-Konzepten auf
        Subversion Übergabe-Transaktionen. Subversion 1.5 änderte
        dieses Verhalten, indem das Eigentum über das
        Aktivitäten-Verzeichnis und die Möglichkeit, dessen Ort zu
        konfigurieren, an <filename>mod_dav_svn</filename> selbst
        übertragen wurde. Nun benötigen neue Projektarchive nicht
        unbedingt ein Unterverzeichnis  <filename>dav</filename>, es
        sei denn,  <filename>mod_dav_svn</filename> wird verwendet und
        wurde nicht dergestalt konfiguriert, dass seine
        Aktivitäten-Datenbank an einem anderen Ort abgelegt wird.
        Siehe <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn"/>
        für weitere Informationen.</para>
    </note>

<!--
    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem&mdash;it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>
-->
    <para>Selbstverständlich wird diese sonst so unauffällige
      Ansammlung aus Dateien und Verzeichnissen, wenn auf sie über die
      Subversion-Bibliotheken zugegriffen wird, eine Implementierung
      eines virtuellen, versionierten Dateisystems, vollständig mit
      anpassbaren Ereignis-Triggern. Dieses Dateisystem hat seine
      eigene Auffassung von Verzeichnissen und Dateien, sehr ähnlich
      den Auffassungen, die echte Dateisysteme (wie NTFS, FAT32, ext3
      usw.) von solchen Dingen haben. Aber dies ist ein spezielles
      Dateisystem &ndash; es hängt diese Dateien und Verzeichnisse an
      Revisionen und hält alle Änderungen, die Sie daran vorgenommen
      haben, sicher abgespeichert und für immer abrufbereit. Hier lebt
      die Gesamtheit Ihrer versionierten Daten.</para>

    <sidebar id="svn.reposadmin.basics.backends">
      <title>Speaking of Filesystems&hellip;</title>

<!--
      <para>When the initial design phase of Subversion was in
        progress, the developers decided to use Berkeley DB (BDB) as
        the storage mechanism behind the virtual versioned filesystem
        implementation.  Berkeley DB was a logical choice for a
        variety of reasons, including its open source license,
        transaction support, reliability, performance, API simplicity,
        thread safety, support for cursors, and so on.</para>
-->
      <para>Während der anfänglichen Entwurfsphase von Subversion
        entschieden sich die Entwickler, Berkeley DB (BDB) als
        Speichermechanismus hinter der Implementierung des virtuellen
        versionierten Dateisystems zu verwenden. Berkeley DB war eine
        vernünftige Wahl aus verschiedenen Gründen; hierzu zählen die
        quelloffene Lizenz, Transaktionsunterstützung,
        Zuverlässigkeit, Arbeitsleistung, Einfachheit der
        Programmierschnittstelle, Thread-Sicherheit,
        Cursor-Unterstützung usw.</para>

<!--
      <para>In the years since, the
        newer <firstterm>FSFS</firstterm><footnote><para>While it is
        often pronounced <quote>fuzz-fuzz,</quote> per Jack
        Repenning's rendition, this book assumes that the reader is
        thinking <quote>eff-ess-eff-ess.</quote></para></footnote>
        backend was introduced.  This so-called <quote>filesystem
        filesystem</quote> was a versioned filesystem implemented not
        within an opaque database container, but instead as a larger
        collection of more transparent files stored in the OS's
        filesystem.  FSFS enjoyed continual development and
        improvement, and eventually earned the right to be the default
        Subversion backend.  But improvements to that backend kept
        coming, and ultimately the FSFS storage layer surpassed the
        Berkeley DB one in nearly every meaningful metric, from
        performance to scalability to reliability and beyond.</para>
-->
      <para>Während der darauf folgenden Jahre wurde das neuere
        <firstterm>FSFS</firstterm><footnote><para>Obwohl es oft
        gemäß Jack Repennings Wiedergabe als <quote>fass-fass</quote>
        ausgesprochen wird, geht dieses Buch davon aus, dass der Leser
        an <quote>ef-es-ef-es</quote> denkt.</para></footnote>
        Backend vorgestellt. Dieses sogenannte
        <quote>Dateisystem-Dateisystem</quote> war ein versioniertes
        Dateisystem, das nicht innerhalb eines undurchsichtigen
        Datenbank-Containers implementiert war, sondern stattdessen
        als eine Sammlung transparenterer Dateien, die im Dateisystem
        des Betriebssystems abgelegt wurden. FSFS erfreute sich
        beständiger Entwicklung und Verbesserung und verdiente sich
        schließlich das Recht, das standardmäßige Backend von
        Subversion zu sein. Verbesserungen an diesem Backend
        erschienen weiter, so dass am Ende die FSFS-Speicherschicht
        die der Berkeley DB in beinahe jeder bedeutsamen Metrik
        übertraf; von Leistungsfähigkeit über Skalierbarkeit sowie
        Zuverlässigkeit und darüber hinaus.</para>

<!--
      <para>These days, it is generally assumed that if you are using
        the open source Subversion product, you are using the FSFS
        backend for your repositories.  In fact, beginning with
        Subversion 1.8, the Berkeley DB Subversion repository
        filesystem backend has been officially deprecated.  Subversion
        repositories which still use this storage layer option will
        continue to function with newer Subversion 1.x releases, but
        no further development&mdash;including feature introduction or
        expansion&mdash;is planned for the Berkeley DB backend.
        Subversion effectively offers a single viable repository
        storage layer option.  FSFS won.</para>
-->
      <para>Heutzutage wird im Allgemeinen angenommen, dass Sie beim
        Arbeiten mit dem Open-Source-Produkte Subversion das
        FSFS-Backend für Ihre Projektarchive verwenden. Tatsächlich
        wurde beginnend mit Subversion 1.8 das Berkeley DB
        Subversion-Projektarchiv Dateisystem-Backend offiziell als
        veraltet erklärt. Subversion-Projektarchive, die diese
        Speicherschicht immer noch verwenden, werden auch mit neueren
        Subversion 1.x Releases funktionieren, jedoch ist für das
        Berkeley DB Backend keine weitere Entwicklung geplant, auch
        keine neuen Funktionalitäten oder Erweiterungen.  Subversion
        bietet gewissermaßen eine einzige brauchbare Option für die
        Speicherschicht eines Projektarchivs. FSFS hat
        gewonnen.</para>

<!--
      <para>This book will continue to provide information relevant to
        administrators of BDB-backed repositories where it makes sense
        to do so, but most of this chapter will assume what the rest
        of the world does: that FSFS is <emphasis>the</emphasis>
        Subversion storage backend implementation.  Please refer to
        <xref linkend="svn.berkeleydb"/> or to older versions of this
        documentation for more complete information about
        administering such repositories.</para>
-->
      <para>Dieses Buch wird weiterhin Informationen liefern, die
        relevant für Administratoren von Projektarchiven mit
        BDB-Backend liefern, sofern es sinnvoll erscheint, doch geht
        ein großer Teil dieses Kapitels davon aus, wovon auch der Rest
        der Welt ausgeht: dass FSFS <emphasis>die</emphasis>
        Implementierung eines Subversion Speicher-Backends ist.
        Schauen Sie unter <xref linkend="svn.berkeleydb"/> oder
        älteren Versionen dieser Dokumentation, um vollständigere
        Informationen über die Verwaltung solcher Projektarchive zu
        erhalten.</para>
    </sidebar>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
<!--
    <title>Strategies for Repository Deployment</title>
-->
    <title>Strategien für die Verwendung eines Projektarchivs</title>

<!--
    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>
-->
    <para>Größtenteils wegen der Einfachheit des Gesamtentwurfs des
      Subversion-Projektarchivs und der ihm zugrunde liegenden Technik,
      ist die Erstellung und Konfiguration eines Projektarchivs eine
      ziemlich unkomplizierte Aufgabe. Es gibt einige Entscheidungen,
      die Sie im Vorfeld treffen sollten, jedoch sind die eigentlichen
      Arbeitsschritte für die Einrichtung eines Subversion-Projektarchivs
      recht einfach und neigen zur stupiden Fleißarbeit, falls Sie
      mehrere davon aufzusetzen haben.</para>

<!--
    <para>Some things you'll want to consider beforehand, though, are:</para>
-->
    <para>Einige Dinge, die Sie jedoch im Vorfeld sorgfältig prüfen
      sollten, sind:</para>

    <itemizedlist>
      <listitem>
<!--
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
-->
        <para>Welche Art von Daten sollen in Ihrem Projektarchiv (oder
          Projektarchiven) abgelegt werden, und wie sind diese Daten
          organisiert?</para>
      </listitem>
      <listitem>
<!--
        <para>Where will your repository live, and how will it be
          accessed?</para>
-->
        <para>Wo soll Ihr Projektarchiv untergebracht werden, und wie
          soll darauf zugegriffen werden?</para>
      </listitem>
      <listitem>
<!--
        <para>What types of access control do you need?</para>
-->
        <para>Welche Art von Zugriffskontrolle benötigen Sie?</para>
      </listitem>
    </itemizedlist>

<!--
    <para>In this section, we'll try to help you answer those
      questions.</para>
-->
    <para>In diesem Abschnitt werden wir versuchen, Ihnen beim
      Beantworten dieser Fragen zu helfen.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
<!--
      <title>Planning Your Repository Organization</title>
-->
      <title>Planung der Organisation Ihres Projektarchivs</title>

<!--
      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>
-->
      <para>Obwohl Subversion Ihnen erlaubt, versionierte Dateien und
        Ordner ohne Informationsverlust hin und her zu verschieben und
        sogar Methoden anbietet, um versionierte Geschichte von einem
        Projektarchiv in ein anderes zu verschieben, kann das ziemlich
        den Arbeitsablauf derjenigen stören, die oft auf das
        Projektarchiv zugreifen und gewisse Dinge an bestimmten Orten
        erwarten. Bevor Sie ein neues Projektarchiv erstellen, sollten
        Sie also versuchen, ein wenig in die Zukunft zu schauen;
        planen Sie weitsichtig, bevor Sie Ihre Daten unter
        Versionskontrolle stellen. Durch die vorzeitige gewissenhafte
        <quote>Anlage</quote> Ihres Projektarchivs oder mehrerer
        Projektarchive können Sie viel künftigen Kopfschmerz
        vermeiden.</para>

<!--
      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>
-->
      <para>Nehmen wir an, Sie seien als Projektarchiv-Administrator für
        die Versions-Kontroll-Systeme mehrerer Projekte zuständig. Ihre
        erste Entscheidung ist, ob Sie ein einzelnes Projektarchiv für
        mehrere Projekte verwenden, jedem Projekt sein eigenes
        Projektarchiv geben oder einen Kompromiss aus diesen beiden
        Lösungen  haben wollen.</para>

<!--
      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>
-->
      <para>Ein einzelnes Projektarchiv für mehrere Projekte zu
        verwenden, hat einige Vorteile, am offensichtlichsten ist der
        vermiedene doppelte Verwaltungsaufwand. Ein einzelnes
        Projektarchiv bedeutet, dass es nur einen Satz Hook-Programme,
        ein Ding zum routinemäßigen Sichern, ein Ding für einen Auszug
        und zum anschließenden Laden nach einer inkompatiblen neuen
        Version von Subversion gibt usw. Sie können Daten auch einfach
        zwischen Projekten verschieben, ohne historische
        Versionierungs=Informationen zu verlieren.</para>

<!--
      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course&mdash;it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.<footnote><para>Whether founded in
        ignorance or in poorly considered concepts about how to derive
        legitimate software development metrics, global revision
        numbers are a silly thing to fear,
        and <emphasis>not</emphasis> the kind of thing you should
        weigh when deciding how to arrange your projects and
        repositories.</para></footnote></para>
-->
      <para>Der Nachteil bei der Verwendung eines einzelnen
        Projektarchivs ist, dass unterschiedliche Projekte auch
        unterschiedliche Anforderungen hinsichtlich der
        Projektarchiv-Ereignis-Trigger haben, wie etwa
        Benachrichtigungs-E-Mails bei Übertragungen an unterschiedliche
        Verteiler, oder unterschiedliche Definitionen dazu, was eine
        berechtigte Übergabe ist und was nicht. Das sind natürlich
        keine unüberwindbaren Probleme &ndash; es bedeutet nur, dass
        all Ihre Hook-Skripte die Struktur Ihres Projektarchivs beachten
        müssen, anstatt davon auszugehen, dass das gesamte Projektarchiv
        von einer einzelnen Gruppe zugeordnet ist. Beachten Sie auch,
        dass Subversion Versionsnummern verwendet, die global für das
        gesamte Projektarchiv gelten. Obwohl diese Nummern keine
        Zauberkräfte haben, mögen manche Zeitgenossen es trotzdem
        nicht, dass, obwohl in letzter Zeit keine Änderungen in ihrem
        Projekt durchgeführt worden sind, die jüngste Versionsnummer
        im Projektarchiv ständig höher wird, weil andere Projekte fleißig
        neue Revisionen hinzufügen.<footnote><para>Ob es an Ignoranz
        oder an schlecht überlegten Konzepten zur Erstellung
        berechtigter Metriken für die Software-Entwicklung liegt,  ist
        es dumm, Angst vor globalen Revisionsnummern zu haben, und es
        ist deshalb <emphasis>kein</emphasis> Kriterium, das Sie
        heranziehen sollten, wenn Sie abwägen, wie Sie Ihre Projekte
        und Projektarchive anlegen wollen.</para></footnote></para>

<!--
      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>
-->
      <para>Es kann auch eine Lösung in der Mitte gewählt werden.
        Beispielsweise können Projekte danach geordnet werden, wie
        stark sie miteinander verbunden sind. Sie könnten ein paar
        Projektarchive haben, die jeweils eine handvoll Projekte
        beherbergen. Auf diese Art können Projekte, die wahrscheinlich
        gemeinsame Daten verwenden wollen, dies auch einfach
        bewerkstelligen, und wenn dem Projektarchiv neue Versionen
        hinzugefügt werden, wissen die Entwickler wenigstens, dass
        diese neuen Revisionen zumindest entfernt eine Beziehung zu
        jedem Anwender dieses Projektarchivs haben.</para>

<!--
      <para>
        <indexterm>
          <primary>project root</primary>
        </indexterm>

        After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each project
        root&mdash;the <quote>topmost</quote> directory
        that contains data related to that project&mdash;and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.<footnote><para>The <filename>trunk</filename>,
        <filename>tags</filename>, and <filename>branches</filename>
        trio is sometimes referred to as <quote>the TTB
        directories.</quote></para></footnote></para>
-->
      <para>Nachdem Sie entschieden haben, wie Sie Ihre Projekte in
        Projektarchive aufteilen, möchten Sie sich nun vielleicht
        Gedanken darüber machen, welche Verzeichnis=Hierarchien Sie im
        Projektarchiv anlegen wollen. Da Subversion zum Verzweigen und
        Etikettieren reguläre Verzeichniskopien verwendet (siehe <xref
        linkend="svn.branchmerge"/>), empfiehlt die
        Subversion-Gemeinschaft, dass Sie einen Ort im Projektarchiv für
        jedes <firstterm>Projekt-Wurzelverzeichnis</firstterm> wählen
        &ndash; das oberste Verzeichnis, das Daten für Ihr Projekt
        enthält &ndash; und hierunter dann drei Unterverzeichnisse
        anlegen: <filename>trunk</filename>, das Verzeichnis, in dem
        die Hauptentwicklung stattfindet,
        <filename>branches</filename>, zur Aufnahme verschiedener
        Zweige der Hauptentwicklungslinie und
        <filename>tags</filename>, als Sammlung von Momentaufnahmen
        des Verzeichnisbaums, die erzeugt, vielleicht gelöscht, jedoch
        nie verändert werden.<footnote><para>Das Trio
        <filename>trunk</filename>, <filename>tags</filename> und
        <filename>branches</filename> wird manchmal als <quote>die
        TTB-Verzeichnisse</quote> bezeichnet.</para></footnote></para>

<!--
      <para>For example, your repository might look like this:</para>
-->
      <para>Ihr Projektarchiv könnte z.B. so aussehen:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</literallayout>
      </informalexample>

<!--
      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>
-->
      <para>Beachten Sie, dass es unerheblich ist, wo in Ihrem
        Projektarchiv sich das Wurzelverzeichnis Ihres Projektes
        befindet.  Falls Sie nur ein Projekt pro Projektarchiv haben, ist
        der logische Ort für das Wurzelverzeichnis des Projektes das
        Wurzelverzeichnis des zum Projekt gehörenden Projektarchivs.
        Falls Sie mehrere Projekte haben, möchten Sie diese vielleicht
        innerhalb des Projektarchivs gruppieren, indem Sie Projekte
        ähnlichen Zwecks in demselben Unterverzeichnis unterbringen
        oder sie vielleicht nur alphabetisch gruppieren. Eine solche
        Anordnung könnte so aussehen:</para>

      <informalexample>
        <literallayout>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</literallayout>
      </informalexample>

<!--
      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>
-->
      <para>Legen Sie Ihr Projektarchiv so an, wie es Ihnen am besten
        passt.  Subversion erwartet oder erzwingt keine bestimmte
        Anordnung &ndash; für Subversion ist und bleibt ein
        Verzeichnis ein Verzeichnis. Letztendlich sollten Sie für ein
        Projektarchiv eine Struktur wählen, die den Bedürfnissen der
        Leute gerecht wird, die an den Projekten arbeiten, die dort
        untergebracht sind.</para>

<!--
      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>
-->
      <para>Der Vollständigkeit halber erwähnen wir noch eine weitere,
        verbreitete Anordnung. Bei dieser Anordnung befinden sich die
        Verzeichnisse <filename>trunk</filename>,
        <filename>tags</filename> und <filename>branches</filename> im
        Wurzelverzeichnis des Projektarchivs und die Projekte in
        Unterverzeichnissen davon:</para>

      <informalexample>
        <literallayout>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</literallayout>
      </informalexample>

<!--
      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons&mdash;it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history&mdash;past, present, tagged, and branched&mdash;for
        that project and that project alone.</para>
-->
      <para>An dieser Anordnung ist zwar nichts verkehrt, allerdings
        könnte es für Ihre Anwender mehr oder weniger intuitiv sein.
        Besonders in Situationen mit vielen Projekten und entsprechend
        vielen Anwendern, kann es vorkommen, dass die Anwender
        gewöhnlich nur mit einem oder zwei dieser Projekte vertraut
        sind. Allerdings schwächt dieser
        Projekt-als-Geschwister-Zweig-Ansatz die Betonung auf
        Projekt-Individualität und betrachtet die Gesamtmenge der
        Projekte als Ganzes. Das ist jedoch ein sozialer Aspekt. Wir
        mögen unseren ursprünglich geäußerten Vorschlag aus rein
        praktischen Erwägungen &ndash; es ist einfacher, in der
        kompletten Historie eines einzelnen Projektes zu forschen
        (oder sie zu verändern oder woanders hin zu migrieren), wenn es
        einen einzelnen Pfad im Projektarchiv gibt, der die gesamte
        Historie für dieses eine Projekt, und nur dieses,  beinhaltet
        &ndash; die Vergangenheit, Tags und Zweige.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
<!--
      <title>Deciding Where and How to Host Your Repository</title>
-->
      <title>Entscheiden Sie, wo und wie Ihr Projektarchiv untergebracht
        werden soll</title>

<!--
      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>
-->
      <para>Bevor Sie Ihr Subversion-Projektarchiv anlegen, bleibt die
        offensichtliche Frage zu beantworten, wo das Ding hin soll.
        Das hängt eng mit etlichen weiteren Fragen zusammen, etwa wie
        auf das Projektarchiv zugegriffen werden soll (über einen
        Subversion-Server oder direkt), wer darauf zugreifen soll
        (Anwender hinter Ihrer Firmen-Firewall oder die weite Welt im
        offenen Netz), welche zusätzlichen Dienste Sie im Zusammenhang
        mit Subversion anbieten wollen (Schnittstellen zum Stöbern im
        Projektarchiv, Übergabe-Benachrichtigungen per E-Mail usw.), Ihre
        Sicherungsstrategie und vieles mehr.</para>

<!--
      <para>We cover server choice and configuration in
        <xref linkend="svn.serverconfig" />, but the point we'd like
        to briefly make here is simply that the answers to some of
        these other questions might have implications that force your
        hand when deciding where your repository will live.  For
        example, certain deployment scenarios might require accessing
        the repository via a remote filesystem from multiple
        computers, or using multiple repositories with syncronized
        contents distributed geographically to permit more performant
        access to that data by users around the globe.  Addressing
        each possible way to deploy Subversion is both impossible and
        outside the scope of this book.  We simply encourage you to
        evaluate your options using these pages and other sources as
        your reference material and to plan ahead.</para>
-->
      <para>Die Auswahl und Konfigurierung des Servers werden wir in
        <xref linkend="svn.serverconfig" /> behandeln; jedoch möchten
        wir an dieser Stelle kurz darauf hinweisen, dass die Antworten
        auf einige der anderen Fragen zur Folge haben, dass Sie bei
        der Entscheidung über den Speicherort für das Projektarchiv
        keine freie Wahl mehr haben.  Beispielsweise könnten bestimmte
        Einsatzumgebungen erfordern, dass von mehreren Rechnern über
        ein freigegebenes Dateisystem auf das Projektarchiv
        zugegriffen werden muss, oder mehrere, geographisch verteilte
        Projektarchive mit synchronisiertem Inhalt verwendet werden,
        um einen effektiveren Zugriff auf diese Daten durch Anwender
        zu erlauben, die auf der Welt verteilt sind. Es ist unmöglich,
        und würde auch den Rahmen dieses Buches sprengen, wenn jede
        erdenkliche Einsatzart von Subversion angesprochen würde. Wir
        ermutigen Sie einfach, Ihre Optionen zu prüfen, indem Sie
        diese Seiten und weitere Quellen als Referenz verwenden und
        weitsichtig planen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.accesscontrol">
      <title>Controlling Access to Your Repository</title>

<!--
      <para>Access control in Subversion is almost entirely managed by
        the Subversion server processes.  We discuss the available
        Subversion servers in <xref linkend="svn.serverconfig" />, and
        explain path-based access control specifically in
        <xref linkend="svn.serverconfig.pathbasedauthz" />.  In
        addition to those user-level access control questions, you'll also
        want to ensure that your repository is accessible by the
        programs on your hosting machine which need to access it.
        Consider the OS-level user and group ownership that makes
        sense for your repository.  Once again, the information found
        in <xref linkend="svn.serverconfig" /> should be able to help
        you make these decisions.</para>
-->
      <para>Die Zugriffskontrolle in Subversion wird beinahe
        vollständig durch die Subversion-Server Prozesse verwaltet.
        Wir erörtern die verfügbaren Subversion-Server in
        <xref linkend="svn.serverconfig" /> und erklären pfadbasierte
        Zugriffskontrolle speziell in
        <xref linkend="svn.serverconfig.pathbasedauthz" />. Zusätzlich
        zu diesen Fragen über die Zugriffskontrolle auf Anwenderebene
        sollten Sie ebenfalls sicherstellen, dass Ihr Projektarchiv
        für die Programme Ihres Wirtsrechners zugänglich ist, die
        Zugang benötigen. Ziehen Sie die Anwender- und
        Gruppenzugehörigkeit auf Betriebssystemebene in Betracht, die
        für Ihr Projektarchiv einen Sinn ergibt. Wie gesagt, die in
        <xref linkend="svn.serverconfig" /> zu findenden Informationen
        sollten Ihnen helfen können, eine Entscheidung zu
        treffen.</para>

    </sect2>
  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
<!--
    <title>Creating and Configuring Your Repository</title>
-->
    <title>Anlegen und konfigurieren Ihres Projektarchivs</title>

<!--
    <para>Earlier in this chapter (in
      <xref linkend="svn.reposadmin.planning" />), we looked at some
      of the important decisions that should be made before creating
      and configuring your Subversion repository.  Now, we finally get
      to get our hands dirty!  In this section, we'll see how to
      actually create a Subversion repository and configure it to
      perform custom actions when special repository events
      occur.</para>
-->
    <para>Weiter oben in diesem Kapitel (in <xref
        linkend="svn.reposadmin.planning" />), schauten wir auf einige
      der wichtigen Entscheidungen, die zu treffen sind, bevor Ihr
      Subversion-Projektarchiv angelegt und konfiguriert wird. Jetzt
      schaffen wir es endlich, uns die Hände schmutzig zu machen! In
      diesem Abschnitt werden wir sehen, wie ein
      Subversion-Projektarchiv überhaupt angelegt wird und wie es
      konfiguriert wird, damit es bei bestimmten
      Projektarchiv-Ereignissen spezielle Aktionen ausführt.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
<!--
      <title>Creating the Repository</title>
-->
      <title>Anlegen des Projektarchivs</title>
 
<!--
      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>
-->
      <para>Das Anlegen eines Subversion-Projektarchivs ist eine
        unglaublich einfache Aufgabe. Das mit Subversion gelieferte
        Dienstprogramm <command>svnadmin</command> stellt ein
        Unterbefehl (<command>svnadmin create</command>) zur
        Verfügung, der genau das macht.</para>

<!--
      <informalexample>
        <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ # Ein Projektarchiv anlegen
$ svnadmin create /var/svn/repos
$
</screen>
      </informalexample>

<!--
      <para>Assuming that the parent directory 
        <filename>/var/svn</filename> exists and that you have
        sufficient permissions to modify that directory, the previous
        command creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store (FSFS).  You can explicitly choose the
        filesystem type using the <option>- -fs-type</option> argument,
        which accepts as a parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>
-->
      <para>Vorausgesetzt, dass das Verzeichnis 
      <filename>/var/svn/repos</filename> vorhanden ist, Sie die zum
      Ändern erforderlichen Rechte besitzen, legt der obige Befehl ein
      neues Projektarchiv mit dem
      Standard-Dateisystem-Speicherverfahren (FSFS) an. Sie können den
      Dateisystemtypen ausdrücklich wählen, indem Sie das
      Argument <option>--fs-type</option> benutzen, das als Parameter
      entweder <literal>fsfs</literal> oder <literal>bdb</literal>
      zulässt.</para>

<!--
      <informalexample>
        <screen>
$ # Create an FSFS-backed repository
$ svnadmin create - -fs-type fsfs /var/svn/repos
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ # Ein FSFS-basiertes Projektarchiv anlegen
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</screen>
      </informalexample>

<!--
      <informalexample>
        <screen>
# Create a Berkeley-DB-backed repository
$ svnadmin create - -fs-type bdb /var/svn/repos
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
# Ein Berkeley-DB-basiertes Projektarchiv anlegen
$ svnadmin create --fs-type bdb /var/svn/repos
$
</screen>
      </informalexample>

<!--
      <para>After running this simple command, you have a Subversion
        repository.  Depending on how users will access this new
        repository, you might need to fiddle with its filesystem
        permissions.  But since basic system administration is rather
        outside the scope of this text, we'll leave further
        exploration of that topic as an exercise to the reader.</para>
-->
      <para>Nach dem Ausführen dieses einfachen Befehls haben Sie ein
        Subversion-Projektarchiv. Abhängig davon, wie Anwender künftig
        auf dieses neue Projektarchiv zugreifen sollen, müssten Sie
        gegebenenfalls an den Dateisystem-Berechtigungen feilen. Da
        allerdings die grundsätzliche Systemverwaltung nicht
        Gegenstand dieses Textes ist, betrachten wir die weitere
        Untersuchung dieses Themas als Übung für den Leser.</para>

      <tip>
<!--
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities&mdash;they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
-->
        <para>Das Pfad-Argument zu <command>svnadmin</command> ist
          bloß ein gewöhnlicher Pfad im Dateisystem und kein URL wie
          ihn das Client-Programm <command>svn</command> verwendet, um
          auf Projektarchive zu verweisen. Sowohl
          <command>svnadmin</command> als auch
          <command>svnlook</command> werden als serverseitige
          Dienstprogramme betrachtet &ndash; sie werden auf dem
          Rechner benutzt, auf dem das Projektarchiv untergebracht ist,
          um Aspekte des Projektarchivs zu untersuchen oder zu verändern;
          tatsächlich sind sie nicht in der Lage, Aufgaben über das
          Netz zu erledigen. Ein verbreiteter Fehler von
          Subversion-Neulingen ist der Versuch, URLs (sogar
          <quote>lokale</quote> vom Typ <literal>file://</literal>) an
          diese zwei Programme zu übergeben.</para>
      </tip>

<!--
      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem.  Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>
-->
      <para>Im Unterverzeichnis <filename>db/</filename> Ihres
        Projektarchivs befindet sich die Implementierung des
        versionierten Dateisystems. Das Leben des versionierten
        Dateisystems Ihres Projektarchivs beginnt mit Revision 0, die aus
        nichts anderem als dem Wurzelverzeichnis
        (<filename>/</filename>) besteht. Zu Beginn hat die Revision 0
        eine einzige Revisions-Eigenschaft, <literal>svn:date</literal>,
        das als Wert die Angabe des Zeitpunktes besitzt, zu dem das
        Projektarchiv angelegt wurde.</para>

<!--
      <para>Now that you have a repository, it's time to customize
        it.</para>
-->
      <para>Da Sie nun ein Projektarchiv haben, ist es an der Zeit, es
        anzupassen.</para>

      <warning>
<!--
        <para>While some parts of a Subversion repository&mdash;such
          as the configuration files and hook scripts&mdash;are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools for tweaking relevant subsections of the
          repository.  Do <emphasis>not</emphasis> attempt manual
          manipulation of your version control history by poking and
          prodding around in your repository's data store
          files!</para>
-->
        <para>Während einige Teile des Projektarchivs &ndash; wie die
          Konfigurationsdateien und Hook-Skripte &ndash; für eine
          manuelle Untersuchung und Bearbeitung gedacht sind, sollten
          Sie nicht (und sie sollten es auch nicht nötig haben) an den
          anderen Teilen des Projektarchivs <quote>händisch</quote>
          herumdoktern. Das Dienstprogramm <command>svnadmin</command>
          sollte für alle notwendigen Änderungen an Ihrem Projektarchiv
          ausreichen; sie können auch Dienstprogramme von
          Drittanbietern verwenden, um in entsprechenden
          Unterabschnitten des Projektarchivs Änderungen vorzunehmen.
          Versuchen Sie <emphasis>nicht</emphasis>, die Historie Ihrer
          Versionskontrolle manuell zu verändern, indem Sie in den
          Speicherdateien des Projektarchivs herumstochern!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.hooks">
<!--
      <title>Implementing Repository Hooks</title>
-->
      <title>Erstellen von Projektarchiv-Hooks</title>

<!--
      <para>
        <indexterm>
          <primary>hook scripts</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>hook scripts</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>hooks</secondary>
          <see>hook scripts</see>
        </indexterm>A <firstterm>hook</firstterm> is a program
        triggered by some repository event, such as the creation of a
        new revision or the modification of an unversioned property.
        Some hooks (the so-called <quote>pre hooks</quote>) run in
        advance of a repository operation and provide a means by which
        to both report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine&mdash;but don't
        modify&mdash;the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
-->
      <para>
        <indexterm>
          <primary>Hook-Skripte</primary>
        </indexterm>
        <indexterm>
          <primary>Hooks</primary>
          <see>Hook-Skripte</see>
        </indexterm>
        <indexterm>
          <primary>Projektarchive</primary>
          <secondary>Hooks</secondary>
          <see>Hook-Skripte</see>
        </indexterm>Ein <firstterm>Hook</firstterm> (Haken) ist ein Programm,
        das durch einige Projektarchiv-Ereignisse gestartet wird, wie
        etwa die Erzeugung einer neuen Revision oder die Veränderung
        einer unversionierten Eigenschaft. Einige Hooks (die sogenannten
        <quote>Pre-Hooks</quote>) starten vor einer
        Projektarchiv-Operation und bieten eine Möglichkeit sowohl zu
        berichten, was passieren wird, als auch zu verhindern, dass es
        überhaupt passiert. Andere Hooks (die
        <quote>Post-Hooks</quote>) starten nach Abschluss eines
        Projektarchiv-Ereignisses und sind nützlich für Aufgaben, die das
        Projektarchiv inspizieren &ndash; aber nicht verändern. Jedem
        Hook wird ausreichend Information übergeben, damit er
        feststellen kann, um welches Ereignis es sich handelt (oder
        handelte), welche genauen Änderungen am Projektarchiv
        beabsichtigt sind (oder durchgeführt wurden) und wie der Name des
        Anwenders lautet, der das Ereignis ausgelöst hat.</para>

<!--
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>
-->
      <para>Das Unterverzeichnis <filename>hooks</filename> beinhaltet
        standardmäßig Vorlagen für verschiedene
        Projektarchiv-Hooks:</para>

      <informalexample>
        <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
      </informalexample>

<!--
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
-->
      <para>Es gibt eine Vorlage für jeden Hook, den Subversion
        unterstützt. Sie können sehen, wodurch jedes dieser Skripte
        gestartet wird und welche Daten übergeben werden, indem Sie
        den Inhalt der Skripte inspizieren. In vielen dieser Vorlagen
        befinden sich auch Beispiele dafür, wie dieses Skript zusammen
        mit anderen Programmen aus dem Lieferumfang von Subversion
        verwendet werden kann, um häufige, nützliche Aufgaben zu erledigen.
        Um einen funktionierenden Hook zu installieren, brauchen Sie
        nur ein ausführbares Programm oder Skripte im Verzeichnis
        <filename>repos/hooks</filename> abzulegen, das unter dem
        Namen des Hooks (etwa <command>start-commit</command> oder
        <command>post-commit</command>) gestartet werden kann.</para>

<!--
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>
-->
      <para>Auf Unix Plattformen bedeutet das, ein Skript oder
        Programm bereitzustellen (welches ein Shell-Skript, ein
        Python-Programm, ein übersetztes C-Binärprogramm oder
        sonst etwas sein kann), das genauso heißt wie der Hook.
        Natürlich sind die Vorlagen nicht nur zur Information da
        &ndash; die einfachste Möglichkeit, unter Unix einen Hook zu
        installieren, ist es, einfach die passende Vorlagedatei in
        eine Datei zu kopieren, der die Dateiendung
        <filename>.tmpl</filename> fehlt, den Inhalt anzupassen und
        sicherzustellen, dass das Skript ausführbar ist. Unter Windows
        werden jedoch Dateiendungen verwendet, um festzustellen, ob
        ein Programm ausführbar ist, so dass Sie ein Programm zur
        Verfügung stellen müssen, dessen Basisname dem Hook entspricht
        und dessen Endung einer derjenigen entspricht, die Windows für
        ausführbare Programme hält, etwa <filename>.exe</filename> für
        Programme und <filename>.bat</filename> für
        Batch-Dateien.</para>

<!--
      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>
-->
      <para>Subversion führt die Hooks unter der Anwenderkennung aus,
        die auch der Prozess besitzt, der auf das Projektarchiv zugreift.
        Meistens wird auf das Projektarchiv über einen Subversion-Server
        zugegriffen, so dass die Anwenderkennung der des
        Serverprozesses entspricht. Die Hooks müssen deshalb mit den
        entsprechenden Berechtigungen des Betriebssystems versehen
        werden, damit diese Anwenderkennung sie ausführen kann. Das
        bedeutet auch, dass der direkte oder indirekte Zugriff auf
        irgendwelche Programme oder Dateien (einschließlich des
        Subversion-Projektarchivs) durch den Hook auch unter derselben
        Kennung erfolgt. Mit anderen Worten: Achten Sie auf mögliche
        Probleme im Zusammenhang mit Zugriffsrechten, die den Hook
        daran hindern könnten, die Ihm zugeteilten Aufgaben
        wahrzunehmen.</para>

<!--
      <para>There are several hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>
-->
      <para>Es gibt mehrere im Subversion-Projektarchiv implementierte
        Hooks; Details zu jedem können Sie in
        <xref linkend="svn.ref.reposhooks" /> nachlesen. Als
        Projektarchiv-Administrator müssen Sie entscheiden, welche
        Hooks sie einrichten wollen (indem Sie ein entsprechend
        benanntes und mit den nötigen Zugriffsrechten versehenes
        Hook-Programm bereitstellen) und wie Sie sie einsetzen wollen.
        Wenn Sie diese Entscheidung treffen, dann behalten Sie das
        Gesamtbild des Projektarchiv-Einsatzes im Auge.  Wenn Sie
        beispielsweise die Konfiguration des Servers verwenden, um
        festzustellen, welche Anwender Änderungen an Ihr Projektarchiv
        übertragen dürfen, benötigen Sie für diese Zugriffskontrolle
        nicht das Hook-System.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.configuration">
<!--
        <title>Hook script environment configuration</title>
-->
        <title>Konfiguration der Umgebung von Hook-Skripten</title>

<!--
        <para>By default, Subversion executes hook scripts with an
          empty environment&mdash;that is, no environment variables
          are set at all, not even <literal>$PATH</literal>
          (or <literal>%PATH%</literal>, under Windows).  Because of
          this, many administrators are baffled when their hook
          program runs fine by hand, but doesn't work when invoked by
          Subversion.  Administrators have historically worked around
          this problem by manually setting all the environment
          variables their hook scripts need in the scripts
          themselves.</para>
-->
        <para>Standardmäßig führt Subversion Hook-Skripte mit
          einer leeren Umgebung aus &ndash; d.h., es sind überhaupt
          keine Umgebungsvariablen gesetzt, nicht einmal
          <literal>$PATH</literal> (oder <literal>%PATH%</literal>
          unter Windows). Deshalb sind viele Administratoren verwirrt,
          wenn deren Hook-Programme normal starten, wenn sie manuell
          aufgerufen werden, aber nicht funktionieren, wenn sie Subversion
          startet. Historisch haben Administratoren dem Problem damit
          entgegengewirkt, dass sie manuell alle Umgebungsvariablen,
          die ihre Hook-Skripte benötigen, im Skript selbst gesetzt
          haben.</para>

<!--
        <para>Subversion 1.8 introduces a new way to manage the
          environment of Subversion-executed hook scripts&mdash;the
          hook script environment configuration file.  If a Subversion
          server finds a file named <filename>hooks-env</filename> in
          the repository's <filename>conf/</filename> subdirectory, it
          parses that file as an INI-formatted configuration file and
          applies the option names and variables found therein to the
          hook script's execution environment as environment
          variables.</para>
-->
        <para>Subversion 1.8 stellt eine neue Art vor, die Umgebung
          von Hook-Skripten zu verwalten, die von Subversion
          ausgeführt werden &ndash; die Konfigurationsdatei für die
          Hook-Skript-Umgebung. Falls Subversion eine Datei namens
          <filename>hooks-env</filename> im Unterverzeichnis
          <filename>conf/</filename> des Projektarchivs findet, parst
          es diese Datei als Konfigurationsdatei im INI-Format und
          wendet die darin gefundenen Optionsnamen und Variablen als
          Umgebungsvariablen in der Ausführungs-Umgebung für das
          Hook-Skript an.</para>

<!--
        <para>The syntax of the <filename>hooks-env</filename> file is
          pretty straightforward: each section name is the name of a
          hook script (such as <literal>pre-commit</literal>
          or <literal>post-revprop-change</literal>), and the
          configuration items inside that section are treated as
          mappings of environment variable names to desired values.
          Additionally, there is a
          special <literal>[default]</literal> section, which can be
          used to configure environment variable mappings that should
          be applied to <emphasis>all</emphasis> hook scripts (unless
          explicitly overridden by per-hook-script settings).  See
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          for a sample <filename>hooks-env</filename> configuration
          file.</para>
-->
        <para>Die Syntax der Datei <filename>hooks-env</filename> ist
          ziemlich einfach: jeder Abschnittsname ist der Name eines
          Hook-Skriptes (etwa <literal>pre-commit</literal>
          oder <literal>post-revprop-change</literal>), und die
          Konfigurationseinträge in diesem Abschnitt werden als
          Abbildungen von Umgebungsvariablen auf gewünschte Werte
          behandelt. Darüber hinaus gibt es noch einen besonderen
          Abschnitt <literal>[default]</literal>, der verwendet werden
          kann, um Abbildungen von Umgebungsvariablen zu
          konfigurieren, die auf <emphasis>alle</emphasis>
          Hook-Skripte angewendet werden sollen (es sei denn, sie sind
          ausdrücklich durch eigene Hook-Skript Einträge
          überschrieben). Siehe
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          für ein Beispiel einer <filename>hooks-env</filename>
          Konfigurationsdatei.</para>

<!--
        <example id="svn.reposadmin.hooks.configuration.ex-1">
          <title>hooks-env (custom hook script environment
            configuration)</title>

          <programlisting>
# All scripts should use a UTF-8 locale and have our hook script
# utilities directory on the search path.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# The post-commit and post-revprop-change scripts want to run
# programs from our custom synctools replication software suite, too.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>
-->

        <example id="svn.reposadmin.hooks.configuration.ex-1">
          <title>hooks-env (maßgeschneiderte Umgebungskonfiguration
            für Hook-Skripte)</title>

          <programlisting>
# Alle Skripte sollten eine UTF-8 Locale verwenden und unser Hook-Skript
# das Werkzeugverzeichnis im Suchpfad haben.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# Auch die post-commit und post-revprop-change Skripte möchten
# Programme aus unserer maßgeschneiderten Synctools-Replikations-Software
# Sammlung verwenden.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>

        <note>
<!--
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> also demonstrates the nifty string substitution syntax
            found in Subversion's configuration file parser.  In this
            example, the value of the <literal>PATH</literal>
            option&mdash;pulled from the <literal>[default]</literal>
            section of the file&mdash;is substituted in place of
            the <literal>%(PATH)s</literal> placeholder text in the
            per-hook sections.  For more about this special syntax,
            see the <filename>README.txt</filename> file which lives
            in the Subversion runtime configuration directory.  (And
            for more information about that directory, see
            <xref linkend="svn.advanced.confarea" />.)</para>
-->
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> zeigt auch die elegante Syntax zur Ersetzung von
            Zeichenketten aus Subversions Konfigurationsdateien-Parser.
            In diesem Beispiel wird der Wert der Option
            <literal>PATH</literal> &ndash; aus dem Abschnitt 
            <literal>[default]</literal> der Datei gelesen &ndash;
            anstelle des Platzhalters <literal>%(PATH)s</literal> in
            den Hook-Abschnitten eingefügt. Mehr zu dieser besonderen
            Syntax finden Sie in der Datei
            <filename>README.txt</filename> in Subversions Verzeichnis
            für die Laufzeitkonfiguration. (Und für weitere
            Informationen zu diesem Verzeichnis, siehe
            <xref linkend="svn.advanced.confarea" />.)</para>
        </note>

<!--
        <para>Of course, having exact duplicates of your custom hook
          script environment configuration files in every single
          repository's <filename>conf/</filename> directory could get
          cumbersome, especially when you need to make changes to them
          all.  So Subversion's servers allow you to specify an
          alternate (possibly shared) location for this configuration
          information.</para>
-->
        <para>Natürlich kann es lästig werden, exakte Duplikate Ihrer
          Hook-Skript-Umgebungs-Konfigurations-Dateien in jedem
          <filename>conf/</filename> Verzeichnis jedes einzelnen
          Projektarchivs vorzuhalten, insbesondere, falls Sie
          Änderungen an allen machen müssen. Deshalb erlauben Ihnen
          die Server von Subversion, einen alternativen (möglicherweise
          gemeinsam benutzten) Speicherort für diese Konfiguration
          anzugeben.</para>

        <!-- ### TODO:  Add cross reference for the above! -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.uses">
<!--
        <title>Common uses for hook scripts</title>
-->
        <title>Häufige Anwendungen für Hook-Skripte</title>

<!--
        <para>Repository hook scripts can offer a wide range of
          utility, but most tend to fall into a few basic categories:
          notification, validation, and replication.</para>
-->
        <para>Projektarchiv-Hook-Skripte können einen breiten Nutzen
          bieten, doch die meisten decken ein paar grundsätzliche
          Kategorien ab: Benachrichtigung, Validierung und
          Replizierung.</para>

<!--
        <para>Notification scripts are those which tell someone that
          something happened.  The most common of these found in a
          Subversion service offering involve programs which send
          commit and revision property change notification emails to
          project members, driven by the post-commit and
          post-revprop-change hooks, respectively.  There are numerous
          other notification approaches, from issue tracker integration
          scripts to scripts which operate as IRC bots to announce
          that something's changed in the repository.</para>
-->
        <para>Benachrichtigungs-Skripte sind diejenigen, die jemanden
          mitteilen, dass etwas passiert ist. Die häufigsten hiervon,
          die in einem Subversion-Dienst angetroffen werden können,
          umfassen Programme, die E-Mails mit Benachrichtigungen zu
          Übertragungen und Änderungen an Revisions-Eigenschaften an
          Projektmitarbeiter versenden, und die von den post-commit
          bzw. post-revprop-change Hooks ausgelöst werden. Es gibt
          zahlreiche andere Ansätze zu Benachrichtigungen, von
          Integrationsskripten für Fehlerverfolgungs-Systeme bis zu
          Skripten, die als IRC-Bots arbeiten, um zu verkünden, dass
          sich etwas im Projektarchiv geändert hat.</para>

<!--
        <para>On the validation side of things, the start-commit and
          pre-commit hooks are widely used to allow or disallow
          commits based on various criteria: the author of the commit,
          the formatting and/or content of the log message which describes the
          commit, and even the low-level details of the changes made
          to files and directories in the commit.  Likewise, the
          pre-revprop-change hook acts as the gateway to revision
          property changes, which is an especially valuable role
          considering the fact that revision properties are not
          themselves versioned, and can therefore only be modified
          destructively.</para>
-->
        <para>Bei der Validierung ist die Verwendung der Hooks
          start-commit und pre-commit weit verbreitet, um
          Übertragungen abhängig von verschiedenen Kriterien zu
          erlauben oder zu verbieten: der Autor der Übertragung, die
          Formatierung und/oder der Inhalt der Protokollnachricht, die
          die Übertragung beschreibt, und sogar die Feinheiten der
          an Dateien und Verzeichnissen vorgenommenen Änderungen in
          der Übertragung. Ähnlich handelt der Hook 
          pre-revprop-change als Portal zu Änderungen an
          Revisions-Eigenschaften, was eine besonders nützliche Rolle
          ist, angesichts der Tatsache, dass Revisions-Eigenschaften
          an sich nicht versioniert sind und deshalb nur destruktiv
          bearbeitet werden können.</para>

<!--
        <para>One special class of change validation that has seen
          widespread use since Subversion 1.5 was released is
          validation of the committing client software itself.  When
          Subversion's merge tracking feature (described extensively
          in <xref linkend="svn.branchmerge" />) was introduced in
          that release, Subversion administrators needed a way to
          ensure that once users of their repositories started using
          the new feature that <emphasis>all</emphasis> their merges
          were tracked.  To reduce the chance of someone committing an
          untracked merge to the repository, they used start-commit
          hooks to examine the feature capabilities string advertised
          by Subversion clients.  If the committing client didn't
          advertise support for merge tracking, the commit was denied
          with instructions to the user to immediately update their
          Subversion client!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> provides
          an example of a start-commit script which does precisely
          this.</para>
-->
        <para>Eine besondere Klasse von Änderungsvalidierung, die seit
          der Veröffentlichung Subversion 1.5 weit verbreitet ist,
          stellt die Validierung des übertragenden Clients an sich
          dar. Als die Merge-Tracking-Funktionalität von Subversion
          (ausführlich beschrieben in <xref linkend="svn.branchmerge" />)
          mit dieser Veröffentlichung eingeführt wurde, benötigten
          Subversion-Administratoren eine Möglichkeit,
          sicherzustellen, dass, <emphasis>alle</emphasis> Merges von
          Anwendern ihrer Projektarchive, die die neue
          Funktionalität verwendeten, verfolgt werden. Um die
          Wahrscheinlichkeit eines nicht verfolgten Merges zu
          verringern, verwendeten sie start-commit-Hooks, um die von
          Subversion-Clients bekanntgegebenen funktionalen Fähigkeiten
          zu untersuchen. Falls der übertragende Client nicht die
          Fähigkeit zur Unterstützung von Merge-Tracking meldete,
          wurde die Übertragung abgelehnt und eine Anleitung zum
          aktualisieren des Clients an den Anwender gesendet. 
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> stellt
          ein Beispiel eines start-commit-Skripts bereit, was genau
          das macht.</para>

        <example id="svn.reposadmin.hooks.uses.ex-1">
<!--
          <title>start-commit hook to require merge tracking
            support</title>
-->
          <title>start-commit Hook, um Merge-Tracking Unterstützung zu
            erzwingen</title>

          <programlisting>
#!/usr/bin/env python
import sys

# sys.argv[3] is a colon-delimited capabilities list
if 'mergeinfo' not in sys.argv[3].split(':'):
  sys.stderr.write("""\
ERROR: Commits to this repository must be made using Subversion
clients which support the merge tracking feature.  Please upgrade
your client to at least Subversion 1.5.0.
""")
  sys.exit(1)
</programlisting>
        </example>

<!--
        <para>
          <indexterm>
            <primary>properties</primary>
            <secondary>ephemeral transaction properties</secondary>
          </indexterm>Beginning in Subversion 1.8, clients committing
          against a Subversion 1.8 server will still provide the
          feature capabilities string, but will also provide
          additional information about themselves by way
          of <firstterm>ephemeral transaction properties</firstterm>.
          Ephemeral transaction properties are essentially revision
          properties which are set on the commit transaction by the
          client at the earliest opportunity while committing, but
          which are automatically removed by the server immediately
          prior to the transaction becoming a finalized revision.  You
          can inspect these properties using the same tools with which
          you'd inspect other unversioned properties set on commit
          transactions during the timeframe between which the
          start-commit and pre-commit repository hook scripts would
          operate.</para>
-->
        <para>
          <indexterm>
            <primary>Eigenschaften</primary>
            <secondary>flüchtige Transaktions-Eigenschaften</secondary>
          </indexterm>Beginnend mit Subversion 1.8, stellen Clients,
          die an einen Subversion 1.8 Server übertragen immer noch die
          Zeichenkette mit ihren funktionalen Fähigkeiten zur
          Verfügung, geben darüber hinaus gehend jedoch zusätzliche
          Informationen über sich preis durch <firstterm>flüchtige
            Transaktions-Eigenschaften</firstterm>. Flüchtige
          Transaktions-Eigenschaften sind im Grunde genommen
          Revisions-Eigenschaften, die vom Client während der
          Übertragungs-Transaktion bei der frühesten Gelegenheit
          gesetzt werden, die dann aber vom Server wieder entfernt
          werden, unmittelbar, bevor die Transaktion eine
          abgeschlossene Revision wird. Sie können diese Eigenschaften
          mit denselben Werkzeugen untersuchen, mit denen Sie andere
          bei Übertragungs-Transaktionen im Zeitraum zwischen dem
          Aufruf der start-commit und pre-commit Hooks gesetzte
          unversionierte Eigenschaften untersuchen würden.</para>

<!--
        <para>The following are the ephemeral transaction properties
          which Subversion currently provides and implements:</para>
-->
        <para>Die folgenden sind die flüchtigen
          Transaktions-Eigenschaften, die Subversion momentan
          unterstützt und implementiert:</para>

        <variablelist>

          <varlistentry>
            <term><literal>svn:txn-client-compat-version</literal></term>
            <listitem>
<!--
              <para>Carries the Subversion library version string with
                which the committing client claims compatibility.
                This is useful for deciding whether the client
                supports the minimal feature set required for proper
                handling of the repository data.</para>
-->
              <para>Beinhaltet die Zeichenkette mit der Version der
                Subversion-Bibliothek zu der der Client angibt,
                kompatibel zu sein. Das ist nützlich, um zu
                entscheiden, ob der Client die zur richtigen
                Behandlung der Projektarchiv-Daten notwendige minimale
                Funktionalität unterstützt.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:txn-user-agent</literal></term>
            <listitem>
<!--
              <para>Carries the <quote>user agent</quote> string which
                describes the committing client program.  Subversion's
                libraries define the initial portion of this string,
                but third-party consumers of the API (GUI clients,
                etc.) can append custom information to it.</para>
-->
              <para>Beinhaltet die Zeichenkette <quote>user
                agent</quote>, die das übertragende Client-Programm
                beschreibt. Die Bibliotheken von Subversion definieren
                der ersten Teil dieser Zeichenkette, doch können
                Dritte, die dieses API verwenden (GUI-Clients, usw.)
                eigene Informationen anhängen.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>

        <!-- ### TODO: Show an example of these being used?  Or ### -->
        <!-- ###       do so in ch07 - Customizing Subversion   ### -->
        <!-- ###       with a cross-reference here.             ### -->

        <note>
<!--
          <para>While most clients will transmit ephemeral transaction
            properties early enough in the commit process that they
            may be inspected by the start-commit hook script, some
            configurations of Subversion will cause those properties
            to not be set on the transaction until later in the commit
            process.  Administrators should consider performing any
            validation based on ephemeral transaction properties in
            both the start-commit and pre-commit hooks&mdash;the
            former to rule out invalid clients before those clients
            transmit the commit payload; the latter <quote>just in
            case</quote> the validation checks couldn't be performed
            by the start-commit hook.</para>
-->
          <para>Obwohl die meisten Clients die flüchtigen
            Transaktions-Eigenschaften früh genug im
            Übertragungsprozess schicken, so dass das start-commit
            Hook-Skript sie untersuchen kann, kann es vorkommen, dass
            es bei einigen Konfigurationen von Subversion dazu kommen,
            dass diese Eigenschaften erst später im
            Übertragungsprozess gesetzt werden. Deshalb sollten
            Administratoren erwägen, Validierungen, die auf flüchtigen
            Transaktions-Eigenschaften beruhen, sowohl im start-commit
            als auch im pre-commit Hook vorzunehmen &ndash; ersteres,
            um ungültige Clients auszuschließen, bevor sie die Daten
            der Übertragung senden, letzteres, <quote>für alle
            Fälle</quote>, falls die Validierung durch den
            start-commit Hook nicht möglich war.</para>
        </note>

<!--
        <para>As noted before, ephemeral transaction properties are
          removed from the transaction just before it is promoted to a
          new revision.  Some administrators may wish to preserve the
          information in those properties indefinitely.  We suggest
          that you do so by using the pre-commit hook script to copy
          the values of those properties to new property names.  In
          fact, the Subversion source code distribution provides a
          <filename>persist-ephemeral-txnprops.py</filename> script
          (in the <filename>tools/hook-scripts/</filename>
          subdirectory) for doing precisely that.</para>
-->
        <para>Wie bereits angemerkt, werden flüchtige
          Transaktions-Eigenschaften aus der Transaktion entfernt,
          kurz bevor sie zu einer neuen Revision hochgestuft wird.
          Einige Administratoren möchten diese Informationen
          vielleicht auf unbestimmte Zeit bewahren. Wir schlagen
          vor, hierfür das pre-commit Hook-Skript die Werte dieser
          Eigenschaften in neue Eigenschaftsnamen kopieren zu lassen.
          In der Tat stellt die Quelltext-Distribution von Subversion
          ein Skript <filename>persist-ephemeral-txnprops.py</filename>
          (im Verzeichnis <filename>tools/hook-scripts/</filename>),
          das genau dies macht.</para>

<!--
        <para>The third common type of hook script usage is for the
          purpose of replication.  Whether you are driving a simple
          backup process or a more involved remote repository
          mirroring scenario, hook scripts can be critical.  See
          <xref linkend="svn.reposadmin.maint.backup" /> and
          <xref linkend="svn.reposadmin.maint.replication" /> for more
          information about these aspects of repository
          maintenance.</para>
-->
        <para>Der dritte verbreitete Anwendungsfall für Hook-Skripte
          ist zum Zweck der Replizierung. Ob Sie einen einfachen
          Backup-Prozess betreiben oder ein ausgeprägteres
          Spiegelungs-Szenario in ein entferntes Projektarchiv &ndash;
          Hook-Skripte können entscheidend sein. Siehe
          <xref linkend="svn.reposadmin.maint.backup" /> und
          <xref linkend="svn.reposadmin.maint.replication" /> für
          weitere Informationen zu diesen Aspekten der
          Projektarchiv-Pflege.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.summary">
        <title>Finding hook scripts or rolling your own</title>

<!--
        <para>As you might imagine, there is no shortage of Subversion
          hook programs and scripts that are freely available either
          from the Subversion community itself or elsewhere.  In fact,
          the Subversion distribution provides several commonly used
          hook scripts in its <filename>tools/hook-scripts/</filename>
          subdirectory.  However, if you are unable to find one that
          meets your specific needs, you might consider writing your
          own.  See <xref linkend="svn.developer" /> for information
          about developing software using Subversion's public
          APIs.</para>
-->
        <para>Wie Sie sich denken können, gibt es keinen Mangel an
          Subversion-Hook-Programmen und Skripten, die frei verfügbar
          sind, entweder von der Subversion-Gemeinschaft oder von
          woanders her. Tatsächlich liefert die
          Subversion-Distribution einige oft genutzte Hook-Skripte im
          Unterverzeichnis <filename>tools/hook-scripts/</filename>
          mit. Sollten Sie jedoch keins finden können, dass Ihre
          besonderen Anforderungen erfüllt, sollten Sie erwägen, Ihr
          eigenes zu schreiben. Siehe <xref linkend="svn.developer" />
          zu Informationen über Softwareentwicklung unter Verwendung
          von Subversions öffentlichen APIs.</para>

<!--
        <warning>
          <para>Hook scripts can do almost anything, but hook script
            authors should show restraint.  It might be tempting to,
            say, use hook scripts to automatically correct errors,
            shortcomings, or policy violations present in the files
            being committed.  Unfortunately, doing so can cause
            problems.  Subversion keeps client-side caches of certain
            bits of repository data, and if you change a commit
            transaction in this way, those caches become indetectably
            stale, leading to surprising and unexpected behavior.
            While it is generally okay to add new commit transaction
            properties via a hook script, essentially everything else
            about a commit transaction should be considered read-only.
            Instead of modifying a transaction to polish its payload,
            simply <emphasis>validate</emphasis> the transaction in
            the pre-commit hook and reject the
            commit if it does not meet the desired requirements.  As a
            bonus, your users will learn the value of careful,
            compliance-minded work habits.</para>
        </warning>
-->
        <warning>
          <para>Hook-Skripte können fast alles machen, doch sollten sich
            Hook-Skript-Autoren zurückhalten. Es mag verlockend erscheinen,
            Hook-Skripte, sagen wir mal, zur automatischen Korrektur von
            Fehlern, Unzulänglichkeiten oder Prozessverletzungen innerhalb
            der zu übertragenden Dateien einzusetzen. Unglücklicherweise
            kann das jedoch zu Problemen führen.  Subversion hält bestimmte
            Projektarchiv-Daten in client-seitigen Caches vor, und wenn Sie
            auf diese Art eine Übergabe-Transaktion verändern, werden die
            im Cache befindlichen Informationen ungültig, ohne dass jemand
            etwas merkt, was zu überraschendem und unerwartetem Verhalten
            führt. Während es im Allgemeinen in Ordnung geht, einer
            Commit-Transaktion neue Eigenschaften über ein Hook-Skript
            hinzuzufügen, sollte im Wesentlichen alles andere an einer
            Commit-Transaktion als nur-lesbar betrachtet werden. Statt die
            Transaktion durch Manipulation der Daten zu verändern, sollten
            Sie sie einfach im pre-commit-Hook auf
            <emphasis>Gültigkeit</emphasis> prüfen und die Übergabe
            ablehnen, falls sie den Anforderungen nicht entspricht.  Als
            Nebeneffekt werden Ihre Anwender lernen, wie wertvoll eine
            sorgfältige, sich an den Vorgaben orientierende Arbeitsweise
            ist.</para>
        </warning>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.fsfs">
<!--
      <title>FSFS Configuration</title>
-->
      <title>FSFS Konfiguration</title>

<!--
      <para>As of Subversion 1.6, FSFS filesystems have several
        configurable parameters which an administrator can use to
        fine-tune the performance or disk usage of their repositories.
        You can find these options&mdash;and the documentation for
        them&mdash;in the <filename>db/fsfs.conf</filename> file in
        the repository.</para>
-->
      <para>Seit Subversion 1.6 besitzen FSFS Dateisysteme mehrere
        konfigurierbare Parameter, die ein Administrator zur
        Feinabstimmung der Leistungsfähigkeit oder der Plattennutzung
        seines Projektarchivs verwenden kann. Sie können diese
        Optionen und deren Dokumentation in der Datei
        <filename>db/fsfs.conf</filename> im Projektarchiv
        finden.</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
<!--
    <title>Repository Maintenance</title>
-->
    <title>Projektarchiv-Wartung</title>

<!--
    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>
-->
    <para>Die Wartung eines Subversion-Projektarchivs kann abschreckend
      sein, was an der Komplexität liegt, die Systemen innewohnt, die
      auf Datenbanken aufbauen. Die Arbeit gut zu machen, bedeutet,
      die Werkzeuge zu kennen &ndash; was sie sind, wann sie zu
      verwenden sind und wie. Dieser Abschnitt stellt Ihnen die
      Projektarchiv-Verwaltungswerkzeuge vor, die Subversion mitbringt
      und erörtert, wie sie gehandhabt werden, um Aufgaben zu
      erledigen, wie etwa Projektarchiv-Datenmigration, Aktualisierungen,
      Sicherungen und Aufräumarbeiten.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
<!--
      <title>An Administrator's Toolkit</title>
-->
      <title>Der Werkzeugkasten eines Administrators</title>

<!--
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your
        repository.  Let's look more closely at each of those
        tools.</para>
-->
      <para>Subversion stellt eine Handvoll Dienstprogramme zur
        Verfügung, die nützlich zum Erstellen, Untersuchen, Verändern
        und Reparieren Ihres Projektarchivs sind. Wir wollen uns diese
        Werkzeuge einmal genauer ansehen.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

<!--
        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>
-->
        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>Das Programm <command>svnadmin</command> ist der
          beste Freund des Projektarchiv-Administrators. Neben der
          Fähigkeit, Subversion-Projektarchive zu erzeugen, erlaubt
          Ihnen dieses Programm verschiedene Wartungsarbeiten auf
          diesen Projektarchive auszuführen. Die Syntax von
          <command>svnadmin</command> ist ähnlich wie bei anderen
          Kommandozeilen=Programmen von Subversion:</para>

<!--
        <informalexample>
          <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin - -version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnadmin help
Aufruf: svnadmin UNTERBEFEHL ARCHIV_PFAD [Optionen &amp; Parameter ...]
Geben Sie »svnadmin help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem Unterbefehl
          zu erhalten.
Geben Sie »svnadmin --version« ein, um die Programmversion und die Datei-
          systemmodule zu sehen.

Verfügbare Unterbefehle:
   crashtest
   create
   deltify
&hellip;
</screen>
        </informalexample>

<!--
        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>
-->
        <para>Früher in diesem Kapitel (in <xref
          linkend="svn.reposadmin.basics.creating"/>), wurde uns der
          Unterbefehl <command>svnadmin create</command> vorgestellt.
          Die meisten anderen Unterbefehle von
          <command>svnadmin</command> werden wir später in diesem
          Kapitel behandeln. Und in <xref linkend="svn.ref.svnadmin"/>
          können Sie in einer vollständigen Aufstellung der
          Unterbefehle nachlesen, was jeder zu bieten hat.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

<!--
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>revisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          pre-commit hook) or that were just
          committed (in the case of the post-commit
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
-->
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>Revisionen</primary>
            <secondary>Untersuchung</secondary>
          </indexterm>
          <indexterm>
            <primary>Transaktionen</primary>
          </indexterm>
          <indexterm>
            <primary>Transaktionen</primary>
            <secondary>Untersuchung</secondary>
          </indexterm><command>svnlook</command> ist ein von Subversion
          mitgeliefertes Dienstprogramm zum Untersuchen der
          mannigfaltigen Revisionen und
          <firstterm>Transaktionen</firstterm> (bei denen es sich um
          Revisionen in Entstehung handelt) in einem Projektarchiv. Kein
          Teil dieses Programms versucht, das Projektarchiv zu verändern.
          <command>svnlook</command> wird üblicherweise von
          Projektarchiv-Hooks verwendet, um die abzuliefernden Änderungen
          zu melden (im Fall des pre-commit-Hooks)
          oder die gerade an das Projektarchiv übertragen wurden (im Fall
          des post-commit-hooks). Ein
          Projektarchiv-Administrator kann dieses Programm zur Diagnose
          benutzen.</para>

<!--
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
-->
        <para><command>svnlook</command> besitzt eine überschaubare
          Syntax:</para>

<!--
        <informalexample>
          <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '- -revision' and '- -transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook - -version' to see the program version and FS modules.
&hellip;
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnlook help
Aufruf: svnlook UNTERBEFEHL ARCHIV_PFAD [Optionen &amp; Parameter ...]
Hinweis: Alle Unterbefehle, die die Parameter »--revision« und »--transaction«
         akzeptieren, werden ohne diese Parameter die neueste
         Revision des Projektarchivs verwenden.
Geben Sie »svnlook help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem Unterbefehl
         zu erhalten.
Geben Sie »svnlook --version« ein, um die Programmversion und die Datei-
         systemmodule zu sehen.
&hellip;
</screen>
        </informalexample>

<!--
        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>- -revision</option>
          (<option>-r</option>) and <option>- -transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>- -revision</option> (<option>-r</option>)
          and <option>- -transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>
-->
        <para>Die meisten Unterbefehle von <command>svnlook</command>
          können entweder auf einem Revisions- oder auf einem
          Transaktionsbaum arbeiten, indem sie Informationen über den
          Baum an sich ausgeben oder darüber, inwiefern er sich von
          einer früheren Revision des Projektarchivs unterscheidet. Sie
          verwenden die Optionen <option>--revision</option>
          (<option>-r</option>) und <option>--transaction</option>
          (<option>-t</option>), um die zu untersuchende Revision bzw.
          Transaktion anzugeben. Ohne eine der Optionen
          <option>--revision</option> (<option>-r</option>) und
          <option>--transaction</option> (<option>-t</option>)
          untersucht Subversion die jüngste (oder
          <literal>HEAD</literal>) Revision des Projektarchivs. Das
          heißt, die beiden folgenden Befehle machen genau dasselbe,
          wenn 19 die jüngste Revision im Projektarchiv unter
          <filename>/var/svn/repos</filename> ist:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>
        </informalexample>

<!--
        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>
-->
        <para>Eine Ausnahme von diesen Regeln zu Unterbefehlen ist der
          Unterbefehl <command>svnlook youngest</command>, der keine
          Optionen entgegennimmt und einfach die jüngste
          Revisionsnummer des Projektarchivs ausgibt:</para>

        <informalexample>
          <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>
        </informalexample>

        <note>
<!--
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>- -revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
-->
          <para>Beachten Sie, dass Sie nur Transaktionen untersuchen
            können, die noch nicht übertragen sind. Die meisten
            Projektarchive haben keine derartigen Transaktionen, da
            Transaktionen entweder übertragen (in diesem Fall sollten
            Sie darauf mit der Option <option>--revision</option>
            (<option>-r</option>) zugreifen) oder abgebrochen und
            entfernt sind.</para>
        </note>
            
<!--
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>
-->
        <para>Die Ausgabe <command>svnlook</command> ist so gestaltet,
          dass sie sowohl für Menschen als auch für Maschinen lesbar
          ist. Nehmen wir zum Beispiel die Ausgabe des Unterbefehls
          <command>svnlook info</command>:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
sally<!--
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
-->
2002-11-04 09:29:13 -0600 (Mo, 04. Nov 2002)
43
Den üblichen griechischen
Baum hinzugefügt.
$
</screen>
        </informalexample>

<!--
        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>
-->
        <para>Die Ausgabe von <command>svnlook info</command> besteht
          aus dem Folgenden in entsprechender Reihenfolge:</para>

        <orderedlist>
          <listitem>
<!--
            <para>The author, followed by a newline</para>
-->
            <para>Der Autor gefolgt von einem Zeilenvorschub</para>
          </listitem>
          <listitem>
<!--
            <para>The date, followed by a newline</para>
-->
            <para>Das Datum gefolgt von einem Zeilenvorschub</para>
          </listitem>
          <listitem>
<!--
            <para>The number of characters in the log message,
              followed by a newline</para>
-->
            <para>Die Anzahl der Zeichen der Protokollnachricht
              gefolgt von einem Zeilenvorschub.</para>
          </listitem>
          <listitem>
<!--
            <para>The log message itself, followed by a newline</para>
-->
            <para>Die eigentliche Protokollnachricht gefolgt von einem
              Zeilenvorschub</para>
          </listitem>
        </orderedlist>

<!--
        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
-->
        <para>Diese Ausgabe ist für Menschen lesbar, d.h., Dinge wie
          der Zeitstempel werden als Text dargestellt statt als
          irgendetwas Obskures (wie die Anzahl der Nanosekunden seit
          der Mann von Bofrost das letzte Mal da war). Jedoch ist die
          Ausgabe auch maschinenlesbar &ndash; weil die
          Protokollnachricht mehrere Zeilen umfassen und von der Länge
          her unbegrenzt sein kann, liefert <command>svnlook</command>
          die Länge der Nachricht vor der eigentlichen Nachricht. Das
          erlaubt Skripten und anderen Programmen, die um diesen
          Befehl herum geschrieben wurden, intelligente Entscheidungen
          in Bezug auf die Protokollnachricht zu treffen, etwa wie viel
          Speicher für die Nachricht anzufordern ist oder zumindest
          wie viele Bytes zu überspringen sind, falls diese Ausgabe
          nicht das letzte Stück im Datenstrom sein sollte.</para>

<!--
        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>
-->
        <para><command>svnlook</command> kann eine Auswahl anderer
          Abfragen ausführen: Teilmengen der bereits erwähnten
          Informationen ausgeben, versionierte Verzeichnisbäume
          rekursiv auflisten, berichten, welche Pfade in einer
          bestimmten Revision oder Transaktion verändert wurden,
          textuelle und property-basierte Unterschiede an Dateien und
          Verzeichnissen aufzeigen, usw. Siehe
          <xref linkend="svn.ref.svnlook" /> für eine vollständige
          Referenz der Funktionen von
          <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

<!--
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>
-->
        <para>Obwohl es nicht das am meisten verwendete Werkzeug im
          Sortiment des Administrators sein wird, bietet
          <command>svndumpfilter</command> eine ganz besondere Art von
          nützlichen Funktionen &ndash; die Fähigkeit, schnell und
          einfach Datenströme aus der Projektarchiv-Historie zu
          verändern, indem es als ein pfadbasierter Filter
          arbeitet.</para>

<!--
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
-->
        <para>Die Syntax von <command>svndumpfilter</command> lautet
          wie folgt:</para>

<!--
        <informalexample>
          <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type 'svndumpfilter help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svndumpfilter - -version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svndumpfilter help
Aufruf: svndumpfilter UNTERBEFEHL [Optionen &amp; Parameter ...]
Geben Sie »svndumpfilter help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
          Unterbefehl zu erhalten.
Geben Sie »svndumpfilter --version« ein, um die Programmversion zu sehen.

Verfügbare Unterbefehle:
   exclude
   include
   help (?, h)
</screen>
        </informalexample>

<!--
        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>
-->
        <para>Es gibt nur zwei interessante Unterbefehle:
          <command>svndumpfilter exclude</command> und
          <command>svndumpfilter include</command>. Sie erlauben
          Ihnen, zwischen einer impliziten oder expliziten
          Einbeziehung von Pfaden im Datenstrom zu wählen. Sie können
          mehr über diese Unterbefehle und den einzigartigen Zweck von
          <command>svndumpfilter</command> später in diesem Kapitel
          unter <xref linkend="svn.reposadmin.maint.filtering" />
          erfahren.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnrdump">
        <title>svnrdump</title>

<!--
        <para>The <command>svnrdump</command> program is, to put it
          simply, essentially just network-aware flavors of
          the <command>svnadmin dump</command> and <command>svnadmin
          load</command> subcommands, rolled up into a separate
          program.</para>
-->
        <para>Das Programm <command>svnrdump</command> ist einfach im
          Wesentlichen eine Kombination netzfähiger Ausprägungen der
          Unterbefehle <command>svnadmin dump</command> und
          <command>svnadmin load</command>.</para>

        <informalexample>
          <screen>
$ svnrdump help <!--
general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]
Type 'svnrdump help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnrdump - -version' to see the program version and RA modules.

Available subcommands:
   dump
   load
   help (?, h) -->
Aufruf: svnrdump UNTERBEFEHL URL [-r VON[:BIS]]
Geben Sie »svnrdump help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
Unterbefehl zu erhalten.
Geben Sie »svnrdump --version« ein, um die Programmversion und die
Zugriffsmodule zu sehen.

Verfügbare Unterbefehle:
   dump
   load
   help (?, h)

$
</screen>
        </informalexample>

<!--
        <para>We discuss the use of <command>svnrdump</command> and
          the aforementioned <command>svnadmin</command> commands
          later in this chapter (see
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>
-->
        <para>Wir wedden sie Verwendung von
          <command>svnrdump</command> und dem vorher erwähnten Befehl
          <command>svnadmin</command> später in diesem Kapitel
          erörtern (siehe
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

<!--
        <para>The <command>svnsync</command> program provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote><footnote><para>Or is that,
          the <quote>sync</quote>?</para></footnote> repositories may
          be on different computers from each other and
          from <command>svnsync</command> itself.</para>
-->
        <para>Der Befehl <command>svnsync</command>, der in Subversion
          1.4 neu hinzugekommen ist, bietet Funktionen zum Verwalten
          eines Nur-Lese-Spiegels des Subversion-Projektarchivs. Das
          Programm hat eine Aufgabe &ndash; die versionierte Historie
          eines Projektarchivs in ein anderes zu übertragen. Und während
          es nicht viele Möglichkeiten gibt, dies zu tun, liegt seine
          hauptsächliche Stärke darin, das es aus der Ferne eingesetzt
          werden kann &ndash; das <quote>Quell</quote>- und
          <quote>Ziel</quote>-Projektarchiv können auf verschiedenen
          Rechnern liegen und auf einem anderen Rechner als
          <command>svnsync</command> selbst.</para>

<!--
        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>
-->
        <para>Wie Sie vielleicht erwarten, hat
          <command>svnsync</command> eine Syntax, die allen anderen
          Programmen aus diesem Kapitel gleicht:</para>

<!--
        <informalexample>
          <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync - -version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnsync help
Aufruf: svnsync UNTERBEFEHL ZIEL_URL [Optionen &amp; Parameter ...]
Geben Sie »svnsync help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
          Unterbefehl zu erhalten.
Geben Sie »svnsync --version« ein, um die Programmversion und die Zugriffs-
          module zu sehen.

Verfügbare Unterbefehle:
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)

$
</screen>
        </informalexample>

<!--
        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>
-->
        <para>Später in diesem Kapitel werden wir mehr über das
          Replizieren von Projektarchiven mit  <command>svnsync</command>
          reden (siehe <xref
          linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

<!--
        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories use individual
          files to house information about each revision.  Sometimes
          these files all live in a single directory; sometimes they
          are sharded across many directories.</para>
-->
        <para>Obwohl es kein offizielles Glied in der Werkzeugkette
          von Subversion ist, handelt es sich bei dem Skript
          <command>fsfs-reshard.py</command> (zu finden im Verzeichnis
          <filename>tools/server-side</filename> des
          Subversion-Quelltext-Paketes) um ein nützliches Werkzeug zur
          Leistungssteigerung für Administratoren von FSFS-basierten
          Subversion-Projektarchiven. FSFS-Projektarchive verwenden
          einzelne Dateien, die die zu einer Revision gehörenden
          Eigenschaften beherbergen. Manchmal liegen alle dieser
          Dateien in einem einzelnen Verzeichnis; manchmal werden sie
          über viele Verzeichnisse verteilt.</para>

<!--
        <para>The earliest FSFS release versions would house all the
          revision files within a single directory that grew&mdash;one
          file per revision&mdash;throughout the lifetime of your
          repository.  This created problems on systems which have
          hard limits on the number of files permitted in a given
          directory, and was a performance burden even on systems
          where such limits didn't exist or were set sufficiently
          high.</para>
-->
        <para>Die frühesten herausgegebenen FSFS Versionen brachten
          alle Revisionsdateien in einem einzelnen Verzeichnis unter,
          das während der gesamten Lebenszeit Ihres Projektarchivs
          wuchs: eine Datei pro Revision. Auf Systemen, die die Anzahl
          von Dateien pro Verzeichnis streng limitiert haben, erzeugte
          das Probleme und war sogar ein Leistungsproblem auf
          Systemen, die diese Begrenzung nicht hatten oder diese
          Grenzen hoch genug waren.</para>

<!--
        <para>Beginning in version 1.5, Subversion creates FSFS-backed
          repositories using a slightly modified layout in which the
          contents of the revision files directory (and other
          always-growing directories)
          are <firstterm>sharded</firstterm>, or scattered across
          several subdirectories.  This can greatly reduce the time it
          takes the system to locate any one of these files, and
          therefore increases the overall performance of Subversion
          when reading from the repository.</para>
-->
        <para>Beginnend mit Version 1.5 erstellt Subversion
          FSFS-basierte Projektarchive mit mit einem etwas veränderten
          Layout, bei dem der Inhalt des Verzeichnisses mit den
          Revisionsdateien (und anderer stets wachsender
          Verzeichnisse) in <firstterm>Scherben</firstterm>
          zerlegt wird, oder über mehrere Unterverzeichnisse
          verteilt wird. Das kann erheblich zur Verkürzung der Zeit
          beitragen, die das System benötigt, um irgendeine dieser
          Dateien zu finden, und somit die Gesamtleistung von
          Subversion beim Lesen des Projektarchivs erhöhen.</para>


<!--
        <para>The number of files permitted to live in a given
          subdirectory is a configurable thing (though the defaults
          are reasonable ones for most known platforms), but changing
          that configuration after the repository has been in use for
          some time could cause Subversion to be unable to locate the
          files it is looking for.  That's
          where <command>fsfs-reshard.py</command> comes in.</para>
-->
        <para>Die Anzahl der erlaubten Dateien in einem gegebenen
          Unterverzeichnis lässt sich konfigurieren (obwohl die
          Standardwerte für die meisten bekannten Plattformen
          angemessen sind); die Änderung dieser Konfiguration nachdem
          das Projektarchiv bereits einige Zeit in Betrieb war, könnte
          aber dazu führen, dass Subversion gesuchte Dateien nicht
          mehr findet. Hier kommt der Befehl
          <command>fsfs-reshard.py</command> ins Spiel.</para>

<!--
        <para><command>fsfs-reshard.py</command> reshuffles the
          repository's file structure into a new arrangement that
          reflects the requested number of sharding subdirectories and
          updates the repository configuration to preserve this
          change.  When used in conjunction with the <command>svnadmin
          upgrade</command> command, this is especially useful for
          upgrading a pre-1.5 Subversion (unsharded) repository to the
          latest filesystem format and sharding its data files (which
          Subversion will not automatically do for you).  This script
          can also be used for fine-tuning an already sharded
          repository.</para>
-->
        <para><command>fsfs-reshard.py</command> mischt
          die Dateistruktur des Projektarchivs, indem es sie gemäß der
          Anzahl der gewünschten Unterverzeichnisse neu anordnet und
          die Konfiguration des Projektarchivs aktualisiert, um diese
          Änderung zu bewahren. In Verbindung mit dem Befehl
          <command>svnadmin upgrade</command> erweist sich das als
          besonders nützlich, wenn ein Projektarchiv aus der Zeit vor
          Subversion 1.5 (mit unverteilten Verwaltungsdateien) in
          das neueste Dateisystem-Format überführt werden soll und
          dessen Dateien aufteilt (was Subversion nicht automatisch
          für Sie macht). Dieses Skript kann ebenfalls dazu verwendet
          werden, um ein bereits aufgeteiltes Projektarchiv noch
          feiner einzustellen.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
<!--
      <title>Commit Log Message Correction</title>
-->
      <title>Berichtigung des Protokolleintrags</title>

<!--
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        pre-revprop-change hook; see
        <xref linkend="svn.reposadmin.hooks" />) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>
-->
      <para>Manchmal kommt es vor, dass ein Anwender einen Fehler im
        Protokolleintrag gemacht hat (einen Tippfehler oder vielleicht
        eine Fehlinformation). Falls das Projektarchiv entsprechend
        eingestellt ist (indem der Hook
        pre-revprop-change verwendet wird; siehe
        <xref linkend="svn.reposadmin.hooks"/>), um Änderungen
        am Protokolleintrag vorzunehmen nachdem die Übergabe
        abgeschlossen ist, kann der Anwender den Protokolleintrag aus
        der Ferne mit dem Befehl <command>svn propset</command> (siehe
        <xref linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>) <quote>berichtigen</quote>.  Wegen
        der Möglichkeit, dadurch für immer Informationen zu verlieren,
        sind Subversion-Projektarchive allerdings standardmäßig nicht
        so eingestellt, dass Änderungen an unversionierten
        Eigenschaften erlaubt sind &ndash; außer für einen
        Administrator.</para>

<!--
      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
-->
      <para>Falls ein Protokolleintrag durch einen Administrator
        geändert werden muss, kann das mit <command>svnadmin
        setlog</command> geschehen. Dieser Befehl ändert den
        Protokolleintrag (die Eigenschaft <literal>svn:log</literal>)
        einer gegebenen Revision eines Projektarchivs, indem der neue
        Inhalt aus einer angegebenen Datei gelesen wird.</para>

      <informalexample>
        <screen><!--
$ echo "Here is the new, correct log message" &gt; newlog.txt
-->
$ echo "Hier ist der neue, korrekte Protokolleintrag" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      </informalexample>

<!--
      <para>The <command>svnadmin setlog</command> command, by
        default, is still bound by the same protections against
        modifying unversioned properties as a remote client
        is&mdash;the pre-revprop-change and
        post-revprop-change hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>- -bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
-->
      <para>Auch der Befehl <command>svnadmin setlog</command> ist
        standardmäßig durch dieselben Schutzmechanismen gegen die
        Veränderung unversionierter Eigenschaften eingeschränkt wie ein
        Client aus der Ferne &ndash; die Hooks
        pre-revprop-change und
        post-revprop-change werden immer noch
        ausgelöst und müssen entsprechend eingestellt werden, um
        solche Änderungen zuzulassen. Allerdings kann ein
        Administrator diese Schutzmechanismen umgehen, indem er die
        Option <option>--bypass-hooks</option> an den Befehl
        <command>svnadmin setlog</command> übergibt.</para>

      <warning>
<!--
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
-->
        <para>Denken Sie trotzdem daran, dass beim Umgehen der Hooks
          auch Dinge umgangen werden wie E-Mail-Benachrichtigungen bei
          Eigenschafts-Änderungen, Sicherungssysteme, die Änderungen an
          unversionierten Eigenschaften verfolgen, usw. Mit anderen
          Worten: Seien Sie sehr vorsichtig bei der Auswahl dessen,
          was Sie ändern und wie Sie es ändern.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
<!--
      <title>Managing Disk Space</title>
-->
      <title>Plattenplatzverwaltung</title>

<!--
      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>
-->
      <para>Obwohl die Kosten für Speicherplatz in den letzten Jahren
        unglaublich gefallen sind, ist Plattenplatz immer noch ein
        berechtigtes Anliegen für Administratoren, die große Mengen
        von Daten zu versionieren haben. Jedes im aktiven Projektarchiv
        gespeicherte Bisschen Information über die Versionshistorie
        muss zu einem anderen Ort gesichert werden; vielleicht sogar
        öfter, falls eine zyklische Sicherungsstrategie angewendet
        wird. Es ist zweckdienlich zu wissen, welche Teile von
        Subversions Projektarchiv am Ort verbleiben müssen, welche
        gesichert werden müssen und welche ruhig entfernt werden
        können.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
<!--
        <title>How Subversion saves disk space</title>
-->
        <title>Wie Subversion Plattenplatz spart</title>

<!--
        <para>
          <indexterm>
            <primary>deltification</primary>
          </indexterm>To keep the repository small, Subversion uses
          <firstterm>deltification</firstterm> (or delta-based storage)
          within the repository itself.  Deltification involves
          encoding the representation of a chunk of data as a
          collection of differences against some other chunk of data.
          If the two pieces of data are very similar, this
          deltification results in storage savings for the deltified
          chunk&mdash;rather than taking up space equal to the size of
          the original data, it takes up only enough space to
          say, <quote>I look just like this other piece of data over
          here, except for the following couple of changes.</quote>
          The result is that most of the repository data that tends to
          be bulky&mdash;namely, the contents of versioned
          files&mdash;is stored at a much smaller size than the
          original full-text representation of that data.</para>
-->
        <para>
          <indexterm>
            <primary>Delta-Kodierung</primary>
          </indexterm>Um das Projektarchiv klein zu halten, verwendet
          Subversion innerhalb des Projektarchivs
          <firstterm>Delta-Kodierung</firstterm> (oder
          Deltaspeicherung). Unter Delta-Kodierung wird die Kodierung
          eines Datensatzes als eine Sammlung von Unterschieden
          gegenüber einem anderen Datensatz verstanden. Falls die
          beiden Datensätze sehr ähnlich sind, bewirkt diese
          Delta-Kodierung eine Einsparung an Speicherplatz für den als
          Delta gespeicherten Datensatz &ndash; anstatt den
          Platz der Originaldaten zu belegen, wird hierbei nur soviel
          Platz benötigt, um zu sagen: <quote>Schau mal, ich sehe
          genau so aus, wie der andere Datensatz da drüben, bis auf
          die folgenden paar Änderungen.</quote> Das Ergebnis ist,
          dass die meisten der Daten im Projektarchiv, die normalerweise
          recht voluminös sind &ndash; nämlich der Inhalt
          versionierter Dateien &ndash; in einer viel geringeren Größe
          gespeichert werden als der ursprüngliche Volltext dieser
          Daten.</para>

<!--
        <para>
          <indexterm>
            <primary>representation sharing</primary>
          </indexterm>While deltified storage has been a part of Subversion's
          design since the very beginning, there have been additional
          improvements made over the years.  Subversion repositories
          created with Subversion 1.4 or later benefit from
          compression of the full-text representations of file
          contents.  Repositories created with Subversion 1.6 or later
          further enjoy the disk space savings afforded by
          <firstterm>representation sharing</firstterm>, a feature
          which allows multiple files or file revisions with identical
          file content to refer to a single shared instance of that data
          rather than each having their own distinct copy thereof.</para>
-->
        <para>
          <indexterm>
            <primary>geteilte Repräsentation</primary>
          </indexterm>Während die delta-kodierte Speicherung bereits von
          Anfang an ein Teil des Designs von Subversion gewesen ist,
          sind im Laufe der Jahre zusätzliche Verbesserungen
          vorgenommen worden. Subversion Projektarchive, die mit
          Subversion 1.4 oder neuer erstellt worden sind, ziehen
          Nutzen aus der Komprimierung der Volltext-Repräsentation
          von Dateiinhalten. Projektarchiv, die mit Subversion 1.6
          oder neuer erstellt worden sind, genießen darüber hinaus den
          durch <firstterm>geteilte Repräsentation</firstterm>
          gesparten Plattenplatz, eine Funktionalität, die es mehreren
          Dateien oder Dateirevisionen mit identischen Dateiinhalt
          erlaubt, auf eine einzelne geteilte Instanz dieser Daten zu
          verweisen, anstatt eine eigene, getrennte Kopie davon
          vorhalten zu müssen.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
<!--
        <title>Removing dead transactions</title>
-->
        <title>Entfernen unvollendeter Transaktionen</title>

<!--
        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>
-->
        <para>Obwohl es selten vorkommt, gibt es Umstände, unter denen
          der Übergabeprozess mit einem Fehler abbricht und die Reste
          einer Revision in Spe  hinterlässt &ndash; eine unvollendete
          Transaktion samt aller Datei- und Verzeichnisänderungen, die
          dazugehören. Dies kann aus verschiedenen Gründen passieren:
          Vielleicht wurde die Operation des Clients vom Anwender
          unsauber beendet oder es trat mittendrin ein Netzfehler auf.
          Aus welchem Grund auch immer, es können unvollendete
          Transaktionen auftreten. Sie verursachen keine tatsächlichen
          Schäden, außer Plattenplatz zu verschwenden. Ein penibler
          Administrator möchte sie vielleicht dennoch
          entfernen.</para>

<!--
        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>
-->
        <para>Sie können den Befehl <command>svnadmin lstxns</command>
          verwenden, um die Namen der aktuell ausstehenden
          Transaktionen anzuzeigen:</para>

        <informalexample>
          <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
        </informalexample>

<!--
        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>- -transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>
-->
        <para>Jeder Eintrag der Ausgabe kann dann mit dem Befehl
          <command>svnlook</command> (und seiner Option
          <option>--transaction</option> (<option>-t</option>))
          aufgerufen werden, um festzustellen, wer die Transaktion
          erzeugt hat, wann sie erzeugt wurde und welche Änderungen
          sie beinhaltet &ndash; Informationen, die bei der
          Entscheidung helfen können, ob eine Transaktion ein sicherer
          Kandidat zum Löschen ist! Wenn Sie tatsächlich eine
          Transaktion löschen wollen, kann deren Name an den Befehl
          <command>svnadmin rmtxns</command> übergeben werden, der
          dann die Transaktion aufräumt. <command>svnadmin
          rmtxns</command> kann seine Eingabe auch direkt aus der
          Ausgabe von <command>svnadmin lstxns</command>
          beziehen!</para>

        <informalexample>
          <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
        </informalexample>

<!--
        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>
-->
        <para>Falls Sie auf diese Weise diese beiden Unterbefehle
          verwenden, sollten Sie vorübergehend das Projektarchiv für
          Clients unzugänglich machen. So kann niemand eine
          berechtigte Transaktion beginnen, bevor Sie aufgeräumt
          haben.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          enthält ein kleines Shell-Skript, das schnell eine Übersicht
          über jede ausstehende Transaktion in Ihrem Projektarchiv
          erzeugen kann.</para>

<!--
        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (reporting outstanding transactions)</title>
-->
        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (ausstehende Transaktionen anzeigen)</title>

<!--
          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "- -[ Transaction ${TXN} ]- - - - - - - - - - - - - - - - - - - - - -"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
-->
          <programlisting>
#!/bin/sh

### Erzeuge Informationen über alle ausstehenden Transaktionen eines
### Subversion Projektarchivs.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "Aufruf: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaktion ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

<!--
        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>
-->
        <para>Die Ausgabe des Skriptes ist im Grunde genommen eine
          Aneinanderreihung mehrerer Teile von <command>svnlook
          info</command>-Ausgaben (siehe <xref
          linkend="svn.reposadmin.maint.tk.svnlook"/>) und sieht etwa
          so aus:</para>

<!--
        <informalexample>
          <screen>
$ txn-info.sh myrepos
- -[ Transaction 19 ]- - - - - - - - - - - - - - - - - - - - - -
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
- -[ Transaction 3a1 ]- - - - - - - - - - - - - - - - - - - - - -
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
- -[ Transaction a45 ]- - - - - - - - - - - - - - - - - - - - - -
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ txn-info.sh myrepos
---[ Transaktion 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Di, 04. Sep 2001)
0
---[ Transaktion 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mo, 10. Sep 2001)
39
Versuch, über eine schlechte Netzverbindung abzuliefern.
---[ Transaktion a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Mi, 12. Sep 2001)
0
$
</screen>
        </informalexample>

<!--
        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>
-->
        <para>Eine vor langer Zeit aufgegebene Transaktion bedeutet
          normalerweise eine Art fehlgeschlagenen oder unterbrochenen
          Übergabeversuch. Der Zeitstempel einer Transaktion kann eine
          interessante Information sein &ndash; ist es beispielsweise
          wahrscheinlich, dass eine vor neun Monaten begonnene
          Operation immer noch aktiv ist?</para>

<!--
        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>
-->
        <para>Kurz gesagt, Entscheidungen zur Bereinigung von
          Transaktionen sollten klug getroffen werden. Verschiedene
          Informationsquellen &ndash; hierzu gehören die Fehler- und
          Zugriffs-Protokolldateien von Apache, die operativen
          Protokolldateien von Subversion, die Revisions-Historie von
          Subversion usw. &ndash; können während des
          Entscheidungsprozesses hinzugezogen werden. Natürlich kann
          sich ein Administrator auch einfach  mit dem Eigentümer
          einer anscheinend abgebrochenen Transaktion in Verbindung
          setzen (z.B., per E-Mail), um sicherzustellen, dass die
          Transaktion sich tatsächlich in einem Zombie-Zustand
          befindet.</para>

      </sect3>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.fsfspacking">
<!--
        <title>Packing FSFS filesystems</title>
-->
        <title>FSFS Filtersystem packen</title>

<!--
        <para>FSFS repositories contain files that describe the
          changes made in a single revision, and files that contain
          the revision properties associated with a single revision.
          Repositories created in versions of Subversion prior to 1.5
          keep these files in two directories&mdash;one for each type
          of file.  As new revisions are committed to the repository,
          Subversion drops more files into these two
          directories&mdash;over time, the number of these files in
          each directory can grow to be quite large.  This has been
          observed to cause performance problems on certain
          network-based filesystems.</para>
-->
        <para>FSFS-Projektarchive beinhalten Dateien, die die in einer
          einzelnen Revision gemachten Änderungen beschreiben und
          Dateien, die die Revisions-Eigenschaften beinhalten, die mit
          einer einzelnen Revision verknüpft sind. Projektarchive, die
          mit früheren Versionen von Subversion als 1.5 erzeugt
          wurden, speichern diese Dateien in zwei Verzeichnissen &ndash;
          jeweils eins für jeden Dateitypen Während neue Revisionen an das
          Projektarchiv übertragen werden, hinterlegt Subversion mehr
          Dateien in den beiden Verzeichnissen; im Lauf der Zeit kann die
          Anzahl dieser Dateien ziemlich groß werden. Es wurde bei bestimmten
          netzbasierten Dateisystemen wurde beobachtet, dass dies zu
          Leistungseinbußen führt..</para>

<!--
        <para>The first problem is that the operating system has to
          reference many different files over a short period of time.
          This leads to inefficient use of disk caches and, as a
          result, more time spent seeking across large disks.  Because
          of this, Subversion pays a performance penalty when
          accessing your versioned data.</para>
-->
        <para>Das erste Problem besteht darin, dass das Betriebssystem
          innerhalb kurzer Zeit auf viele verschiedene Dateien
          beziehen muss. Das führt zur ineffektiven Verwendung von
          Zwischenspeicherungen der Platte und hat zur Folge, dass bei
          großen Platten viel Zeit zum Suchen verbraucht wird. Daher
          kommt es beim Zugriff von Subversion auf versionierte Daten
          zu Leistungseinbußen.</para>

<!--
        <para>The second problem is a bit more subtle.  Because of the
          ways that most filesystems allocate disk space, each file
          claims more space on the disk than it actually uses.  The
          amount of extra space required to house a single file can
          average anywhere from 2 to 16 kilobytes <emphasis>per
          file</emphasis>, depending on the underlying
          filesystem in use.  This translates directly
          into a per-revision disk usage penalty for FSFS-backed
          repositories.  The effect is most pronounced in repositories
          which have many small revisions, since the overhead involved
          in storing the revision file quickly outgrows the size of
          the actual data being stored.</para>
-->
        <para>Das zweite Problem ist etwas subtiler. Aufgrund der Art
          und Weise wie die meisten Dateisysteme Plattenplatz
          zuweisen, benötigt eine Datei mehr Platz, als sie eigentlich
          belegt. Der Umfang des zusätzlichen Platzes, um eine
          einzelne Datei unterzubringen, kann, je nach verwendetem
          Dateisystem durchschnittlich irgendwo zwischen 2 und 16
          Kilobyte <emphasis>pro Datei</emphasis> liegen. Das bedeutet
          pro Revision eine Einbuße bei der Plattennutzung für
          Projektarchive auf FSFS Basis. Besonders deutlich wird der
          Effekt bei Projektarchiven mit vielen kleinen Revisionen, da
          hier platzmäßig die Kosten der Speicherung der
          Revisionsdatei schnell den Umfang der eigentlich zu
          speichernden Daten überschreiten.</para>

<!--
        <para>To solve these problems, Subversion 1.6 introduced the
          <command>svnadmin pack</command> command.  By concatenating
          all the files of a completed shard into a single <quote>pack</quote> file
          and then removing the original per-revision
          files, <command>svnadmin pack</command> reduces the file
          count within a given shard down to just a single file.  In
          doing so, it aids filesystem caches and reduces (to one) the
          number of times a file storage overhead penalty is
          paid.</para>
-->
        <para>Zur Lösung dieser Probleme führte Subversion 1.6 den
          Befehl <command>svnadmin pack</command> ein. Durch das
          Aneinanderfügen aller Dateien einer vollständigen Scherbe in
          eine einzelne <quote>pack</quote>-Datei und das
          anschließende Entfernen der ursprünglichen Dateien, die pro
          Revision angelegt wurden, verringert <command>svnadmin
          pack</command> die Anzahl der Dateien innerhalb einer
          gegebenen Scherbe auf nur eine einzelne Datei.
          Das kommt den Zwischenspeichern des Dateisystems entgegen
          und verringert die Anzahl der Kosten für Dateispeicherung
          auf eins.</para>

<!--
        <para>Subversion can pack existing sharded repositories which
          have been upgraded to the 1.6 filesystem format or later (see
          <xref linkend="svn.ref.svnadmin.c.upgrade"/>) in
          <xref linkend="svn.ref.svnadmin"/>.  To do so, just
          run <command>svnadmin pack</command> on the
          repository:</para>
-->
        <para>Subversion kann bestehende zerlegte Projektarchive
          packen, die auf das Dateisystemformat von 1.6 oder neuer
          aktualisiert worden sind (siehe
          <xref linkend="svn.ref.svnadmin.c.upgrade"/> in
          <xref linkend="svn.ref.svnadmin"/>). Lassen Sie dafür einfach
          <command>svnadmin pack</command> über das Projektarchiv
          laufen:</para>

<!--
        <informalexample>
          <screen>
$ svnadmin pack /var/svn/repos
Packing shard 0...done.
Packing shard 1...done.
Packing shard 2...done.
&hellip;
Packing shard 34...done.
Packing shard 35...done.
Packing shard 36...done.
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnadmin pack /var/svn/repos
Packe 0...erledigt.
Packe 1...erledigt.
Packe 2...erledigt.
&hellip;
Packe 34...erledigt.
Packe 35...erledigt.
Packe 36...erledigt.
$
</screen>
        </informalexample>

<!--
        <para>Because the packing process obtains the required locks
          before doing its work, you can run it on live repositories,
          or even as part of a post-commit hook.  Repacking packed
          shards is legal, but will have no effect on the disk usage
          of the repository.</para>
-->
        <para>Da der Packprozess die benötigten Sperren erlangt, bevor
          er seine Arbeit beginnt, können Sie ihn auf in Benutzung
          befindliche Projektarchive anwenden oder sogar als Teil
          eines Hooks nach der Übergabe. Das erneute Packen bereits
          gepackter Scherben ist legal, hat allerdings keine
          Auswirkungen auf den Plattenplatzverbrauch des
          Projektarchivs.</para>

<!--
        <para><command>svnadmin pack</command> has no effect on
          BDB-backed Subversion repositories.</para>
-->
        <para><command>svnadmin pack</command> hat keine Auswirkungen
          auf Subversion-Projektarchive auf BDB-Basis.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
<!--
      <title>Migrating Repository Data Elsewhere</title>
-->
      <title>Projektarchiv-Daten woanders hin verschieben</title>

<!--
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>
-->
      <para>Ein Subversion-Dateisystem hält seine Daten in Dateien,
        die auf eine Art und Weise über das Projektarchiv verstreut sind,
        die im Allgemeinen nur die Subversion-Entwickler selbst
        verstehen (und auch nur sie interessieren).  Allerdings können
        es bestimmte Umstände erforderlich machen, alle Daten oder nur
        Teile davon in ein anderes Projektarchiv zu kopieren oder zu
        verschieben.</para>

<!--
      <para>
        <indexterm>
          <primary>repository dump streams</primary>
        </indexterm>
        <indexterm>
          <primary>dump files</primary>
          <see>repository dump streams</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands, respectively,
        and the <command>svnrdump</command> program.</para>
-->
      <para>
        <indexterm>
          <primary>Projektarchiv-Auszugs-Datenströme</primary>
        </indexterm>
        <indexterm>
          <primary>Auszugsdatei</primary>
          <see>Projektarchiv-Auszugs-Datenströme</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>Unterbefehle</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>Unterbefehle</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion stellt solche Funktionen durch
        <firstterm>Projektarchiv-Auszugs-Datenströme</firstterm>
        (repository dump streams) bereit.  Ein
        Projektarchiv-Auszugs-Datenstrom (oft als
        <quote>Auszugsdatei</quote> bezeichnet, wenn er als Datei auf
        Platte gespeichert wird) ist ein portables, flaches
        Dateiformat, das die zahlreichen Revisionen in Ihrem
        Projektarchiv beschreibt &ndash; was geändert wurde, von wem usw.
        Dieser Datenstrom ist der primäre Mechanismus zum
        Herumschieben der versionierten Historie &ndash; als Ganzes
        oder in Teilen, mit oder ohne Änderung &ndash; zwischen
        Projektarchiven. Und Subversion stellt die Werkzeuge zum Erzeugen
        und Laden dieser Datenströme zur Verfügung: die Unterbefehle
        <command>svnadmin dump</command> bzw.  <command>svnadmin
        load</command> und das Programm <command>svnrdump</command>.</para>

      <warning>
<!--
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
-->
        <para>Obwohl das Format der Subversion Auszugsströme
          menschenlesbare Teile enthält und das Format eine gewohnte
          Struktur besitzt (es gleicht einem RFC 822 Format, das
          meistens für E-Mail verwendet wird), ist es
          <emphasis>kein</emphasis> reines Textformat. Es ist ein
          Binärformat, das sehr empfindlich gegenüber Herumgepfusche
          ist. Beispielsweise würden viele Texteditoren die Datei
          beschädigen, indem sie automatisch die Zeilenenden
          umformen.</para>
      </warning>

<!--
      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>
-->
      <para>Es gibt viele Gründe, Auszüge von
        Subversion-Projektarchiv-Daten zu machen und zu laden. In der
        Anfangsphase von Subversion war der häufigste Grund die
        Weiterentwicklung von Subversion an sich. Während Subversion
        reifte, gab es Zeiten, als Änderungen an der Datenbankbasis zu
        Kompatibilitätsproblemen mit früheren Projektarchiv-Versionen
        führten, so dass Anwender mit der vorherigen Version von
        Subversion Auszüge von ihren Projektarchiv-Daten machen und sie
        mit der neueren Version von Subversion in ein frisch erzeugtes
        Projektarchiv laden mussten. Diese Schemaänderungen haben seit
        Subversion 1.0 nicht mehr stattgefunden, und die
        Subversion-Entwickler versprechen, dass die Anwender zwischen
        Unterversionen von Subversion (wie etwa von 1.3 nach 1.4)
        keine Abzüge ihrer Projektarchive machen und neu laden müssen.
        Jedoch gibt es noch andere Gründe, die es erforderlich machen,
        zu denen Dinge gehören wie das erneute Aufsetzen eines
        Berkeley-DB-Projektarchivs auf einem neuen Betriebssystem oder
        einer CPU-Architektur, der Wechsel von einem
        Berkeley-DB-basierten auf ein FSFS-basiertes Projektarchiv oder
        (was wir später in diesem Kapitel in <xref
        linkend="svn.reposadmin.maint.filtering" /> behandeln werden)
        das Entfernen versionierter Daten aus der
        Projektarchiv-Historie.</para>

<!--
      <note>
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      </note>
-->
      <note>
        <para>Das Auszugsformat eines Subversion Projektarchivs
          beschreibt nur versionierte Änderungen. Es beinhaltet keine
          Informationen über unvollendete Transaktionen, von Anwendern
          gesetzte Sperren auf Pfade im Projektarchiv, Anpassungen an
          Projektarchiv- oder Server-Konfigurationen (inklusive
          Hook-Skripten) usw.</para></note>

<!--
      <para>The Subversion repository dump format also enables
        conversion from a different storage mechanism or version
        control system altogether.  Because the dump file format is,
        for the most part, human-readable, it should be relatively
        easy to describe generic sets of changes&mdash;each of which
        should be treated as a new revision&mdash;using this file
        format.  In fact, the <command>cvs2svn</command> utility (see
        <xref linkend="svn.forcvs.convert" />) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>
-->
      <para>Das Auszugsformat eines Subversion Projektarchivs erlaubt
        ebenfalls die Umwandlung aus einem vollständig
        unterschiedlichen Speichermechanismus oder
        Versions-Kontroll-System. Da das Format der Auszugsdatei
        größtenteils menschenlesbar ist, sollte es relativ einfach
        sein, in diesem Dateiformat generische Änderungsmengen zu
        beschreiben, wobei jede als neue Revision behandelt werden
        sollte. Tatsächlich verwendet das Werkzeug
        <command>cvs2svn</command> (siehe
        <xref linkend="svn.forcvs.convert" />) das Auszugsformat, um den
        Inhalt eines CVS Projektarchivs zu repräsentieren, so dass
        dieser Inhalt in ein Subversion Projektarchiv kopiert werden
        kann.</para>

<!--
      <para>For now, we'll concern ourselves only with migration of
        repository data between Subversion repositories, which we'll
        describe in detail in the sections which follow.</para>
-->
      <para>Momentan beschäftigen wir uns lediglich mit der Migration
        von Projektarchiv-Daten zwischen Subversion Projektarchiven,
        die wir detailliert in den folgenden Abschnitten beschreiben
        werden.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnadmin">
        <title>Repository data migration using svnadmin</title>

<!--
        <para>Whatever your reason for migrating repository history,
          using the <command>svnadmin dump</command> and
          <command>svnadmin load</command> subcommands is
          straightforward.  <command>svnadmin dump</command> will output
          a range of repository revisions that are formatted using
          Subversion's custom filesystem dump format.  The dump format
          is printed to the standard output stream, while informative
          messages are printed to the standard error stream.  This
          allows you to redirect the output stream to a file while
          watching the status output in your terminal window.  For
          example:</para>
-->
        <para>Welche Gründe für den Umzug der Projektarchiv-Historie für
          Sie auch immer eine Rolle spielen, die Verwendung der
          Unterbefehle <command>svnadmin dump</command> und
          <command>svnadmin load</command> sind der direkte Weg.
          <command>svnadmin dump</command> gibt ein Intervall von
          Projektarchiv-Revisionen im speziellen Subversion-Auszugsformat
          aus. Der Auszug wird zur Standardausgabe geschrieben, während
          Mitteilungen an die Standardfehlerausgabe gehen. Das erlaubt
          Ihnen, den Ausgabestrom in eine Datei umzuleiten, während Sie
          Statusausgaben im Terminalfenster verfolgen können. Zum
          Beispiel:</para>

<!--
        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Revision 0 ausgegeben.
* Revision 1 ausgegeben.
* Revision 2 ausgegeben.
&hellip;
* Revision 25 ausgegeben.
* Revision 26 ausgegeben.
</screen>
        </informalexample>

<!--
        <para>At the end of the process, you will have a single file
          (<filename>dumpfile</filename> in the previous example) that
          contains all the data stored in your repository in the
          requested range of revisions.  Note that <command>svnadmin
          dump</command> is reading revision trees from the repository
          just like any other <quote>reader</quote> process would
          (e.g., <command>svn checkout</command>), so it's safe
          to run this command at any time.</para>
-->
        <para>Am Ende haben Sie eine einzelne Datei (im vorangegangenen
          Beispiel <filename>dumpfile</filename>), die alle im
          Projektarchiv gespeicherten Daten aus dem gewählten Intervall von
          Revisionen beinhaltet. Beachten Sie, dass <command>svnadmin
          dump</command> wie jeder andere <quote>lesende</quote> Prozess
          (z.B. <command>svn checkout</command>) Revisionsbäume aus dem
          Projektarchiv liest, so dass Sie diesen Befehl jederzeit aufrufen
          können.</para>

<!--
        <para>The other subcommand in the pair, <command>svnadmin
          load</command>, parses the standard input stream as a
          Subversion repository dump file and effectively replays those
          dumped revisions into the target repository for that
          operation.  It also gives informative feedback, this time
          using the standard output stream:</para>
-->
        <para>Der andere Unterbefehl dieses Paars, <command>svnadmin
          load</command>, liest den Standardeingabestrom als eine
          Subversion-Projektarchiv-Auszugsdatei und spielt diese Revisionen
          aus dem Auszug gewissermaßen neu in das Ziel-Projektarchiv. Auch
          dieser Befehl erzeugt Meldungen, dieses Mal aber über die
          Standardausgabe:</para>

<!--
        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
- - - - Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

- - - - Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

- - - - Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

- - - - Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: A ... erledigt.
     * Füge Pfad hinzu: A/B ... erledigt.
     &hellip;
------- Neue Revision 1 übertragen (geladen aus Original 1) &gt;&gt;&gt;

&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 2 gestartet
     * Bearbeite Pfad: A/mu ... erledigt.
     * Bearbeite Pfad: A/D/G/rho ... erledigt.

------- Neue Revision 2 übertragen (geladen aus Original 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 25 gestartet
     * Bearbeite Pfad: A/D/gamma ... erledigt.

------- Neue Revision 25 übertragen (geladen aus Original 25) &gt;&gt;&gt;

&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 26 gestartet
     * Füge Pfad hinzu: A/Z/zeta ... erledigt.
     * Bearbeite Pfad: A/mu ... erledigt.

------- Neue Revision 26 übertragen (geladen aus Original 26) &gt;&gt;&gt;

</screen>
        </informalexample>

<!--
        <para>The result of a load is new revisions added to a
          repository&mdash;the same thing you get by making commits
          against that repository from a regular Subversion client.
          Just as in a commit, you can use hook programs to perform
          actions before and after each of the commits made during a
          load process.  By passing the
          <option>- -use-pre-commit-hook</option> and
          <option>- -use-post-commit-hook</option> options to
          <command>svnadmin load</command>, you can instruct
          Subversion to execute the pre-commit and post-commit hook
          programs, respectively, for each loaded revision.  You might
          use these, for example, to ensure that loaded revisions pass
          through the same validation steps that regular commits pass
          through.  Of course, you should use these options with
          care&mdash;if your post-commit hook sends emails to a
          mailing list for each new commit, you might not want to spew
          hundreds or thousands of commit emails in rapid succession
          at that list!  You can read more about the use of hook
          scripts in <xref linkend="svn.reposadmin.hooks" />.</para>
-->
        <para>Das Ergebnis eines Ladevorgangs sind neue Revisionen, die
          dem Projektarchiv hinzugefügt wurden &ndash; dasselbe, was Sie
          erhalten, wenn Sie mit einem normalen Subversion-Client
          Übergaben an das Projektarchiv machen. Ebenso wie bei einer
          Übergabe können können Sie Hook-Programme verwenden, um
          Aktionen vor und nach jeder Übergabe während des Ladevorgangs
          auszuführen. Indem Sie die Optionen
          <option>--use-pre-commit-hook</option> und
          <option>--use-post-commit-hook</option> an <command>svnadmin
          load</command> übergeben, können Sie Subversion befehlen, für
          jede zu ladende Revision die Hook-Programme pre-commit bzw.
          post-commit auszuführen. Sie könnten diese beispielsweise
          verwenden, um sicherzustellen, dass die geladenen Revisionen
          dieselben Validierungsschritte durchlaufen müssen wie reguläre
          Übergaben. Natürlich sollten Sie diese Optionen mit Sorgfalt
          verwenden &ndash; wenn Ihr post-commit-Hook für jede neue
          Übergabe E-Mails an eine Mailing-Liste verschickt, wollen Sie
          bestimmt nicht, das innerhalb kürzester Zeit hunderte oder
          tausende Übergabe-E-Mails in diese Liste hineinhageln! Sie
          können mehr über Hook-Skripte in
          <xref linkend="svn.reposadmin.hooks"/> lesen.</para>

<!--
        <para>Note that because <command>svnadmin</command> uses
          standard input and output streams for the repository dump and
          load processes, people who are feeling especially saucy can try
          things such as this (perhaps even using different versions of
          <command>svnadmin</command> on each side of the pipe):</para>
-->
        <para>Beachten Sie, dass Menschen, die sich besonders gewitzt
          fühlen, weil <command>svnadmin</command> für den Auszug und
          den Ladevorgang den Standardeingabe- und den
          Standardausgabestrom benutzt, Dinge wie dieses ausprobieren
          können (vielleicht sogar unterschiedliche Versionen von
          <command>svnadmin</command> auf jeder Seite der Pipe):</para>

        <informalexample>
          <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>
        </informalexample>

<!--
        <para>By default, the dump file will be quite large&mdash;much
          larger than the repository itself.  That's because by default
          every version of every file is expressed as a full text in the
          dump file.  This is the fastest and simplest behavior, and
          it's nice if you're piping the dump data directly into some other
          process (such as a compression program, filtering program, or
          loading process).  But if you're creating a dump file
          for longer-term storage, you'll likely want to save disk space
          by using the <option>- -deltas</option> option.  With this
          option, successive revisions of files will be output as
          compressed, binary differences&mdash;just as file revisions
          are stored in a repository.  This option is slower, but it
          results in a dump file much closer in size to the original
          repository.</para>
-->
        <para>Im Normalfall wird die Auszugsdatei ziemlich groß &ndash;
          viel größer als das Projektarchiv selbst. Das liegt daran, dass
          standardmäßig jede Version jeder Datei als vollständiger Text
          in der Auszugsdatei dargestellt wird. Dies ist das schnellste
          und einfachste Verhalten, und es ist nett, wenn Sie die
          Auszugsdaten über eine Pipe direkt an einen weiteren Prozess
          weiterleiten (etwa ein Komprimierprogramm, ein Filterprogramm
          oder einen Prozess zum Laden). Wenn Sie jedoch eine
          Auszugsdatei für die Langzeitspeicherung erzeugen, möchten Sie
          wahrscheinlich Plattenplatz sparen, indem Sie die Option
          <option>--deltas</option> verwenden. Mit dieser Option werden
          aufeinanderfolgende Revisionen von Dateien als komprimierte
          binäre Unterschiede ausgegeben &ndash; so wie Dateirevisionen
          im Projektarchiv gespeichert werden. Diese Option ist langsamer,
          führt jedoch zu einer Größe der Auszugsdatei, die der Größe
          des Original-Projektarchivs näher kommt.</para>

<!--
        <para>We mentioned previously that <command>svnadmin
          dump</command> outputs a range of revisions.  Use the
          <option>- -revision</option> (<option>-r</option>) option to
          specify a single revision, or a range of revisions, to dump.
          If you omit this option, all the existing repository revisions
          will be dumped.</para>
-->
        <para>Wir haben eben erwähnt, dass <command>svnadmin
          dump</command> einen Bereich von Revisionen ausgibt. Verwenden
          Sie die Option <option>--revision</option>
          (<option>-r</option>), um eine einzelne Revision oder einen
          Bereich von Revisionen für den Auszug anzugeben. Wenn Sie
          diese Option weglassen, wird ein Auszug aller
          Projektarchiv-Revisionen erstellt.</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>
        </informalexample>

<!--
        <para>As Subversion dumps each new revision, it outputs only
          enough information to allow a future loader to re-create that
          revision based on the previous one.  In other words, for any
          given revision in the dump file, only the items that were
          changed in that revision will appear in the dump.  The only
          exception to this rule is the first revision that is dumped
          with the current <command>svnadmin dump</command>
          command.</para>
-->
        <para>Beim Erstellen eines Auszugs jeder Revision gibt
          Subversion gerade soviel Information aus, dass später ein
          Ladeprozess in der Lage ist, diese Revision auf der Basis der
          Vorgängerrevision wiederherzustellen. Mit anderen Worten: Für
          jede Revision befinden sich nur die Dinge in der Auszugsdatei,
          die sich in dieser Revision geändert haben. Die einzige
          Ausnahme von dieser Regel ist die erste Revision, die mit dem
          aktuellen <command>svnadmin dump</command> erstellt
          wird.</para>

<!--
        <para>By default, Subversion will not express the first dumped
          revision as merely differences to be applied to the previous
          revision.  For one thing, there is no previous revision in the
          dump file!  And second, Subversion cannot know the state of
          the repository into which the dump data will be loaded (if it
          ever is).  To ensure that the output of each
          execution of <command>svnadmin dump</command> is
          self-sufficient, the first dumped revision is, by default, a
          full representation of every directory, file, and property in
          that revision of the repository.</para>
-->
        <para>Standardmäßig wird Subversion den Auszug der ersten
          Revision nicht bloß als Unterschied ausdrücken, der auf die
          Vorgängerrevision anzuwenden ist. Zum Ersten gibt es keine
          Vorgängerrevision in der Auszugsdatei. Und zum Zweiten kann
          Subversion den Zustand des Projektarchivs, in das der Auszug
          (falls überhaupt) geladen werden soll, nicht kennen. Um
          sicherzustellen, dass die Ausgabe jedes Aufrufs von
          <command>svnadmin dump</command> unabhängig ist, ist der
          Auszug der ersten Revision standardmäßig eine vollständige
          Darstellung jedes Verzeichnisses, jeder Datei und jeder
          Eigenschaft aus dieser Revision im Projektarchiv.</para>

<!--
        <para>However, you can change this default behavior.  If you add
          the <option>- -incremental</option> option when you dump your
          repository, <command>svnadmin</command> will compare the first
          dumped revision against the previous revision in the
          repository&mdash;the same way it treats every other revision that
          gets dumped.  It will then output the first revision exactly
          as it does the rest of the revisions in the dump
          range&mdash;mentioning only the changes that occurred in that
          revision.  The benefit of this is that you can create several
          small dump files that can be loaded in succession, instead of
          one large one, like so:</para>
-->
        <para>Sie können dieses Standardverhalten jedoch ändern. Falls
          Sie die Option <option>--incremental</option> angeben,
          vergleicht <command>svnadmin</command> die erste Revision für
          die ein Auszug erstellt werden soll mit der vorhergehenden
          Revision im Projektarchiv &ndash; auf dieselbe Art und Weise, wie
          jede andere Revision behandelt wird, für die ein Auszug
          erstellt werden soll &ndash; indem lediglich die Änderungen
          aus dieser Revision erwähnt werden. Der Vorteil dabei ist,
          dass Sie mehrere kleinere Auszugsdateien erstellen können, die
          hintereinander geladen werden können, anstatt eine
          große:</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>
        </informalexample>

<!--
        <para>These dump files could be loaded into a new repository
          with the following command sequence:</para>
-->
        <para>Diese Auszugsdateien können mit der folgenden Befehlsfolge
          in ein neues Projektarchiv geladen werden:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
        </informalexample>

<!--
        <para>Another neat trick you can perform with this
          <option>- -incremental</option> option involves appending to an
          existing dump file a new range of dumped revisions.  For
          example, you might have a post-commit hook
          that simply appends the repository dump of the single revision
          that triggered the hook.  Or you might have a script that runs
          nightly to append dump file data for all the revisions that
          were added to the repository since the last time the script
          ran.  Used like this, <command>svnadmin dump</command> can be
          one way to back up changes to your repository over time in case
          of a system crash or some other catastrophic event.</para>
-->
        <para>Ein weiterer toller Trick, den Sie mit der Option
          <option>--incremental</option> anwenden können besteht darin,
          einen neuen Bereich von Revisionsauszügen an eine existierende
          Revisionsdatei anzuhängen. Beispielsweise könnten Sie einen
          post-commit-Hook haben, der der Datei einen
          Auszug derjenigen Revision anfügt, die den Hook ausgelöst hat.
          Oder Sie haben ein Skript, das jede Nacht läuft, um Auszüge
          sämtlicher Revisionen seit dem letzten Lauf anzufügen. Wenn es
          auf diese Weise verwendet wird, stellt <command>svnadmin
          dump</command> eine Möglichkeit dar, laufend die Änderungen an
          Ihrem Projektarchiv für den Fall eines Systemabsturzes oder eines
          anderen katastrophalen Ereignisses zu sichern.</para>

<!--
        <para>The dump format can also be used to merge the contents of
          several different repositories into a single repository.  By
          using the <option>- -parent-dir</option> option of
          <command>svnadmin load</command>, you can specify a new
          virtual root directory for the load process.  That means if
          you have dump files for three repositories&mdash;say
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename>, and
          <filename>ss-dumpfile</filename>&mdash;you can first create a new
          repository to hold them all:</para>
-->
        <para>Das Auszugsformat kann auch dazu verwendet werden, um die
          Inhalte mehrerer verschiedener Projektarchive in ein Projektarchiv
          zusammenzuführen. Indem Sie die Option
          <option>--parent-dir</option> von <command>svnadmin
          load</command> benutzen, können Sie ein neues virtuelles
          Wurzelverzeichnis für den Ladevorgang angeben. Das heißt,
          falls Sie beispielsweise die Auszugsdateien von drei
          Projektarchiven haben &ndash; etwa
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename> und
          <filename>ss-dumpfile</filename> &ndash; können Sie zunächst
          ein Projektarchiv anlegen, das alle beherbergt:</para>

        <informalexample>
          <screen>
$ svnadmin create /var/svn/projects
$
</screen>
        </informalexample>

<!--
        <para>Then, make new directories in the repository that will
          encapsulate the contents of each of the three previous
          repositories:</para>
-->
        <para>Erstellen Sie dann neue Verzeichnisse im Projektarchiv, die
          den Inhalt der vorherigen drei Projektarchive aufnehmen
          werden:</para>

        <informalexample>
          <screen>
$ svn mkdir -m "Initial project roots" \
            file:///var/svn/projects/calc \
            file:///var/svn/projects/calendar \
            file:///var/svn/projects/spreadsheet <!--
Committed revision 1.
-->
Revision 1 übertragen.
$ 
</screen>
        </informalexample>

<!--
        <para>Lastly, load the individual dump files into their
          respective locations in the new repository:</para>
-->
        <para>Laden Sie schließlich die Auszugsdateien an ihren
          jeweiligen Ort im neuen Projektarchiv:</para>

        <informalexample>
          <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnrdump">
<!--
        <title>Repository data migration using svnrdump</title>
-->
        <title>Projektarchiv-Daten-Migration mit svnrdump</title>

<!--
        <para>In Subversion 1.7, <command>svnrdump</command> joined
          the set of stock Subversion tools.  It offers fairly
          specialized functionality, essentially as a network-aware
          version of the <command>svnadmin dump</command>
          and <command>svnadmin load</command> commands which we
          discuss in depth in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> will generate a dump
          stream from a remote repository, spewing it to standard
          output; <command>svnrdump load</command> will read a dump
          stream from standard input and load it into a remote
          repository.  Using <command>svnrdump</command>, you can
          generate incremental dumps just as you might
          with <command>svnadmin dump</command>.  You can even dump a
          subtree of the repository&mdash;something
          that <command>svnadmin dump</command> cannot do.</para>
-->
        <para>In Subversion 1.7 kam <command>svnrdump</command> zu der
          Menge von mitgelieferten Subversion-Werkzeugen hinzu. Es
          bietet eine ziemlich spezialisierte Funktionalität, im
          Wesentlichen als netzwerkfähige Version der Befehle
          <command>svnadmin dump</command> und <command>svnadmin
          load</command>, die wir im Detail in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          /> erörtern.  <command>svnrdump dump</command> erzeugt einen
          Auszugsstrom eines Fern-Projektarchivs und schreibt ihn in
          den Standard-Ausgabekanal; <command>svnrdump load</command>
          liest einen Auszugsstrom aus dem Standard-Eingabekanal und
          lädt ihn in ein Fern-Projektarchiv. Mit
          <command>svnrdump</command> können Sie inkrementelle Auszüge
          erstellen, wie mit <command>svnadmin dump</command>. Sie
          können sogar einen Auszug eines Teilbaums des Projektarchivs
          erstellen, was <command>svnadmin dump</command> nicht
          kann.</para>

<!--
        <para>The primary difference is that instead of requiring
          direct access to the repository, <command>svnrdump</command>
          operates remotely, using the very same Repository Access
          (RA) protocols that the Subversion client does.  As such,
          you might need to provide authentication credentials.  Also,
          your remote interactions are subject to any authorization
          limitations configured on the Subversion server.</para>
-->
        <para>Der Hauptunterschied besteht darin, dass
          <command>svnrdump</command> ohne einen Direktzugriff auf
          das Projektarchiv zu benötigen, aus der Ferne arbeitet,
          wobei es die selben Repository Access (RA) Protokolle
          verwendet wie der Subversion-Client. Daher kann es sein,
          dass Sie Authentifizierungs-Informationen bereitstellen
          müssen. Darüber hinaus unterliegen Ihre Aktionen aus der
          Ferne den konfigurierten Autorisierungs-Einschränkungen des
          Subversion-Servers.</para>

        <note>
<!--
          <para><command>svnrdump dump</command> requires that the
            remote server be running Subversion 1.4 or newer.  It
            currently generates dump streams only of the sort which
            are created when you pass the <option>- -deltas</option>
            option to <command>svnadmin dump</command>.  This isn't
            interesting in the typical use-cases, but might impact
            specific types of custom transformations you might wish to
            apply to the resulting dump stream.</para>
-->
          <para><command>svnrdump dump</command> erfordert einen
            Fern-Server mit Subversion 1.4 oder neuer. Gegenwärtig
            erzeugt es nur Auszugsströme der Art wie Sie sie bekommen,
            wenn Sie <command>svnadmin dump</command> die Option
            <option>--deltas</option> mitgeben. In den typischen
            Anwendungsfällen ist das nicht von Interesse, jedoch kann
            es Auswirkungen auf bestimmte Arten besonderer
            Transformationen haben, die Sie auf den Auszugsstrom
            anwenden möchten.</para>
        </note>

        <note>
<!--
          <para>Because it modifies revision properties after
            committing new revisions, <command>svnrdump load</command>
            requires that the target repository have revision property
            changes enabled via the pre-revprop-change hook.  See
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/> for details.</para>
-->
          <para>Da es nach der Übergabe neuer Revisionen die
            Revisions-Eigenschaften ändert, verlangt <command>svnrdump
            load</command>, dass im Ziel-Projektarchiv Änderungen an
            Revisions-Eigenschaften mittels des Hooks
            pre-revprop-change ermöglicht sind. Zu Details, siehe
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/>.</para>
        </note>

<!--
        <para>As you might expect, you can use
          <command>svnadmin</command> and <command>svnrdump</command>
          in concert.  You can, for example, use <command>svnrdump
          dump</command> to generate a dump stream from a remote
          repository, and pipe the results thereof through
          <command>svnadmin load</command> to copy all that repository
          history into a local repository.  Or you can do the reverse,
          copying history from a local repository into a remote
          one.</para>
-->
        <para>Wie Sie wohl erwartet haben, können Sie 
          <command>svnadmin</command> und <command>svnrdump</command>
          in Verbindung verwenden. Sie können beispielsweise
          <command>svnrdump dump</command> verwenden, um einen
          Auszugsstrom eines Fern-Projektarchivs zu erstellen und das
          Ergebnis an <command>svnadmin load</command> weiterleiten,
          um die Historie jenes Projektarchivs in das lokale
          Projektarchiv zu kopieren. Oder Sie können im Gegenzug die
          Historie eines lokalen Projektarchivs in ein fernes
          kopieren.</para>

        <tip>
<!--
          <para>By using <literal>file://</literal>
            URLs, <command>svnrdump</command> can also access local
            repositories, but it will be doing so via Subversion's
            Repository Access (RA) abstraction layer&mdash;you'll get
            better performance out of <command>svnadmin</command> in
            such situations.</para>
-->
          <para>Durch die Verwendung von <literal>file://</literal>
            URLs kann <command>svnrdump</command> auch auf lokale
            Projektarchive zugreifen, allerdings wird hierfür auf
            Subversions Abstraktionsebene Repository Access (RA)
            zugegriffen; mit  <command>svnadmin</command> ist in
            solchen Fällen der Durchsatz besser.</para>
        </tip>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
<!--
      <title>Filtering Repository History</title>
-->
      <title>Filtern der Projektarchiv-Historie</title>

<!--
      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion generally
        doesn't provide an easy way to remove that
        data.<footnote><para>That's rather the reason you use version
        control at all, right?</para></footnote>  But inevitably, there
        will be times when you would like to manipulate the history of
        your repository.  You might need to strip out all instances of
        a file that was accidentally added to the repository (and
        shouldn't be there for whatever
        reason).<footnote><para>Conscious, cautious removal of certain
        bits of versioned data is actually supported by real use
        cases.  That's why an <quote>obliterate</quote> feature has
        been one of the most highly requested Subversion features, and
        one which the Subversion developers hope to soon
        provide.</para></footnote>  Or, perhaps you have multiple
        projects sharing a single repository, and you decide to split
        them up into their own repositories.  To accomplish tasks such
        as these, administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>
-->
      <para>Da Subversion Ihre versionierte Historie mindestens mit
        binären Differenz-Algorithmen und Datenkompression abspeichert
        (optional in einem völlig undurchsichtigen Datenbanksystem),
        ist der Versuch manueller Eingriffe unklug, zumindest
        schwierig und unter allen Umständen nicht angeraten. Sobald
        Daten im Projektarchiv gespeichert sind, bietet Subversion im
        Allgemeinen keine einfache Möglichkeit, diese Daten zu
        entfernen.<footnote><para>Das ist doch überhaupt der Grund
        dafür, Versionskontrolle einzusetzen, oder?</para></footnote>
        Doch zwangsläufig werden sich Gelegenheiten ergeben, bei denen
        Sie die Historie Ihres Projektarchivs manipulieren müssen. Es
        könnte sein, dass Sie alle Instanzen einer Datei entfernen
        müssen, die versehentlich dem Projektarchiv hinzugefügt worden
        ist, aber aus welchen Gründen auch immer nicht hineingehört).
        <footnote><para>Das bewusste, vorsichtige Entfernen bestimmter
        Teile versionierter Daten wird tatsächlich von wirklichen
        Anwendungsfällen verlangt. Das ist der Grund, warum eine
        <quote>Vernichtungs</quote>-Funktion eine der am häufigsten
        gewünschten Funktionen von Subversion ist, von der die
        Subversion-Entwickler hoffen, sie bald zur Verfügung stellen
        zu können.</para></footnote> Oder Sie haben vielleicht mehrere
        Projekte, die sich ein Projektarchiv teilen und entscheiden
        sich nun, jedem Projekt sein eigenes Projektarchiv zu geben.
        Um Aufgaben wie diese bewerkstelligen zu können, benötigen
        Administratoren eine besser handhabbare und bearbeitbare
        Repräsentation der Daten in den Projektarchiven &ndash; das
        Subversion-Projektarchiv-Auszugsformat.</para>

<!--
      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> or <command>svnrdump
        dump</command> command to generate the dump data,
        and <command>svnadmin load</command> or <command>svnrdump
        load</command> to populate a new repository with it.  The
        great thing about the human-readability aspect of the dump
        format is that, if you aren't careless about it, you can
        manually inspect and modify it.  Of course, the downside is
        that if you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>
-->
      <para>Wie bereits in <xref
        linkend="svn.reposadmin.maint.migrate" /> beschrieben, ist
        das Subversion-Projektarchiv-Auszugsformat eine
        menschenlesbare Wiedergabe der Änderungen, die Sie an Ihren
        versionierten Daten im Laufe der Zeit vorgenommen haben.
        Verwenden Sie den Befehl <command>svnadmin dump</command> oder
        <command>svnrdump dump</command>, um den Auszug anzulegen und
        <command>svnadmin load</command> oder <command>svnrdump
        load</command>, um ein neues Projektarchiv damit zu füllen.
        Das Tolle an der Menschenlesbarkeit des Auszugsformates ist,
        dass Sie, sofern es Ihnen nicht egal ist, die Daten manuell
        untersuchen und verändern können. Natürlich besteht ein
        Nachteil darin, dass eine Auszugsdatei eines Projektarchivs,
        in das über drei Jahre Änderungen eingeflossen sind, riesig
        groß sein wird, und es Sie eine lange, lange Zeit kosten wird,
        die Daten manuell zu untersuchen und zu verändern.</para>

<!--
      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>
-->
      <para>Hierbei hilft <command>svndumpfilter</command>.  Dieses
        Programm verhält sich wie ein pfadbasierter Filter für
        Auszugsströme. Geben Sie ihm einfach eine Liste von Pfaden
        mit, die Sie behalten möchten oder eine Liste von Pfaden, die
        Sie nicht behalten möchten, und leiten Sie Ihre Auszugsdaten
        durch diesen Filter. Das Ergebnis ist ein modifizierter Strom
        der Auszugsdaten, der nur die versionierten Pfade beinhaltet,
        die Sie (explizit oder implizit) verlangt haben.</para>

<!--
      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>
-->
      <para>Lassen Sie uns an einem realistischen Beispiel betrachten,
      wie Sie diesen Programm verwenden könnten. Früher in diesem
      Kapitel (siehe <xref
      linkend="svn.reposadmin.projects.chooselayout"/>) erörterten wir
      das Entscheidungsfindungsverfahren, wie Sie Ihre Daten im
      Projektarchiv anordnen sollen &ndash; ein Projektarchiv pro Projekt
      oder kombiniert, wie Sie die Daten im Projektarchiv verteilen usw.
      Doch manchmal, nachdem bereits einige Revisionen hinzugekommen
      sind, überdenken Sie die Anordnung und würden gerne einige
      Änderungen vornehmen. Eine verbreitete Änderung ist die
      Entscheidung, mehrere Projekte, die sich ein Projektarchiv teilen,
      auf getrennte Projektarchive pro Projekt aufzuteilen.</para>

<!--
      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>
-->
      <para>Unser imaginäres Projektarchiv beinhaltet drei Projekte:
        <literal>calc</literal>, <literal>calendar</literal> und
        <literal>spreadsheet</literal>. Sie waren miteinander in der
        folgenden Anordnung abgelegt:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

<!--
      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>
-->
      <para>Um diese drei Projekte in ihre eigenen Projektarchive zu
        bekommen, erstellen wir zunächst einen Auszug des gesamten
        Projektarchivs:</para>

<!--
      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Revision 0 ausgegeben.
* Revision 1 ausgegeben.
* Revision 2 ausgegeben.
* Revision 3 ausgegeben.
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>
-->
      <para>Dann leiten wir die Auszugsdatei durch die Filter, wobei
        jedes Mal nur jeweils eins der obersten Verzeichnisse
        ausgewählt wird.  Als Ergebnis erhalten wir drei
        Auszugsdateien:</para>

      <informalexample>
        <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>
-->
      <para>An dieser Stelle müssen sie eine Entscheidung treffen.
        Jede Ihrer Auszugsdateien wird ein gültiges Projektarchiv
        erzeugen, allerdings unter Beibehaltung der Pfade wie sie im
        ursprünglichen Projektarchiv waren. Das bedeutet, dass, obwohl
        Sie ein Projektarchiv ausschließlich für Ihr
        <literal>calc</literal> Projekt haben, wird es immer noch ein
        Wurzelverzeichnis namens <filename>calc</filename> besitzen.
        Falls Sie möchten, dass die Verzeichnisse
        <filename>trunk</filename>, <filename>tags</filename> und
        <filename>branches</filename> direkt im Wurzelverzeichnis
        Ihres Projektarchivs liegen, sollten Sie Ihre Auszugsdateien
        editieren, indem Sie die Einträge <literal>Node-path</literal>
        und <literal>Node-copyfrom-path</literal> verändern, so dass
        sie nicht mehr die erste Komponente <filename>calc/</filename>
        im Pfad haben. Sie sollten auch den Abschnitt entfernen, der
        das Verzeichnis <filename>calc</filename> anlegt. Es sollte
        etwa wie folgt aussehen:</para>

      <informalexample>
        <programlisting>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</programlisting>
      </informalexample>

<!--
      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>
-->
      <warning>
        <para>Falls Sie sich entscheiden sollten, die Auszugsdatei
          manuell zu editieren, um eins der obersten Verzeichnisse zu
          entfernen, sollten Sie sicherstellen, dass Ihr Editor nicht
          automatisch Zeilenenden in das native Format umwandelt (z.B.
          <literal>\r\n</literal> in <literal>\n</literal>), da sonst
          der Inhalt nicht zu den Metadaten passt. Das würde Ihre
          Auszugsdatei nutzlos machen.</para>
      </warning>

<!--
      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>
-->
      <para>Alles, was jetzt noch übrig bleibt, ist, Ihre drei neuen
        Projektarchive zu erstellen und jede Auszugsdatei in das richtige
        Projektarchiv zu laden, wobei die UUID aus dem Auszugsstrom
        ignoriert wird:</para>

<!--
      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load - -ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load - -ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load - -ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: Makefile ... erledigt.
     * Füge Pfad hinzu: button.c ... erledigt.
&hellip;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: Makefile ... erledigt.
     * Füge Pfad hinzu: cal.c ... erledigt.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: Makefile ... erledigt.
     * Füge Pfad hinzu: ss.c ... erledigt.
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>
-->
      <para>Beide Unterbefehle von <command>svndumpfilter</command>
        akzeptieren Optionen, die angeben, wie <quote>leere</quote>
        Revisionen behandelt werden sollen. Falls eine Revision nur
        Änderungen an herausgefilterten Pfaden beinhaltet, könnte die
        neue Revision als uninteressant oder gar unerwünscht gelten.
        Um dem Anwender die Kontrolle darüber zu geben, wie hiermit
        verfahren werden soll, bietet <command>svndumpfilter</command>
        die folgenden Kommandozeilen-Optionen:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
<!--
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
-->
            <para>Überhaupt keine leeren Revisionen erzeugen &ndash;
              einfach auslassen.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
<!--
            <para>If empty revisions are dropped (using the
              <option>- -drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
-->
            <para>Falls leere Revisionen ausgelassen werden (mit der
              Option <option>--drop-empty-revs</option>), die
              Nummern der übrig gebliebenen Revisionen ändern, so dass
              keine Lücken in der Nummernfolge auftreten.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
<!--
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
-->
            <para>Falls leere Revisionen nicht ausgelassen werden, die
              Eigenschaften der leeren Revisionen bewahren
              (Protokolleintrag, Autor, Datum, Eigenschaften usw.). Sonst
              beinhalten leere Revisionen lediglich den Zeitstempel
              und einen erzeugten Protokolleintrag, der darauf
              hinweist, dass diese Revision von
              <command>svndumpfilter</command> geleert wurde.</para>
          </listitem>
        </varlistentry>
      </variablelist>

<!--
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>
-->
      <para>Obwohl <command>svndumpfilter</command> sehr nützlich und
        eine Zeitersparnis sein kann, gibt es unglücklicherweise ein
        paar Fallstricke. Erstens ist das Dienstprogramm
        überempfindlich gegenüber der Pfadsemantik. Achten Sie darauf,
        ob die Pfade in Ihrer Auszugsdatei mit oder ohne führende
        Schrägstriche angegeben werden. Sie sollten sich die Einträge
        <literal>Node-path</literal> und
        <literal>Node-copyfrom-path</literal> ansehen.</para>

      <informalexample>
        <programlisting>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</programlisting>
      </informalexample>

<!--
      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an
        inconsistent usage of leading slashes for some
        reason,<footnote><para>While <command>svnadmin dump</command>
        has a consistent leading slash policy (to not include them),
        other programs that generate dump data might not be so
        consistent.</para></footnote> you should probably normalize
        those paths so that they all have, or all lack, leading
        slashes.</para>
-->
      <para>Falls die Pfade führende Schrägstriche haben, sollten auch
        Sie Schrägstriche in den Pfaden angeben, die Sie an
        <command>svndumpfilter include</command> und
        <command>svndumpfilter exclude</command> übergeben (und wenn
        sie keine haben, sollten Sie auch keine angeben). Falls Ihre
        Auszugsdatei aus irgendwelchen Gründen einen nicht
        konsistenten Gebrauch von führenden Schrägstrichen macht,
        <footnote><para>Obwohl <command>svnadmin dump</command> ein
        konsistentes Vorgehen bezüglich führender Schrägstriche
        vorweisen kann (indem es sie nicht einfügt), sind andere
        Programme, die Auszugsdateien erzeugen eventuell nicht so
        konsistent.</para></footnote> sollten Sie diese Pfade
        normalisieren, so dass sie alle entweder Schrägstriche haben
        oder nicht.</para>

<!--
      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>
-->
      <para>Ebenso können kopierte Pfade Probleme bereiten. Subversion
        unterstützt Kopieroperationen im Projektarchiv, bei denen ein
        neuer Pfad erzeugt wird, indem ein bereits bestehender kopiert
        wird. Es kann vorkommen, dass Sie zu irgendeinem Zeitpunkt der
        Lebenszeit Ihres Projektarchivs eine Datei oder ein Verzeichnis
        von einer durch <command>svndumpfilter</command> ausgelassenen
        Stelle an eine durch <command>svndumpfilter</command>
        berücksichtigte Stelle kopiert haben. Um die Auszugsdateien
        unabhängig zu machen, muss <command>svndumpfilter</command>
        trotzdem das Hinzufügen des neuen Pfades anzeigen &ndash; mit
        dem Inhalt aller durch die Kopie erzeugten Dateien &ndash;
        allerdings nicht als eine Kopie aus einer Quelle, die es gar
        nicht im gefilterten Auszugsstrom gibt. Da allerdings das
        Subversion Auszugsdateiformat nur Änderungen von Revisionen
        beinhaltet, kann es sein, dass der Inhalt der Quelle der Kopie
        nicht verfügbar ist. Wenn Sie mutmaßen, dass Sie solche Kopien
        in Ihrem Projektarchiv haben, sollten Sie die Auswahl der
        ausgelassenen/berücksichtigten Pfade überdenken, indem Sie
        vielleicht die Pfade, die als Quellen für die problematischen
        Kopien dienten, hinzunehmen.</para>

<!--
      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>
-->
      <para>Schließlich behandelt <command>svndumpfilter</command>
        Pfadfilterung ziemlich wörtlich. Wenn Sie die Historie eines
        Projektes mit dem Wurzelverzeichnis
        <filename>trunk/my-project</filename> kopieren und sie in ein
        eigenes Projektarchiv verschieben möchten, werden Sie
        selbstverständlich den Befehl <command>svndumpfilter
        include</command> verwenden, um alle Änderungen in und
        unterhalb von <filename>trunk/my-project</filename> zu
        bewahren. Doch macht die entstehende Auszugsdatei keinerlei
        Annahmen bezüglich des Projektarchivs, in das Sie die Daten zu
        laden beabsichtigen. In diesem besonderen Fall könnten die
        Auszugsdaten mit der Revision beginnen, die das Verzeichnis
        <filename>trunk/my-project</filename> hinzugefügt hat, doch
        sie werden <emphasis>keine</emphasis> Direktiven enthalten,
        dir das Verzeichnis <filename>trunk</filename> selbst anlegen
        (weil <filename>trunk</filename> nicht zum Filter der zu
        berücksichtigenden Pfade passt). Sie müssen sicherstellen,
        dass alle Verzeichnisse, die der Auszugsstrom erwartet,
        tatsächlich im Ziel-Projektarchiv vorhanden sind, bevor Sie
        versuchen, den Strom in dieses Projektarchiv zu laden.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
<!--
      <title>Repository Replication</title>
-->
      <title>Projektarchiv Replikation</title>

<!--
      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>
-->
      <para>Es gibt mehrere Szenarien, in denen es sehr passend ist,
        ein Subversion-Projektarchiv zu haben, dessen Versionshistorie
        genau dieselbe wie die eines anderen Projektarchivs ist.
        Vielleicht das offensichtlichste ist die Aufrechterhaltung
        eines Projektarchivs als einfache Sicherheitskopie, das verwendet
        wird, wenn das primäre Projektarchiv wegen Materialdefekt,
        Netzausfall oder ähnlichen Ärgernissen unzugänglich geworden
        ist. Andere Szenarien umfassen den Einsatz von
        Spiegel-Projektarchiven, um heftige Subversion-Last über mehrere
        Server zu verteilen, zum sanften Aufrüsten usw.</para>

<!--
      <para>Subversion provides a program for managing scenarios such
        as these.  <command>svnsync</command> works by essentially
        asking the Subversion server to <quote>replay</quote>
        revisions, one at a time.  It then uses that revision
        information to mimic a commit of the same to another
        repository.  Neither repository needs to be locally accessible
        to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>
-->
      <para>Subversion stellt ein Programm zur Handhabung solcher
        Szenarien zur Verfügung. Im Wesentlichen funktioniert
        <command>svnsync</command>, indem der Subversion-Server
        aufgefordert wird, Revisionen zu <quote>wiederholen</quote>,
        eine nach der anderen. Dann wird die Information dieser
        Revision benutzt, um eine Übergabe derselben an ein anderes
        Projektarchiv zu imitieren. Keins der Projektarchive muss
        lokal auf der Maschine liegen, auf der
        <command>svnsync</command> läuft &ndash; seine Parameter sind
        Projektarchiv-URLs, und es verrichtet seine gesamte Arbeit
        über die Projektarchiv-Access-Schnittstellen (RA) von
        Subversion. Das Einzige, was benötigt wird, ist Lesezugriff
        auf das Quell-Projektarchiv und Lese-/Schreibzugriff auf das
        Ziel-Projektarchiv.</para>

      <note>
<!--
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
-->
        <para>Wenn Sie <command>svnsync</command> mit einem entfernt
          liegenden Quell-Projektarchiv verwenden, muss auf dem
          Subversion-Server für dieses Projektarchiv Subversion 1.4 oder
          neuer laufen.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync">
<!--
        <title>Replication with svnsync</title>
-->
        <title>Replizierung mit svnsync</title>

<!--
        <para>Assuming you already have a source repository that you'd
          like to mirror, the next thing you need is a target repository
          that will actually serve as that mirror.  This target
          repository can use either of the available filesystem
          data-store backends (see
          <xref linkend="svn.reposadmin.basics.backends"
          />)&mdash;Subversion's abstraction layers ensure that such
          details don't matter.  But by default, it must
          not yet have any version history in it.  (We'll discuss an
          exception to this later in this section.)</para>
-->
        <para>Angenommen, Sie haben bereits ein Projektarchiv, das Sie
          gerne spiegeln möchten. Als nächstes brauchen Sie ein leeres
          Ziel-Projektarchiv, das als Spiegel dienen soll. Dieses
          Projektarchiv kann irgendeins der verfügbaren Speicherverfahren
          benutzen (siehe
          <xref linkend="svn.reposadmin.basics.backends" />) &ndash;
          die Abstraktionsschichten von Subversion stellen sicher,
          dass solche Details unerheblich sind. Doch standardmäßig
          darf es noch keine Versionshistorie enthalten. (Eine
          Ausnahme davon werden wir später in diesem Abschnitt
          erörtern.)</para>

<!--
        <para>The protocol that <command>svnsync</command> uses to
          communicate revision information is highly sensitive to
          mismatches between the versioned histories contained in the
          source and target repositories.  For this reason,
          while <command>svnsync</command>
          cannot <emphasis>demand</emphasis> that the target repository
          be read-only,<footnote><para>In fact, it can't truly be
          read-only, or <command>svnsync</command> itself would have a
          tough time copying revision history into it.</para></footnote>
          allowing the revision history in the target repository to
          change by any mechanism other than the mirroring process is a
          recipe for disaster.</para>
-->
        <para>Das von <command>svnsync</command> verwendete Protokoll
          zur Übermittlung der Revisionsinformation ist sehr
          empfindlich gegenüber nicht übereinstimmender
          Versionshistorien im Quell- und Ziel-Projektarchiv. Aus dem
          Grund, dass <command>svnsync</command> nicht
          <emphasis>verlangen</emphasis> kann, dass das
          Ziel-Projektarchiv nur lesbar
          ist,<footnote><para>Tatsächlich kann es gar nicht nur lesbar
          sein, denn sonst hätte <command>svnsync</command> ein echtes
          Problem, die Versionshistorie
          hineinzukopieren.</para></footnote> ist die Katastrophe
          programmiert, wenn erlaubt wird, die Revisions-Historie im
          Ziel-Projektarchiv mit anderen Mitteln als durch das
          Spiegeln zu verändern.</para>

        <warning>
<!--
          <para>Do <emphasis>not</emphasis> modify a mirror repository
            in such a way as to cause its version history to deviate
            from that of the repository it mirrors.  The only commits
            and revision property modifications that ever occur on that
            mirror repository should be those performed by the
            <command>svnsync</command> tool.</para>
-->
          <para>Verändern Sie ein Spiegel-Projektarchiv
            <emphasis>nicht</emphasis> auf eine Art und Weise, die dazu
            führt, dass die Versionshistorie von der des
            Original-Projektarchivs abweicht. Die einzigen Übergaben und
            Änderungen an Revisions-Eigenschaften die in diesem
            Spiegel-Projektarchiv stattfinden, sollten ausschließlich durch
            den Befehl <command>svnsync</command> vorgenommen
            werden.</para>
        </warning>

<!--
        <para>Another requirement of the target repository is that the
          <command>svnsync</command> process be allowed to modify
          revision properties.  Because <command>svnsync</command> works
          within the framework of that repository's hook system, the
          default state of the repository (which is to disallow revision
          property changes; see <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) is insufficient.
          You'll need to explicitly implement the pre-revprop-change
          hook, and your script must allow <command>svnsync</command>
          to set and change revision properties.  With those
          provisions in place, you are ready to start mirroring
          repository revisions.</para>
-->
        <para>Eine weitere Anforderung an das Ziel-Projektarchiv ist,
          dass dem <command>svnsync</command>-Prozess erlaubt wird,
          Revisions-Eigenschaften zu verändern. Da
          <command>svnsync</command> im Rahmen des Hook-Systems
          ausgeführt wird, ist der standardmäßige Zustand des
          Projektarchivs (welcher keine Änderungen an
          Revisions-Eigenschaften zulässt; siehe
          <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) nicht ausreichend. Sie
          müssen ausdrücklich den pre-revprop-change-Hook
          bereitstellen, der <command>svnsync</command> erlaubt,
          Revisions-Eigenschaften zu definieren und zu ändern. Mit
          diesen Vorkehrungen sind Sie gerüstet, um
          Projektarchiv-Revisionen zu spiegeln.</para>

        <tip>
<!--
          <para>It's a good idea to implement authorization measures
            that allow your repository replication process to perform
            its tasks while preventing other users from modifying the
            contents of your mirror repository at all.</para>
-->
          <para>Es ist eine gute Idee, Autorisierungsmaßnahmen zu
            ergreifen, um Ihrem Projektarchiv-Replikations-Prozess die
            Arbeit zu ermöglichen, wohingegen anderen Anwendern die
            Veränderung der Inhalte des Spiegel-Projektarchivs
            verwehrt wird.</para>
        </tip>

<!--
        <para>Let's walk through the use of <command>svnsync</command>
          in a somewhat typical mirroring scenario.  We'll pepper this
          discourse with practical recommendations, which you are free to
          disregard if they aren't required by or suitable for your
          environment.</para>
-->
        <para>Lassen Sie uns nun die Benutzung von
          <command>svnsync</command> bei einem Rundgang in einem
          typischen Spiegel-Szenario erklären. Wir werden diesen Diskurs
          mit Empfehlungen würzen, die Sie jedoch getrost missachten
          können, falls sie für Ihre Umgebung nicht benötigt werden oder
          nicht passend sind.</para>

<!--
        <para>We will be mirroring the public Subversion repository
          which houses the source code for this very book and exposing
          that mirror publicly on the Internet, hosted on a different
          machine than the one on which the original Subversion source
          code repository lives.  This remote host has a global
          configuration that permits anonymous users to read the
          contents of repositories on the host, but requires users to
          authenticate to modify those repositories.  (Please forgive
          us for glossing over the details of Subversion server
          configuration for the moment&mdash;those are covered
          thoroughly in <xref linkend="svn.serverconfig" />.)  And for
          no other reason than that it makes for a more interesting
          example, we'll be driving the replication process from a
          third machine&mdash;the one that we currently find ourselves
          using.</para>
-->
        <para>Wir wollen das öffentliche Subversion-Projektarchiv
          spiegeln, das den Quelltext des vorliegenden Buchs beherbergt,
          und diesen Spiegel von einer anderen Maschine als der, auf der
          das ursprüngliche Subversion-Quelltext-Projektarchiv
          untergebracht ist, im Internet veröffentlichen. Dieser
          entfernt liegende Rechner besitzt eine globale Konfiguration,
          die es anonymen Anwendern erlaubt, den Inhalt von
          Projektarchivs auf diesem Rechner zu lesen, aber zum Ändern
          dieser Projektarchive eine Authentifizierung der Anwender
          erforderlich macht. (Vergeben Sie uns bitte, dass wir für den
          Augenblick über die Details der
          Subversion-Server-Konfiguration hinwegsehen &ndash; sie werden
          in <xref linkend="svn.serverconfig" /> behandelt.) Und aus dem
          alleinigen Grund, es noch interessanter machen zu wollen,
          werden wir den Replikations-Prozess von einer dritten Maschine
          aus steuern &ndash; diejenige, die wir aktuell
          benutzen.</para>

<!--
        <para>First, we'll create the repository which will be our
          mirror.  This and the next couple of steps do require shell
          access to the machine on which the mirror repository will
          live.  Once the repository is all configured, though, we
          shouldn't need to touch it directly again.</para>
-->
        <para>Zunächst erstellen wir das Projektarchiv, das unser Spiegel
          sein soll. Dieser und die folgenden paar Schritte erfordern
          einen Shell-Zugang auf die Maschine, die das
          Spiegel-Projektarchiv beherbergen soll. Sobald das Projektarchiv
          jedoch konfiguriert ist, sollten wir nicht mehr direkt darauf
          zugreifen müssen.</para>

        <informalexample>
          <screen>
$ ssh admin@svn.example.com "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>
        </informalexample>

<!--
        <para>At this point, we have our repository, and due to our
          server's configuration, that repository is now
          <quote>live</quote> on the Internet.  Now, because we don't
          want anything modifying the repository except our replication
          process, we need a way to distinguish that process from other
          would-be committers.  To do so, we use a dedicated username
          for our process.  Only commits and revision property
          modifications performed by the special username
          <literal>syncuser</literal> will be allowed.</para>
-->
        <para>Zu diesem Zeitpunkt haben wir unser Projektarchiv, und wegen
          unserer Server-Konfiguration ist das Projektarchiv nun
          <quote>live</quote> im Internet. Da wir aber außer unserem
          Replikations-Prozess niemanden erlauben wollen, das Projektarchiv
          zu ändern, benötigen wir eine Möglichkeit, diesen Prozess von
          anderen potentiellen Zugriffen zu unterscheiden. Um dies zu
          machen, verwenden wir einen ausgezeichneten Anwendernamen für
          unseren Prozess. Nur Übergaben und Änderungen an
          Revisions-Eigenschaften unter dem Anwenderkonto
          <literal>syncuser</literal> werden erlaubt.</para>

<!--
        <para>We'll use the repository's hook system both to allow the
          replication process to do what it needs to do and to enforce
          that only it is doing those things.  We accomplish this by
          implementing two of the repository event
          hooks&mdash;pre-revprop-change and start-commit.  Our
          pre-revprop-change hook script is found
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />, and basically verifies that the user attempting the
          property changes is our <literal>syncuser</literal> user.  If
          so, the change is allowed; otherwise, it is denied.</para>
-->
        <para>Wir verwenden das Hook-System des Projektarchivs sowohl, um
          dem Replikations-Prozess seine Arbeit zu ermöglichen, als auch,
          um sicherzustellen, dass nur er diese Dinge tut. Wir
          bewerkstelligen dies, indem wir zwei der
          Projektarchiv-Ereignis-Hooks implementieren &ndash;
          pre-revprop-change und start-commit. Unser
          pre-revprop-change-Hook-Skript finden Sie
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />; grundsätzlich stellt es sicher, dass der Anwender, der die
          Eigenschaften ändern möchte, unser <literal>syncuser</literal>
          ist. Falls dies zutrifft, ist die Änderung erlaubt,
          anderenfalls wird die Änderung abgelehnt.</para>

        <example id="svn.reposadmin.maint.replication.pre-revprop-change">
<!--
          <title>Mirror repository's pre-revprop-change hook script</title>
-->
          <title>pre-revprop-change-Hook-Skript des Spiegel-Projektarchivs</title>
<!--
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
-->
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Ausschließlich der Anwender syncuser darf Revisions-Eigenschaften ändern" &gt;&amp;2
exit 1
</programlisting>
        </example>

<!--
        <para>That covers revision property changes.  Now we need to
          ensure that only the <literal>syncuser</literal> user is
          permitted to commit new revisions to the repository.  We do
          this using a start-commit hook script
          such as the one in <xref
          linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>
-->
        <para>Das deckt Änderungen an Revisions-Eigenschaften ab. Nun müssen
          wir sicherstellen, dass nur der Anwender
          <literal>syncuser</literal> neue Revisionen an das Projektarchiv
          übertragen darf. Wir machen das, indem wir ein
          start-commit-Hook-Skript wie das in <xref
          linkend="svn.reposadmin.maint.replication.start-commit" />
          benutzen.</para>

        <example id="svn.reposadmin.maint.replication.start-commit">
<!--
          <title>Mirror repository's start-commit hook script</title>
-->
          <title>start-commit-Hook-Skript des Spiegel-Projektarchivs</title>

<!--
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
-->
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Ausschließlich der Anwender syncuser darf neue Revisionen übertragen" &gt;&amp;2
exit 1
</programlisting>
        </example>

<!--
        <para>After installing our hook scripts and ensuring that they
          are executable by the Subversion server, we're finished with
          the setup of the mirror repository.  Now, we get to actually
          do the mirroring.</para>
-->
        <para>Nachdem wir unsere Hook-Skripte installiert und uns
          vergewissert haben, dass sie auf dem Subversion-Server
          ausführbar sind, sind wir mit dem Aufsetzen des
          Spiegel-Projektarchivs fertig. Nun kommen wir zum eigentlichen
          Spiegeln.</para>

<!--
        <para>The first thing we need to do with
          <command>svnsync</command> is to register in our target
          repository the fact that it will be a mirror of the source
          repository.  We do this using the <command>svnsync
          initialize</command> subcommand.  The URLs we provide point
          to the root directories of the target and source
          repositories, respectively.  In Subversion 1.4, this is
          required&mdash;only full mirroring of repositories is
          permitted.  Beginning with Subversion 1.5, though, you can
          use <command>svnsync</command> to mirror only some subtree
          of the repository, too.</para>
-->
        <para>Das Erste, was wir machen müssen ist, unserem
          Ziel-Projektarchiv mit <command>svnsync</command> zu sagen, dass
          es ein Spiegel des Quell-Projektarchivs sein wird. Wir machen das
          mit dem Unterbefehl <command>svnsync initialize</command>. Die
          URLs, die wir mitgeben, zeigen auf die Wurzelverzeichnisse des
          Ziel- bzw. Quell-Projektarchivs. In Subversion 1.4 ist das
          erforderlich &ndash; nur die vollständige Spiegelung von
          Projektarchiven ist erlaubt. Beginnend mit Subversion 1.5
          jedoch können Sie <command>svnsync</command> auch zum Spiegeln
          von Teilbäumen des Projektarchivs verwenden.</para>

<!--
        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     https://svn.code.sf.net/p/svnbook/source \
                     - -sync-username syncuser - -sync-password syncpass
Copied properties for revision 0 (svn:sync-* properties skipped).
NOTE: Normalized svn:* properties to LF line endings (1 rev-props, 0 node-props).
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnsync help init
initialize (init): Aufruf: svnsync initialize ZIEL_URL QUELL_URL

Bereitet ein Zielprojektarchiv auf die Synchronisation mit einem
anderen Projektarchiv vor.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     https://svn.code.sf.net/p/svnbook/source \
                     --sync-username syncuser --sync-password syncpass
Eigenschaften für Revision 0 kopiert (svn:sync-* Eigenschaften übergangen).
HINWEIS: svn:* Eigenschaften nach LF-Zeilenenden normalisiert (1 Revisionseigenschaften, 0 Knoteneigenschaften).
$
</screen>
        </informalexample>

<!--
        <para>Our target repository will now remember that it is a
          mirror of the public Subversion source code repository.
          Notice that we provided a username and password as arguments
          to <command>svnsync</command>&mdash;that was required by the
          pre-revprop-change hook on our mirror repository.</para>
-->
        <para>Unser Ziel-Projektarchiv wird sich nun erinnern, dass es ein
          Spiegel des öffentlichen Subversion-Quelltext-Projektarchivs ist.
          Beachten Sie, dass wir einen Anwendernamen und ein Passwort an
          <command>svnsync</command> übergeben haben &ndash; das war für
          den pre-revprop-change-Hook in unserem Spiegel-Projektarchiv
          erforderlich.</para>

        <note>
<!--
          <para>In Subversion 1.4, the values given to
            <command>svnsync</command>'s <option>- -username</option> and
            <option>- -password</option> command-line options were used
            for authentication against both the source and destination
            repositories.  This caused problems when a user's
            credentials weren't exactly the same for both repositories,
            especially when running in noninteractive mode (with the
            <option>- -non-interactive</option> option).  This was
            fixed in Subversion 1.5 with the introduction of two new
            pairs of options.  Use
            <option>- -source-username</option> and
            <option>- -source-password</option> to provide authentication
            credentials for the source repository; use
            <option>- -sync-username</option> and
            <option>- -sync-password</option> to provide credentials for
            the destination repository.  (The old
            <option>- -username</option> and <option>- -password</option>
            options still exist for compatibility, but we advise against
            using them.)</para>
-->
          <para>In Subversion 1.4 wurden die an die
            Kommandozeilenoptionen <option>--username</option> und
            <option>--password</option> von <command>svnsync</command>
            übergebenen Werte sowohl für die Authentisierung gegenüber
            dem Quell-Projektarchiv als auch gegenüber dem Ziel-Projektarchiv
            verwendet. Das führte zu Problemen, falls die Zugangsdaten
            eines Anwenders nicht für beide Projektarchive identisch waren,
            insbesondere im nicht-interaktiven Modus (mit der Option
            <option>--non-interactive</option>). Dies ist in Subversion
            1.5 mit der Einführung von zwei neuen Optionspaaren behoben
            worden. Benutzen Sie <option>--source-username</option> und
            <option>--source-password</option> für die Zugangsdaten des
            Quell-Projektarchivs sowie <option>--sync-username</option>
            und <option>--sync-password</option> für das
            Ziel-Projektarchiv.  (Die alten Optionen
            <option>--username</option> und <option>--password</option>
            bleiben aus Kompatibilitätsgründen bestehen, doch raten wir
            von deren Verwendung ab.)</para>

        </note>

<!--
        <para>And now comes the fun part.  With a single subcommand, we
          can tell <command>svnsync</command> to copy all the
          as-yet-unmirrored revisions from the source repository to the
          target.<footnote><para>Be forewarned that while it will take
          only a few seconds for the average reader to parse this
          paragraph and the sample output that follows it, the actual
          time required to complete such a mirroring operation is, shall
          we say, quite a bit longer.</para></footnote> The
          <command>svnsync synchronize</command> subcommand will peek
          into the special revision properties previously stored on the
          target repository and determine how much of the source
          repository has been previously mirrored&mdash;in this case,
          the most recently mirrored revision is r0.  Then it will query
          the source repository and determine what the latest revision
          in that repository is.  Finally, it asks the source
          repository's server to start replaying all the revisions
          between 0 and that latest revision.  As
          <command>svnsync</command> gets the resultant response from
          the source repository's server, it begins forwarding those
          revisions to the target repository's server as new
          commits.</para>
-->
        <para>Und nun kommt der lustige Teil. Mit einem einfachen
          Unterbefehl können wir <command>svnsync</command> auffordern,
          alle bislang ungespiegelten Revisionen aus dem
          Quell-Projektarchiv zum Ziel zu kopieren.<footnote><para>Seien
          Sie jedoch vorgewarnt, dass, obwohl der durchschnittliche
          Leser nur ein paar Sekunden benötigt, um diesen Absatz und die
          ihm folgende Beispielausgabe zu erfassen, die tatsächlich für
          eine vollständige Spiegelung erforderliche Zeit um Einiges
          länger ist.</para></footnote> Der Unterbefehl
          <command>svnsync synchronize</command> wird die bereits vorher
          im Ziel-Projektarchiv gespeicherten besonderen
          Revisions-Eigenschaften untersuchen und sowohl ermitteln,
          welches Projektarchiv es spiegelt und dass die zuletzt
          gespiegelte Revision die Revision 0 war. Dann fragt es das
          Quell-Projektarchiv ab, welches die jüngste Revision in diesem
          Projektarchiv ist.  Schließlich fordert es den Server des
          Quell-Projektarchivs auf, alle Revisionen zwischen 0 und
          dieser letzten Revision zu wiederholen. Sobald
          <command>svnsync</command> die entsprechende Antwort vom
          Quell-Projektarchiv-Server erhält, leitet es diese Revisionen
          als neue Übergaben an den Server des Ziel-Projektarchivs
          weiter.</para>

<!--
        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL [SOURCE_URL]

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      https://svn.code.sf.net/p/svnbook/source
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data .
Committed revision 4063.
Copied properties for revision 4063.
Transmitting file data .
Committed revision 4064.
Copied properties for revision 4064.
Transmitting file data ....
Committed revision 4065.
Copied properties for revision 4065.
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): Aufruf: svnsync synchronize ZIEL_URL [QUELL_URL]

Überträgt alle laufenden Revisionen von der Quelle, mit der es
initialisiert wurde, zum Ziel.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      https://svn.code.sf.net/p/svnbook/source
Revision 1 übertragen.
Eigenschaften für Revision 1 kopiert.
Revision 2 übertragen.
Eigenschaften für Revision 2 kopiert.
Übertrage Daten .
Revision 3 übertragen.
Eigenschaften für Revision 3 kopiert.
&hellip;
Übertrage Daten .
Revision 4063 übertragen.
Eigenschaften für Revision 4063 kopiert.
Übertrage Daten .
Revision 4064 übertragen.
Eigenschaften für Revision 4064 kopiert.
Übertrage Daten .
Revision 4065 übertragen.
Eigenschaften für Revision 4065 kopiert.
$
</screen>
        </informalexample>

<!--
        <para>Of particular interest here is that for each mirrored
          revision, there is first a commit of that revision to the
          target repository, and then property changes follow.  This
          two-phase replication is required because the initial commit
          is performed by (and attributed to) the user
          <literal>syncuser</literal> and is datestamped with the time
          as of that revision's creation.  <command>svnsync</command>
          has to follow up with an immediate series of property
          modifications that copy into the target repository all the
          original revision properties found for that revision in the
          source repository, which also has the effect of fixing the
          author and datestamp of the revision to match that of the
          source repository.</para>
-->
        <para>Von besonderem Interesse ist hier, dass für jede
          gespiegelte Revision zunächst eine Übergabe der Revision an
          das Ziel-Projektarchiv erfolgt und dann die Änderungen der
          Eigenschaften folgen. Diese zweiphasige Replizierung ist
          notwendig, da die anfängliche Übergabe durch den Anwender
          <literal>syncuser</literal> durchgeführt (und ihm auch
          zugeschrieben) wird und mit dem Zeitstempel der Erzeugung
          dieser Revision versehen wird. <command>svnsync</command> hat
          hinterher unmittelbaren Serie von Änderungen an den
          Eigenschaften vorzunehmen, die all die Eigenschaften dieser
          Revision vom Quell-Projektarchiv ins Ziel-Projektarchiv
          kopieren, was auch den Effekt hat, dass der Autor und der
          Zeitstempel so korrigiert werden, dass diese den
          entsprechenden Werten im Quell-Projektarchiv
          entsprechen.</para>

<!--
        <para>Also noteworthy is that <command>svnsync</command>
          performs careful bookkeeping that allows it to be safely
          interrupted and restarted without ruining the integrity of the
          mirrored data.  If a network glitch occurs while mirroring a
          repository, simply repeat the <command>svnsync
          synchronize</command> command, and it will happily pick up
          right where it left off.  In fact, as new revisions appear in
          the source repository, this is exactly what you do
          to keep your mirror up to date.</para>
-->
        <para>Erwähnenswert ist ebenfalls, dass
          <command>svnsync</command> eine sorgfältige Buchführung
          vornimmt, die es ihm erlaubt, sicher unterbrochen und erneut
          gestartet zu werden, ohne die Integrität der gespiegelten
          Daten zu gefährden. Falls während des Spiegelns ein
          Netzproblem entsteht, wiederholen Sie einfach den Befehl
          <command>svnsync synchronize</command>, und er wird einfach
          damit weitermachen, womit er aufgehört hat. Das ist
          tatsächlich genau das, was Sie machen, um Ihren Spiegel
          aktuell zu halten, wenn neue Revisionen im Quell-Projektarchiv
          auftauchen.</para>

        <warning>
          <para>As part of its bookkeeping, <command>svnsync</command>
            records in the mirror repository the URL with which the
            mirror was initialized.  Because of this, invocations of
            <command>svnsync</command> which follow the initialization
            step do not <emphasis>require</emphasis> that you provide
            the source URL on the command line again.  However, for
            security purposes, we recommend that you continue to do so.
            Depending on how it is deployed, it may not be safe for
            <command>svnsync</command> to trust the source URL which it
            retrieves from the mirror repository, and from which it
            pulls versioned data.</para>
        </warning>

        <sidebar>
<!--
          <title>svnsync Bookkeeping</title>
-->
          <title>svnsync-Buchhaltung</title>

<!--
          <para><command>svnsync</command> needs to be able to set and
            modify revision properties on the mirror repository because
            those properties are part of the data it is tasked with
            mirroring.  As those properties change in the source
            repository, those changes need to be reflected in the mirror
            repository, too.  But <command>svnsync</command> also uses a
            set of custom revision properties&mdash;stored in revision 0
            of the mirror repository&mdash;for its own internal
            bookkeeping.  These properties contain information such as
            the URL and UUID of the source repository, plus some
            additional state-tracking information.</para>
-->
          <para><command>svnsync</command> muss in der Lage sein,
            Revisions-Eigenschaften im Ziel-Projektarchiv zu setzen und zu
            verändern, da diese Eigenschaften Teil der Daten sind, die es
            spiegeln soll. Wenn sich diese Eigenschaften im Quell-Projektarchiv
            ändern, müssen sie im Ziel-Projektarchiv nachgezogen werden.
            Allerdings verwendet <command>svnsync</command> auch eine
            Menge von speziellen Revisions-Eigenschaften &ndash;
            gespeichert in Revision 0 des Spiegel-Projektarchivs &ndash;
            für seine eigene interne Buchhaltung. Diese Eigenschaften
            beinhalten Informationen wie etwa der URL oder die UUID des
            Quell-Projektarchivs plus einige Informationen zur
            Zustandsverfolgung.</para>

<!--
          <para>One of those pieces of state-tracking information is a
            flag that essentially just means <quote>there's a
            synchronization in progress right now.</quote> This is used
            to prevent multiple <command>svnsync</command> processes
            from colliding with each other while trying to mirror data
            to the same destination repository.  Now, generally you
            won't need to pay any attention whatsoever to
            <emphasis>any</emphasis> of these special properties (all of
            which begin with the prefix <literal>svn:sync-</literal>).
            Occasionally, though, if a synchronization fails
            unexpectedly, Subversion never has a chance to remove this
            particular state flag.  This causes all future
            synchronization attempts to fail because it appears that a
            synchronization is still in progress when, in fact, none is.
            Fortunately, recovering from this situation is easy to do.
            In Subversion 1.7, you can use the newly introduced
            <option>- -steal-lock</option> option with
            <command>svnsync</command>'s commands.  In previous
            Subversion versions, you need only to remove the
            <literal>svn:sync-lock</literal> property which serves as
            this flag from revision 0 of the mirror repository:</para>
-->
          <para>Ein Teil dieser Zustandsverfolgungs-Information ist ein
            Flag, das bedeutet: <quote>momentan findet eine
            Synchronisierung statt</quote>. Dies wird verwendet, um zu
            verhindern, dass mehrere <command>svnsync</command>-Prozesse
            miteinander kollidieren, während sie versuchen, Daten in
            dasselbe Ziel-Projektarchiv zu spiegeln. Im Allgemeinen
            brauchen Sie auf <emphasis>keins</emphasis> dieser
            besonderen Eigenschaften zu achten (sie beginnen alle mit dem
            Präfix <literal>svn:sync-</literal>). Gelegentlich jedoch,
            falls eine Synchronisierung unerwartet fehlschlägt, bekommt
            Subversion keine Chance, dieses besondere Zustands-Flag zu
            entfernen. Das führt dazu, dass alle weiteren
            Synchronisierungsversuche fehlschlagen, da es scheint, dass
            eine Synchronisierung gerade durchgeführt wird, obwohl
            tatsächlich keine stattfindet. Glücklicherweise ist es
            einfach zu beheben. In Subversion 1.7 können Sie die neu
            eingeführte Option <option>--steal-lock</option> mit den
            <command>svnsync</command> Befehlen verwenden. In
            vorherigen Versionen von Subversion, brauchten Sie
            lediglich die Eigenschaft <literal>svn:sync-lock</literal>
            von Revision 0 des Spiegel-Projektarchivs entfernen,
            die als dieses Flag dient:</para>

<!--
          <informalexample>
            <screen>
$ svn propdel - -revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
</informalexample>
-->
          <informalexample>
            <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
Eigenschaft »svn:sync-lock« wurde von Revision 0 im Projektarchiv gelöscht
$
</screen>
          </informalexample>

<!--
          <para>Also, <command>svnsync</command> stores the source
            repository URL provided at mirror initialization time in a
            bookkeeping property on the mirror repository.  Future
            synchronization operations against that mirror which omit
            the source URL at the command line will consult the
            special <literal>svn:sync-from-url</literal> property
            stored on the mirror itself to know where to synchronize
            from.  This value is used literally by the synchronization
            process, though.  Be wary of using non-fully-qualified
            domain names (such as referring
            to <literal>svnbook.red-bean.com</literal> as
            simply <literal>svnbook</literal> because that happens to
            work when you are connected directly to
            the <literal>red-bean.com</literal> network), domain names
            which don't resolve or resolve differently depending on
            where you happen to be operating from, or IP addresses
            (which can change over time).  But here again, if you need
            an existing mirror to start referring to a different URL
            for the same source repository, you can change the
            bookkeeping property which houses that information.  Users
            of Subversion 1.7 or better can use <command>svnsync init
            - -allow-non-empty</command> to reinitialize their mirrors
            with new source URL:</para>
-->
          <para><command>svnsync</command> speichert auch den bei der
            Initialisierung übergebenen URL des
            Quell-Projektarchivs in einer Buchhaltungs-Eigenschaft des
            Spiegel-Projektarchivs. Künftige Operationen zur
            Synchronisierung mit diesem Spiegel, bei denen der
            Quell-URL weggelassen wird lesen die besondere Eigenschaft
            <literal>svn:sync-from-url</literal>, das auf dem Spiegel
            selbst gespeichert ist, um herauszubekommen, woher
            synchronisiert werden soll. Dieser Wert wird vom
            Synchronisierungsprozess jedoch wortwörtlich benutzt.
            Seien Sie vorsichtig, wenn Sie nicht vollständig qualifizierte
            Domainnamen verwenden (etwa wenn Sie sich auf
            <literal>svnbook.red-bean.com</literal> einfach mit
            <literal>svnbook</literal> beziehen, da das funktioniert,
            wenn Sie direkt mit dem  <literal>red-bean.com</literal>
            Netz verbunden sind), Domainnamen, die sich nicht auflösen
            lassen oder sich unterschiedlich auflösen, je nachdem von wo
            aus Sie arbeiten oder IP-Adressen (die sich im Lauf der Zeit
            ändern können).  Aber auch hier können Sie die Eigenschaft
            zur Buchhaltung ändern, falls ein bestehender Spiegel einen
            unterschiedlichen URL für dasselbe Quell-Projektarchiv
            benötigt. Anwender von Subversion 1.7 oder besser können
            <command>svnsync init --allow-non-empty</command>
            verwenden, um deren Spiegel mit einem neuen Quell-URL zu
            reinitialisieren.</para>

          <informalexample>
            <screen>
$ svnsync initialize --allow-non-empty http://svn.example.com/svn-mirror \ <!--
                                       <replaceable>NEW-SOURCE-URL</replaceable>
Copied properties for revision 4065.
-->
                                       <replaceable>NEUER-QUELL-URL</replaceable>
Eigenschaften für Revision 4065 kopiert.
$
</screen>
          </informalexample>

<!--
          <para>If you are running an older version of Subversion,
            you'll need to manually tweak
            the <literal>svn:sync-from-url</literal> bookkeeping
            property:</para>
-->
          <para>Wenn Sie eine ältere Version von Subversion verwenden,
            müssen Sie die Buchhaltungs-Eigenschaft
            <literal>svn:sync-from-url</literal> manuell
            anpassen:</para>

          <informalexample>
            <screen><!--
$ svn propset - -revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \ -->
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEUER-QUELL-URL</replaceable> \
      http://svn.example.com/svn-mirror <!--
property 'svn:sync-from-url' set on repository revision 0
-->
Eigenschaft »svn:sync-from-url« wurde für Revision 0 im Projektarchiv gesetzt
$
</screen>
          </informalexample>

<!--
          <para>Another interesting thing about these special
            bookkeeping properties is that <command>svnsync</command>
            will not attempt to mirror any of those properties when they
            are found in the source repository.  The reason is probably
            obvious, but basically boils down to
            <command>svnsync</command> not being able to distinguish the
            special properties it has merely copied from the source
            repository from those it needs to consult and maintain for
            its own bookkeeping needs.  This situation could occur if,
            for example, you were maintaining a mirror of a mirror of a
            third repository.  When <command>svnsync</command> sees its
            own special properties in revision 0 of the source
            repository, it simply ignores them.</para>
-->
          <para>Eine weitere interessante Angelegenheit an dieser
            speziellen Eigenschaft zur Buchhaltung ist, dass
            <command>svnsync</command> nicht versucht, diese Eigenschaften
            zu spiegeln, wenn sie im Quell-Projektarchiv gefunden werden.
            Der Grund ist wahrscheinlich offensichtlich, aber im Grunde
            läuft es darauf hinaus, dass <command>svnsync</command>
            nicht zu unterscheiden vermag, welche der speziellen
            Eigenschaften es bloß aus dem Quell-Projektarchiv kopiert hat und
            welche es für seine Buchhaltung benötigt und verwaltet.
            Diese Situation kann auftreten, falls Sie beispielsweise
            einen Spiegel eines Spiegels eines dritten Projektarchivs
            vorhalten. Wenn <command>svnsync</command> seine eigenen
            speziellen Eigenschaften in Revision 0 des Quell-Projektarchivs
            entdeckt, ignoriert es sie einfach.</para>

<!--
          <para>An <command>svnsync info</command> subcommand was
            added in Subversion 1.6 to easily display the special
            bookkeeping properties in the destination
            repository.</para>
-->
          <para>Ein Unterbefehl <command>svnsync info</command> wurde in
            Subversion 1.6 hinzugefügt, um die besonderen
            Buchhaltungs-Eigenschaften im Ziel-Projektarchiv anzeigen zu
            lassen.</para>

<!--
          <informalexample>
            <screen>
$ svnsync help info
info: usage: svnsync info DEST_URL

Print information about the synchronization destination repository
located at DEST_URL.
&hellip;
$ svnsync info http://svn.example.com/svn-mirror
Source URL: https://svn.code.sf.net/p/svnbook/source
Source Repository UUID: 931749d0-5854-0410-9456-f14be4d6b398
Last Merged Revision: 4065
$
</screen>
          </informalexample>
-->
          <informalexample>
            <screen>
$ svnsync help info
Aufruf: svnsync info ZIEL_URL

Gibt Informationen über das Zielprojektarchiv der Synchronisation aus,
das sich unter ZIEL_URL befindet.
&hellip;
$ svnsync info http://svn.example.com/svn-mirror
Quell-URL: https://svn.code.sf.net/p/svnbook/source
UUID des Quellprojektarchivs: 931749d0-5854-0410-9456-f14be4d6b398
Letzte zusammengeführte Revision: 4065
$
</screen>
          </informalexample>
        </sidebar>

<!--
        <para>There is, however, one bit of inelegance in the process.
          Because Subversion revision properties can be changed at any
          time throughout the lifetime of the repository, and because
          they don't leave an audit trail that indicates when they were
          changed, replication processes have to pay special attention
          to them.  If you've already mirrored the first 15 revisions of
          a repository and someone then changes a revision property on
          revision 12, <command>svnsync</command> won't know to go back
          and patch up its copy of revision 12.  You'll need to tell it
          to do so manually by using (or with some additional tooling
          around) the <command>svnsync copy-revprops</command>
          subcommand, which simply rereplicates all the revision
          properties for a particular revision or range thereof.</para>
-->
        <para>In diesem Prozess ist jedoch eine kleine Unfeinheit. Da
          die Revisions-Eigenschaften von Subversion jederzeit während der
          Lebenszeit eines Projektarchivs geändert werden können, ohne zu
          protokollieren, wann sie geändert wurden, müssen replizierende
          Prozesse ein besonderes Augenmerk auf sie richten. Wenn Sie
          bereits die ersten 15 Revisionen eines Projektarchivs gespiegelt
          haben, und dann jemand eine Revisions-Eigenschaft von Revision 12
          ändert, weiß <command>svnsync</command> nicht, dass es
          zurückgehen und die Kopie der Revision 12 korrigieren muss.
          Sie müssen es ihm manuell mitteilen, indem Sie den Unterbefehl
          <command>svnsync copy-revprops</command> verwenden, der
          einfach alle Eigenschaften einer bestimmten Revision oder eines
          Revisionsintervalls erneut repliziert.</para>

        <informalexample>
          <screen>
$ svnsync help copy-revprops <!--
copy-revprops: usage:

    1. svnsync copy-revprops DEST_URL [SOURCE_URL]
    2. svnsync copy-revprops DEST_URL REV[:REV2] -->
copy-revprops: Aufruf:

    1. svnsync copy-revprops ZIEL_URL [QUELL_URL]
    2. svnsync copy-revprops ZIEL_URL PAR1[PAR2]

&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 <!--
Copied properties for revision 12.
-->
Eigenschaften für Revision 12 kopiert.
$
</screen>
        </informalexample>

<!--
        <para>That's repository replication
          via <command>svnsync</command> in a nutshell.  You'll likely
          want some automation around such a process.  For example,
          while our example was a pull-and-push setup, you might wish to
          have your primary repository push changes to one or more
          blessed mirrors as part of its post-commit and
          post-revprop-change hook implementations.  This would enable
          the mirror to be up to date in as near to real time as is
          likely possible.</para>
-->
        <para>Das ist Projektarchiv-Replikation mit
          <command>svnsync</command> in aller Kürze.  Sehr
          wahrscheinlich möchten Sie einen solchen Prozess etwas
          automatisieren. Während unser Beispiel ein
          Ziehen-und-Schieben-Szenario beschrieb, möchten Sie
          vielleicht, dass Ihr primäres Projektarchiv als Teil der
          post-commit- und post-revprop-change-Hooks Änderungen an
          einen oder mehrere ausgesuchte Spiegel weiterschiebt. Das
          würde es ermöglichen, dass der Spiegel beinahe in Echtzeit
          aktuell gehalten werden kann.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-partial">
<!--
        <title>Partial replication with svnsync</title>
-->
        <title>Teilweise Replizierung mit svnsync</title>

<!--
        <para><command>svnsync</command> isn't limited to full copies
          of everything which lives in a repository.  It can handle
          various shades of partial replication, too.  For example,
          while it isn't very commonplace to do so,
          <command>svnsync</command> does gracefully mirror repositories
          in which the user as whom it authenticates has only partial
          read access.  It simply copies only the bits of the repository
          that it is permitted to see.  Obviously, such a mirror is not
          useful as a backup solution.</para>
-->
        <para><command>svnsync</command> ist nicht darauf beschränkt,
          vollständige Kopien des Inhalts von Projektarchiven zu
          machen. Es kann auch verschiedene Spielarten der teilweisen
          Replizierung bewerkstelligen. Beispielsweise spiegelt
          <command>svnsync</command>, wenn dies auch nicht ein
          häufiger Anwendungsfall ist, Projektarchive, in denen der
          Anwender unter dessen Kennung es läuft, nur eingeschränkte
          Rechte besitzt. Es werden dann einfach nur die Teile des
          Projektarchivs kopiert, die der Anwender sehen darf.
          Offensichtlich taugt so ein Spiegel nicht als
          Sicherheitskopie.</para>

<!--
        <para>As of Subversion 1.5, <command>svnsync</command> also
          has the ability to mirror a subset of a repository rather than
          the whole thing.  The process of setting up and maintaining
          such a mirror is exactly the same as when mirroring a whole
          repository, except that instead of specifying the source
          repository's root URL when running <command>svnsync
          init</command>, you specify the URL of some subdirectory
          within that repository.  Synchronization to that mirror will
          now copy only the bits that changed under that source
          repository subdirectory.  There are some limitations to this
          support, though.  First, you can't mirror multiple disjoint
          subdirectories of the source repository into a single mirror
          repository&mdash;you'd need to instead mirror some parent
          directory that is common to both.  Second, the filtering
          logic is entirely path-based, so if the subdirectory you are
          mirroring was renamed at some point in the past, your mirror
          would contain only the revisions since the directory appeared
          at the URL you specified.  And likewise, if the source
          subdirectory is renamed in the future, your synchronization
          processes will stop mirroring data at the point that the
          source URL you specified is no longer valid.</para>
-->
        <para>Seit Subversion 1.5 hat <command>svnsync</command>
          auch die Fähigkeit, eine Teilmenge eines Projektarchivs statt des
          Ganzen zu spiegeln. Das Anlegen und Pflegen eines solchen
          Spiegels unterscheidet sich nicht vom Spiegeln eines
          kompletten Projektarchivs; anstatt den Wurzel-URL des
          Quell-Projektarchivs bei <command>svnsync init</command>
          anzugeben, nennen Sie einfach den URL eines
          Unterverzeichnisses dieses Projektarchivs. Hierbei gibt es
          allerdings einige Einschränkungen. Als Erstes können Sie nicht
          mehrere disjunkte Unterverzeichnisse des Quell-Projektarchivs in
          ein einzelnes Ziel-Projektarchiv spiegeln &ndash; stattdessen
          müssen Sie ein Eltern-Verzeichnis spiegeln, das allen
          gemeinsam ist. Zum Zweiten ist die Filterlogik vollständig
          pfadbasiert, so dass bei Verzeichnissen, die in der
          Vergangenheit einmal umbenannt wurden, Ihr Spiegel nur die
          Revisionen seit dem Zeitpunkt enthält an dem das Verzeichnis
          unter diesem URL zu finden war. Auch wenn das Unterverzeichnis
          künftig umbenannt wird, werden Revisionen nur bis zu dem
          Zeitpunkt gespiegelt, an dem der URL ungültig wird.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-init-nonempty">
<!--
        <title>A quick trick for mirror creation</title>
-->
        <title>Ein schneller Trick zur Spiegel-Erstellung</title>

<!--
        <para>We mentioned previously the cost of setting up an
          initial mirror of an existing repository.  For many folks,
          the sheer cost of transmitting thousands&mdash;or
          millions&mdash;of revisions of history to a new mirror
          repository via <command>svnsync</command> is a show-stopper.
          Fortunately, Subversion 1.7 provides a workaround by way of
          a new <option>- -allow-non-empty</option> option to
          <command>svnsync initialize</command>.  This option allows
          you to initialize one repository as a mirror of another
          while bypassing the verification that the to-be-initialized
          mirror has no version history present in it.  Per our
          previous warnings about the sensitivity of this whole
          replication process, you should rightly discern that this is
          an option to be used only with great caution.  But it's
          wonderfully handy when you have administrative access to the
          source repository, where you can simply make a physical copy
          of the repository and then initialize that copy as a new
          mirror:</para>
-->
        <para>Vorher erwähnten wir die Kosten der Einrichtung und der
          initialen Spiegelung eines bestehenden Projektarchivs. Für
          viele Leute sind die reinen Kosten der Übertragung tausender
          &ndash; oder Millionen von &ndash; Revisionen der Historie
          in ein neues Spiegel-Projektarchiv mit
          <command>svnsync</command> das KO-Kriterium.
          Glücklicherweise stellt Subversion 1.7 eine Abhilfe in Form
          der neuen Option <option>--allow-non-empty</option> für
          <command>svnsync initialize</command> zur Verfügung. Diese
          Option erlaubt Ihnen, ein Projektarchiv als Spiegel eines
          anderen zu initialisieren, wobei die Verifizierung umgangen
          wird, dass der zu initialisierende Spiegel keine Historie
          beinhaltet. Durch unsere vorhergehenden Warnungen über die
          Empfindlichkeit des gesamten Replizierungsprozesses, sollten
          Sie mit Recht wahrgenommen haben, dass diese Option nur mit
          großer Vorsicht verwendet werden sollte. Aber sie ist
          wunderbar praktisch, falls Sie administrativen Zugriff auf
          das Quell-Projektarchiv haben und einfach eine physikalische
          Kopie des Projektarchivs erstellen und diese Kopie als einen
          neuen Spiegel initialisieren können:</para>

        <informalexample>
          <screen>
$ svnadmin hotcopy /path/to/repos /path/to/mirror-repos <!--
$ ### create /path/to/mirror-repos/hooks/pre-revprop-change
-->
$ ### /path/to/mirror-repos/hooks/pre-revprop-change anlegen
$ svnsync initialize file:///path/to/mirror-repos \
                     file:///path/to/repos <!--
svnsync: E000022: Destination repository already contains revision history; co
nsider using - -allow-non-empty if the repository's revisions are known to mirr
or their respective revisions in the source repository -->
svnsync: E000022: Das Zielprojektarchiv enthält schon eine Revisionsgeschichte
. Sie können es mit »--allow-non-empty« versuchen, falls die Revisionen dieses
Projektarchivs denen des Quellprojektarchivs genau entsprechen.
$ svnsync initialize --allow-non-empty file:///path/to/mirror-repos \
                                       file:///path/to/repos <!--
Copied properties for revision 32042.
-->
Eigenschaften für Revision 32042 kopiert.
$
</screen>
        </informalexample>

<!--
        <para>Admins who are running a version of Subversion prior to
          1.7 (and thus do not have access to <command>svnsync
          initialize</command>'s <option>- -allow-non-empty</option>
          feature) can accomplish effectively the same thing that that
          feature does through <emphasis>careful</emphasis>
          manipulation of the r0 revision properties on the copy of
          the repository which is slated to become a mirror of the
          original.  Use <command>svnadmin setrevprop</command> to
          create the same bookkeeping properties
          that <command>svnsync</command> would have created
          there.</para>
-->
        <para>Administratoren, die eine Version von Subversion vor 1.7
          betreiben (und deshalb keinen Zugang zur
          <option>--allow-non-empty</option>-Funktionalität von
          <command>svnsync initialize</command> haben), können
          effektiv das selbe erreichen, indem sie
          <emphasis>sorgfältig</emphasis> die r0-Eigenschaften der
          Kopie des Projektarchivs manipulieren, dass der Spiegel des
          Originals werden soll. Verwenden Sie <command>svnadmin
          setrevprop</command>, um die selben Eigenschaften zur
          Buchhaltung zu erstellen, die <command>svnsync</command>
          dort erstellt hätte.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.wrapup">
<!--
        <title>Replication wrap-up</title>
-->
        <title>Nachbereitung der Replizierung</title>

<!--
        <para>We've discussed a couple of ways to replicate revision
          history from one repository to another.  So let's look now
          at the user end of these operations.  How does replication
          and the various situations which call for it affect
          Subversion clients?</para>
-->
        <para>Wir erörterten ein paar Möglichkeiten,
          Revisionsgeschichte vin einem Projektarchiv zu einem anderen
          zu replizierten. Lassen Sie uns nun aus Anwendersicht auf
          diese Operationen schauen. Wie wirkt sich Replikation und
          die verschiedenen Situationen, die sie erforderlich machen
          auf die Subversion-Clients aus?</para>

<!--
        <para>As far as user interaction with repositories and mirrors
          goes, it <emphasis>is</emphasis> possible to have a single
          working copy that interacts with both, but you'll have to
          jump through some hoops to make it happen.  First, you need
          to ensure that both the primary and mirror repositories have
          the same repository UUID (which is not the case by default).
          See <xref linkend="svn.reposadmin.maint.uuids" /> later in
          this chapter for more about this.</para>
-->
        <para>Was das Zusammenspiel von Anwendern mit Projektarchiven und
          Spiegeln betrifft, <emphasis>ist</emphasis> es möglich eine
          einzelne Arbeitskopie zu haben, die mit beiden kommuniziert,
          doch müssen Sie hierfür einige Verrenkungen machen. Zunächst
          müssen Sie sicherstellen, dass sowohl das primäre Projektarchiv
          als auch das Spiegel-Projektarchiv dieselbe Projektarchiv-UUID haben
          (was standardmäßig nicht der Fall ist). Mehr darüber unter
          <xref linkend="svn.reposadmin.maint.uuids" /> später in diesem
          Kapitel.</para>

<!--
        <para>Once the two repositories have the same UUID, you can use
          <command>svn relocate</command> to point your working
          copy to whichever of the repositories you wish to operate
          against, a process that is described in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref.svn"/>.  There is a possible danger here,
          though, in that if the primary and mirror repositories
          aren't in close synchronization, a working copy up to date
          with, and pointing to, the primary repository will, if
          relocated to point to an out-of-date mirror, become confused
          about the apparent sudden loss of revisions it fully expects
          to be present, and it will throw errors to that effect.  If
          this occurs, you can relocate your working copy back to the
          primary repository and then either wait until the mirror
          repository is up to date, or backdate your working copy to a
          revision you know is present in the sync repository, and
          then retry the relocation.</para>
-->
        <para>Sobald beide Projektarchive dieselbe UUID haben, können
          Sie <command>svn relocate</command> benutzen, um das
          Projektarchiv auszuwählen, mit dem Sie arbeiten wollen;
          dieser Prozess ist in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref.svn"/> beschrieben. Eine mögliche
          Gefahr besteht allerdings, wenn das Haupt- und das
          Spiegel-Projektarchiv nicht zeitnah synchronisiert sind.
          Eine Arbeitskopie, die auf das Haupt-Projektarchiv zeigt und
          gegenüber diesem aktuell ist, wird nach dem Umschalten auf
          den nicht aktuellen Spiegel durch den plötzlichen Verlust
          von Revisionen, die sie dort erwartet, verwirrt werden und
          deshalb Fehler ausgeben. Falls dies auftritt, können Sie
          entweder Ihre Arbeitskopie wieder zurück auf das
          Haupt-Projektarchiv schalten und warten bis das
          Spiegel-Projektarchiv aktuell ist oder Ihre Arbeitskopie auf
          eine Revision zurücksetzen, von der Sie wissen, dass sie im
          synchronisierten Projektarchiv vorhanden ist, und dann noch
          einmal das Umschalten versuchen.</para>

<!--
        <para>Finally, be aware that the revision-based replication
          provided by <command>svnsync</command> is only
          that&mdash;replication of revisions.  Only the kinds of
          information carried by the Subversion repository dump file
          format are available for replication.  As such, tools such
          as <command>svnsync</command>
          (and <command>svnrdump</command>, which we discuss in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />)
          are limited in ways similar to that of the repository dump
          stream.  They do not include in their replicated information
          such things as the hook implementations, repository or
          server configuration data, uncommitted transactions, or
          information about user locks on repository paths.</para>
-->
        <para>Zum Schluss sollte Ihnen bewusst sein, dass die von
          <command>svnsync</command> angebotene revisionsbasierte
          Replikation genau das ist &ndash; die Replikation von
          Revisionen. Nur die durch das Format der
          Subversion-Auszugsdateien übertragene Information ist
          replizierbar. Somit besitzen Werkzeuge wie
          <command>svnsync</command> (und <command>svnrdump</command>,
          das wir in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />
          erörtern) dieselben Einschränkungen wie der Auszugsstrom und
          beinhalten weder Dinge wie Hook-Implementierungen,
          Projektarchiv- oder Server-Konfigurationen, unvollständige
          Transaktionen noch Anwendersperren auf Pfaden im
          Projektarchiv.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
<!--
      <title>Repository Backup</title>
-->
      <title>Sicherung des Projektarchivs</title>

<!--
      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>
-->
      <para>Trotz zahlreicher technischer Fortschritte seit der Geburt
        des modernen Computers bleibt eine Sache unglücklicherweise
        wahr: manchmal geht etwas richtig schief. Eine kleine Auswahl
        von schlimmen Dingen, die das Schicksal auch auf den
        gewissenhaftesten Administrator loslassen kann, sind
        Stromausfälle, Netzzusammenbrüche, defekter Speicher und
        Festplattenabstürze. So kommen wir zu einem sehr wichtigen
        Thema: Wie mache ich Sicherheitskopien von den Daten meines
        Projektarchivs?</para>

<!--
      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>
-->
      <para>Dem Administrator stehen zwei Arten von Sicherungsmethoden
        zur Verfügung: vollständig und inkrementell. Eine vollständige
        Sicherungskopie des Projektarchivs beinhaltet eine umfassende
        Speicherung aller Informationen, die für die Wiederherstellung
        des Projektarchivs im Katastrophenfall benötigt werden. Dies
        bedeutet gewöhnlich eine Kopie des gesamten
        Projektarchiv-Verzeichnisses (inklusive der Berkeley-DB- oder
        FSFS-Umgebung). Inkrementelle Sicherungen haben einen
        geringeren Umfang: nur die Teile des Projektarchivs, die sich
        seit der letzten Sicherung geändert haben.</para>

<!--
      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutiae involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>
-->
      <para>Was eine vollständige Sicherung betrifft, scheint der
        naive Ansatz vernünftig zu sein; jedoch besteht beim einfachen
        rekursiven Kopieren des Verzeichnisses das Risiko, eine
        fehlerhafte Sicherung zu erstellen, sofern nicht alle anderen
        Zugriffe auf das Projektarchiv verhindert werden. Für Berkeley DB
        beschreibt die Dokumentation eine bestimmte Reihenfolge, in
        der die Datenbankdateien kopiert werden können, um eine
        gültige Sicherungskopie zu gewährleisten. Eine ähnliche
        Reihenfolge gibt es für FSFS-Daten. Allerdings brauchen Sie
        diese Algorithmen nicht selbst zu implementieren, da das
        Subversion-Entwicklerteam das bereits getan hat. Der Befehl
        <command>svnadmin hotcopy</command> kümmert sich um die
        Details, die für eine Sicherungskopie während des Betriebes
        erforderlich sind. Der Aufruf ist so trivial wie die Bedienung
        von Unix' <command>cp</command> oder Windows'
        <command>copy</command>:</para>

      <informalexample>
        <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>
      </informalexample>

<!--
      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>
-->
      <para>Das Ergebnis der Sicherung ist ein vollständig
        funktionsfähiges Subversion-Projektarchiv, das jederzeit die
        Aufgaben Ihres Projektarchivs übernehmen kann, falls irgendetwas
        Schlimmes passieren sollte.</para>

<!--
      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>
-->
      <para>Ein zusätzliches Werkzeug für diesen Befehl steht auch zur
        Verfügung. Im Verzeichnis <filename>tools/backup/</filename>
        des Subversion-Quelltextpaketes liegt das Skript
        <command>hot-backup.py</command>. Dieses Skript ergänzt
        <command>svnadmin hotcopy</command> um ein wenig
        Sicherungsverwaltung, indem es Ihnen erlaubt, lediglich eine
        konfigurierbare Anzahl der letzten Sicherungskopien jedes
        Projektarchivs zu behalten. Es verwaltet automatisch die Namen
        der gesicherten Projektarchiv-Verzeichnisse, um Kollisionen mit
        vorherigen Sicherungen zu vermeiden und löscht ältere
        Sicherungen, so dass nur die jüngsten übrig bleiben. Selbst
        wenn Sie ebenfalls eine inkrementelle Sicherung haben, sollten
        Sie dieses Programm regelmäßig aufrufen. Sie könnten
        beispielsweise <command>hot-backup.py</command> mit einem
        Programmstarter (so wie <command>cron</command> auf Unix
        Systemen) verwenden, der es jede Nacht (oder in einem
        Zeitintervall, das Ihnen sicher erscheint) aufruft.</para>

<!--
      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with
        the <option>- -incremental</option> option to perform an
        incremental backup of a given revision or range of revisions.
        And of course, you can achieve a full backup variation of this
        by omitting the <option>- -incremental</option> option to that
        command.  There is some value in these methods, in that the
        format of your backed-up information is flexible&mdash;it's
        not tied to a particular platform, versioned filesystem type,
        or release of Subversion or the libraries it uses.  But that
        flexibility comes at a cost, namely that restoring that data
        can take a long time&mdash;longer with each new revision
        committed to your repository.  Also, as is the case with so
        many of the various backup methods, revision property changes
        that are made to already backed-up revisions won't get picked
        up by a nonoverlapping, incremental dump generation.  For
        these reasons, we recommend against relying solely on
        dump-based backup approaches.</para>
-->
      <para>Einige Administratoren verwenden einen unterschiedlichen
        Sicherungsmechanismus, der auf der Erzeugung und Speicherung
        von Projektarchiv-Auszugs-Daten basiert. In <xref
        linkend="svn.reposadmin.maint.migrate" /> haben wir
        beschrieben, wie <command>svnadmin dump</command> mit der
        Option <option>--incremental</option> verwendet werden kann,
        um eine inkrementelle Sicherung einer Revision oder eines
        Bereichs von Revisionen zu erstellen. Natürlich können Sie
        davon eine vollständige Sicherung bekommen, wenn Sie die
        Option <option>--incremental</option> weglassen. Der Vorteil
        dieser Methode besteht darin, dass das Format der gesicherten
        Information flexibel ist &ndash; es erfordert keine bestimmte
        Plattform, keinen bestimmten Typ eines versionierten
        Dateisystems, keine bestimmte Version von Subversion oder
        der von ihm verwendeten Bibliotheken. Diese Flexibilität kommt
        allerdings zu dem Preis, dass die Wiederherstellung der Daten
        sehr lange dauern kann &ndash; länger mit jeder neuen
        Revision, die ins Projektarchiv übertragen wird. Wie bei
        vielen verschiedenen Sicherungsmethoden werden auch hier
        Änderungen an Revisions-Eigenschaften bereits gesicherter
        Revisionen nicht berücksichtigt, sofern es sich um eine
        nicht-überlappende inkrementelle Sicherung handelt. Wir raten
        aus diesen Gründen davon ab, sich ausschließlich auf
        Sicherungsstrategien zu verlassen, die alleine auf Auszügen
        basieren.</para>

<!--
      <para>Beginning with Subversion 1.8, <command>svnadmin hotcopy</command>
        accepts <option>- -incremental</option> option and supports incremental
        hotcopy mode for FSFS repositories.  In incremental hotcopy mode,
        revision data which has already been copied from the source to the
        destination repository will not be copied again. When
        <option>- -incremental</option> option is used with
        <command>svnadmin hotcopy</command>, Subversion will only copy new
        revisions, and revisions which have changed in size or had their
        modification time stamp changed since the previous hotcopy
        operation.  Moreover, unlike with <command>svnsync</command> or
        <command>svnadmin dump - -incremental</command>, performance of
        <command>svnadmin hotcopy - -incremental</command> is only limited to
        disk I/O.  Therefore, incremental hotcopy can be a huge
        time saver when making a backup of a large repository.</para>
-->
      <para>Beginnend mit Subversion 1.8 akzeptiert <command>svnadmin
        hotcopy</command> die Option <option>--incremental</option>
        und unterstützt den inkrementellen Hotcopy-Modus für
        FSFS-Projektarchive. Bei dem inkrementellen Hotcopy-Modus
        werden bereits kopierte Revisionsdaten nicht erneut kopiert.
        Wenn die Option <option>--incremental</option> mit
        <command>svnadmin hotcopy</command> verwendet wird, kopiert
        Subversion nur neue Revisionen sowie Revisionen, die seit der
        letzten Hotcopy-Operation eine geänderte Größe oder einen
        geänderten Änderungszeitstempel haben. Darüber hinaus wird die
        Leistungsfähigkeit von <command>svnadmin hotcopy
        --incremental</command> nur durch Plattenzugriffe
        eingeschränkt, anders als bei <command>svnsync</command> oder
        <command>svnadmin dump --incremental</command>. Aus diesem
        Grund kann ein inkrementelles Hotcopy eine riesige
        Zeitersparnis bei der Sicherung eines großen Projektarchivs
        sein.</para>

<!--
      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>
-->
      <para>Wie Sie sehen können, hat jeder der verschiedenen
        Sicherungstypen seine Vor- und Nachteile. Bei weitem am
        einfachsten ist die vollständige Sicherungskopie im laufenden
        Betrieb, die stets ein perfektes, einsatzfähiges Abbild Ihres
        Projektarchivs erzeugt. Falls Ihrem Projektarchiv irgendetwas
        Schlimmes widerfahren sollte, können Sie es durch eine
        einfache rekursive Verzeichniskopie aus der Sicherung
        wiederherstellen. Falls Sie mehrere Sicherungen Ihres
        Projektarchivs vorhalten, benötigt leider jede dieser
        vollständigen Kopien genauso viel Plattenplatz wie das
        Original. Im Gegensatz dazu lassen sich inkrementelle
        Sicherungen schneller erzeugen und platzsparender sichern.
        Allerdings kann die Wiederherstellung eine Plage sein, da oft
        mehrere inkrementelle Sicherungen eingespielt werden müssen.
        Andere Methoden wiederum haben auch ihre Besonderheiten.
        Administratoren müssen das Gleichgewicht zwischen den Kosten
        der Sicherung und den Kosten der Wiederherstellung
        finden.</para>

<!--
      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>
-->
      <para>Das Programm <command>svnsync</command> (siehe <xref
        linkend="svn.reposadmin.maint.replication" />) bietet
        tatsächlich einen handlichen Ansatz dazwischen. Falls Sie
        regelmäßig einen nur lesbaren Spiegel mit Ihrem
        Haupt-Projektarchiv synchronisieren, stellt der Spiegel einen
        ausgezeichneten Kandidaten dar, um für Ihr Haupt-Projektarchiv
        einzuspringen, falls es mal umkippt. Der Hauptnachteil dieses
        Ansatzes besteht darin, dass nur versionierte Projektarchiv-Daten
        synchronisiert werden &ndash;
        Projektarchiv-Konfigurationsdateien, benutzerdefinierte Sperren
        auf Projektarchiv-Pfaden und andere Dinge, die sich zwar im
        physikalischen Projektarchiv-Verzeichnis befinden können, jedoch
        nicht <emphasis>innerhalb</emphasis> des virtuellen
        versionierten Dateisystems des Projektarchivs, werden durch
        <command>svnsync</command> nicht berücksichtigt.</para>

<!--
      <para>In any backup scenario, repository administrators need to
        be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change
        hooks.<footnote><para><command>svnadmin setlog</command> can
        be called in a way that bypasses the hook interface
        altogether.</para></footnote>  And since you can change
        revision properties without respect to chronological
        order&mdash;you can change any revision's properties at any
        time&mdash;an incremental backup of the latest few revisions
        might not catch a property modification to a revision that was
        included as part of a previous backup.</para>
-->
      <para>In jedem Sicherungs-Szenario müssen sich
        Projektarchiv-Administratoren bewusst sein, inwiefern Änderungen
        an unversionierten Revisions-Eigenschaften Auswirkungen auf die
        Sicherungen haben. Da diese Änderungen allein keine Revisionen
        erzeugen, werden auch keine post-commit-Hooks ausgelöst; es
        kann sogar sein, dass die Hooks pre-revprop-change und
        post-revprop-change nicht ausgelöst werden.
        <footnote><para><command>svnadmin setlog</command> kann auf eine Art
        aufgerufen werden, dass die Hook-Schnittstelle völlig umgangen
        wird.</para></footnote> Und da Sie Revisions-Eigenschaften ohne
        Rücksicht auf die zeitliche Abfolge ändern können &ndash; Sie können
        jederzeit die Eigenschaften jeder Revision ändern &ndash; könnte eine
        inkrementelle Sicherung der letzten paar Revisionen eine Änderung an
        einer Revision aus einer vorangegangenen Sicherung übersehen.</para>

<!--
      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
-->
      <para>Im Allgemeinen braucht nur ein echter Paranoiker nach
        jeder Übergabe eine vollständige Sicherung des Projektarchivs.
        Eine vollständige Sicherheitskopie des Projektarchivs im
        laufenden Betrieb im Rahmen einer systemweiten, nächtlichen
        Sicherung sollte ein Projektarchiv-Administrator jedoch erwägen,
        unter der Voraussetzung, dass das Projektarchiv bereits
        irgendeinen Redundanzmechanismus mit der nötigen Granularität
        verwendet (etwa Übergabe-E-Mails oder inkrementelle Auszüge).
        Es sind Ihre Daten &ndash; schützen Sie sie, wie es Ihnen
        passt.</para>

<!--
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of
        Fate,<footnote><para>You know&mdash;the collective term for
        all of her <quote>fickle fingers.</quote></para></footnote> it
        should certainly help you recover from those trying
        times.</para>
-->
      <para>Oftmals ist der beste Ansatz für die Projektarchiv-Sicherung
        ein diversifizierter, der die Stärken von Kombinationen der
        hier beschriebenen Methoden ausspielt. Die
        Subversion-Entwickler beispielsweise sichern jede Nacht das
        Subversion-Quelltext-Projektarchiv mit
        <command>hot-backup.py</command> und einem
        <command>rsync</command> dieser vollständigen Sicherungen von
        einem entfernten Standort aus; sie halten mehrere Archive
        aller Übergabe- und Eigenschafts-Änderungs-E-Mails vor und sie
        haben Spiegel des Projektarchivs, die von Freiwilligen mit
        <command>svnsync</command> verwaltet werden. Ihre Lösung
        könnte ähnlich aussehen, sollte aber Ihren Bedürfnissen
        entsprechen und das empfindliche Gleichgewicht zwischen
        Bequemlichkeit und Paranoia aufrechterhalten. Egal, was Sie
        machen: überprüfen Sie Ihre Sicherungen ab und an &ndash; was
        nutzt ein Reservereifen mit einem Loch? Obwohl all das Ihr
        Material nicht vor der eisernen Faust des Schicksals zu retten
        vermag, sollte es Ihnen sicherlich helfen, sich aus diesen
        schwierigen Zeiten zu erholen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
<!--
      <title>Managing Repository UUIDs</title>
-->
      <title>Verwaltung von Projektarchiv UUIDs</title>

<!--
      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>
-->
      <para>Subversion-Projektarchive haben eine mit ihnen verknüpfte,
        universelle, eindeutige Identifizierung (universally unique
        identifier, UUID). Dieser UUID wird von Subversion-Clients
        verwendet, um die Identität eines Projektarchivs zu verifizieren,
        falls andere Methoden nicht ausreichend sind (wie die
        Überprüfung des Projektarchiv-URLs, der sich im Lauf der Zeit
        ändern kann). Selten, wenn überhaupt, müssen sich
        Subversion-Projektarchiv-Administratoren weitergehende
        Gedanken über Projektarchiv UUIDs machen, anstatt sie als
        triviales Implementierungsdetail von Subversion zu betrachten.
        Manchmal jedoch gibt es einen Grund, der Aufmerksamkeit für
        dieses Detail verlangt.</para>

<!--
      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>
-->
      <para>Im Allgemeinen möchten Sie, dass die UUIDs Ihrer aktiven
        Projektarchive eindeutig sind. Das ist schließlich der Sinn von
        UUIDs. Jedoch gibt es Gelegenheiten, bei denen Sie möchten,
        dass die UUIDs zweier Projektarchive identisch sind. Wenn Sie
        beispielsweise zu Sicherungszwecken eine Kopie eines
        Projektarchivs machen, möchten Sie, dass die Sicherungskopie ein
        perfektes Abbild des Originals ist, so dass die Anwender nach
        einer Wiederherstellung des Projektarchivs aus der
        Sicherheitskopie nicht das Gefühl haben, es mit einem
        unterschiedlichen Projektarchiv zu tun zu haben. Beim Erstellen
        bzw. beim Laden eines Auszugs der Projektarchiv-Historie (wie
        oben in <xref linkend="svn.reposadmin.maint.migrate" />
        beschrieben) können Sie entscheiden, ob der im Auszugsstrom
        befindliche UUID auf das Projektarchiv angewendet werden soll, in
        das Sie die Daten laden. Die besonderen Umstände diktieren
        hier das richtige Verhalten.</para>

<!--
      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>
-->
      <para>Eine Projektarchiv-UUID kann auf verschiedene Art und Weise
        gesetzt (oder zurückgesetzt) werden, falls sie es müssen.
        Seit Subversion 1.5 wird einfach der Befehl <command>svnadmin
        setuuid</command> verwendet. Wenn Sie diesem Befehl einen
        ausdrücklichen UUID mitgeben, wird die Wohlgeformtheit des
        UUID überprüft und der UUID des Projektarchivs auf diesen Wert
        gesetzt. Wenn Sie den UUID weglassen, wird ein nagelneuer UUID
        für Ihr Projektarchiv erzeugt.</para>

      <informalexample>
        <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec <!--
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
-->
$ svnadmin setuuid /var/svn/repos   # neuen UUID erzeugen
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \ <!--
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
-->
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # alten UUID wiederherstellen
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

<!--
      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load - -force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>.</para>
-->
      <para>Für Anwender älterer Versionen als Subversion 1.5 sieht
        die Sache etwas komplizierter aus. Sie können den UUID eines
        Projektarchivs ausdrücklich setzen, indem Sie einen
        Projektarchiv-Auszugs-Fragment mit dem neuen UUID durch den
        Befehl <userinput>svnadmin load --force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>
        leiten.</para>

      <informalexample>
        <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

<!--
      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>
-->
      <para>Die Erzeugung eines nagelneuen UUID mit älteren Versionen
        von Subversion gestaltet sich jedoch nicht so einfach. Am
        besten finden Sie eine andere Möglichkeit zum Erzeugen des
        UUIDs und setzen anschließend den Projektarchiv-UUID auf diesen
        Wert.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
<!--
    <title>Moving and Removing Repositories</title>
-->
    <title>Verschieben und Entfernen von Projektarchiven</title>

<!--
    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>
-->
    <para>Sämtliche Daten eines Subversion-Projektarchivs befinden sich
      innerhalb des Projektarchiv-Verzeichnisses. Als solches können Sie
      ein Subversion-Projektarchiv an einen anderen Ort auf der Platte
      verschieben, ein Projektarchiv umbenennen, kopieren oder
      vollständig löschen, indem Sie die Werkzeuge Ihres
      Betriebssystems zum Manipulieren von Verzeichnissen verwenden
      &ndash; <command>mv</command>, <command>cp
      -a</command> und <command>rm -r</command> auf Unix-Plattformen;
      <command>copy</command>, <command>move</command> und
      <command>rmdir /s /q</command> unter Windows; eine riesige
      Anzahl an Maus- und Menüoperationen in verschiedenen graphischen
      Dateiverwaltungs-Anwendungen, usw.</para>

<!--
    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>
-->
    <para>Natürlich gehört bei derartigen Änderungen mehr dazu, wenn
      deren Auswirkungen sauber behandelt werden sollen.
      Beispielsweise sollten Sie ihre Server-Konfiguration
      aktualisieren, so dass sie auf den neuen Ort des verschobenen
      Projektarchivs zeigt oder die Konfigurationseiträge für ein nun
      gelöschtes Projektarchiv entfernen. Sollten Sie automatisierte
      Prozesse haben, die Informationen aus Ihrem oder über Ihr
      Projektarchiv veröffentlichen, sollten auch sie gegebenenfalls
      aktualisiert werden. Auch Hook-Skripte bedürfen eventuell einer
      erneute Konfigurierung. Anwender müssten vielleicht
      benachrichtigt werden. Die Liste könnte beliebig verlängert
      werden oder zumindest bis zu dem Punkt, dass Ihre um das
      Subversion-Projektarchiv gebauten Prozesse und Prozeduren
      berücksichtigt werden.</para>

<!--
    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including
      their UUIDs.  In some circumstances, this might be desirable.
      But in the instances where it is not, you'll need to generate a
      new UUID for one of these identical repositories.  See
      <xref linkend="svn.reposadmin.maint.uuids" /> for more about
      managing repository UUIDs.</para>
-->
    <para>Im Fall eines kopierten Projektarchivs sollten Sie auch die
      Tatsache berücksichtigen, dass Subversion Projektarchiv-UUIDs zur
      Unterscheidung von Projektarchivs benutzt. Wenn Sie ein
      Subversion-Projektarchiv mit einem typischen rekursiven
      Kommandozeilen-Kopierprogramm kopieren, haben Sie nachher zwei
      völlig identische Projektarchive &ndash; einschließlich ihrer
      UUIDs. Manchmal mag das erwünscht sein; anderenfalls müssen Sie
      für eins dieser identischen Projektarchivs einen neuen UUID
      erzeugen. Für weitere Informationen über Projektarchiv-UUIDs, siehe
      <xref linkend="svn.reposadmin.maint.uuids" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
<!--
    <title>Summary</title>
-->
    <title>Zusammenfassung</title>

<!--
    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>
-->
    <para>Sie sollten bis jetzt ein grundlegendes Verständnis darüber
      haben, wie Subversion-Projektarchive angelegt, konfiguriert und
      gewartet werden. Wir haben Ihnen die verschiedenen Werkzeuge
      vorgestellt, die Ihnen bei diesen Aufgaben helfen. Im Verlauf
      dieses Kapitels haben wir auf verbreitete Fallstricke bei der
      Verwaltung hingewiesen und Vorschläge zu deren Vermeidung
      gegeben.</para>

<!--
    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>
-->
    <para>Was jetzt noch bleibt ist, dass Sie entscheiden müssen,
      welche aufregenden Daten Sie in Ihrem Projektarchiv unterbringen
      und wie sie schließlich über das Netz verfügbar gemacht werden
      sollen. Das nächste Kapitel ist ganz dem Netz gewidmet.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
