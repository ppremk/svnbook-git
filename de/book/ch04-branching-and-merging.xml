<!-- -*- sgml -*- -->

<chapter id="svn.branchmerge">
<!--
  <title>Branching and Merging</title>
-->
  <title>Verzweigen und Zusammenführen</title>

  <blockquote>
<!--
    <attribution>Confucius</attribution>
    <para><quote>君子务本
      (It is upon the Trunk that a gentleman works.)</quote></para>
-->
    <attribution>Konfuzius</attribution>
    <para><quote>君子务本
      (Der Edle pflegt die Wurzel)</quote></para>
  </blockquote>

<!--
  <para>Branching and merging are fundamental aspects of version
    control, simple enough to explain conceptually but offering just
    enough complexity and nuance to merit their own chapter in this
    book.  Herein, we'll introduce you to the general ideas behind
    these operations as well as Subversion's somewhat unique approach
    to them.  If you've not familiarized yourself with Subversion's
    basic concepts (found in <xref linkend="svn.basic"/>), we
    recommend that you do so before reading this chapter.</para>
-->
  <para>Verzweigen (<foreignphrase>Branching</foreignphrase>) und
    Zusammenführen
    (<foreignphrase>Merging</foreignphrase><footnote><para>Die
    Begriffe <quote>Verzweigen</quote> bzw. <quote>Zweig</quote> und
    <quote>Zusammenführen</quote> werden durchgängig in den Ausgaben
    von Subversion verwendet, sofern die entsprechenden deutschen
    Gebietsschemaparameter (<foreignphrase>Locale</foreignphrase>)
    eingestellt sind, was für diese Übersetzung gemacht wurde. In der
    Übersetzung dieses Buchs werden jedoch auch die entsprechenden englischen
    Begriffe <foreignphrase>Branch/Branching</foreignphrase> bzw.
    <foreignphrase>Merge/Merging</foreignphrase> verwendet, wenn das
    handlicher erscheint als die teilweise sperrig klingenden
    deutschen Übersetzungen, zumal Begriffe wie
    <foreignphrase>Branch</foreignphrase>,
    <foreignphrase>Merge</foreignphrase>,
    <foreignphrase>Diff</foreignphrase> Bestandteil des Vokabulars der
    Entwicklergemeinde sind.</para></footnote>) sind grundlegende
    Konzepte der Versionskontrolle, die zwar konzeptuell einfach zu
    beschreiben sind, allerdings auch hinreichend Komplexität und
    Feinheiten mit sich bringen, so dass sie ein eigenes Kapitel in
    diesem Buch verdient haben. Hier werden wir Ihnen sowohl die
    dahinter stehenden allgemeinen Konzepte vorstellen als auch den,
    gewissermaßen einzigartigen, Ansatz von Subversion hierzu. Sollten
    Sie sich noch nicht mit den grundlegenden Konzepten von
    Subversions vertraut gemacht haben (zu finden in
    <xref linkend="svn.basic"/>), möchten wir Ihnen vor dem Lesen
    dieses Kapitel dazu raten.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
<!--
    <title>What's a Branch?</title>
-->
    <title>Was ist ein Zweig?</title>

<!--
    <para>Suppose it's your job to maintain a document for a division
      in your company&mdash;a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>
-->
    <para>Angenommen, Sie haben die Aufgabe, ein Dokument für eine
      Abteilung Ihrer Firma zu pflegen &ndash; eine Art
      Handbuch. Eines Tages fragt eine andere Abteilung nach dem
      gleichen Handbuch, jedoch an einigen Stellen auf ihre
      Bedürfnisse <quote>angepasst</quote>, da sie auf etwas andere
      Weise arbeiten.</para>

<!--
    <para>What do you do in this situation?  You do the obvious: make
      a second copy of your document and begin maintaining the two
      copies separately.  As each department asks you to make small
      changes, you incorporate them into one copy or the other.</para>
-->
    <para>Was machen Sie in dieser Situation? Sie machen das
      Offensichtliche: Sie erstellen eine Kopie Ihres Dokumentes und
      beginnen, die beiden Kopien getrennt zu pflegen. Sobald Sie
      irgendeine Abteilung auffordert, kleine Änderungen vorzunehmen,
      pflegen Sie diese in die entsprechende Kopie ein.</para>

<!--
    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they differ only in
      small, specific ways.</para>
-->
    <para>Oftmals möchten Sie die selbe Änderung in beiden Kopien
      machen. Wenn Sie zum Beispiel einen Schreibfehler in der ersten
      Kopie entdecken, ist es sehr wahrscheinlich, dass dieser Fehler
      auch in der zweiten Kopie vorliegt. Schließlich sind die beiden
      Dokumente, bis auf kleine Unterschiede, fast gleich.</para>

<!--
    <para>
      <indexterm>
        <primary>branches</primary>
      </indexterm>This is the basic concept of a branch&mdash;namely,
      a line of development that exists independently of another line,
      yet still shares a common history if you look far enough back in
      time.  A branch always begins life as a copy of something, and
      moves on from there, generating its own history (see
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>
-->
    <para>
      <indexterm>
        <primary>Zweige</primary>
        <see>Branches</see>
      </indexterm>
      <indexterm>
        <primary>Branches</primary>
      </indexterm>
      Das Grundkonzept eines <firstterm>Zweigs</firstterm>
      (<foreignphrase>Branch</foreignphrase>) ist eine Entwicklungslinie, die
      unabhängig von einer anderen existiert, jedoch über eine gemeinsame
      Geschichte verfügt, wenn in der Zeit weit genug zurück gegangen wird. Ein
      Zweig beginnt sein Leben stets als eine Kopie von etwas und läuft von da
      an weiter, wobei er seine eigene Geschichte erzeugt (siehe
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

    <figure id="svn.branchmerge.whatis.dia-1">
<!--
      <title>Branches of development</title>
-->
      <title>Entwicklungszweige</title>
      <graphic fileref="images/ch04dia1.png"/>
    </figure>

<!--
    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>
-->
    <para>Subversion verfügt über Befehle, die Ihnen dabei helfen,
      parallele Zweige Ihrer Dateien und Verzeichnisse zu verwalten.
      Es erlaubt Ihnen, durch Kopieren Ihrer Daten Zweige zu
      erstellen und merkt sich, dass die Zweige untereinander in
      Beziehung stehen. Es hilft Ihnen auch dabei, Änderungen von einem
      Zweig auf einen anderen zu duplizieren. Schließlich ermöglicht es,
      dass Teile Ihrer Arbeitskopie verschiedene Zweige repräsentieren
      können, was Ihnen bei Ihrer täglichen Arbeit erlaubt,
      verschiedene Entwicklungslinien zu <quote>mischen und
      gegenüberzustellen</quote>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
<!--
    <title>Using Branches</title>
-->
    <title>Verwenden von Zweigen</title>

<!--
    <para>At this point, you should understand how each commit creates
      a new state of the filesystem tree (called a <quote>revision</quote>)
      in the repository.  If you don't, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>
-->
    <para>An dieser Stelle sollten Sie ein Verständnis haben, wie jede
      Übergabe an das Projektarchiv dort einen neuen Zustand des
      Dateibaums (genannt <quote>Revision</quote>) erzeugt. Wenn
      nicht, blättern Sie zurück und lesen Sie in
      <xref linkend="svn.basic.in-action.revs"/> über Revisionen
      nach.</para>

<!--
    <para>Let's revisit the example from
      <xref linkend="svn.basic"/>.  Remember that you and your
      collaborator, Sally, are sharing a repository that contains two
      projects, <filename>paint</filename> and
      <filename>calc</filename>.  Notice that in <xref
      linkend="svn.branchmerge.using.dia-1"/>, however, each project
      directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>
-->
    <para>Lassen Sie uns noch einmal auf das Beispiel aus
      <xref linkend="svn.basic"/> zurückkommen. Erinnern Sie sich,
      dass Sie und Ihre Mitarbeiterin Sally sich ein Projektarchiv
      teilen, das zwei Projekte beinhaltet: <filename>paint</filename>
      und <filename>calc</filename>. Beachten Sie, dass in <xref
      linkend="svn.branchmerge.using.dia-1"/> dieses Mal jedoch
      jedes Projektverzeichnis Unterverzeichnisse namens
      <filename>trunk</filename> und <filename>branches</filename>
      beinhaltet.  Der Grund hierfür wird bald klar sein.</para>

    <figure id="svn.branchmerge.using.dia-1">
<!--
      <title>Starting repository layout</title>
-->
      <title>Projektarchiv-Struktur zu Beginn</title>
      <graphic fileref="images/ch04dia2.png"/>
    </figure>

<!--
    <para>As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>
-->
    <para>Wie vorher sei hier angenommen, dass sowohl Sally als auch
      Sie Arbeitskopien des Projektes <quote>calc</quote> besitzen.
      Genauer gesagt, hat jeder von Ihnen eine Arbeitskopie von
      <filename>/calc/trunk</filename>. Alle Dateien des Projektes
      befinden sich in diesem Unterverzeichnis statt in
      <filename>/calc</filename> selber, da Ihr Team entschieden hat,
      dass in <filename>/calc/trunk</filename> die
      <quote>Hauptlinie</quote> der Entwicklung stattfindet.</para>

<!--
    <para>Let's say that you've been given the task of implementing a
      large software feature.  It will take a long time to write, and
      will affect all the files in the project.  The immediate problem
      is that you don't want to interfere with Sally, who is in the
      process of fixing small bugs here and there.  She's depending on
      the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit by bit, you'll surely break
      things for Sally (and other team members as well).</para>
-->
    <para>Nehmen wir an, Sie haben die Aufgabe bekommen, einen großen
      Teil einer Software umzusetzen. Die Erstellung benötigt einen
      langen Zeitraum und berührt alle Dateien im Projekt. Das Problem,
      dass sofort auftaucht ist, dass Sie Sally nicht in die Quere
      kommen möchten, die gerade hier und da kleinere Fehler
      beseitigt. Sallys Arbeit hängt davon ab, dass die letzte Version
      des Projektes (in <filename>/calc/trunk</filename>) stets
      benutzbar ist. Wenn Sie nun damit beginnen, Stück für Stück Ihre
      Änderungen zu übertragen, werden Sie die Dinge für Sally (und
      auch für andere Teammitglieder) bestimmt in Unordnung
      bringen.</para>

<!--
    <para>One strategy is to crawl into a hole: you can stop sharing
      information for a week or two, gutting and reorganizing all the
      files in your private working copy but not committing or
      updating until you're completely finished with your task.  There
      are a number of problems with this, though.  First, it's not
      very safe.  Should something bad happen to your working copy or
      computer, you risk losing all your changes.  Second, it's not
      very flexible.  Unless you manually replicate your changes
      across different working copies or computers, you're stuck trying
      to make your changes in a single working copy.  Similarly, it's
      difficult to share your work-in-progress with anyone else.  A
      common software development <quote>best practice</quote> is to
      allow your peers to review your work as you go.  If nobody sees
      your intermediate commits, you lose potential feedback and may
      end up going down the wrong path for weeks before another person
      on your team notices.  Finally, when you're finished with all
      your changes, you might find it very difficult to merge your
      completed work with the rest of the company's main body of code.
      Sally (or others) may have made many other changes in the
      repository that are difficult to incorporate into your working
      copy when you eventually run <command>svn update</command> after
      weeks of isolation.</para>
-->
    <para>Eine Strategie wäre es, sich in ein Loch zu verkriechen: Sie
      können für eine Woche oder zwei den Informationsaustausch
      einstellen, und die Dateien Ihrer Arbeitskopie ausräumen und
      umorganisieren, ohne Änderungen zu übertragen oder die
      Arbeitskopie zu aktualisieren, bevor Sie mit Ihrer Arbeit
      vollständig fertig sind. Das wirft allerdings einige Probleme
      auf. Erstens ist das nicht sehr sicher. Falls Ihrer Arbeitskopie
      oder Ihrem Rechner etwas Schlimmes zustoßen sollte, riskieren
      Sie, alle Ihre Änderungen zu verlieren.  Zweitens ist es nicht
      sehr flexibel. Falls Sie Ihre Änderungen nicht manuell über
      mehrere Arbeitskopien oder Rechner abgleichen, müssen Sie Ihre
      Änderungen in einer einzigen Arbeitskopie vornehmen. Ebenso
      schwierig wäre es, Ihre Änderungen mit anderen zu teilen. Eine
      weit verbreitete <quote>beste Vorgehensweise</quote> ist es,
      Ihren Mitarbeitern zu erlauben, Ihre bisherigen Ergebnisse zu
      überprüfen, während Sie mit Ihrer Arbeit fortfahren. Wenn
      niemand Ihre unmittelbaren Änderungen sieht, haben Sie keine
      möglichen Rückmeldungen und es könnte sein, dass Sie für Wochen
      einen falschen Weg einschlagen, bevor es jemand aus Ihrem Team
      bemerkt. Schließlich könnte es am Ende, wenn Sie mit Ihren
      Änderungen fertig sind, sehr schwierig sein, Ihr Arbeitsergebnis
      wieder mit dem Hauptteil der Quelltexte Ihrer Firma
      zusammenzuführen. Sally (und andere) hätten viele andere
      Änderungen ins Projektarchiv übertragen haben können, die sich
      schwer in Ihre Arbeitskopie einarbeiten lassen, wenn Sie
      schließlich nach Wochen der Isolierung <command>svn
      update</command> ausführen.</para>

<!--
    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      not-yet-completed work frequently without interfering with
      others' changes and while still selectively sharing information
      with your collaborators.  You'll see exactly how this works as
      we continue.</para>
-->
    <para>Die bessere Lösung ist es, Ihren eigenen Zweig oder Ihre
      eigene Entwicklungslinie im Projektarchiv zu erzeugen. Dies
      erlaubt Ihnen, Ihre unvollständigen Arbeitsergebnisse regelmäßig
      zu sichern, ohne die Änderungen anderer zu stören; dennoch
      können Sie selektiv Informationen mit Ihren Kollegen teilen. Im
      Weiteren werden Sie sehen, wie das funktioniert.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
<!--
      <title>Creating a Branch</title>
-->
      <title>Erzeugen eines Zweiges</title>

<!--
      <para>Creating a branch is very simple&mdash;you make a copy of
        your project tree in the repository using the <command>svn
        copy</command> command.  Since your project's source code is
        rooted in the <filename>/calc/trunk</filename> directory, it's
        that directory that you'll copy.  Where should the new
        copy live?  Wherever you wish.  The repository location in
        which branches are stashed is left by Subversion as a matter
        of project policy.  Finally, your branch will need a name to
        distinguish it from other branches.  Once again, the name you
        choose is unimportant to Subversion&mdash;you can use whatever
        name works best for you and your team.</para>
-->
      <para>Es ist sehr einfach, einen Zweig zu erzeugen &ndash; Sie
        erstellen mit dem Befehl <command>svn copy</command> eine
        Kopie des Projekt-Baumes im Projektarchiv. Da der Quelltext
        Ihres Projektes seine Wurzel im Verzeichnis
        <filename>/calc/trunk</filename> hat, werden Sie diese
        Verzeichnis kopieren. Wo soll die neue Kopie angelegt werden?
        Wo Sie wünschen. Der Ort im Projektarchiv, in dem Zweige
        gespeichert werden sollen, wird von Subversion den
        Projektrichtlinien überlassen. Schließlich benötigt Ihr Zweig
        noch einen Namen, um ihn von anderen Zweigen zu unterscheiden.
        Auch diesmal ist der von Ihnen gewählte Name für Subversion
        unwichtig &ndash; Sie können einen Namen verwenden, der am
        besten für Sie und Ihr Team geeignet ist.</para>

<!--
      <para>Let's assume that your team (like most) has a policy of
        creating branches in the <filename>branches</filename>
        directory that is a sibling of the project's trunk
        (the <filename>/calc/branches</filename> directory in our
        scenario).  Lacking inspiration, you settle
        on <literal>my-calc-branch</literal> as the name you wish to
        give your branch.  This means that you'll create a new
        directory, <filename>/calc/branches/my-calc-branch</filename>,
        which begins its life as a copy
        of <filename>/calc/trunk</filename>.</para>
-->
      <para>Nehmen wir an, dass Ihr Team (wie die meisten) vereinbart
        hat, Zweige im Verzeichnis <filename>branches</filename> zu
        erzeugen, das ein Geschwister-Verzeichnis des Projekt-Stamms
        (<foreignphrase>Trunk</foreignphrase>) ist (in unserem
        Szenario das Verzeichnis <filename>/calc/branches</filename>).
        Aus Mangel an Phantasie wählen Sie als Namen für Ihren Zweig
        <literal>my-calc-branch</literal>. Das heißt, sie legen ein
        neues Verzeichnis
        <filename>/calc/branches/my-calc-branch</filename> an, das als
        Kopie von <filename>/calc/trunk</filename> beginnt.</para>

<!--
      <para>
        <indexterm>
          <primary>copying</primary>
          <secondary>remote copies</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
          <secondary>creating</secondary>
        </indexterm>You may already have seen <command>svn
        copy</command> used to copy one file to another within a
        working copy.  But it can also be used to do
        a <firstterm>remote copy</firstterm>&mdash;a copy that
        immediately results in a newly committed repository revision
        and for which no working copy is required at all.  Just copy
        one URL to another:</para>
-->
      <para>
        <indexterm>
          <primary>Kopieren</primary>
          <secondary>Kopien aus der Ferne</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>Unterbefehle</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>Branches</primary>
          <secondary>erzeugen</secondary>
        </indexterm>Sie haben vielleicht schon gesehen, wie mit <command>svn
        copy</command> innerhalb einer Arbeitskopie eine Datei auf
        eine andere kopiert wird. Es kann allerdings auch verwendet
        werden, um eine <firstterm>Kopie aus der Ferne</firstterm>
        durchzuführen: eine Kopie die unmittelbar eine neue Revision
        des Projektarchivs zur Folge hat, und für die überhaupt keine
        Arbeitskopie notwendig ist. Kopieren Sie einfach einen URL auf
        einen anderen:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/my-calc-branch \ <!--
           -m "Creating a private branch of /calc/trunk."

Committed revision 341.
-->
           -m "Privaten Zweig von /calc/trunk angelegt."

Revision 341 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>This command causes a near-instantaneous commit in the
        repository, creating a new directory in revision 341.  The new
        directory is a copy of <filename>/calc/trunk</filename>.  This
        is shown in <xref linkend="svn.branchmerge.using.create.dia-1"
        />.<footnote><para>Subversion does not support copying between
        different repositories.  When using URLs with <command>svn
        copy</command> or <command>svn move</command>, you can only
        copy items within the same repository.</para></footnote>  While
        it's also possible to create a branch by using <command>svn
        copy</command> to duplicate a directory within the working
        copy, this technique isn't recommended.  It can be quite slow,
        in fact!  Copying a directory on the client side is a
        linear-time operation, in that it actually has to duplicate
        every file and subdirectory within that working copy directory
        on the local disk.  Copying a directory on the server,
        however, is a constant-time operation, and it's the way most
        people create branches.  In addition, this practice raises the
        possibility of copying mixed-revision working copies.  This isn't
        inherently dangerous, but can cause unnecessary complications later
        during merging.  If you do choose to create a branch by copying a
        working copy path, you should be sure the source directory has no
        local modifications and is not at mixed-revisions.</para>
-->
      <para>Dieser Befehl bewirkt eine fast sofortige Übergabe im
        Projektarchiv, wobei in Revision 341 ein neues Verzeichnis
        erzeugt wird. Das neue Verzeichnis ist eine Kopie von
        <filename>/calc/trunk</filename>. Dies wird in <xref
        linkend="svn.branchmerge.using.create.dia-1"/> gezeigt.
        <footnote><para>Subversion unterstützt nicht das Kopieren
        zwischen unterschiedlichen Projektarchiven. Wenn Sie mit
        <command>svn copy</command> oder <command>svn move</command>
        URLs verwenden, können Sie nur Objekte innerhalb desselben
        Projektarchivs kopieren oder verschieben.</para></footnote>
        Obwohl es auch möglich ist, einen Zweig zu erzeugen, indem
        <command>svn copy</command> verwendet wird, um ein Verzeichnis
        innerhalb der Arbeitskopie zu duplizieren, wird dieses
        Vorgehen nicht empfohlen. Es kann in der Tat sehr langsam
        sein! Das client-seitige Kopieren eines Verzeichnisses besitzt
        einen linearen Zeitaufwand, da wirklich jede Datei und jedes
        Verzeichnis innerhalb dieser Arbeitskopie auf der lokalen
        Platte dupliziert werden muss. Das Kopieren eines
        Verzeichnisses auf dem Server jedoch besitzt einen konstanten
        Zeitaufwand und ist die Art und Weise, auf die die meisten
        Leute Zweige erstellen. Zusätzlich eröffnet diese
        Vorgehensweise die Möglichkeit, Arbeitskopien mit gemischten
        Revisionen zu kopieren. Das ist nicht von Natur aus
        gefährlich, kann jedoch später beim Zusammenführen zu
        unnötigen Komplikationen führen. Falls Sie sich entscheiden,
        einen Zweig über eine Kopie eines Pfades der Arbeitskopie zu
        erstellen, sollten Sie sicherstellen, dass das
        Quellverzeichnis weder lokale Änderungen noch gemischte
        Revisionen hat.</para>

      <figure id="svn.branchmerge.using.create.dia-1">
<!--
        <title>Repository with new copy</title>
-->
        <title>Projektarchiv mit neuer Kopie</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
<!--
        <title>Cheap Copies</title>
-->
        <title>Billige Kopien</title>

<!--
        <para>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&mdash;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're an experienced Unix user, you'll recognize this as
          the same concept behind a hard link.  As further changes are
          made to files and directories beneath the copied directory,
          Subversion continues to employ this hard link concept where
          it can.  It duplicates data only when it is necessary to
          disambiguate different versions of objects.</para>
-->
        <para>Das Projektarchiv von Subversion ist auf eine besondere
          Weise konstruiert. Wenn Sie ein Verzeichnis kopieren,
          brauchen Sie sich keine Gedanken darüber zu machen, dass das
          Projektarchiv riesengroß wird &ndash; Subversion dupliziert
          tatsächlich überhaupt keine Daten. Stattdessen erzeugt es
          einen neuen Verzeichniseintrag, der auf einen
          <emphasis>bestehenden</emphasis> Baum verweist. Falls Sie
          ein erfahrener Unix-Benutzer sind, werden Sie erkennen, dass
          es sich um dasselbe Konzept handelt wie bei einem Hardlink.
          Während weitere Änderungen an den Dateien und Verzeichnissen
          unterhalb des kopierten Verzeichnisses gemacht werden, hält
          Subversion an diesem Konzept fest wo es geht. Es dupliziert
          Daten nur dann, wenn es nätig ist, verschiedene Versionen
          von Objekten auseinanderzuhalten.</para>

<!--
        <para>This is why you'll often hear Subversion users talk
          about <quote>cheap copies.</quote>  It doesn't matter how
          large the directory is&mdash;it takes a very tiny, constant
          amount of time and space to make a copy of it.  In fact,
          this feature is the basis of how commits work in Subversion:
          each revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's web site and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>
-->
        <para>Deshalb sprechen Subversion-Benutzer oft von
          <quote>billigen Kopien</quote>. Es spielt keine Rolle, wie
          umfangreich das Verzeichnis ist: es bedarf lediglich eines
          kleinen, konstanten Zeitaufwands und wenig Speicherplatzes,
          um eine Kopie zu erstellen. Diese Fähigkeit ist tatsächlich
          die Grundlage für die Umsetzung von Übergaben in Subversion:
          Jede Revision ist eine <quote>billige Kopie</quote> der
          vorhergehenden Revision mit ein paar Dingen, die sich im
          Innern geändert haben. (Um mehr hierüber zu lesen, gehen Sie
          auf die Website von Subversion und lesen Sie in den
          Subversion-Design-Dokumenten über die
          <quote>bubble-up</quote>-Methode.)</para>

<!--
        <para>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and in space.  If you create a branch
          entirely within the repository (by running <userinput>svn copy
          <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput>),
          it's a quick, constant-time operation.  Make branches as
          often as you want.</para>
-->
        <para>Natürlich sind diese internen Mechanismen des Kopierens
          und Teilens vor dem Benutzer verborgen, der lediglich Kopien
          von Bäumen sieht. Die Hauptsache hierbei ist, das Kopien
          billig sind, sowohl was die Zeit als auch den Speicherplatz
          angeht. Wenn Sie einen Zweig komplett im Projektarchiv anlegen
          (durch den Aufruf von <userinput>svn copy
          <replaceable>URL1</replaceable>
          <replaceable>URL2</replaceable></userinput>), handelt es
          sich um eine schnelle Operation mit konstanter
          Zeitdauer. Erstellen Sie Zweige so oft Sie wollen.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
<!--
      <title>Working with Your Branch</title> 
-->
      <title>Arbeiten mit Ihrem Zweig</title> 

<!--
      <para>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>
-->
      <para>Da Sie nun einen Zweig des Projektes erzeugt haben, können
        Sie eine neue Arbeitskopie auschecken, um ihn zu
        benutzen:</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A    my-calc-branch/doc
A    my-calc-branch/src
A    my-calc-branch/doc/INSTALL
A    my-calc-branch/src/real.c
A    my-calc-branch/src/main.c
A    my-calc-branch/src/button.c
A    my-calc-branch/src/integer.c
A    my-calc-branch/Makefile
A    my-calc-branch/README<!--
Checked out revision 341.
-->
Ausgecheckt, Revision 341.
$
</screen>
      </informalexample>

<!--
      <para>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't see them when she
        updates, because her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternative way of
        creating a working copy of a branch.)</para>
-->
      <para>An dieser Arbeitskopie ist nichts besonders; sie spiegelt
        bloß ein anderes Verzeichnis im Projektarchiv wider. Wenn Sie
        Änderungen übertragen, wird sie Sally jedoch nicht sehen, wenn
        sie aktualisiert, da sie eine Arbeitskopie von
        <filename>/calc/trunk</filename> hat. (Stellen Sie sicher,
        dass Sie <xref linkend="svn.branchmerge.switchwc"/> weiter
        unten in diesem Kapitel lesen: Der Befehl <command>svn
        switch</command> ist eine Alternative für die Bereitstellung
        einer Arbeitskopie eines Zweiges.)</para>

<!--
      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>
-->
      <para>Tun wir mal so, als ob eine Woche ins Land geht und die
        folgenden Übergaben stattfinden:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>,
            which creates revision 342.</para>
-->
          <para>Sie machen eine Änderung an
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>,
          die die Revision 342 erzeugt.</para>
        </listitem>

        <listitem>
<!--
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>,
            which creates revision 343.</para>
-->
          <para>Sie machen eine Änderung an
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>,
            die die Revision 343 erzeugt.</para>
        </listitem>

        <listitem>
<!--
          <para>Sally makes a change to
            <filename>/calc/trunk/src/integer.c</filename>, which creates
            revision 344.</para>
-->
          <para>Sally macht eine Änderung an
            <filename>/calc/trunk/src/integer.c</filename>, die die Revision
            344 erzeugt.</para>
        </listitem>
      </itemizedlist>

<!--
      <para>Now two independent lines of development (shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>) are happening on
        <filename>integer.c</filename>.</para>
-->
      <para>Nun hat <filename>integer.c</filename> zwei unabhängige
        Entwicklungslinien (siehe
        <xref linkend="svn.branchmerge.using.work.dia-1"/>).</para>

      <figure id="svn.branchmerge.using.work.dia-1">
<!--
        <title>The branching of one file's history</title>
-->
        <title>Die Verzweigung der Geschichte einer Datei</title>
        <graphic width="4.81in" depth="2.18in" fileref="images/basic-branch.png" />
      </figure>

<!--
      <para>Things get interesting when you look at the history of
        changes made to your copy of <filename>integer.c</filename>:</para>
-->
      <para>Es wird interessant, wenn Sie die Geschichte der
        Änderungen an Ihrer Kopie von <filename>integer.c</filename>
        betrachten:</para>

<!--
      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -v src/integer.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r343 | user | 2013-02-15 14:11:09 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch/src/integer.c

* integer.c:  frozzled the wazjub.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&hellip;
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -v src/integer.c
------------------------------------------------------------------------
r343 | user | 2013-02-15 14:11:09 -0500 (Fr, 15. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/branches/my-calc-branch/src/integer.c

* integer.c:  Wazjub gefrozzelt.
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fr, 15. Feb 2013) | 1 Zeile
Geänderte Pfade:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Privaten Zweig von /calc/trunk angelegt.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Mi, 30. Jan 2013) | 2 Zeilen
Geänderte Pfade:
   M /calc/trunk/src/integer.c

* integer.c:  Einen Docstring geändert.
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sa, 26. Jan 2013) | 2 Zeilen
Geänderte Pfade:
   A /calc/trunk/src/integer.c

* integer.c:  Die fooplus API überarbeitet.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Do, 17. Jan 2013) | 1 Zeile
Geänderte Pfade:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Ursprünglicher Calc Projekt Quelltext-Import von trunk.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look at what happens when Sally runs the same
        command on her copy of the file:</para>
-->

      <para>Beachten Sie, dass Subversion die Geschichte von
        <filename>integer.c</filename> auf Ihrem Zweig über die
        gesamte Zeit zurück verfolgt, und dabei sogar über den Punkt
        hinweg geht, an dem er kopiert wurde. Es zeigt die Erzeugung
        des Zweigs als ein Ereignis in der Geschichte, da
        <filename>integer.c</filename> implizit kopiert wurde, als
        alles andere aus <filename>/calc/trunk/</filename> kopiert
        wurde. Sehen Sie nun, was passiert, wenn Sally den gleichen
        Befehl auf Ihre Arbeitskopie der Datei anwendet:</para>

<!--
      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/integer.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Refactor the bazzle functions.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
&hellip;
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/integer.c
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fr, 15. Feb 2013) | 1 Zeile
Changed paths:
   M /calc/trunk/src/integer.c

Die bazzle Funktionen refaktoriert.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Mi, 30. Jan 2013) | 2 Zeilen
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  Einen Docstring geändert.
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sa, 26. Jan 2013) | 2 Zeilen
Changed paths:
   A /calc/trunk/src/integer.c

* integer.c:  Die fooplus API überarbeitet.

------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Do, 17. Jan 2013) | 1 Zeile
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Ursprünglicher Calc Projekt Quelltext-Import von trunk.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch copy was made in revision
        341, the files used to be the same file.  That's why you and
        Sally both see the changes made between revisions 8 and
        154.</para>
-->
      <para>Sally sieht ihre eigene Änderung in Revision 344, aber
        nicht die Änderung, die Sie in Revision 343 gemacht haben. Was
        Subversion angeht, hatten diese beiden Übergaben Auswirkungen
        auf unterschiedliche Dateien an unterschiedlichen Stellen im
        Projektarchiv. <emphasis>Gleichwohl</emphasis> zeigt
        Subversion, dass die beiden Dateien einen Teil der Geschichte
        gemeinsam haben. Bevor die Kopie des Zweiges in Revision 341
        gemacht wurde, waren die Dateien dieselbe Datei.  Deshalb
        sehen sowohl Sie als auch Sally die Änderungen, die zwischen
        den Revisionen 8 und 154 gemacht wurden.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
<!--
      <title>The Key Concepts Behind Branching</title> 
-->
      <title>Die Schlüsselkonzepte des Verzweigens</title> 

<!--
      <para>You should remember two important lessons
        from this section.  First, Subversion has no internal concept
        of a branch&mdash;it knows only how to make copies.  When you
        copy a directory, the resultant directory is only
        a <quote>branch</quote> because <emphasis>you</emphasis>
        attach that meaning to it.  You may think of the directory
        differently, or treat it differently, but to Subversion it's
        just an ordinary directory that happens to carry some extra
        historical information.</para>
-->
      <para>Sie sollten sich zwei Lektionen aus diesem Abschnitt
        merken. Erstens besitzt Subversion kein internes Konzept für
        einen Zweig &ndash; es weiß lediglich, wie Kopien angelegt
        werden. Wenn Sie ein Verzeichnis kopieren, ist das entstehende
        Verzeichnis bloß ein <quote>Zweig</quote>, weil
        <emphasis>Sie</emphasis> ihm diese Bedeutung geben. Sie mögen
        über das Verzeichnis anders denken oder es anders behandeln,
        doch für Subversion ist es einfach ein gewöhnliches
        Verzeichnis, das nebenbei mit einigen zusätzlichen
        historischen Informationen versehen ist.</para>

<!--
      <para>Second, because of this copy mechanism, Subversion's
        branches exist as <emphasis>normal filesystem
        directories</emphasis> in the repository.  This is different
        from other version control systems, where branches are
        typically defined by adding
        extra-dimensional <quote>labels</quote> to collections of
        files.  The location of your branch directory doesn't matter
        to Subversion.  Most teams follow a convention of putting all
        branches into a <filename>/branches</filename> directory, but
        you're free to invent any policy you wish.</para>
-->
      <para>Zweitens bestehen die Zweige von Subversion, bedingt durch
        den Kopiermechanismus, als <emphasis>normale
        Dateisystemverzeichnisse</emphasis> im Projektarchiv. Das ist ein
        Unterschied zu anderen Versions-Kontroll-Systemen, bei denen
        Zweige typischerweise definiert werden, indem auf einer
        eigenen Ebene den Dateisammlungen <quote>Etiketten</quote> 
        hinzugefügt werden. Der Ort Ihres Zweig-Verzeichnisses spielt
        für Subversion keine Rolle. Die meisten Teams folgen der
        Konvention, alle Zweige in einem Verzeichnis namens
        <filename>/branches</filename> abzulegen, jedoch steht es
        Ihnen frei, eine Vorgehensweise nach Ihren Wünschen zu
        erfinden.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.basicmerging">
<!--
    <title>Basic Merging</title>
-->
    <title>Grundlegendes Zusammenführen</title>

<!--
    <para>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the trunk, or main line of development.</para>
-->
    <para>Nun arbeiten Sie und Sally auf parallelen Zweigen des
      Projektes: Sie arbeiten auf einem privaten Zweig, und Sally
      arbeitet auf dem <firstterm>Stamm</firstterm>
      (<foreignphrase>Trunk</foreignphrase>) oder dem
      Hauptzweig der Entwicklung.</para>

<!--
    <para>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>
-->
    <para>Bei Projekten mit einer großen Zahl von Mitarbeitern
      besitzen die meisten gewöhnlich Arbeitskopien vom Stamm. Sobald
      jemand eine langwierige Änderung machen muss, die wahrscheinlich
      den Stamm stören würde, ist die Vorgehensweise Standard, einen
      Zweig zu erzeugen und die Änderungen bis zum Abschluss der
      Arbeiten nach dorthin zu übertragen.</para>

<!--
    <para>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>
-->
    <para>Die gute Nachricht ist also, dass Sie und Sally sich nicht
      in die Quere kommen. Die schlechte Nachricht ist, dass es sehr
      leicht ist, <emphasis>zu</emphasis> weit auseinander zu treiben.
      Erinnern Sie sich, dass eins der Probleme bei der Strategie
      <quote>sich in ein Loch verkriechen</quote> darin bestand, dass
      es zu dem Zeitpunkt, an dem Sie mit dem Zweig fertig sind, fast
      unmöglich sein kann, Ihre Änderungen ohne eine riesige Zahl an
      Konflikten auf den Stamm zurückzuführen.</para>

<!--
    <para>
      <indexterm>
        <primary>merging</primary>
      </indexterm>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <firstterm>merging</firstterm>, and
      it is performed using various invocations of the <command>svn
      merge</command> subcommand.</para>
-->
    <para>
      <indexterm>
        <primary>Merging</primary>
      </indexterm>
      <indexterm>
        <primary>Zusammenführen</primary>
        <see>Merging</see>
      </indexterm>Stattdessen könnten Sie und Sally fortfahren,
      während der Arbeit Änderungen gemeinsam zu verwenden. Es liegt
      an Ihnen, zu entscheiden, welche Änderungen teilenswert sind;
      Subversion bietet Ihnen die Fähigkeit, Änderungen selektiv
      zwischen Zweigen zu <quote>kopieren</quote>. Und wenn Sie mit
      Ihrem Zweig vollständig fertig sind, kann die gesamte Menge
      Ihrer Änderungen vom Zweig auf den Stamm zurück kopiert werden.
      In der Terminologie von Subversion heißt der allgemeine Vorgang,
      Änderungen von einem Zweig auf einen anderen zu übertragen
      <firstterm>Zusammenführung</firstterm>
      (<foreignphrase>Merge</foreignphrase>) und wird durch
      verschiedene Aufrufe des Unterbefehls <command>svn
      merge</command> durchgeführt.</para>

<!--
    <para>In the examples that follow, we're assuming that both your
      Subversion client and server are running Subversion 1.8 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won't track changes
      automatically, forcing you to use painful manual methods to
      achieve similar results.  That is, you'll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/> later
      in this chapter), and take special care to keep track of what's
      already been merged and what hasn't.  For this reason,
      we <emphasis>strongly</emphasis> recommend that you make sure your
      client and server are at least at version 1.5.</para>
-->
    <para>In den folgenden Beispielen gehen wir davon aus, dass sowohl
      auf Ihrem Subversion-Client als auch auf dem Server Subversion
      1.8 (oder neuer) läuft. Falls einer von beiden älter als Version
      1.5 ist, wird es komplizierter: Das System wird Änderungen nicht
      automatisch mitverfolgen, so dass Sie schmerzhafte manuelle
      Methoden anwenden müssen, um ähnliche Resultate zu
      erzielen. Dass heißt, dass Sie stets die detaillierte Syntax
      beim Zusammenführen verwenden müssen, um bestimmte
      Revisionsintervalle zu übertragen (siehe
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/> weiter
      unten in diesem Kapitel), und besonders sorgfältig verfolgen
      müssen, was bereits zusammengeführt ist und was nicht. Aus
      diesem Grund empfehlen wir Ihnen <emphasis>dringend</emphasis>,
      sicherzustellen, dass Ihr Client und Server mindestens die
      Version 1.5 haben.</para>

    <sidebar id="svn.branchmerge.basicmerging.mergetracking">
<!--
      <title>Merge Tracking</title>
      <para>
        <indexterm>
          <primary>merge tracking</primary>
        </indexterm>Subversion 1.5 introduced the
        <firstterm>merge tracking</firstterm> feature to Subversion.
        Prior to this feature keeping track of merges required cumbersome
        manual procedures or the use of external tools. Subsequent
        releases of Subversion introduced many enhancements and bug
        fixes to merge tracking, which is why we recommend using the
        most recent versions for both your server and client.  Keep in
        mind that even if your server is running 1.5-1.7, you can still
        use a 1.8 client.  This is particularly important with regard to merge
        tracking, because the overwhelming majority of fixes and enhancements
        to it are on the client side.</para>
-->
      <title>Verfolgung von Zusammenführungen</title>
      <para>
        <indexterm>
          <primary>Merge-Tracking</primary>
        </indexterm>
        <indexterm>
          <primary>Verfolgung von Zusammenführungen</primary>
          <see>Merge-Tracking</see>
        </indexterm>Subversion 1.5 führte die Funktionalität der
        <firstterm>Verfolgung von Zusammenführungen</firstterm>
        (<foreignphrase>merge tracking</foreignphrase>) in Subversion
        ein. Davor erforderte das Verfolgen von Zusammenführungen
        unhandliche manuelle Eingriffe oder die Verwendung externer
        Werkzeuge. Nachfolgende Ausgaben von Subversion führten viele
        Verbesserungen und Fehlerbehebungen für das Merge-Tracking
        ein, weshalb wir empfehlen, die neuesten Versionen sowohl auf
        Ihrem Server als auch auf dem Client einzusetzen. Vergessen
        Sie nicht, dass Sie immer noch einen 1.8 Client verwenden
        können, auch wenn auf Ihrem Server 1.5-1.7 laufen. Das ist
        besonders wichtig hinsichtlich des Merge-Trackings, da die
        überwältigende Mehrheit der Fehlerbehebungen und
        Verbesserungen auf der Client-Seite statt gefunden hat.</para>
    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.changesets">
<!--
      <title>Changesets</title>
-->
      <title>Änderungsmengen</title>

<!--
      <para>
        <indexterm>
          <primary>changesets</primary>
        </indexterm>Before we proceed further, we should warn you that there's
        a lot of discussion of <quote>changes</quote> in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms <quote>change</quote>
        and <quote>changeset</quote> interchangeably, and we should
        clarify what Subversion understands as
        a <firstterm>changeset</firstterm>.</para>
-->
      <para>
        <indexterm>
          <primary>Changesets</primary>
        </indexterm>
        <indexterm>
          <primary>Änderungsmengen</primary>
          <see>Changesets</see>
        </indexterm>Bevor wir weitermachen, sollten wir Sie warnen, dass Sie
        auf den kommenden Seiten viele Erörterungen zum Thema
        <quote>Änderungen</quote> erwarten. Viele mit
        Versions-Kontroll-Systemen erfahrene Leute benutzen die Begriffe
        <quote>Änderung</quote> und <quote>Änderungsmenge</quote>
        (<foreignphrase>Changeset</foreignphrase>) austauschbar, so
        dass wir klären sollten, was Subversion unter einer
        <firstterm>Änderungsmenge</firstterm> versteht.</para>

<!--
      <para>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let's say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</para>
-->
      <para>Jeder scheint eine etwas unterschiedliche Definition für
        den Begriff Änderungsmenge zu haben oder zumindest eine
        unterschiedliche Erwartung darüber, was es für ein
        Versions-Kontroll-System bedeutet, so etwas zu besitzen. Für
        unsere Zwecke reicht es aus, zu sagen, dass eine
        Änderungsmenge lediglich eine Sammlung von Änderungen mit
        einem eindeutigen Namen ist. Die Änderungen können aus der
        Bearbeitung an Textdateien, Modifizierungen an der
        Baumstruktur oder Justierungen an Metadaten bestehen. In
        einfachen Worten ist eine Änderungsmenge einfach ein Patch mit
        einem Namen, auf den Sie sich beziehen können.</para>

<!--
      <para>In Subversion, a global revision
        number <replaceable>N</replaceable> names a tree in the
        repository: it's the way the repository looked after the
        <replaceable>N</replaceable>th commit.  It's also the name of
        an implicit changeset: if you compare
        tree <replaceable>N</replaceable> with
        tree <replaceable>N</replaceable>-1, you can derive the exact
        patch that was committed.  For this reason, it's easy to think
        of revision <replaceable>N</replaceable> as not just a tree,
        but a changeset as well.  If you use an issue tracker to
        manage bugs, you can use the revision numbers to refer to
        particular patches that fix bugs&mdash;for example,
        <quote>this issue was fixed by r9238.</quote> Somebody
        can then run <userinput>svn log -r 9238</userinput> to read about
        the exact changeset that fixed the bug, and run
        <userinput>svn diff -c 9238</userinput> to see the patch itself.
        And (as you'll see shortly)
        Subversion's <command>svn merge</command> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <userinput>-c 9238</userinput>
        to <command>svn merge</command> would merge changeset r9238
        into your working copy.</para>
-->
      <para>In Subversion bezeichnet eine globale Revisionsnummer
        <replaceable>N</replaceable> einen Baum im Projektarchiv: Sie
        beschreibt das Aussehen des Projektarchivs nach der
        <replaceable>N</replaceable>-ten Übertragung. Sie ist auch der
        Name einer impliziten Änderungsmenge: Wenn Sie den Baum
        <replaceable>N</replaceable> mit dem Baum
        <replaceable>N</replaceable>-1 vergleichen, können Sie genau
        den Patch ableiten, der übertragen wurde. Daher ist es einfach,
        sich Revision <replaceable>N</replaceable> nicht nur als Baum
        sondern auch als Änderungsmenge vorzustellen. Falls Sie ein
        Fehlerverwaltungssystem verwenden, können Sie die
        Revisionsnummern benutzen, um auf bestimmte Patches zu
        verweisen, die Fehler beheben &ndash; zum Beispiel:
        <quote>Dieser Fehler wurde durch r9238 behoben</quote>. Dann
        kann jemand <userinput>svn log -r 9238</userinput> aufrufen,
        um den Protokolleintrag zu genau der Änderungsmenge zu lesen,
        die den Fehler behoben hat, und sich mit <userinput>svn diff
        -c 9238</userinput> den eigentlichen Patch ansehen. Und (wie
        Sie bald sehen werden) auch der Subversion Befehl <command>svn
        merge</command> kann Revisionsnummern verwenden. Sie können
        bestimmte Änderungsmengen von einem Zweig mit einem anderen
        zusammenführen, indem sie in den Argumenten zum entsprechenden
        Kommando benannt werden: Die Übergabe von <userinput>-c
        9238</userinput> an <command>svn merge</command> würde das
        Änderungsmenge r9238 mit Ihrer Arbeitskopie
        zusammenführen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync">
<!--
      <title>Keeping a Branch in Sync</title>
-->
      <title>Einen Zweig synchron halten</title>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>sync merges</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>merge</tertiary>
        </indexterm>Continuing with our running example, let's suppose
        that a week has passed since you started working on your
        private branch.  Your new feature isn't finished yet, but at
        the same time you know that other people on your team continue
        to make important changes in the
        project's <filename>/trunk</filename>.  It's in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  This is done
        by performing an <firstterm>automatic sync merge</firstterm>&mdash;a
        merge operation designed to bring your branch up to date with
        any changes made to its ancestral parent branch since your
        branch was created.
        <indexterm>
          <primary>merging</primary>
          <secondary>automatic</secondary>
        </indexterm> An <quote>automatic</quote> merge is simply
        one in which you provide the bare minimum of information required
        for a merge (i.e. a single merge source and a working copy target)
        and let Subversion determine which changes need merging&mdash;no
        changesets are passed to <command>svn merge</command> via the
        <option>-r</option> or <option>-c</option> options in an automatic
        merge.</para>
-->
      <para>
        <indexterm>
          <primary>Merging</primary>
          <secondary>Synchronisierungs-Merge</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>Unterbefehle</secondary>
          <tertiary>merge</tertiary>
        </indexterm>Machen wir mit unserem Beispiel weiter und nehmen
        an, dass eine Woche vergangen ist seitdem Sie mit der Arbeit
        auf Ihrem privaten Zweig begonnen haben. Ihre Arbeit ist noch
        nicht beendet, jedoch wissen Sie, dass gleichzeitig andere
        Leute in Ihrem Team weiterhin wichtige Änderungen in
        <filename>/trunk</filename> des Projektes machen. Es ist in
        Ihrem Interesse, diese Änderungen in Ihren Zweig zu
        übernehmen, um sicherzustellen, dass sie sich gut mit Ihren
        Änderungen vertragen. Das wird durch einen
        <firstterm>Synchronisierungs-Merge</firstterm> erreicht
        &ndash; ein <foreignphrase>Merge</foreignphrase> zu dem Zweck,
        Ihren Zweig mit Änderungen zu aktualisieren, die seit der
        Erstellung Ihres Zweigs auf dem Ursprungszweig vorgenommen
        wurden.
        <indexterm>
          <primary>Merging</primary>
          <secondary>automatisch</secondary>
        </indexterm> Ein <quote>automatischer</quote> Merge ist ganz
        einfach einer, bei dem Sie das absolute Minimum an benötigten
        Informationen für einen Merge angeben (d.h., eine einzelne
        Merge-Quelle und ein Arbeitskopie-Ziel) und Subversion
        entscheiden lassen, welche Änderungen zusammengeführt werden
        müssen &ndash; bei einem automatischen Merge werden keine
        Änderungsmengen mit <option>-r</option> oder
        <option>-c</option> an <command>svn merge</command>
        übergeben.</para>
<!--
      <tip>
        <para>Frequently keeping your branch in sync with the main
          development line helps prevent <quote>surprise</quote>
          conflicts when the time comes for you to fold your changes
          back into the trunk.</para>
      </tip>
-->
      <tip>
        <para>Ihren Zweig regelmäßig mit der Hauptentwicklungslinie zu
          synchronisieren hilft, <quote>überraschende</quote>
          Konflikte zu vermeiden, wenn es an der Zeit ist, Ihre
          Änderungen zurück auf den Stamm zu bringen.</para>
      </tip>

<!--
      <para>Subversion is aware of the history of your branch and
        knows when it split away from the trunk.  To perform a sync
        merge, first make sure your working copy of the branch
        is <quote>clean</quote>&mdash;that it has no local
        modifications reported by <command>svn status</command>.  Then
        simply run:</para>
-->
      <para>Subversion kennt die Geschichte Ihres Zweigs und weiß,
        wann Sie ihn vom Stamm abgezweigt haben. Um eine
        Synchronisierungs-Zusammenführung zu machen, sollten Sie
        zunächst sicherstellen, dass die Arbeitskopie des Zweigs
        <quote>sauber</quote> ist &ndash; dass sie keine lokalen
        Änderungen hat, die durch <command>svn status</command>
        angezeigt werden. Dann rufen Sie einfach die folgenden Befehle
        auf:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn merge ^/calc/trunk <!--
- - Merging r341 through r351 into '.':
-->
-- Zusammenführen von r341 bis r351 in ».«:
U    doc/INSTALL
U    src/real.c
U    src/button.c<!--
- - Recording mergeinfo for merge of r341 through r351 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r341 bis r351 in ».«:
 U   .
$
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>properties</primary>
          <secondary>svn:mergeinfo</secondary>
        </indexterm>This basic syntax&mdash;<userinput>svn merge
        <replaceable>URL</replaceable></userinput>&mdash;tells
        Subversion to merge all changes which have not been previously
        merged from the URL to the current working directory (which is
        typically the root of your working copy).  Notice that we're
        using the caret (<literal>^</literal>)
        syntax<footnote><para>This was introduced in svn
        1.6.</para></footnote> to avoid having to type out the
        entire <filename>/trunk</filename> URL.  Also note
        the <quote>Recording mergeinfo for merge&hellip;</quote>
        notification.  This tells you that the merge is updating
        the <literal>svn:mergeinfo</literal> property. We'll discuss
        both this property and these notifications later in this
        chapter, in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>
-->
      <para>
        <indexterm>
          <primary>Eigenschaften</primary>
          <secondary>svn:mergeinfo</secondary>
        </indexterm>Diese einfache Syntax &ndash; <userinput>svn merge
        <replaceable>URL</replaceable></userinput> &ndash; fordert
        Subversion auf, alle Änderungen von dem URL, die vorher noch
        nicht zusammengeführt wurden, mit dem aktuellen
        Arbeitsverzeichnis (welches typischerweise das
        Wurzelverzeichnis Ihrer Arbeitskopie ist) zusammenzuführen.
        Beachten Sie auch, dass wir die Syntax  mit dem Zirkumflex
        (<literal>^</literal>) verwenden<footnote><para>Diese wurde in
        svn 1.6 eingeführt,</para></footnote>, um nicht den
        vollständigen <filename>/trunk</filename>-URL tippen zu
        müssen. Beachten Sie ebenfalls die Mitteilung
        <quote>Aufzeichnung der Informationen für
        Zusammenführung&hellip;</quote>. Das teilt Ihnen mit, dass
        durch den <foreignphrase>Merge</foreignphrase> die Eigenschaft
        <literal>svn:mergeinfo</literal> aktualisiert wird. Wir werden
        sowohl diese Eigenschaft als auch diese Mitteilungen später in
        diesem Kapitel besprechen, und zwar in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>

<!--
      <tip>
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
          </indexterm>In this book and elsewhere (Subversion mailing
          lists, articles on merge tracking, etc.) you will frequently
          come across the term <firstterm>mergeinfo</firstterm>. This
          is simply shorthand for the <literal>svn:mergeinfo</literal>
          property.</para>
      </tip>
-->
      <tip>
        <para>
          <indexterm>
            <primary>Mergeinfo</primary>
          </indexterm>In diesem Buch und anderswo (Subversion
          Mailing-Listen, Artikeln über Merge-Tracking usw.) wird
          Ihnen oft der Begriff <firstterm>Mergeinfo</firstterm>
          begegnen.  Das ist einfach die Abkürzung für die Eigenschaft
          <literal>svn:mergeinfo</literal>.</para>
      </tip>

      <sidebar>
<!--
        <title>Keeping a Branch in Sync Without Merge Tracking</title>
-->
        <title>Einen Zweig ohne Merge-Tracking synchron halten</title>

<!--
        <para>You may not always be able to use Subversion's merge
          tracking feature, perhaps because your server is running
          Subversion 1.4 or earlier or you must use an older client.
          In such a scenario, you can of course still perform merges,
          but Subversion will need you to manually do many of the historical
          calculations that it automatically does on your behalf when the
          merge tracking feature is available.</para>
-->
        <para>Es kann sein, dass Sie nicht immer das Merge-Tracking
          von Subversion verwenden können, vielleicht, weil auf Ihrem
          Server Subversion 1.4 oder älter läuft oder Sie einen
          älteren Client verwenden. In einem solchen Szenario, können
          Sie selbstverständlich immer noch zusammenführen, doch
          erwartet Subversion von Ihnen, viele der historischen
          Berechnungen selbst manuell vorzunehmen, die Ihnen das
          Merge-Tracking abnehmen würde, wenn es verfügbar
          wäre.</para>

<!--
        <para>To replicate the most recent trunk changes you need to
          perform sync merges the <quote>old-fashioned</quote>
          way&mdash;by specifying ranges of revisions you wish to
          merge.</para>
-->
        <para>Um die letzten Änderungen vom Stamm zu replizieren,
          müssen Sie die Synchronisierungs-Zusammenführungen auf die
          <quote>althergebrachte</quote> Art machen &ndash; indem Sie
          Revisionsintervalle angeben, die Sie zusammenführen
          möchten.</para>

<!--
        <para>Using the ongoing example, you know that you branched
          <filename>/calc/trunk</filename> to 
          <filename>/calc/branches/my-calc-branch</filename> in revision
          341:</para>
-->
        <para>Im laufenden Beispiel wissen Sie, dass Sie in Revision
          341 <filename>/calc/trunk</filename> nach
          <filename>/calc/branches/my-calc-branch</filename>
          abgezweigt haben:</para>

        <informalexample>
          <screen>
$ svn log -v -r341
------------------------------------------------------------------------ <!--
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)
-->
r341 | user | 2013-02-15 07:41:25 -0500 (Fr, 15. Feb 2013) | 1 Zeile
Geänderte Pfade:
   A /calc/branches/my-calc-branch (von /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
</screen>
        </informalexample>

<!--
        <para>When you are ready to synchronize your branch with the
          ongoing changes from trunk, you specify the starting
          revision as the revision of <filename>/calc/trunk</filename>
          which the branch was copied from and the ending revision as
          the youngest change on <filename>/calc/trunk</filename>.  You
          can find the latter with the <command>svn log</command> command
          with the <option>-r</option> set to <literal>HEAD</literal>:</para>
-->
        <para>Wenn Sie soweit sind, Ihren Zweig mit den fortlaufenden
          Änderungen vom Stamm zu synchronisieren, geben Sie die
          Start-Revision als die Revision von
          <filename>/calc/trunk</filename> an, von wo aus Sie den
          Zweig kopiert haben, und als End-Revision die letzte
          Änderung auf <filename>/calc/trunk</filename>. Letztere
          können Sie finden, indem Sie den Befehl <command>svn
          log</command> mit der Option <option>-r</option> und dem
          Optionsargument <literal>HEAD</literal> aufrufen:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------<!--
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013)-->
r351 | sally | 2013-02-16 08:04:22 -0500 (Sa, 16. Feb 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r340:351
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
</screen>
        </informalexample>

<!--
        <para>After any conflicts have been resolved, you can commit
          the merged changes to your branch.  Now, to avoid
          accidentally trying to merge these same changes into your
          branch again in the future, you'll need to record the fact
          that you've already merged them.  But where should that
          record be kept?  One of the simplest places to record this
          information is in the log message for the commit of the
          merge:</para>
-->
        <para>Nach dem Auflösen etwaiger Konflikte können Sie die
          zusammengeführten Änderungen auf Ihren Zweig übertragen. Um
          nun zu vermeiden, dass diese Änderungen künftig erneut mit
          Ihrem Zweig zusammengeführt werden, müssen Sie den bereits
          erfolgten Merge vermerken. Aber wo? Einer der
          einfachsten Orte, um diese Information unterzubringen, ist
          die Protokollnachricht für die Übergabe nach der
          Zusammenführung:</para>

        <informalexample>
          <screen>
$ svn ci -m "Sync the my-calc-branch with ^/calc/trunk through r351."
&hellip;
</screen>
        </informalexample>

<!--
        <para>The next time you sync
          <filename>/calc/branches/my-calc-branch</filename>  with
          <filename>/calc/trunk</filename> you repeat this process, except
          that the starting revision is the <emphasis>youngest</emphasis>
          revision that's already been merged in from the trunk.
          If you've been keeping good records of your merges in the
          commit log messages, you should be able to determine what
          that youngest revision was by reading the revision logs
          associated with your branch.  Once you know your starting
          revision, you can perform another sync merge:</para>
-->
        <para>Beim nächsten Mal, wenn Sie
          <filename>/calc/branches/my-calc-branch</filename> mit
          <filename>/calc/trunk</filename> synchronisieren,
          wiederholen Sie diesen Prozess, mit der Ausnahme, dass die
          Start-Revision die <emphasis>jüngste</emphasis> bereits vom
          Stamm zusammengeführte Revision ist. Wenn Sie in Ihren
          Protokollnachrichten darüber gut Buch geführt haben, sollten
          Sie in der Lage sein, festzustellen, welches diese jüngste
          Revision war, indem Sie die Protokollnachrichten Ihres
          Zweiges durchlesen. Sobald Sie Ihre Start-Revision kennen,
          können Sie einen weiteren Synchronisierungs-Merge
          machen:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------<!--
r959 | sally | 2013-03-5 7:30:21 -0500 (Tue, 05 Mar 2013)-->
r959 | sally | 2013-03-5 7:30:21 -0500 (Di, 05. Mär 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r351:959
&hellip;
</screen>
        </informalexample>

      </sidebar>

<!--
      <para>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</para>
-->
      <para>Nach dem Ausführen des vorangegangenen Beispiels enthält
        Ihre Arbeitskopie nun neue lokale Änderungen, die
        Nachbildungen all der Änderungen auf dem Stamm seit der
        Erstellung Ihres Zweiges sind:</para>

      <informalexample>
        <screen>
$ svn status
 M      .
M       Makefile
M       doc/INSTALL
M       src/button.c
M       src/real.c
</screen>
      </informalexample>

<!--
      <para>At this point, the wise thing to do is look at the changes
        carefully with <command>svn diff</command>, and then build and
        test your branch.  Notice that the current working directory
        (<quote><filename>.</filename></quote>) has also been
        modified; <command>svn diff</command> shows that
        its <literal>svn:mergeinfo</literal> property has been created.
  </para>
-->
      <para>Zu diesem Zeitpunkt ist es weise, sich die Änderungen
        mithilfe von <command>svn diff</command> sorgfältig anzusehen,
        und anschließend die Software von Ihrem Zweig zu bauen und zu
        testen. Beachten Sie, dass auch das aktuelle
        Arbeitsverzeichnis (<quote><filename>.</filename></quote>)
        verändert wurde; <command>svn diff</command> zeigt an, dass
        seine Eigenschaft <literal>svn:mergeinfo</literal> angelegt
        wurde.</para>

      <informalexample>
<!--
        <screen>
$ svn diff - -depth empty .
Index: .
===================================================================
- - .   (revision 351)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /calc/trunk:r341-351
</screen>
-->
        <screen>
$ svn diff --depth empty .
Index: .
===================================================================
--- .   (Revision 351)
+++ .   (Arbeitskopie)

Eigenschaftsänderungen: .
___________________________________________________________________
Hinzugefügt: svn:mergeinfo
   Zusammengeführt /calc/trunk:r341-351
</screen>
      </informalexample>

<!--
      <para>
        This new property is important merge-related metadata
        that you should <emphasis>not</emphasis> touch, since it is
        needed by future <command>svn merge</command> commands.
        (We'll learn more about this metadata later in the
        chapter.)</para>
-->
      <para>Diese neue Eigenschaft ist ein wichtiges Metadatum in
        Zusammenhang mit Zusammenführungen, das Sie
        <emphasis>nicht</emphasis> anfassen sollten, da es von
        künftigen <command>svn merge</command>-Befehlen benötigt wird.
        (Wir werden später in diesem Kapitel mehr über diese Metadaten
        erfahren.)</para>

<!--
      <para>After performing the merge, you might also need to resolve
        some conflicts&mdash;just as you do with <command>svn
        update</command>&mdash;or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <emphasis>syntactic</emphasis> conflicts doesn't mean there
        aren't any <emphasis>semantic</emphasis> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <userinput>svn revert . -R</userinput> (which
        will undo all local modifications) and starting a
        long <quote>what's going on?</quote> discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</para>
-->
      <para>Nach der Übernahme kann es möglich sein, dass Sie noch
        einige Konflikte auflösen müssen &ndash; wie bei <command>svn
        update</command> &ndash; oder möglicherweise noch einige kleinere
        Bearbeitungen durchzuführen haben, damit alles wieder
        funktioniert. (Denken Sie daran, dass die Abwesenheit
        <emphasis>syntaktischer</emphasis> Konflikte nicht bedeutet,
        dass keine <emphasis>semantischen</emphasis> Konflikte
        vorhanden sind!) Falls ernsthafte Probleme auftauchen, können
        Sie jederzeit die lokalen Änderungen mit <userinput>svn revert
        . -R</userinput> wieder rückgängig machen und eine lange
        <quote>was geht hier eigentlich vor</quote>-Unterredung mit
        Ihren Mitarbeitern führen. Falls jedoch alles gut aussieht,
        können Sie die Änderungen zum Projektarchiv übertragen:</para>

      <informalexample>
        <screen>
<!--
$ svn commit -m "Sync latest trunk changes to my-calc-branch."
Sending        .
Sending        Makefile
Sending        doc/INSTALL
Sending        src/button.c
Sending        src/real.c
Transmitting file data ....
Committed revision 352.
-->
$ svn commit -m "Die letzten Änderungen von trunk mit my-calc-branch synchronisiert."
Sende              .
Sende              Makefile
Sende              doc/INSTALL
Sende              src/button.c
Sende              src/real.c
Übertrage Daten ..
Revision 352 übertragen.
</screen>
      </informalexample>

<!--
      <para>At this point, your private branch is now <quote>in
        sync</quote> with the trunk, so you can rest easier knowing
        that as you continue to work in isolation, you're not drifting
        too far away from what everyone else is doing.</para>
-->
      <para>An dieser Stelle ist Ihr Zweig <quote>synchron</quote> mit
        dem Stamm, und Sie können sich ruhig zurücklehnen in der
        Gewissheit, dass Sie sich nicht zu weit von der Arbeit aller
        anderen entfernen, während Sie isoliert weiterarbeiten.</para>

      <sidebar>
<!--
        <title>Why Not Use Patches Instead?</title>
-->
        <title>Warum stattdessen keine Patches verwenden?</title>

<!--
        <para>A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use <command>svn patch</command> or the
          operating system's <command>patch</command> command to
          accomplish the same job?  For example:</para>
-->
        <para>Eine Frage könnte Ihnen durch den Kopf gehen, besonders,
          falls Sie ein Unix-Benutzer sind: Warum soll ich überhaupt
          <command>svn merge</command> verwenden? Warum kann ich
          dieselbe Aufgabe nicht mit <command>svn patch</command> oder
          dem Betriebssystembefehl <command>patch</command> lösen? Zum
          Beispiel:</para>

        <informalexample>
          <screen>
$ cd my-calc-branch

$ svn diff -r 341:351 ^/calc/trunk > my-patch-file

$ svn patch my-patch-file
U         doc/INSTALL
U         src/real.c
U         src/button.c
U         Makefile
</screen>
        </informalexample>

<!--
        <para>In this particular example, there really isn't much
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's able to tweak file contents only.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <command>patch</command> program
          notice changes to properties.  If Sally's change had,
          say, added a new directory, the output of <command>svn
          diff</command> wouldn't have mentioned it at
          all.  <command>svn diff</command> outputs only the limited
          patch format, so there are some ideas it simply can't
          express.  Even Subversion's own <command>svn patch</command>
          subcommand, while more flexible than the <command>patch</command>
          program, still has similar limitations.</para>
-->
        <para>Bei diesem speziellen Beispiel gibt es wahrhaftig keinen
          großen Unterschied. Allerdings hat <command>svn
          merge</command> besondere Fähigkeiten, die über die des
          Programms <command>patch</command> hinaus gehen. Das von
          <command>patch</command> verwendete Dateiformat ist sehr
          eingeschränkt; es kann lediglich Dateiinhalte verändern. Es
          besteht keine Möglichkeit, Änderungen an
          <emphasis>Bäumen</emphasis>, etwa das Hinzufügen, Entfernen
          oder Umbenennen von Dateien und Verzeichnissen
          abzubilden. Des Weiteren bemerkt das Programm
          <command>patch</command> keine Änderungen an
          Eigenschaften. Falls Sallys Änderung etwa ein neues
          Verzeichnis hinzugefügt hätte, wäre es in der Ausgabe von
          <command>svn diff</command> überhaupt nicht erwähnt worden.
          <command>svn diff</command> gibt nur das eingeschränkte
          patch-Format aus, so dass es einige der Konzepte gar nicht
          wiedergeben kann. Selbst der eigene Subversion-Unterbefehl
          <command>svn patch</command>hat, obwohl flexibler als das
          Programm <command>patch</command>, ähnliche
          Einschränkungen.</para>

<!--
        <para>The <command>svn merge</command> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven't been merged
          yet.</para>
-->
        <para>Der Befehl <command>svn merge</command> jedoch kann
          Änderungen an der Baumstruktur und an Eigenschaften
          erfassen, indem sie direkt auf Ihre Arbeitskopie angewendet
          werden. Noch wichtiger ist, dass dieser Befehl alle
          Änderungen festhält, die auf Ihren Zweig angewendet wurden,
          so dass Subversion genau Bescheid weiß, welche Änderungen an
          welcher Stelle vorhanden sind (siehe <xref
          linkend="svn.branchmerge.basicmerging.mergeinfo"/>).  Dies
          ist eine kritische Fähigkeit, die die Verwaltung von Zweigen
          brauchbar macht; ohne sie müssten Benutzer sich manuelle
          Aufzeichnungen darüber machen, welche Änderungsmengen
          zusammengeführt worden sind und welche noch nicht.</para>

      </sidebar>

<!--
      <para>Suppose that another week has passed.  You've committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you want to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</para>
-->
      <para>Nehmen wir an, noch eine Woche sei ins Land gegangen. Sie
        haben weitere Änderungen an Ihren Zweig übertragen, und Ihre
        Kollegen haben damit weitergemacht, den Stamm zu
        verbessern. Nun möchten Sie mal wieder die letzten Änderungen
        vom Stamm mit Ihrem Zweig abgleichen, damit Sie wieder
        synchron sind. Starten Sie einfach noch einmal den
        <command>svn merge</command>-Befehl!</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk <!--
svn: E195020: Cannot merge into mixed-revision working copy [352:357]; try up\
dating first
-->
svn: E195020: Kann nicht in eine Arbeitskopie mit verschiedenen Revisionen\
zusammenführen [352:357], versuchen Sie erst zu aktualisieren
$
</screen>
      </informalexample>

<!--
      <para>Well that was unexpected!  After making changes to your
        branch over the past week you now find yourself with a working
        copy that contains a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs"/>).  With Subversion
        1.7 and later, the <command>svn merge</command>
        subcommand disables merges into mixed-revision working copies
        by default.  Without going into too much detail, this is
        because of limitations in the way merges are tracked by the
        <literal>svn:mergeinfo</literal> property (see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details).  These limitations mean that merges into
        mixed-revision working copies can result in unexpected text
        and tree conflicts.<footnote><para>The <command>svn
        merge</command> subcommand
        option <option>- -allow-mixed-revisions</option> allows you to
        override this prohibition, but you should only do so if you
        understand the ramifications and have a good reason for
        it.</para></footnote>  We don't want any needless conflicts, so
        we update the working copy and then reattempt the
        merge.</para>
-->
      <para>Oh, das war jetzt aber unerwartet! Nachdem Sie während der
        letzten Woche Änderungen auf Ihrem Zweig gemacht haben, sehen
        Sie sich nun einer Arbeitskopie gegenüber, die eine Mischung
        von Revisionen enthält (siehe
        <xref linkend="svn.basic.in-action.mixedrevs"/>). Mit
        Subversion 1.7 und neuer verhindert der Unterbefehl
        <command>svn merge</command> standardmäßig die Zusammenführung
        in Arbeitskopien mit gemischten Revisionen. Ohne auf
        Einzelheiten einzugehen, liegt das an Einschränkungen der Art
        und Weise, wie Merges durch die Eigenschaft
        <literal>svn:mergeinfo</literal> verfolgt werden (für Details,
        siehe <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
        Diese Einschränkungen bedeuten, dass Merges in Arbeitskopien
        aus gemischten Revisionen unerwartete Text- und Baumkonflikte
        hervorrufen können.<footnote><para>Die Option
        <option>--allow-mixed-revisions</option> des Unterbefehls
        <command>svn merge</command> erlaubt Ihnen, diese
        Einschränkung zu umgehen, jedoch sollten Sie das nur dann
        machen, wenn Sie die Auswirkungen verstehen und einen guten
        Grund dafür haben.</para></footnote> Wir möchten keine
        unnötigen Konflikte, also aktualisieren wir die Arbeitskopie
        und versuchen erneut die Zusammenführung.</para>

      <informalexample>
        <screen>
$ svn up<!--
Updating '.':
At revision 361.-->
Aktualisiere ».«:
Revision 361.

$ svn merge ^/calc/trunk<!--
- - Merging r352 through r361 into '.':
-->
--- Zusammenführen von r352 bis r361 in ».«:
U    src/real.c
U    src/main.c<!--
- - Recording mergeinfo for merge of r352 through r361 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r352 bis r361 in ».«:
 U   .
</screen>
      </informalexample>

<!--
      <para>Subversion knows which trunk changes you previously
        replicated to your branch, so it carefully replicates only
        those changes you don't yet have.  And once again, you build,
        test, and <command>svn commit</command> the local modifications
        to your branch.</para>
-->
      <para>Subversion weiß, welche Änderungen Sie vorher mit Ihrem
        Zweig abgeglichen haben, so dass es sorgfältig nur die
        Änderungen berücksichtigt, die Sie noch nicht haben. Einmal
        mehr müssen Sie bauen, testen und die lokalen Änderungen an
        Ihren Zweig mit <command>svn commit</command>
        übertragen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync.subtree">
<!--
      <title>Subtree Merges and Subtree Mergeinfo</title>
-->
      <title>Teilbaum-Merges und -Mergeinfo</title>
<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>subtree merge</secondary>
        </indexterm>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>subtree mergeinfo</secondary>
        </indexterm>In most of the examples in this chapter the
        merge target is the root directory of a branch (see
        <xref linkend="svn.branchmerge.whatis"/>). While this is a
        best practice, you may occasionally need to merge directly
        to some child of the branch root. This type of merge is
        called a <firstterm>subtree merge</firstterm> and the
        mergeinfo recorded to describe it is called
        <firstterm>subtree mergeinfo</firstterm>. There is nothing
        special about subtree merges or subtree mergeinfo.  In fact
        there is really only one important point to keep in mind
        about these concepts: the complete record of merges to a
        branch may not be contained solely in the mergeinfo on the
        branch root.  You may have to consider subtree mergeinfo
        to get a full accounting.  Fortunately Subversion does this
        for you and rarely will you need to concern yourself with
        it.  A brief example will help explain:</para>
-->
      <para>
        <indexterm>
          <primary>Merging</primary>
          <secondary>Teilbaum-Merge</secondary>
        </indexterm>
        <indexterm>
          <primary>Merging</primary>
          <secondary>Teilbaum-Mergeinfo</secondary>
        </indexterm>In den meisten Beispielen dieses Kapitels liegt
        das Ziel einer Zusammenführung im Wurzelverzeichnis eines
        Zweigs (siehe <xref linkend="svn.branchmerge.whatis"/>).
        Obwohl es sich dabei um eine empfohlene Vorgehensweise
        handelt, kann es vorkommen, dass Sie gelegentlich einen
        Merge direkt in irgendein Kindverzeichnis der Wurzel des
        Zweigs vornehmen müssen. Diese Art der Zusammenführung wird
        <firstterm>Teilbaum-Merge</firstterm> genannt, und die
        aufgezeichneten Informationen dazu
        <firstterm>Teilbaum-Mergeinfo</firstterm>. Es gibt weder
        Besonderheiten bei Teilbaum-Merges noch bei
        Teilbaum-Mergeinfo. Es gibt hierbei tatsächlich nur einen
        wichtigen Punkt bei diesen Konzepten zu beachten: die
        vollständigen Aufzeichnungen über Zusammenführungen auf
        einen Zweig müssen nicht notwendigerweise in den
        Informationen der Wurzel des Zweigs vorliegen. Für eine
        vollständige Übersicht müssen Sie alle Teilbaum-Mergeinfos
        berücksichtigen. Glücklicherweise erledigt das Subversion
        für Sie, so dass Sie sich in den seltensten Fällen selbst
        darum kümmern müssen. Ein kurzes Beispiel hilft bei der
        Erklärung:</para>

<!--
      <informalexample>
        <screen>
# We need to merge r958 from trunk to branches/proj-X/doc/INSTALL,
# but that revision also affects main.c, which we don't want to merge:
$ svn log - -verbose - -quiet -r 958 ^/
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r958 | bruce | 2011-10-20 13:28:11 -0400 (Thu, 20 Oct 2011)
Changed paths:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

# No problem, we'll do a subtree merge targeting the INSTALL file
# directly, but first take a note of what mergeinfo exists on the
# root of the branch:
$ cd branches/proj-X

$ svn propget svn:mergeinfo - -recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652

# Now we perform the subtree merge, note that merge source
# and target both point to INSTALL:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
- - Merging r958 into 'doc/INSTALL':
U    doc/INSTALL
- - Recording mergeinfo for merge of r958 into 'doc/INSTALL':
 G   doc/INSTALL

# Once the merge is complete there is now subtree mergeinfo on INSTALL:
$ svn propget svn:mergeinfo - -recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652
Properties on 'doc/INSTALL':
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# What if we then decide we do want all of r958? Easy, all we need do is
# repeat the merge of that revision, but this time to the root of the
# branch, Subversion notices the subtree mergeinfo on INSTALL and doesn't
# try to merge any changes to it, only the changes to main.c are merged:
$ svn merge ^/subversion/trunk . -c 958
- - Merging r958 into '.':
U    src/main.c
- - Recording mergeinfo for merge of r958 into '.':
 U   .
- - Eliding mergeinfo from 'doc/INSTALL':
 U   doc/INSTALL
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
# Wir müssen r958 von trunk und branches/proj-X/doc/INSTALL
# zusammenführen, doch beeinflusst diese Revision auch main.c, das
# wir jedoch nicht zusammenführen wollen:
$ svn log --verbose --quiet -r 958 ^/
------------------------------------------------------------------------
r958 | bruce | 2011-10-20 13:28:11 -0400 (Do, 20. Okt 2011)
Geänderte Pfade:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
------------------------------------------------------------------------

# Kein Problem. Wir führen einen Teilbaum direkt auf der Datei INSTALL
# zusammen, doch merken uns zunächst, welche
# Mergeinfo für die Wurzel des Zweigs vorhanden
# ist:
$ cd branches/proj-X

$ svn propget svn:mergeinfo --recursive
Eigenschaften zu ».«:
  svn:mergeinfo
    /trunk:651-652

# Nun führen wir den Teilbaum zusammen; beachten Sie, dass sowohl
# Quelle als auch Ziel auf  INSTALL zeigen:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
-- Zusammenführen von r958 in »doc/INSTALL«:
U    doc/INSTALL
-- Aufzeichnung der Informationen für Zusammenführung von r958 in »doc/INSTALL«:
 G   doc/INSTALL

# Sobald die Zusammenführung abgeschlossen ist, gibt es Mergeinfo
# an INSTALL:
$ svn propget svn:mergeinfo --recursive
Eigenschaften zu ».«:
  svn:mergeinfo
    /trunk:651-652
Eigenschaften zu »doc/INSTALL«:
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# Was, wenn wir und dann entscheiden, alles von r958 haben zu wollen?
# Ganz einfach, alles, was wir tun müssen, ist, die Zusammenführung
# dieser Revision zu wiederholen, diesen mal allerdings auf der Wurzel
# des Zweigs. Subversion erkennt die Mergeinfo des Teilbaums an
# INSTALL und versucht nicht, irgendwelche Änderungen
# hineinzubringen, sondern es führt nur die Änderungen an main.c
# zusammen:
$ svn merge ^/subversion/trunk . -c 958
-- Zusammenführen von r958 in ».«:
U    src/main.c
-- Aufzeichnung der Informationen für Zusammenführung von r958 in ».«:
 U   .
-- Entfernung der Zusammenführungsinformationen von »doc/INSTALL«:
 U   doc/INSTALL
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>elision</secondary>
        </indexterm>You might be wondering
        why <filename>INSTALL</filename> in the above example has
        mergeinfo for r651-652, when we only merged r958. This is
        due to mergeinfo inheritance, which we'll cover in the
        sidebar
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
        />.  Also note that the subtree mergeinfo on
        <filename>doc/INSTALL</filename> was removed, or
        <quote>elided</quote>.  This is called
        <firstterm>mergeinfo elision</firstterm> and it occurs
        whenever Subversion detects redundant subtree mergeinfo.</para>
-->
      <para>
        <indexterm>
          <primary>Mergeinfo</primary>
          <secondary>Entfernung</secondary>
        </indexterm>Sie haben sich vielleicht gefragt, warum im obigen
        Beispiel <filename>INSTALL</filename> Mergeinfo für r651-652
        besitzt, wenn wir nur r958 zusammengeführt haben. Das liegt
        an der Vererbung der Mergeinfo, die wir in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
        /> behandeln. Beachten Sie weiterhin, dass die
        Teilbaum-Mergeinfo von <filename>doc/INSTALL</filename>
        <quote>entfernt</quote> wurde. Das nennt
        sich <firstterm>Entfernung von Mergeinfo</firstterm> und
        passiert immer dann, wenn Subversion redundante
        Teilbaum-Mergeinfo entdeckt.</para>


      <tip>
<!--
        <para>Prior to Subversion 1.7, merges unconditionally updated
          <emphasis>all</emphasis> of the subtree mergeinfo under the
          target to describe the merge. For users with a lot of subtree
          mergeinfo this meant that relatively <quote>simple</quote>
          merges (e.g. one which applied a diff to only a single file)
          resulted in changes to every subtree with mergeinfo, even
          those that were not parents of the affected path(s). This
          caused some level of confusion and frustration. Subversion 1.7
          and later addresses this problem by only updating the mergeinfo
          on subtrees which are parents of the paths modified by the merge
          (i.e. paths changed, added, or deleted by application of the
          difference, see
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          The one exception to this behavior regards the actual merge
          target; the merge target's mergeinfo is always updated to
          describe the merge, even if the applied difference made no
          changes.</para>
-->
        <para>Vor Subversion 1.7 haben Zusammenführungen bedingungslos
          <emphasis>die gesamte</emphasis> Teilbaum-Mergeinfo unter
          dem Ziel aktualisiert, um den Merge zu beschreiben. Für
          Anwender mit umfangreicher Teilbaum-Mergeinfo bedeutete das,
          dass auch relativ <quote>einfache</quote> Zusammenführungen
          (z.B., bei der ein Diff auf eine einzige Datei angewendet
          wurde) Änderungen der Mergeinfo in jedem Teilbaum nach sich
          zog, selbst bei denen, die keine Eltern des betroffenen
          Pfades waren. Dies führte zu einiger Verwirrung und
          Frustration. Subversion 1.7 und neuer geht dieses Problem
          an, indem es nur die Mergeinfo an den Teilbäumen
          aktualisiert, die Eltern der vom Merge betroffenen Pfade
          sind (d.h., durch die Anwendung der Differenz geänderte,
          hinzugefügte oder gelöschte Pfade, siehe
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          Die einzige Ausnahme von diesem Verhalten betrifft das
          eigentliche Ziel der Zusammenführung; dessen Mergeinfo wird
          stets aktualisiert, um den Merge zu beschreiben, auch wenn
          die angewandte Differenz keine Änderung nach sich
          zog.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.reintegrate">
<!--
      <title>Reintegrating a Branch</title>
-->
      <title>Reintegration eines Zweigs</title>

<!--
      <para>What happens when you finally finish your work, though?
        Your new feature is done, and you're ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch into sync with the trunk again, just as you've been
        doing all along<footnote><para>Since Subversion 1.7 you don't
        absolutely have to do all your sync merges to the root of your
        branch as we do in this example.  <emphasis>If</emphasis> your
        branch is effectively synced via a series of subtree
        merges then the reintegrate will work, but ask yourself, if the
        branch is effectively synced, then why are you doing subtree
        merges? Doing so is almost always needlessly
        complex.</para></footnote>:</para>
-->
      <para>Was passiert jedoch, wenn Sie schließlich Ihre Arbeit
        abgeschlossen haben? Ihre neue Funktion ist fertig, und Sie
        sind bereit, die Änderungen von Ihrem Zweig zurück auf den
        Stamm zu überführen (so dass Ihr Team die Früchte Ihrer Arbeit
        genießen kann). Die Vorgehensweise ist einfach. Zunächst
        synchronisieren Sie Ihren Zweig noch einmal mit dem Stamm, wie
        Sie es bisher gemacht haben:<footnote><para>Seit Subversion
        1.7 brauchen Sie nicht unbedingt alle Ihre
        Synchronisierungs-Merges in die Wurzel Ihres Zweigs zu bringen
        wie in diesem Beispiel. <emphasis>Falls</emphasis> Ihr Zweig
        effektiv durch eine Reihe von Teilbaum-Merges synchronisiert
        ist, wird die Reintegration funktionieren, doch fragen Sie
        sich einmal, warum Sie Teilbäume zusammenführen, wenn doch der
        Zweig effektiv synchronisiert wird. Diese Vorgehensweise ist
        oft unnötig kompliziert.</para></footnote></para>

      <informalexample>
        <screen>
<!--
$ svn up # (make sure the working copy is up to date)
Updating '.':
At revision 378.

$ svn merge ^/calc/trunk
- - Merging r362 through r378 into '.':
U    src/main.c
- - Recording mergeinfo for merge of r362 through r378 into '.':
 U   .

$ # build, test, ...

$ svn commit -m "Final merge of trunk changes to my-calc-branch."
Sending        .
Sending        src/main.c
Transmitting file data .
Committed revision 379.

$ svn up # (make sure the working copy is up to date)
Updating '.':
At revision 378. -->
$ svn up # (sicherstellen, dass die Arbeitskopie aktuell ist)
Aktualisiere ».«:
Revision 378.

$ svn merge ^/calc/trunk
--- Zusammenführen von r362 bis r378 in ».«:
U    src/main.c
-- Aufzeichnung der Informationen für Zusammenführung von r381 bis r385 in ».«:
 U   .

$ # bauen, testen, ...

$ svn commit -m "Endgültiger Merge der trunk-Änderungen nach my-calc-branch."
Sende              .
Sende              src/main.c
Übertrage Daten .
Revision 379 übertragen.
</screen>
      </informalexample>

<!--
      <para>Now, use <command>svn merge</command> subcommand to automatically
        replicate your branch changes back into the trunk.  This type of
        merge is called an
        <indexterm>
          <primary>merging</primary>
          <secondary>reintegrate merges</secondary>
        </indexterm> <quote>automatic reintegrate</quote> merge.  You'll need
        a working copy of <filename>/calc/trunk</filename>.  You can get one
        by doing an <command>svn checkout</command>, dredging up an old trunk
        working copy from somewhere on your disk, or
        using <command>svn switch</command> (see
        <xref linkend="svn.branchmerge.switchwc" />).</para>
-->
      <para>Verwenden Sie den Unterbefehl <command>svn
        merge</command>, um Ihre Änderungen automatisch zurück auf
        den Stamm zu replizieren. Diese Art von Merge wird
        <indexterm>
          <primary>Merging</primary>
          <secondary>Reintegrations-Merges</secondary>
        </indexterm><quote>automatischer Reintegrations</quote>-Merge
        genannt. Sie benötigen eine Arbeitskopie von
        <filename>/calc/trunk</filename>. Sie bekommen sie entweder
        durch <command>svn checkout</command>, indem Sie von irgendwo
        auf Ihrer Platte eine alte Arbeitskopie vom Stamm
        hervorkramen, oder den Befehl <command>svn switch</command>
        (siehe <xref linkend="svn.branchmerge.switchwc"/>)
        verwenden.</para>

      <tip>
<!--
        <para>The term <quote>reintegrating</quote> comes from the
          <command>merge</command> option <option>- -reintegrate</option>.
          This option is deprecated in Subversion 1.8 (which automatically
          detects when a reintegrate merge is needed), but is required
          for Subversion 1.5 through 1.7 clients when performing reintegrate
          merges.</para>
-->
        <para>Der Begriff <quote>Reintegration</quote> kommt von der
          <command>merge</command>-Option
          <option>--reintegrate</option>.  Diese Option gilt in
          Subversion 1.8 (das automatisch erkennt, wann ein
          Reintegrations-Merge notwendig ist) als veraltet, wird
          jedoch für Clients von Subversion 1.5 bis 1.7 benötigt, wenn
          Reintegrations-Merges ausgeführt werden.</para>
      </tip>

<!--
      <para>Your trunk working copy cannot have any local edits, switched
        paths, or contain a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs" />).  While
        these are typically best practices for merging anyway, they
        are <emphasis>required</emphasis> for automatic reintegrate
        merges.</para>
-->

      <para>Ihre Arbeitskopie darf keine lokalen Änderungen beinhalten
        oder aus gemischten Revisionen bestehen
        (siehe <xref linkend="svn.basic.in-action.mixedrevs"/>).
        Obwohl es sich dabei normalerweise um die bewährten
        Vorgehensweisen beim Zusammenführen handelt, sind sie bei
        automatischen Reintegrations-Merges
        <emphasis>zwingend</emphasis> notwendig.</para>

<!--
      <para>Once you have a clean working copy of the trunk, you're
        ready to merge your branch back into it:</para>
-->
      <para>Sobald Sie eine saubere Arbeitskopie des Stamms haben,
        sind Sie bereit, Ihren Zweig damit zusammenzuführen:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/calc-trunk

$ svn update<!--
Updating '.':
At revision 379.
-->
Aktualisiere ».«:
Revision 390.

$ svn merge ^/calc/branches/my-calc-branch <!--
- - Merging differences between repository URLs into '.':
-->
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
U    src/real.c
U    src/main.c
U    Makefile <!--
- - Recording mergeinfo for merge between repository URLs into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung zwischen Projektarchiv-URLs in ».«:
 U   .
<!--
$ # build, test, verify, ...
-->
$ # bauen, testen, überprüfen, ...
<!--
$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        Makefile
Sending        src/main.c
Sending        src/real.c
Transmitting file data ...
Committed revision 380.
-->
$ svn commit -m "my-calc-branch mit Stamm zusammenführen!"
Sende              .
Sende              Makefile
Sende              src/main.c
Sende              src/real.c
Übertrage Daten ..
Revision 380 übertragen.
</screen>
      </informalexample>

<!--
      <para>Congratulations, your branch-specific changes have now
        been merged back into the main line of development.  Notice that
        the automatic reintegrate merge did a different sort of work than
        what you've done up until now.  Previously, we were
        asking <command>svn merge</command> to grab the <quote>next
        set</quote> of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 341:351 from
        <filename>/calc/trunk</filename> to
        <filename>/calc/branches/my-calc-branch</filename>;
        later on, it continues by merging the next contiguously
        available range, 351:361.  When doing the final sync, it
        merges the range 361:378.</para>
-->
      <para>Gratulation! Ihre Änderungen vom Zweig sind nun zurück in
        die Hauptentwicklungslinie überführt worden. Beachten Sie,
        dass der automatische Reintegrations-Merge etwas anderes ist,
        als was Sie bisher gemacht haben. Vorher haben wir
        <command>svn merge</command> aufgefordert, die <quote>nächste
        Änderungsmenge</quote> von einer Entwicklungslinie (dem Stamm)
        zu holen und sie mit einer anderen (Ihrem Zweig) abzugleichen.
        Das ist recht überschaubar, und Subversion weiß jedes Mal, wo
        es wieder ansetzen soll. Bei unseren vorangehenden Beispielen
        können Sie sehen, dass es erst die Intervalle 341:351 von
        <filename>/calc/trunk</filename> nach
        <filename>/calc/branches/my-calc-branch</filename> überführte;
        später fuhr es mit dem nächsten verfügbaren
        aufeinanderfolgenden Intervall 351:361 fort.  Wenn Sie die
        letzte Synchronisierung machen, wird es das Intervall 361:378
        zusammenführen.</para>

<!--
      <para>When merging <filename>/calc/branches/my-calc-branch</filename>
        back to the <filename>/calc/trunk</filename>, however, the
        underlying mathematics are quite different.  Your feature
        branch is now a mishmash of both duplicated trunk changes and
        private branch changes, so there's no simple contiguous range
        of revisions to copy over.  By using an automatic merge, you're
        asking Subversion to carefully replicate <emphasis>only</emphasis>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</para>
-->
      <para>Wenn Sie jedoch <filename>/calc/branches/my-calc-branch</filename>
        auf <filename>/calc/trunk</filename> zurückführen, sehen die
        dem zugrundeliegenden Berechnungen ganz anders aus. Ihr Zweig
        ist nun ein Mischmasch aus abgeglichenen Änderungen vom Stamm
        und privaten Änderungen auf dem Zweig, so dass es kein
        einfaches, aufeinanderfolgendes Intervall mit Revisionen zum
        Herüberkopieren gibt. Indem Sie einen automatischen Merge
        verwenden, fordern Sie Subversion auf, sorgfältig
        <emphasis>nur</emphasis> die Änderungen von Ihrem Zweig zu
        replizieren. (Und tatsächlich macht es das so, dass es die
        letzte Version auf dem Stamm mit der letzten Version auf dem
        Zweig vergleicht: Der Unterschied macht genau die Änderung auf
        dem Zweig aus!)</para>

<!--
      <para>Keep in mind that the automatic reintegrate merges only support
        the use case described above.  Because of this narrow focus, in
        addition to the requirements previously mentioned (up-to-date working
        copy <footnote><para>Automatic reintegrate merges are allowed if the
        target is a shallow checkout
        (see <xref linkend="svn.advanced.sparsedirs"/>) but any paths
        affected by the diff which are <quote>missing</quote> due to the
        sparse working copy will be skipped&mdash;this is probably
        <emphasis>not</emphasis> what you intended!</para></footnote>
        with no mixed-revisions, switched paths or local changes) it will not
        function in combination with most of the other
        <command>svn merge</command> options. You'll get an error if you
        use any non-global options but these: <option>- -accept</option>,
        <option>- -dry-run</option>, <option>- -diff3-cmd</option>,
        <option>- -extensions</option>, or <option>- -quiet</option>.
        </para>
-->
      <para>Beachten Sie, dass automatische Reintegrations-Merges nur
        die oben beschriebenen Anwendungsfälle unterstützen.  Wegen
        dieses engen Einsatzgebietes sowie der vorher erwähnten
        Voraussetzungen (aktualisierte
        Arbeitskopie<footnote><para>Automatische Reintegrations-Merges
        sind erlaubt, falls das Ziel ein flacher Checkout ist (siehe
        <xref linkend="svn.advanced.sparsedirs"/>), doch sämtliche vom
        Diff betroffene, durch die Beschränkung der Arbeitskopie auf
        einen Teilbaum <quote>fehlende</quote> Pfade werden
        übersprungen, was wahrscheinlich <emphasis>nicht</emphasis>
        von Ihnen beabsichtigt ist!</para></footnote> ohne
        gemischte Revisionen, umgeschaltete Pfade oder lokale
        Änderungen), wird diese Option nicht mit den meisten anderen
        Optionen von <command>svn merge</command> funktionieren. Sie
        werden einen Fehler bekommen, falls Sie andere nicht-globale
        Optionen verwenden, außer den folgenden:
        <option>--accept</option>, <option>--dry-run</option>,
        <option>--diff3-cmd</option>, <option>--extensions</option>
        oder <option>--quiet</option>.</para>

<!--
      <para>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</para>
-->
      <para>Nachdem nun Ihr privater Zweig mit dem Stamm
        zusammengeführt wurde, können Sie ihn aus dem Projektarchiv
        löschen:</para>

      <informalexample>
        <screen>
$ svn delete ^/calc/branches/my-calc-branch \ <!--
      -m "Remove my-calc-branch, reintegrated with trunk in r391."
-->
      -m "my-calc-branch entfernt, auf Stamm zurückgeführt in r391."
&hellip;
</screen>
      </informalexample>

<!--
      <para>But wait!  Isn't the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <filename>/calc/branches</filename> directory, its
        existence is still an immutable part of the repository's
        history.  A simple <command>svn log</command> command on
        the <filename>/calc/branches</filename> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>
-->
      <para>Aber halt! Ist die Geschichte des Zweigs nicht wertvoll?
        Was, wenn jemand sich eines Tages die Evolution Ihrer Funktion
        ansehen möchte und hierfür auf die Änderungen des Zweiges
        schauen möchte? Keine Sorge! Denken Sie daran, dass, obwohl
        Ihr Zweig nicht mehr im Verzeichnis
        <filename>/calc/branches</filename> sichtbar ist, seine
        Existenz gleichwohl ein unveränderbarer Teil der Geschichte
        des Projektarchivs ist. Ein einfacher Befehl <command>svn
        log</command> auf dem <filename>/calc/branches</filename> URL
        wird die gesamte Geschichte des Zweiges anzeigen. Ihr Zweig
        kann eines Tages sogar wiederbelebt werden, sollten Sie dieses
        wünschen (siehe
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>


<!--
      <para>If you choose not to delete your branch after reintegrating
        it to the trunk you may continue to perform sync merges from the
        trunk and then reintegrate the branch again<footnote><para>Only
        Subversion 1.8 supports this reuse of a feature branch.  Earlier
        versions require some special handling before a feature branch
        can be reintegrated more than once.  See the earlier version of
        this chapter for more information: <ulink
        url="http://svnbook.red-bean.com/en/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. If you do this, only the changes made on your
        branch after the first reintegrate are merged to the trunk.</para>
-->
      <para>Falls Sie sich entscheiden, den Zweig nach der
        Reintegration auf den Stamm nicht zu löschen, können Sie mit
        Synchronisierungs-Merges vom Stamm fortfahren und dann den
        Zweig erneut Reintegrieren.<footnote><para>Diese
        Wiederverwendung eines Arbeitszweigs wird nur von
        Subversion 1.8 unterstützt. Frühere Versionen erfordern einige
        besondere Schritte, bevor ein Arbeitszweig mehr als einmal
        reintegriert werden kann. Siehe eine frühere Version dieses
        Kapitels für weitere Informationen: <ulink
        url="http://svnbook.red-bean.com/de/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote> Falls Sie das machen, werden nur die
        Änderungen, die Sie nach dem ersten Reintegrieren auf dem
        Zweig vorgenommen haben, mit dem Stamm zusammengeführt.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.mergeinfo">
<!--
      <title>Mergeinfo and Previews</title>
-->
      <title>Mergeinfo und Vorschauen</title>

<!--
      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>property</secondary>
        </indexterm>The basic mechanism Subversion uses to track
        changesets&mdash;that is, which changes have been merged to
        which branches&mdash;is by recording data in versioned
        properties.  Specifically, merge data is tracked in
        the <literal>svn:mergeinfo</literal> property attached to
        files and directories.  (If you're not familiar with
        Subversion properties, see <xref linkend="svn.advanced.props"
        />.)</para>
-->
      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>property</secondary>
        </indexterm>Der grundsätzliche Mechanismus, den Subversion verwendet,
        um Änderungsmengen zu verfolgen &ndash; d.h., welche
        Änderungen auf welchen Zweig übertragen worden sind &ndash;
        besteht aus der Datenspeicherung in versionierten
        Eigenschaften.  Namentlich werden Daten die das Zusammenführen
        betreffen in der Eigenschaft <literal>svn:mergeinfo</literal>
        festgehalten, die mit Dateien und Verzeichnissen verknüpft
        ist. (Falls Sie mit Subversion-Eigenschaften nicht vertraut
        sind, siehe <xref linkend="svn.advanced.props"/>.)</para>

<!--
      <para>You can examine the mergeinfo property, just like any other
        versioned property:</para>
-->
      <para>Sie können sich die mergeinfo-Eigenschaft ansehen, wie
        jede andere versionierte Eigenschaft:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn pg svn:mergeinfo -v <!--
Properties on '.': -->
Eigenschaften von ».«:
  svn:mergeinfo
    /calc/trunk:341-378
</screen>
      </informalexample>

<!--
      <warning>
        <para>While it is possible to
          modify <literal>svn:mergeinfo</literal> just as you might
          any other versioned property, we strongly discourage doing
          so unless you <emphasis>really</emphasis> know what you're
          doing.</para>
      </warning>
-->
      <warning>
        <para>Obwohl es möglich ist, <literal>svn:mergeinfo</literal>
          zu ändern wie jede andere versionierte Eigenschaft, raten
          wir dringend davor ab, es sei denn, Sie wissen
          <emphasis>wirklich</emphasis>, was Sie da machen.</para>
      </warning>

      <tip>
<!--
        <para>The amount of <literal>svn:mergeinfo</literal> on a single
          path can get quite large, as can the output of a
          <command>svn propget - -recursive</command> or
          <command>svn proplist - -recursive</command> when dealing with
          large amounts of subtree mergeinfo, see
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>
          . The formatted output produced by the
          <option>- -verbose</option> option with either of these
          subcommands is often very helpful in these cases.</para>
-->
        <para>Der Umfang von <literal>svn:mergeinfo</literal> auf
          einem einzelnen Pfad kann recht groß werden, so wie die
          Ausgabe eines <command>svn propget --recursive</command>
          oder <command>svn proplist --recursive</command> falls man
          es mit umfangreicher Mergeinfo auf Teilbäumen zu tun hat,
          siehe
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>.
          Die durch die Option <option>--verbose</option> erzeugte
          formatierte Ausgabe mit jedem dieser Unterbefehle ist in
          diesen Fällen oft sehr hilfreich.</para>
      </tip>

<!--
      <para>The <literal>svn:mergeinfo</literal> property is
        automatically maintained by Subversion whenever you
        run <command>svn merge</command>.  Its value indicates which
        changes made to a given path have been replicated into the
        directory in question.  In our previous example, the path
        which is the source of the merged changes is
        <filename>/calc/trunk</filename> and the directory which has
        received the changes is
        <filename>/calc/branches/my-calc-branch</filename>.
        Earlier versions of Subversion maintained the
        <literal>svn:mergeinfo</literal> property silently. You could
        still detect the changes, after a merge completed, with the
        <command>svn diff</command> or <command>svn status</command>
        subcommands, but the merge itself gave no indication when it
        changed the <literal>svn:mergeinfo</literal> property. In
        Subversion 1.7 and later this is no longer true as there are
        several notifications to alert you when a merge updates the
        <literal>svn:mergeinfo</literal> property. These notifications
        all begin with <quote>- - Recording mergeinfo for</quote>
        and appear at the end of the merge.  Unlike other merge
        notifications, these don't describe the application of a
        difference to a working copy
        (see <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        but instead describe "housekeeping" changes made to keep
        track of what was merged.</para>
-->

      <para>Die Eigenschaft <literal>svn:mergeinfo</literal> wird
        automatisch von Subversion gepflegt, sobald Sie den Befehl
        <command>svn merge</command> ausführen. Ihr Wert gibt
        Aufschluss darüber, welche Änderungen an einem gegebenen Pfad
        mit dem in Frage kommenden Verzeichnis abgeglichen wurden. Im
        vorangegangenen Beispiel ist <filename>/calc/trunk</filename> der
        Ursprungspfad der zusammengeführten Änderungen und
        <filename>/calc/branches/my-calc-branch</filename> das
        Zielverzeichnis. Frühere Versionen von Subversion pflegten die
        Eigenschaft <literal>svn:mergeinfo</literal> im Hintergrund.
        Sie konnten die Änderungen nach einem abgeschlossenen
        Merge mit <command>svn diff</command> oder <command>svn
        status</command> zwar entdecken, doch gab die eigentliche
        Zusammenführung keinerlei Hinweis, dass sie die Eigenschaft
        <literal>svn:mergeinfo</literal> geändert hat. In Subversion
        1.7 und später trifft das nicht mehr zu, da es verschiedene
        Mitteilungen gibt, um Sie zu benachrichtigen, wenn ein
        Merge die Eigenschaft <literal>svn:mergeinfo</literal>
        ändert. Diese Mitteilungen beginnen alle mit
        <quote>-- Aufzeichnung der Informationen für
        Zusammenführung</quote> und tauchen am Ende einer
        Zusammenführung auf. Im Gegensatz zu anderen Mitteilungen bei
        Merges beschreiben diese kein Anwenden eines Diffs auf eine
        Arbeitskopie (siehe
        <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        sondern Änderungen zur Buchhaltung, um festzuhalten, was
        zusammengeführt wurde.</para>

<!--
      <para>Subversion also provides a subcommand, <command>svn
        mergeinfo</command>, which is helpful in seeing the merge
        relationships between two branches; specifically which changesets
        a directory has absorbed or which changesets it's still eligible
        to receive.  The latter gives a sort of preview of which changes a
        subsequent <command>svn merge</command> operation would replicate
        to your branch.  By default, <command>svn mergeinfo</command> gives
        an graphical overview of the relationship between to branches.
        Returning to our earlier example, we use the subcommand to analyze
        the relationship between <filename>/calc/trunk</filename> and
        <filename>/calc/branches/my-calc-branch</filename>:</para>
-->
      <para>Subversion stellt auch den Unterbefehl <command>svn
        mergeinfo</command> zur Verfügung, der dabei hilfreich ist,
        die Zusammenführungen zwischen zwei Zweigen zu zeigen;
        insbesondere welche Änderungsmengen in ein Verzeichnis
        eingeflossen sind oder welche noch für einen Abgleich bereit
        stehen. Letzteres ergibt eine Art Vorschau, welche
        Änderungsmengen ein folgender <command>svn
        merge</command>-Befehl auf Ihren Zweig replizieren wird.
        Standardmäßig zeigt <command>svn mergeinfo</command> eine
        graphische Übersicht der Beziehungen zwischen zwei Zweigen an.
        Wenn wir auf unser früheres Beispiel zurückkommen, verwenden
        wir den Unterbefehl, um die Beziehung zwischen
        <filename>/calc/trunk</filename> und
        <filename>/calc/branches/my-calc-branch</filename> zu
        untersuchen:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn mergeinfo ^/calc/trunk<!--
    youngest common ancestor
    |         last full merge
    |         |        tip of branch
    |         |        |         repository path
-->
    letzter gemeinsamer Vorfahr
    |         letzte vollständige Zusammenführung
    |         |        Spitze des Zweigs
    |         |        |         Projektarchiv-Pfad
    340                382
    |                  |
  -------| |------------         calc/trunk
     \          /
      \        /
       --| |------------         calc/branches/my-calc-branch
              |        |
              379      382
</screen>
      </informalexample>

<!--
      <para>The diagram shows that <filename>/calc/branches/my-calc-branch
      </filename> was copied from <filename>/calc/trunk@340</filename> and
      that most recent automatic merge was the reintegrate merge we made
      from the branch to the trunk in r380.  Notice that the diagram does
      <emphasis>not</emphasis> show the four automatic sync merges we made
      in revisions 352, 362, 372, and 379.  Only the most recent automatic
      merge, in either direction<footnote><para>By <quote>direction</quote>
      we mean either trunk-to-branch (automatic sync) or branch-to-trunk
      (automatic reintegrate) merges.</para></footnote>, is shown.  This
      default output is useful for obtaining an overview of the merges
      between two branches, but to see the specific revisions which were
      merged we use the <option>- -show-revs=merged</option> option:</para>
-->
      <para>Das Diagramm zeigt, dass
        <filename>/calc/branches/my-calc-branch </filename> von
        <filename>/calc/trunk@340</filename> herüber kopiert wurde und
        der letzte automatische Merge der Reintegrations-Merge war,
        den wir vom Zweig zum Stamm in r380 gemacht haben. Beachten
        Sie, dass das Diagramm die vier automatischen
        Synchronisierungs-Merges <emphasis>nicht</emphasis> zeigt, die
        wir in den Revisionen 352, 362, 372 und 379 gemacht haben.
        Gezeigt wird lediglich der letzte automatische Merge, egal in
        welche Richtung.<footnote><para>Unter <quote>Richtung</quote>
        verstehen wir entweder Stamm-Zweig- (automatische
        Synchronisierung) oder Zweig-Stamm-Merges (automatische
        Reintegration).</para></footnote> Diese Standard-Ausgabe
        ist als Übersicht über die Merges zwischen zwei Zweigen
        brauchbar, jedoch sollten Sie die Option
        <option>--show-revs=merged</option> verwenden, um die
        zusammengeführten Versionen genau zu sehen:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs merged
r344
r345
r346
&hellip;
r366
r367
r368
</screen>
      </informalexample>

<!--
      <para>Likewise, to see which changes are eligible to merge from the
        trunk to the branch we can use the <option>- -show-revs=eligible
        </option> option:</para>
-->
      <para>Um auf ähnliche Art die Änderungen zu sehen, die für einen
        Merge vom Stamm auf den Zweig in Frage kommen, können wir die
        Option <option>--show-revs=eligible </option> verwenden:</para>
      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r380
r381
r382
</screen>
      </informalexample>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.operativerevs">
<!--
        <title>Operative and Inoperative Merge Revisions</title>
-->
        <title>Operative und inoperative Merge-Revisionen</title>

<!--
        <para>The revision lists produced by the <option>- -show-revs
          </option> option include only revisions which made (or would make)
          changes when merged.  So while we have merged a contiguous range of
          revisions (i.e. r341-378) from <filename>/calc/trunk</filename> to
          <filename>/calc/branches/my-calc-branch</filename>, only the
          revisions listed with the <option>- -show-revs=merged</option> option
          actually represent changes made on <filename>/calc/trunk</filename>.
          These revisions are described as <quote>operative</quote>
          revisions as regards merging, not to be confused with the
          operative revision used with the <option>-r</option> option, see
          <xref linkend="svn.advanced.pegrevs"/>.  Not suprisingly, the
          revisions in the range r341-378 that are <emphasis>not</emphasis>
          listed as merged are termed <quote>inoperative</quote> revisions.
        </para>
-->
        <para>Die von der Option <option>--show-revs </option>
          erzeugten Revisionlisten beinhalten nur Revisionen, die beim
          Zusammenführen Änderungen hervorrufen (würden). Während wir
          also einen Bereich aufeinanderfolgender Revisionen (z.B.
          r341-378) von <filename>/calc/trunk</filename> nach
          <filename>/calc/branches/my-calc-branch</filename>
          zusammengeführt haben, repräsentieren nur die mit der Option
          <option>--show-revs=merged</option> aufgelisteten Revisionen
          tatsächliche Änderungen auf
          <filename>/calc/trunk</filename>. Diese Revisionen werden
          als <quote>operative</quote> Revisionen hinsichtlich der
          Zusammenführung bezeichnet und sind nicht zu verwechseln mit
          den operativen Revisionen, die mit der Option
          <option>-r</option> verwendet werden, siehe <xref
          linkend="svn.advanced.pegrevs"/>. Wie zu erwarten, werden
          die Revisionen aus dem Bereich r341-378, die
          <emphasis>nicht</emphasis> als zusammengeführt aufgelistet
          werden, <quote>inoperative</quote> Revisionen genannt.
      </para>
    </sidebar>

<!--
      <para>The <command>svn mergeinfo</command> command requires
        a <quote>source</quote> URL (where the changes come
        from), and takes an optional <quote>target</quote> URL (where
        the changes merge to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we're querying our
        branch working copy, the command assumes we're interested in
        receiving changes to <filename>/calc/branches/my-calc-branch
        </filename> from the specified trunk URL.</para>
-->
      <para>Der Befehl <command>svn mergeinfo</command> erwartet einen
        <quote>Quell</quote>-URL (woher die Änderungen kommen)
        und einen optionalen <quote>Ziel</quote>-URL (wohin die
        Änderungen abgeglichen werden). Falls kein Ziel-URL angegeben
        ist, wird das aktuelle Arbeitsverzeichnis als Ziel angenommen.
        Da wir im vorangegangenen Beispiel unser dem Zweig
        entsprechenden Arbeitsverzeichnis abfragen, geht der Befehl
        davon aus, dass wir daran interessiert sind, Änderungen vom
        angegebenen Stamm-URL für
        <filename>/calc/branches/my-calc-branch</filename> zu
        erhalten.</para>

<!--
      <para>Since Subversion 1.7, the
        <command>svn mergeinfo</command> subcommand can also account for
        subtree mergeinfo and non-inheritable mergeinfo.  It accounts for
        subtree mergeinfo by use of the <option>- -recursive</option> or
        <option>- -depth</option> options, while non-inheritable mergeinfo
        is considered by default.</para>
-->
      <para>Seit Subversion 1.7 kann der Unterbefehl <command>svn
        mergeinfo</command> auch Teilbaum-Mergeinfo und
        nichterbliche Mergeinfo berücksichtigen. Mit den Option
        <option>--recursive</option> oder <option>--depth</option>
        wird Teilbaum-Mergeinfo berücksichtigt, während nicht
        vererbbare Mergeinfo standardmäßig beachtet wird.</para>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.inheritance">
<!--
        <title>Mergeinfo Inheritance</title>
-->
        <title>Vererbung von Mergeinfo</title>

<!--
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>inheritance</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>explicit</secondary>
          </indexterm>When a path has
          the <literal>svn:mergeinfo</literal> property set on it we
          say it has <firstterm>explicit mergeinfo</firstterm>.  This
          explicit mergeinfo describes not only what changes were
          merged into that particular directory, but also all the
          children of that directory (because those children inherit
          the mergeinfo of their parent path).  For example:</para>
-->
        <para>
          <indexterm>
            <primary>Mergeinfo</primary>
            <secondary>Vererbung</secondary>
          </indexterm>
          <indexterm>
            <primary>Mergeinfo</primary>
            <secondary>explizite</secondary>
          </indexterm>Besitzt ein Pfad die gesetzte Eigenschaft
          <literal>svn:mergeinfo</literal>, sagen wir, er hat
          <firstterm>explizite Mergeinfo</firstterm>. Diese expliziten
          Informationen beschreiben nicht nur, welche Änderungen in
          dieses bestimmte Verzeichnis gebracht worden sind, sondern
          auch in welche Kindverzeichnisse desselben (da diese Kinder
          die Informationen ihres Elternpfades erben). Zum
          Beispiel:</para>

        <informalexample>
          <screen> <!--
# What explicit mergeinfo exists on a branch?
-->
# Welche expliziten Mergeinfo gibt es auf dem Zweig?
$ svn propget svn:mergeinfo ^/branches/proj-X --recursive
/trunk:651-652
<!--
# What children does proj-X have?
-->
# Welche Kinder hat proj-X?
$ svn list --recursive ^/branches/proj-X
doc/
doc/INSTALL
README
src/main.c
<!--
# Ask what revs were merged to a file with no explicit mergeinfo
-->
# Frage nach den Revisionen, die ohne explizite Mergeinfo
# in eine Datei eingepflegt wurden
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

<!--
        <para>Notice from our first subcommand that only the root of
          <filename>/branches/proj-X</filename> has any explicit
          mergeinfo.  However, when we use
          <command>svn mergeinfo</command> to ask what was merged to
          <filename>/branches/proj-X/src/main.c</filename> it reports
          that the two revisions described in the explicit mergeinfo
          on <filename>/branches/proj-X</filename> were merged.  This is
          because <filename>/branches/proj-X/src/main.c</filename>, having
          no explicit mergeinfo of its own, inherits the mergeinfo from
          its nearest parent with explicit mergeinfo,
          <filename>/branches/proj-X</filename>.</para>
-->
        <para>Beachten Sie, dass bei unserem ersten Unterbefehl
          lediglich die Wurzel von
          <filename>/branches/proj-X</filename> überhaupt explizite
          Mergeinfo besitzt. Dennoch, wenn wir <command>svn
          mergeinfo</command> aufrufen, um nachzusehen, was in
          <filename>/branches/proj-X/src/main.c</filename> eingepflegt
          wurde,  werden die zwei Revisionen aus der expliziten
          Information von <filename>/branches/proj-X</filename>
          angezeigt. Das liegt daran, weil
          <filename>/branches/proj-X/src/main.c</filename>, das
          keinerlei eigene Mergeinfo besitzt, die Informationen des
          nächsten Elternteils mit expliziten Informationen erbt,
          nämlich <filename>/branches/proj-X</filename>.</para>

<!--
        <para>There are two cases in which mergeinfo is not inherited.
          First, if a path has explicit mergeinfo, then it never inherits
          mergeinfo. Another way to think of this is that explicit
          mergeinfo is always a complete record of the merges to a given
          path, once it exists it overrides any mergeinfo that path might
          otherwise inherit. The second way is when dealing with
          non-inheritable mergeinfo, a special type of explicit mergeinfo
          that applies <emphasis>only</emphasis> to the directory on which
          the <literal>svn:mergeinfo</literal> property is set (and it's
          only directories, non-inheritable mergeinfo is never set on
          files). For example:</para>
-->
        <para>In zwei Fällen werden die Informationen nicht vererbt.
          Erstens, sofern ein Pfad explizite Mergeinfo besitzt, erbt
          er sie nie. Auf eine andere Art betrachtet, handelt es sich
          dabei um eine vollständige Aufzeichnung der Merges auf
          diesen Pfad, die, sobald sie existiert, jegliche eventuell
          zu erbende Information überschreibt. Der zweite Fall liegt
          vor, wenn es um nichterbliche Mergeinfo geht, einer
          besonderen Art der expliziten Informationen, die
          <emphasis>nur</emphasis> auf das Verzeichnis anwendbar ist,
          bei dem die Eigenschaft <literal>svn:mergeinfo</literal>
          gesetzt ist (und nur bei Verzeichnissen; nichterbliche
          Mergeinfo wird nie an Dateien gesetzt).  Zum
          Beispiel:</para>

        <informalexample>
          <screen> <!--
# The '*' decorator indicates non-inheritable mergeinfo
-->
"*" markiert nichterbliche Mergeinfo
$ svn propget svn:mergeinfo ^/branches/proj-X
/trunk:651-652,758*
<!--
# Revision 758 is non-inheritable, but still applies to the path it is
# set on. Here the '*' decorator signals that r758 is only partially
# merged from trunk. 
-->
# Revision 758 ist nicht erblich, doch trotzdem auf den Pfad, auf dem
# es gesetzt ist, anwendbar. Hier zeigt "*" an, dass r758 nur
# teilweise mit dem Stamm zusammengeführt wurde.
$ svn mergeinfo ^/trunk ^/branches/proj-X --show-revs merged
651
652
758*
<!--
# Revision 758 is not reported as merged because it is non-inheritable
# and applies only to ^/trunk
-->
# Revision 758 wird nicht als zusammengeführt angezeigt, da sie
# nicht erblich und nur auf ^/trunk anwendbar ist.
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

<!--
        <para>You might never have to think about mergeinfo inheritance
          or encounter non-inheritable mergeinfo in your own repository.
          A discussion of the full ramifications of mergeinfo inheritance
          are beyond the scope of this book.  If you have more questions
          check out some of the references mentioned in
          <xref linkend="svn.branchmerge.advanced.finalword"/></para>
-->
        <para>Es mag sein, dass Sie sich niemals Gedanken über die
          Vererbung von Mergeinfo machen müssen oder Ihnen
          nichterbliche Mergeinfo in Ihrem Projektarchiv begegnen.
          Eine Erörterung der vollständigen Auswirkungen der Vererbung
          von Mergeinfo würden den Rahmen dieses Buches sprengen.
          Sollten Sie weitere Fragen haben, schauen Sie einige der in
          <xref linkend="svn.branchmerge.advanced.finalword"/>
          aufgeführten Referenzen an.</para>
      </sidebar>

<!--
      <para>Let's say we have a branch with both subtree and
        non-inheritable mergeinfo:</para>
-->
      <para>Angenommen, wir haben einen Zweig sowohl mit Teilbaum- als
        auch nichterblichen Mergeinfo:</para>

        <informalexample>
          <screen>
$ svn pg svn:mergeinfo -vR <!--
# Non-inheritable mergeinfo
Properties on '.':
-->
# Nichterbliche Mergeinfo
Eigenschaften zu ».«
  svn:mergeinfo
    /calc/trunk:354,385-388* <!--
# Subtree mergeinfo
Properties on 'Makefile':
-->
# Teilbaum-Mergeinfo
Eigenschaften zu »doc/INSTALL«
  svn:mergeinfo
    /calc/trunk/Makefile:354,380
</screen>
        </informalexample>

<!--
      <para>From the above mergeinfo we see that r385-388 has only been
        merged into the root of the branch, but not any of the root's
        children.  We also see that r380 has only been merged to
        <filename>Makefile</filename>.
        When we use <command>svn mergeinfo</command> with the
        <option>- -recursive</option> option to see what has been merged
        from <filename>/calc/trunk</filename> to this branch, we see three
        revisions are flagged with the <literal>*</literal> marker:</para>
-->
      <para>Aus den obigen Informationen geht hervor, dass r385-388
        nur in die Wurzel des Zweigs eingepflegt wurde, aber in keins
        der Kindverzeichnisse. Ferner ist erkennbar, dass r380 nur in
        die Datei <filename>Makefile</filename> eingearbeitet wurde.
        Wenn wir <command>svn mergeinfo</command> mit der Option
        <option>--recursive</option> verwenden, um nachzusehen, was
        von <filename>/calc/trunk</filename> in diesen Zweig
        eingepflegt wurde, erkennen wir drei Revisionen, die mit der
        Markierung <literal>*</literal> versehen sind:</para>

        <informalexample>
          <screen>
$ svn mergeinfo -R --show-revs=merged ^/calc/trunk .
r354
r380*
r385
r386
r387*
r388*
</screen>
        </informalexample>

<!--
      <para>The <literal>*</literal> indicates revisions that are only
        <emphasis>partially</emphasis> merged to the target in question
        (the meaning is the same if we are checking for eligible
        revisions).  What this means in this example is that if we tried
        to merge r380, r387, or r388 from <filename>^/trunk</filename> then
        more changes would result. Likewise, because r354, r385 and r386 are
        <emphasis>not</emphasis> flagged with a <literal>*</literal>,
        we know that re-merging those revisions would have no result.
        <footnote><para>This is a good example of inoperative merge
        revisions.</para></footnote></para>
-->
      <para><literal>*</literal> markiert Revisionen, die nur
        <emphasis>teilweise</emphasis> in das in Frage kommende Ziel
        eingepflegt worden sind (die Bedeutung ist die gleiche wie bei
        der Überprüfung nach in Frage kommenden Revisionen). In diesem
        Beispiel bedeutet das, dass beim Versuch r380, r387 oder r388
        von <filename>^/trunk</filename> einzupflegen, mehr Änderungen
        angefallen wären. Ebenso wissen wir, da r354, r385 und r386
        <emphasis>nicht</emphasis> mit <literal>*</literal> markiert
        ist, dass der Versuch, sie erneut einzupflegen, keine
        Auswirkung hätte.<footnote><para>Das ist ein gutes Beispiel
        für <quote>inoperative</quote>
        Merge-Revisionen.</para></footnote></para>

<!--
      <para>Another way to get a more precise preview of a merge
        operation is to use the <option>- -dry-run</option>
        option:</para>
-->
      <para>Eine andere Methode, eine genauere Vorschau auf einen
        Abgleich zu bekommen, ist die Verwendung der Option
        <option>--dry-run</option>:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk paint-feature-branch --dry-run <!--
- - Merging r290 through r383 into 'paint-feature-branch':
-->
-- Zusammenführen von r290 bis r383 in »paint-feature-branch«:
U    paint-feature-branch/src/palettes.c
U    paint-feature-branch/src/brushes.c
U    paint-feature-branch/Makefile

$ svn status <!--
#  nothing printed, working copy is still unchanged.
-->
#  es wird nichts ausgegeben, die Arbeitskopie ist unverändert
</screen>
      </informalexample>

<!--
      <para>The <option>- -dry-run</option> option doesn't actually
        apply any local changes to the working copy.  It shows only
        status codes that <emphasis>would</emphasis> be printed in a
        real merge.  It's useful for getting a <quote>high-level</quote>
        preview of the potential merge, for those times
        when running <command>svn diff</command> gives too much
        detail.</para>
-->
        <para>Die Option <option>--dry-run</option> macht tatsächlich
        überhaupt keine lokalen Änderungen an der Arbeitskopie. Sie
        zeigt nur Status-Codes, die ausgegeben
        <emphasis>würden</emphasis>, wenn ein echter Abgleich
        stattfände. Sie ist nützlich, um eine Vorschau für einen
        möglichen Abgleich auf <quote>hoher Ebene</quote> zu erhalten,
        falls <command>svn diff</command> zu detailliert wäre.</para>

      <tip>
<!--
        <para>After performing a merge operation, but before
          committing the results of the merge, you can use
          <userinput>svn diff - -depth=empty <replaceable>
          /path/to/merge/target</replaceable></userinput> to see only the
          changes to the immediate target of your merge.  If your merge
          target was a directory, only property differences are displayed.
          This is a handy way to see the changes to the
          <literal>svn:mergeinfo</literal> property recorded by the
          merge operation, which will remind you about what you've
          just merged.</para>
-->
        <para>Nach dem Merge, aber vor der Übergabe des Ergebnisses,
          können Sie <userinput>svn diff --depth=empty
          <replaceable>/pfad/zum/abgleichs/ziel</replaceable></userinput>
          verwenden, um nur die Änderungen am unmittelbaren Ziel des
          Merges zu sehen. Falls das Ziel ein Verzeichnis war,
          werden nur Unterschiede von Eigenschaften angezeigt. Das ist
          eine praktische Methode, um sich die Änderungen an der
          Eigenschaft <literal>svn:mergeinfo</literal> anzusehen, die
          dort durch den Merge vermerkt wurden, und die Sie daran
          erinnern, was Sie eben abgeglichen haben.</para>
      </tip>

<!--
      <para>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <command>svn merge</command>
        isn't an inherently risky thing (unless you've made local
        modifications to your working copy&mdash;but we already
        stressed that you shouldn't merge into such an
        environment).  If you don't like the results of the merge,
        simply run <userinput>svn revert . -R</userinput> to revert
        the changes from your working copy and retry the command with
        different options.  The merge isn't final until you
        actually <command>svn commit</command> the results.</para>
-->
      <para>Natürlich ist die beste Methode, eine Vorschau eines
        Merges zu erhalten, ihn zu machen! Denken Sie daran, dass
        der Aufruf von <command>svn merge</command> an sich nichts
        Riskantes ist (es sei denn, sie haben lokale Änderungen an
        Ihrer Arbeitskopie gemacht &ndash; aber wir haben bereits
        betont, dass Sie in eine derartige Umgebung nicht abgleichen
        sollten). Falls Ihnen das Ergebnis des Abgleichs nicht
        gefallen sollte, rufen Sie einfach <userinput>svn revert
        . -R</userinput> auf, um die Änderungen an Ihrer Arbeitskopie
        rückgängig zu machen, und versuchen Sie den Befehl erneut mit
        unterschiedlichen Optionen. Der Abgleich ist solange nicht
        endgültig, bis Sie mit <command>svn commit</command> das
        Ergebnis übertragen.</para>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.undo">
<!--
      <title>Undoing Changes</title>
-->
      <title>Änderungen rückgängig machen</title>

<!--
      <para>An extremely common use for <command>svn merge</command>
        is to roll back a change that has already been committed.
        Suppose you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made back in revision 392, which changed
        several code files, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference.  (You can do this by
        specifying <option>- -revision 303:302</option>, or by an
        equivalent <option>- -change -303</option>.)</para>
-->
      <para>Sehr häufig wird <command>svn merge</command> verwendet,
        um eine Änderung rückgängig zu machen, die bereits an das
        Projektarchiv übertragen worden war. Nehmen wir einmal an, Sie
        arbeiten fröhlich in einer Arbeitskopie von
        <filename>/calc/trunk</filename> und entdecken, dass die
        damaligen Änderungen an verschiedenen Quelltext-Dateien in
        Revision 392 völlig falsch waren. Sie hätten nie übertragen
        werden sollen. Sie können <command>svn merge</command>
        verwenden, um die Änderung in Ihrer Arbeitskopie
        <quote>zurückzunehmen</quote>, und dann die lokale Änderung an
        das Projektarchiv übertragen. Sie müssen hierfür nur eine
        <emphasis>umgekehrte</emphasis> Differenz angeben. (Sie machen
        das durch die Angabe von <option>--revision 303:302</option>
        oder durch das äquivalente <option>--change -303</option>.)
      </para>


      <informalexample>
        <screen>
$ svn merge ^/calc/trunk . -c-392 <!--
- - - Reverse-merging r392 into '.':
-->
-- Rückwärtiges Zusammenführen von r392 in ».«:
U    src/real.c
U    src/main.c
U    src/button.c
U    src/integer.c <!--
- - - Recording mergeinfo for reverse merge of r392 into '.':
-->
-- Aufzeichnung der Informationen für rückwärtiges Zusammenführen von r392 in ».«:
 U   .

$ svn st
M       src/button.c
M       src/integer.c
M       src/main.c
M       src/real.c

$ svn diff
&hellip; <!--
# verify that the change is removed
-->
# überprüfen, ob die Änderung entfernt wurde
&hellip;
<!--
$ svn commit -m "Undoing erroneous change committed in r392."
Sending        src/button.c
Sending        src/integer.c
Sending        src/main.c
Sending        src/real.c
Transmitting file data ....
Committed revision 399.
-->
$ svn commit -m "Fehlerhafte Änderung aus r392 rückgängig machen."
Sende              src/button.c
Sende              src/integer.c
Sende              src/main.c
Sende              src/real.c
Sende              integer.c
Übertrage Daten ....
Revision 399 übertragen.
</screen>
      </informalexample>

<!--
      <para>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <option>-r</option> option, you can ask <command>svn
        merge</command> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset r392 to our working copy
        <emphasis>backward</emphasis>.</para>
-->
      <para>Wie wir früher bereits erwähnten, kann man eine
        Projektarchiv-Version als eine bestimmte Änderungsmenge
        betrachten. Bei Verwendung der Option <option>-r</option> wird
        <command>svn merge</command> aufgefordert, eine Änderungsmenge
        oder ein ganzes Intervall von Änderungsmengen auf Ihre
        Arbeitskopie anzuwenden. In unserem Fall, bei dem wir eine
        Änderung zurücknehmen, fordern wir <command>svn
        merge</command> auf, die Änderungsmenge r392
        <emphasis>rückwärts</emphasis> auf unsere Arbeitskopie
        anzuwenden.</para>

<!--
      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>
-->
      <para>Merken Sie sich, dass ein solches Rückgängigmachen wie
        jeder andere <command>svn merge</command>-Vorgang ist, so dass
        Sie <command>svn status</command> und <command>svn
        diff</command> benutzen sollten, um sicherzustellen, dass Ihre
        Arbeit in dem Zustand ist, den Sie haben möchten, und
        verwenden Sie anschließend <command>svn commit</command>, um
        die endgültige Version in das Projektarchiv zu bringen. Nach der
        Übergabe wird sich diese bestimmte Änderungsmenge nicht mehr
        in der <literal>HEAD</literal>-Revision wiederfinden.</para>

<!--
      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 392.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 392 and
        398, she'll still see the bad change, right?</para>
-->
      <para>Nun denken Sie vielleicht: Gut, aber das hat doch nicht
        wirklich die Übergabe rückgängig gemacht, oder? Die Änderung
        besteht immer noch in Revision 392. Falls jemand eine Version
        des Projektes <filename>calc</filename> zwischen den
        Revisionen 392 und 398 auscheckt, wird doch trotzdem die
        fehlerhafte Änderung sichtbar, oder nicht?</para>

<!--
      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from the <literal>HEAD</literal> revision.  The
        original change still exists in the repository's history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.<footnote><para>The
        Subversion project has plans, however, to someday implement a
        command that would accomplish the task of permanently deleting
        information.  In the meantime, see
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a
        possible workaround.</para></footnote></para>
-->
      <para>Ja, das stimmt. Wenn wir davon sprechen, eine Änderung zu
        <quote>entfernen</quote>, sprechen wir eigentlich darüber, sie
        aus der <literal>HEAD</literal>-Revision zu entfernen. Die
        ursprüngliche Änderung besteht immer noch in der Geschichte
        des Projektarchivs. Für die meisten Situationen ist das
        ausreichend. Die meisten Leute sind sowieso nur am
        <literal>HEAD</literal> eines Projektes interessiert. Es gibt
        jedoch Spezialfälle, in denen Sie wirklich alle Beweise der
        Übergabe vernichten möchten. (Vielleicht hat jemand ein
        vertrauliches Dokument in das Projektarchiv übertragen.) Das ist
        leider nicht so einfach, da Subversion absichtlich so
        konstruiert wurde, dass es niemals Informationen
        verliert. Revisionen sind unveränderliche Bäume, die
        aufeinander aufbauen. Die Beseitigung einer Revision aus der
        Geschichte würde einen Dominoeffekt auslösen, Chaos in allen
        nachfolgenden Revisionen anrichten und möglicherweise alle
        Arbeitskopien ungültig machen.<footnote><para>Allerdings gibt
        es im Subversion-Projekt Pläne, eines Tages einen Befehl zu
        implementieren, der die Aufgabe erledigen würde, Informationen
        dauerhaft zu löschen. Bis dahin, siehe 
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> für
        einen möglichen Notbehelf.</para>
        </footnote>
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.resurrect">
<!--
      <title>Resurrecting Deleted Items</title>
-->
      <title>Zurückholen gelöschter Objekte</title>

<!--
      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote></para>
-->
      <para>Das Tolle an Versions-Kontroll-Systemen ist, dass
        Informationen nie verlorengehen. Selbst wenn Sie eine Datei
        oder ein Verzeichnis löschen, ist es zwar nicht mehr in der
        <literal>HEAD</literal>-Revision vorhanden, jedoch noch in
        früheren Revisionen. Eine der häufigsten Fragen neuer Benutzer
        ist: <quote>Wie bekomme ich meine alte Datei oder mein altes
        Verzeichnis zurück?</quote></para>

<!--
      <para>The first step is to define
        exactly <emphasis>which</emphasis> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        is defined by a specific coordinate pair.  (Remember the
        <quote>peg revision</quote>
        syntax&mdash;foo.c@224&mdash;mentioned back in
        <xref linkend="svn.advanced.pegrevs"/>.)</para>
-->
      <para>Der erste Schritt ist es, genau zu definieren
        <emphasis>welches</emphasis> Objekt Sie zurückholen
        möchten. Hier ist eine nützliche Metapher: Sie können sich
        vorstellen, dass jedes Objekt im Projektarchiv in einem
        zweidimensionalen Koordinatensystem befindet. Die erste
        Koordinate ist ein bestimmter Revisionsbaum und die zweite
        Koordinate ist ein Pfad innerhalb dieses Baumes. So wird jede
        Version Ihrer Datei oder Ihres Verzeichnisses durch ein
        bestimmtes Koordinatenpaar definiert werden. (Erinnern Sie
        sich an die Syntax einer <quote>Peg-Revision</quote> &ndash;
        foo.c@224 &ndash; die in <xref
        linkend="svn.advanced.pegrevs"/> erwähnt wurde.) </para>

<!--
      <para>First, you might need to use <command>svn log</command> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <userinput>svn log - -verbose</userinput>
        in a directory that used to contain your deleted item.  The
        <option>- -verbose</option> (<option>-v</option>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).  If you know that
        the item in question was recently deleted you might also use
        the <option>- -limit</option> option to keep the log output brief
        enough to examine manually.</para>
-->
      <para>Zunächst sollten Sie <command>svn log</command> benutzen,
        um das exakte Koordinatenpaar zu ermitteln, das Sie
        zurückholen wollen. Eine gute Strategie ist es, <userinput>svn
        log --verbose</userinput> in einem Verzeichnis aufzurufen, in
        dem das gelöschte Objekt einmal enthalten war. Die Option
        <option>--verbose</option> (<option>-v</option>) gibt eine
        Liste aller geänderten Objekte in jeder Revision aus; Sie
        müssen nur noch die Revision finden, in der Sie die Datei oder
        das Verzeichnis gelöscht haben. Sie können das visuell tun
        oder ein Werkzeug zur Untersuchung der Protokollausgaben
        einsetzen (mit <command>grep</command> oder vielleicht durch
        eine inkrementelle Suche in einem Editor). Falls Sie wissen,
        dass das fragliche Objekt kürzlich gelöscht wurde, können Sie
        auch die Option <option>--limit</option> verwenden, um die
        Protokollausgabe für eine manuelle Untersuchung knapp genug zu
        halten.</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn log -v --limit 3
------------------------------------------------------------------------ <!--
r401 | sally | 2013-02-19 23:15:44 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
-->
r401 | sally | 2013-02-18 23:15:44 -0500 (Di, 19. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/trunk/src/main.c
<!--
Follow-up to r400: Fix typos in help text.
-->
Nachtrag zu r400: Tippfehler im Hifetext.
------------------------------------------------------------------------<!--
r400 | bill | 2013-02-19 20:55:08 -0500 (Tue, 19 Feb 2013) | 4 lines
Changed paths:-->
r400 | bill | 2013-02-19 20:55:08 -0500 (Di, 19. Feb 2013) | 4 Zeilen
Geänderte Pfade:
   M /calc/trunk/src/main.c
   D /calc/trunk/src/real.c

<!--
* calc/trunk/src/main.c: Update help text.

* calc/trunk/src/real.c: Remove this file, none of the APIs
  implemented here are used anymore.
-->
* calc/trunk/src/main.c: Hilfetext aktualisiert.

* calc/trunk/src/real.c: Datei entfernt, keine der hier implementierten
  APIs werden noch irgendwo verwendet.
------------------------------------------------------------------------<!--
r399 | sally | 2013-02-19 20:05:14 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
-->
r399 | sally | 2013-02-19 20:05:14 -0500 (Di, 19. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/trunk/src/button.c
   M /calc/trunk/src/integer.c
   M /calc/trunk/src/main.c
   M /calc/trunk/src/real.c
<!--
Undoing erroneous change committed in r392.-->
Fehlerhafte Änderung aus r392 rückgängig gemeacht.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 400.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        399.</para>
-->
      <para>In diesem Beispiel nehmen wir an, dass Sie nach der
        gelöschten Datei <filename>real.c</filename> suchen. Beim
        Durchsehen der Protokolle des Elternverzeichnisses haben Sie
        entdeckt, dass diese Datei in Revision 400 gelöscht
        wurde. Daher war die letzte Revision in der die Datei noch
        vorhanden war die unmittelbare Vorgänger-Revision. Die
        Schlussfolgerung: Sie möchten den Pfad
        <filename>/calc/trunk/real.c</filename> aus Revision 399
        zurückholen.</para>

<!--
      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>
-->
      <para>Das war der schwierige Teil &ndash; die
        Nachforschung. Nun, da Sie wissen, was Sie wiederherstellen
        wollen, haben Sie die Wahl zwischen zwei verschiedenen
        Methoden.</para>

<!--
      <para>One option is to use <command>svn merge</command> to apply
        revision 400 <quote>in reverse.</quote> (We already
        discussed how to undo changes in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.)  This
        would have the effect of re-adding <filename>real.c</filename>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <literal>HEAD</literal>.</para>
-->
      <para>Die eine Option ist, <command>svn merge</command> zu
        verwenden, um Revision 400 <quote>rückwärts</quote>
        anzuwenden. (Wir haben bereits in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>
        besprochen, wie Änderungen rückgängig gemacht werden.) Das
        hätte den Effekt, <filename>real.c</filename> als lokale
        Änderung erneut hinzuzufügen. Die Datei würde zum Hinzufügen
        ins Projektarchiv markiert, und nach der Übergabe wäre die Datei
        wieder in <literal>HEAD</literal> vorhanden.</para>

<!--
      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 400 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>main.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 400 and
        then <command>svn revert</command> the local modifications to
        <filename>main.c</filename>, but this technique doesn't
        scale well.  What if 90 files were changed in revision
        400?</para>
-->
      <para>In diesem besonderen Beispiel ist das aber wahrscheinlich
        nicht die beste Strategie. Die Rückwärts-Anwendung von
        Revision 400 würde nicht nur <filename>real.c</filename> zum
        Hinzufügen markieren, sondern, wie aus den Protokollmeldungen
        hervorgeht, dass ebenso bestimmte Änderungen an
        <filename>main.c</filename> zurücknehmen, was Sie aber
        nicht wollen. Sie können sicherlich Revision 400 rückwärts
        anwenden und dann mit <command>svn revert</command> die
        lokalen Änderungen an <filename>main.c</filename>
        zurücknehmen; allerdings ist diese Technik nicht sehr
        effektiv. Was wäre, wenn 90 Dateien in Revision 400 geändert
        worden wären?</para>

<!--
      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather to use the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>
-->
      <para>Eine zweite, zielorientiertere, Strategie ist es, den
        Befehl <command>svn merge</command> überhaupt nicht zu
        verwenden, sondern stattdessen <command>svn
        copy</command>. Kopieren Sie einfach das exakte
        <quote>Koordinatenpaar</quote> aus Revision und Pfad vom
        Projektarchiv in Ihre Arbeitskopie:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ./real.c
A         real.c

$ svn st
A  +    real.c
<!--
# Commit the resurrection.
-->
# Übertragung der Wiederbelebung
&hellip;
</screen>
      </informalexample>

<!--
      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history.</quote>  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 399.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <emphasis>without</emphasis>
        maintaining a historical link to the old file, this technique
        works just as well:</para>
-->
      <para>Das Plus-Zeichen in der Statusausgabe zeigt an, dass das
        Objekt nicht bloß zu Hinzufügen vorgemerkt ist, sondern zum
        Hinzufügen <quote>mit Geschichte</quote>. Subversion merkt
        sich, woher es kopiert wurde. Künftig wird beim Anwenden von
        <command>svn log</command> auf diese Datei die gesamte
        Geschichte, über das Zurückholen hinweg, inklusive der
        Geschichte vor Revision 399 durchlaufen. In anderen Worten,
        dieses neue <filename>real.c</filename> ist nicht wirklich
        neu; es ist ein direkter Nachfahre der ursprünglichen,
        gelöschten Datei. Dies ist normalerweise eine gute und
        nützliche Sache. Falls Sie jedoch die Datei
        <emphasis>ohne</emphasis> geschichtliche Verbindung zur alten
        Datei zurückholen wollen, funktioniert diese Technik
        ebenso gut:</para>

      <informalexample>
        <screen>
$ svn cat ^/calc/trunk/src/real.c@399 &gt; ./real.c

$ svn add real.c
A         real.c
<!--
# Commit the resurrection.
-->
# Übertragung der Wiederbelebung
&hellip;
</screen>
      </informalexample>

<!--
      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn't
        have to happen in your working copy&mdash;it can happen
        entirely in the repository:</para>
-->
      <para>Obwohl unser Beispiel zeigt, wie eine Datei zurückgeholt
        wird, sollten sie beachten, dass dieselben Techniken auch beim
        Wiederherstellen von gelöschten Verzeichnissen funktionieren.
        Beachten Sie auch, dass die Wiederherstellung nicht unbedingt
        in Ihrer Arbeitskopie passieren muss &ndash; sie kann auch
        vollständig im Projektarchiv ausgeführt werden:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ^/calc/trunk/src/real.c \ <!--
           -m "Resurrect real.c from revision 399."
Committed revision 402.
-->
           -m "real.c aus Revision 399 wiederhergestellt."
Revision 402 übertragen.

$ svn up <!--
Updating '.': -->
Aktualisiere ».«:
A    real.c <!--
Updated to revision 402.
-->
Aktualisiert zu Revision 402.
</screen>
      </informalexample>

  </sect2>

</sect1>

<!-- ================================================================= -->
<!-- ================================================================= -->
<!-- ================================================================= -->
  <sect1 id="svn.branchmerge.advanced">
<!--
    <title>Advanced Merging</title>
-->
    <title>Fortgeschrittenes Zusammenführen</title>

<!--
    <para>Here ends the automated magic.  Sooner or later, once you
      get the hang of branching and merging, you're going to have to
      ask Subversion to merge <emphasis>specific</emphasis> changes
      from one place to another.  To do this, you're going to
      have to start passing more complicated arguments to <command>svn
      merge</command>.  The next section describes the fully expanded
      syntax of the command and discusses a number of common
      scenarios that require it.</para>
-->
    <para>Hier endet die automatische Magie. sobald Sie früher oder
      später den Dreh beim Verzweigen und Zusammenführen heraus haben,
      werden Sie Subversion fragen müssen,
      <emphasis>bestimmte</emphasis> Änderungen von einem Ort zum
      anderen zusammenzuführen. Um dies tun zu können, werden Sie
      damit beginnen müssen, kompliziertere Argumente an <command>svn
      merge</command> zu übergeben. Der nächste Abschnitt beschreibt
      die vollständig erweiterte Syntax des Befehls und behandelt eine
      Anzahl verbreiteter Szenarien, die diese erforderlich macht.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.cherrypicking">
<!--
      <title>Cherrypicking</title>
-->
      <title>Rosinenpicken</title>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>cherrypicking</secondary>
        </indexterm>Just as the term <quote>changeset</quote> is often used in
        version control systems, so is the term
        <firstterm>cherrypicking</firstterm>.  This word refers to
        the act of choosing <emphasis>one</emphasis> specific
        changeset from a branch and replicating it to another.
        Cherrypicking may also refer to the act of duplicating a
        particular set of (not necessarily contiguous!) changesets
        from one branch to another.  This is in contrast to more
        typical merging scenarios, where the <quote>next</quote>
        contiguous range of revisions is duplicated
        automatically.</para>
-->
      <para>
        <indexterm>
          <primary>Merging</primary>
          <secondary>Rosinenpicken</secondary>
          </indexterm>Genauso oft wie der Begriff <quote>Änderungsmenge</quote>
        wird der Ausdruck <firstterm>Rosinenpicken</firstterm> in
        Versions-Kontroll-Systemen verwendet. Das bezieht sich darauf,
        <emphasis>eine</emphasis> bestimmte Änderungsmenge von einem
        Zweig auszuwählen und sie auf einen anderen anzuwenden.
        Rosinenpicken kann sich auch darauf beziehen, eine bestimmte
        Menge von (nicht notwendigerweise angrenzenden)
        Änderungsmengen von einem auf einen anderen Zweig zu
        duplizieren. Dieses Vorgehen steht im Gegensatz zu den üblicheren
        Merge-Szenarien, bei denen der <quote>nächste</quote>
        zusammenhängende Bereich von Revisionen automatisch dupliziert
        wird.</para>

<!--
      <para>Why would people want to replicate just a single change?
        It comes up more often than you'd think.  For example, let's
        assume you've created a new feature branch <filename>
        /calc/branches/my-calc-feature-branch</filename> copied from
        <filename>/calc/trunk</filename>:</para>
-->
      <para>Warum sollte jemand nur eine einzelne Änderung wollen? Das
        kommt häufiger vor, als Sie denken. Gehen wir beispielsweise
        einmal davon aus, dass Sie einen neuen Arbeitszweig <filename>
        /calc/branches/my-calc-feature-branch</filename> durch
        kopieren von <filename>/calc/trunk</filename> erstellt
        haben:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/new-calc-feature-branch -v -r403
------------------------------------------------------------------------<!--
r403 | user | 2013-02-20 03:26:12 -0500 (Wed, 20 Feb 2013) | 1 line
Changed paths:-->
r403 | user | 2013-02-20 03:26:12 -0500 (Mi, 20. Feb 2013) | 1 Zeile
Geänderte Pfade:
   A /calc/branches/new-calc-feature-branch (from /calc/trunk:402)
<!--
Create a new calc branch for Feature 'X'.
-->
Einen neuen Zweig calc für Arbeit an 'X' erzeugt.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>At the water cooler, you get word that Sally made an interesting
        change to <filename>main.c</filename> on the trunk.
        Looking over the history of commits to the trunk, you see that
        in revision 413 she fixed a critical bug that directly
        impacts the feature you're working on.  You might not be ready
        to merge all the trunk changes to your branch just yet, but
        you certainly need that particular bug fix in order to continue
        your work.</para>
-->
      <para>In der Kaffeeküche bekommen Sie mit, dass Sally eine
        interessante Änderung an <filename>main.c</filename> auf
        Trunk gemacht hat. Als Sie sich die Geschichte der
        Übertragungen auf Trunk ansehen, entdecken Sie, dass sie in
        Revision 413 einen kritischen Fehler beseitigt hat, der
        direkte Auswirkungen auf die Funktion hat, an der Sie gerade
        arbeiten.  Es kann sein, dass Sie noch nicht bereit sind, alle
        Änderungen vom Stamm zu übernehmen, jedoch benötigen Sie diese
        bestimmte Fehlerbehebung, um mit Ihrer Arbeit weitermachen zu
        können.</para>

<!--
      <para>Just as you used <command>svn diff</command> in the prior
        example to examine revision 355, you can pass the same option
        to <command>svn merge</command>:</para>
-->
      <para>Ebenso wie Sie <command>svn diff</command> im vorigen
        Beispiel benutzt haben, um sich Revision 355 anzusehen, können
        Sie die gleiche Option an <command>svn merge</command>
        übergeben:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/trunk -r413 -v
------------------------------------------------------------------------<!--
r413 | sally | 2013-02-21 01:57:51 -0500 (Thu, 21 Feb 2013) | 3 lines
Changed paths:-->
r413 | sally | 2013-02-21 01:57:51 -0500 (Do, 21. Feb 2013) | 3 Zeilen
Geänderte Pfade:
   M /calc/trunk/src/main.c
<!--
Fix issue #22 'Passing a null value in the foo argument
of bar() should be a tolerated, but causes a segfault'.
-->
Fehler #22 'Übergabe eines Null-Wertes im Argument foo von bar()
sollte erlaubt sein, aber ruft Schutzverletzung hervor'.
------------------------------------------------------------------------

$ svn diff ^/calc/trunk -c413
Index: src/main.c
=================================================================== <!--
- - src/main.c  (revision 412)
+++ src/main.c  (revision 413) -->
--- src/main.c  (Revision 412)
+++ src/main.c  (Revision 413)
@@ -34,6 +34,7 @@
&hellip;<!--
Details of the fix-->
Details zur Fehlerbehebung
&hellip;
</screen>
      </informalexample>

<!--
      <para>Just as you used <command>svn diff</command> in the prior
        example to examine revision 413, you can pass the same option
        to <command>svn merge</command>:</para>
-->
      <para>So wie Sie <command>svn diff</command> im vorangegangenen
        Beispiel verwendet haben, um Revision 413 zu untersuchen,
        können Sie die gleiche Option an <command>svn merge</command>
        übergeben:</para>

      <informalexample>
        <screen>
$ cd new-calc-feature-branch

$ svn merge ^/calc/trunk -c413 <!--
- - - Merging r413 into '.':
-->
--- Zusammenführen von r413 in ».«:
U    src/main.c<!--
- - Recording mergeinfo for merge of r413 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r413 in ».«:
 U   .

$ svn st
 M      .
M       src/main.c
</screen>
      </informalexample>

<!--
      <para>You can now go through the usual testing procedures before
        committing this change to your branch.  After the commit,
        Subversion updates the <literal>svn:mergeinfo</literal> on your
        branch to reflect that r413 was been merged to the branch.  This
        prevents future automatic sync merges from attempting to merge
        r413 again.  (Merging the same change to the same branch almost
        always results in a conflict!) Notice also the mergeinfo <literal>
        /calc/branches/my-calc-branch:341-379</literal>.  This was
        recorded during the earlier reintegrate merge to <filename>
        /calc/trunk</filename> from the <filename>
        /calc/branches/my-calc-branch</filename> branch which we made in
        r380.  When we created the <filename>my-calc-branch</filename>
        branch in r403, this mergeinfo was carried along with the copy.
        </para>
-->
      <para>Sie können nun Ihre üblichen Tests durchführen, bevor Sie
        diese Änderung an den Zweig übertragen. Nach der Übertragung
        bringt Subversion das <literal>svn:mergeinfo</literal> ihres
        Zweigs auf den neuesten Stand, um festzuhalten, dass r413 mit
        dem Zweig zusammengeführt wurde. Das verhindert, dass künftige
        automatische Synchronisierungs-Merges versuchen, r413 erneut
        zusammenzuführen. (Das Mergen derselben Änderung auf denselben
        Zweig führt fast immer zu einem Konflikt!) Beachten Sie auch
        das Mergeinfo <literal>
        /calc/branches/my-calc-branch:341-379</literal>, Das wurde bei
        unserem in r380 gemachten Reintegrations-Merge nach
        <filename>/calc/trunk</filename> vom Zweig <filename>
        /calc/branches/my-calc-branch</filename> aufgezeichnet. Als
        wir den Zweig <filename>my-calc-branch</filename> in r403
        erstellt haben, wurde diese Mergeinfo mit der Kopie
        mitgenommen.</para>

      <informalexample>
        <screen>
$ svn pg svn:mergeinfo -v<!--
Properties on '.':-->
Eigenschaften von ».«:
  svn:mergeinfo
    /calc/branches/my-calc-branch:341-379
    /calc/trunk:413
</screen>
      </informalexample>

<!--
      <para>Notice too that the <command>mergeinfo</command> doesn't list r413
        as "eligible" to merge, because it's already been merged:</para>
-->
      <para>Beachten Sie auch, dass <command>mergeinfo</command> r413
        nicht als Kandidaten für einen Merge anzeigt, da sie bereits
        zusammengeführt wurde:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r404
r405
r406
r407
r409
r410
r411
r412
r414
r415
r416
&hellip;
r455
r456
r457
</screen>
      </informalexample>

<!--
      <para>The preceding means that when the time finally comes to do an
        automatic sync merge, Subversion breaks the merge into two parts.
        First it merges all eligible merges up to revision 412.  Then it
        merges all eligible revisions from revisions 414 to the <literal>HEAD
        </literal> revision.  Because we already cherrypicked r413, that
        change is skipped:</para>
-->
      <para>Das oben stehende bedeutet, dass Subversion den Merge in
        zwei Teile aufspaltet, wenn schließlich die Zeit für einen
        automatischen Synchronisierungs-Merge gekommen ist. Zunächst
        werden alle in Frage kommenden Merges bis Revision 412
        ausgeführt. Dann werden alle in Frage kommenden Revisionen
        von Revision 412 bis zur Revision <literal>HEAD</literal>
        zusammengeführt. Da wir uns bereits r413 herausgepickt haben,
        wird diese Änderung übersprungen:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk <!--
- - Merging r403 through r412 into '.':
-->
--- Zusammenführen von r403 bis r412 in ».«:
U    doc/INSTALL
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README<!--
- - Merging r414 through r458 into '.':
-->
--- Zusammenführen von r414 bis r458 in ».«:
G    doc/INSTALL
G    src/main.c
G    src/integer.c
G    Makefile<!--
- - Recording mergeinfo for merge of r403 through r458 into '.':-->
-- Aufzeichnung der Informationen für Zusammenführung von r403 bis r458 in ».«:
 U   .
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>backporting</secondary>
        </indexterm>This use case of replicating
        (or <firstterm>backporting</firstterm>) bug fixes from one
        branch to another is perhaps the most popular reason for
        cherrypicking changes; it comes up all the time, for example,
        when a team is maintaining a <quote>release branch</quote> of
        software.  (We discuss this pattern in
        <xref linkend="svn.branchmerge.commonpatterns.release"/>.)</para>
-->
      <para>
        <indexterm>
          <primary>Merging</primary>
          <secondary>nachziehen</secondary>
        </indexterm>Dieser Anwendungsfall des Abgleichens (oder
        <firstterm>Nachziehens</firstterm>) von Fehlerbehebungen von
        einem Zweig zu einem anderen ist vielleicht der gängigste
        Grund des Rosinenpickens bei Änderungen; es kommt ständig vor,
        beispielsweise, wenn ein Team einen
        <quote>Software-Release-Zweig</quote> verwendet.  (Wir
        erörtern dieses Muster in
        <xref linkend="svn.branchmerge.commonpatterns.release"/>.)
      </para>

      <warning>
<!--
        <para>Did you notice how, in the last example, the merge
          invocation merged two distinct ranges?
          The <command>svn merge</command> command applied
          two independent patches to your working copy to skip over
          changeset 413, which your branch already contained.  There's
          nothing inherently wrong with this, except that it has the
          potential to make conflict resolution trickier.  If the
          first range of changes creates conflicts,
          you <emphasis>must</emphasis> resolve them interactively for
          the merge process to continue and apply the second range of
          changes.  If you postpone a conflict from the first wave of
          changes, the whole merge command will bail out with an error
          message and you must resolve the conflict before running the
          merge a second time to get the remainder of the changes.</para>
-->
        <para>Haben Sie bemerkt, wie im letzten Beispiel der Aufruf
          von <command>svn merge</command> zwei unterschiedliche
          Abgleichsintervalle zusammengeführt hat? Der Befehl führte
          zwei unabhängige Patches auf Ihrer Arbeitskopie aus, um die
          Änderungsmenge 413 zu überspringen, die Ihr Zweig bereits
          beinhaltete. An und für sich ist daran nichts falsch, bis
          auf die Tatsache, dass die Möglichkeit besteht, eine
          Konfliktauflösung komplizierter zu machen. Falls das erste
          Änderungsintervall Konflikte erzeugt,
          <emphasis>müssen</emphasis> Sie diese interaktiv auflösen,
          um den Merge fortzusetzen und das zweite Änderungsintervall
          anzuwenden. Wenn Sie die Konfliktauflösung der ersten Phase
          aufschieben, wird der komplette Merge-Befehl mit einer
          Fehlermeldung abbrechen und Sie müssen den Konflikt
          auflösen, bevor Sie den Merge erneut anwenden, um den Rest
          der Änderungen zu bekommen.</para>
      </warning>

<!--
      <para>A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in <xref linkend="svn.ref.svn"/> for details, or ask
        <command>svn help</command>.  For example, <command>svn
        merge</command> requires a working copy path as a target, that is,
        a place where it should apply the generated patch.  If the
        target isn't specified, it assumes you are trying to perform
        one of the following common operations:</para>
-->
      <para>Ein Wort zur Warnung: Während <command>svn diff</command>
        und <command>svn merge</command> vom Konzept her sehr ähnlich
        sind, haben sie in vielen Fällen eine unterschiedliche Syntax.
        Stellen Sie sicher, dass Sie Details hierzu in <xref
        linkend="svn.ref.svn"/> nachlesen oder <command>svn help</command>
        fragen. Zum Beispiel benötigt <command>svn merge</command>
        einen Pfad in der Arbeitskopie als Ziel, d.h., einen Ort, an
        dem es den erzeugten Patch anwenden kann. Falls das Ziel
        nicht angegeben wird, nimmt es an, dass Sie eine der folgenden
        häufigen Operationen durchführen möchten:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>You want to merge directory changes into your current
            working directory.</para>
-->
          <para>Sie möchten Verzeichnisänderungen auf Ihr aktuelles
            Arbeitsverzeichnis abgleichen.</para>
        </listitem>
        <listitem>
<!--
          <para>You want to merge the changes in a specific file into
            a file by the same name that exists in your current working
            directory.</para>
-->
          <para>Sie möchten die Änderungen in einer bestimmten Datei
            mit einer Datei gleichen Namens in Ihrem aktuellen
            Arbeitsverzeichnis zusammenführen.</para>
        </listitem>
      </itemizedlist>

<!--
      <para>If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first
        case and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a
        file by the same name) exists in your current working
        directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>
-->
      <para>Falls Sie ein Verzeichnis zusammenführen und keinen
        Zielpfad angegeben haben, nimmt <command>svn merge</command>
        den ersten Fall an und versucht, die Änderungen auf Ihr
        aktuelles Arbeitsverzeichnis anzuwenden. Falls Sie eine Datei
        zusammenführen und diese Datei (oder eine gleichnamige Datei)
        in Ihrem aktuellen Arbeitsverzeichnis existiert, nimmt
        <command>svn merge</command> den zweiten Fall an und wendet
        die Änderungen auf eine lokale Datei gleichen Namens
        an.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.advancedsyntax">
<!--
      <title>Merge Syntax: Full Disclosure</title>
-->
      <title>Merge-Syntax: Die vollständige Offenlegung</title>

<!--
      <para>You've now seen some examples of the <command>svn
        merge</command> command, and you're about to see several more.
        If you're feeling confused about exactly how merging works,
        you're not alone.  Many users (especially those new to version
        control) are initially perplexed about the proper syntax of
        the command and about how and when the feature should be
        used.  But fear not, this command is actually much simpler
        than you think!  There's a very easy technique for
        understanding exactly how <command>svn merge</command>
        behaves.</para>
-->
      <para>Sie haben nun einige Beispiele zum Befehl <command>svn
        merge</command> gesehen und werden bald einige mehr sehen.
        Falls Sie verwirrt sind, wie das Zusammenführen genau
        funktioniert, sind Sie nicht allein. Viele Anwender (besonders
        diejenigen, für die Versionskontrolle etwas Neues ist) sind
        anfangs verwirrt mit der korrekten Syntax des Befehls und wann
        das Feature verwendet werden soll.  Aber, keine Angst, dieser
        Befehl ist tatsächlich viel einfacher als Sie denken! Es gibt
        eine einfache Technik, zum genauen Verstehen des Verhaltens
        von <command>svn merge</command>.</para>

<!--
      <para>The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that some sort of mysterious
        blending of data is going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>
-->
      <para>Die Hauptquelle der Verwirrung ist der
        <emphasis>Name</emphasis> des Befehls. Der Begriff
        <quote>merge</quote> (Zusammenführung, Mischung) deutet
        irgendwie an, dass Zweige miteinander verschmolzen werden,
        oder dass irgendeine geheimnisvolle Mischung der Daten
        erfolgt. Das ist nicht der Fall. Ein besserer Name für den
        Befehl wäre vielleicht <command>svn
        ermittele-die-Unterschiede-und-wende-sie-an</command>
        gewesen, da das alles ist, was passiert: Die Bäume im
        Projektarchiv werden verglichen und die Unterschiede in eine
        Arbeitskopie eingearbeitet.</para>

<!--
      <para>If you're using <command>svn merge</command> to do basic
        copying of changes between branches, an automatic merge will
        generally do the right thing.  For example, a command such as the
        following,</para>
-->
      <para>Falls Sie <command>svn merge</command> benutzen, um
        einfache Kopien von Änderungen zwischen Zweigen vorzunehmen,
        wird ein automatischer Merge üblicherweise das Richtige machen.
        Beispielsweise wird ein Befehl wie der folgende:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/some-branch
</screen>
      </informalexample>

<!--
      <para>will attempt to duplicate any changes made
        on <filename>some-branch</filename> into your current working
        directory, which is presumably a working copy that shares some
        historical connection to the branch.  The command is smart
        enough to only duplicate changes that your working copy
        doesn't yet have.  If you repeat this command once a week, it
        will only duplicate the <quote>newest</quote> branch changes
        that happened since you last merged.</para>
-->
      <para>versuchen, alle Änderungen, die auf
        <filename>some-branch</filename> gemacht worden sind, in Ihr
        aktuelles Arbeitsverzeichnis zu kopieren, das vermutlich eine
        irgendeine mit dem Zweig historisch verbindene Arbeitskopie
        ist. Der Befehl ist intelligent genug, nur die Änderungen zu
        kopieren, die noch nicht in Ihrer Arbeitskopie sind. Wenn Sie
        diesen Befehl einmal pro Woche wiederholen, wird er nur die
        <quote>neuesten</quote> Änderungen vom Zweig kopieren, die
        seit Ihrem letzten Merge stattfanden.</para>

<!--
      <para>If you choose to use the <command>svn merge</command>
        command in all its full glory by giving it specific revision
        ranges to duplicate, the command takes three main
        arguments:</para>
-->
      <para>Wenn Sie den Befehl <command>svn merge</command> in seiner
        ganzen Pracht wählen, indem Sie ihm bestimmte
        Revisionsintervalle zum Kopieren übergeben, benötigt der
        Befehl drei Hauptargumente:</para>

      <orderedlist>
        <indexterm>
<!--
          <primary>merging</primary>
          <secondary>left side</secondary>
-->
          <primary>Merging</primary>
          <secondary>linke Seite</secondary>
        </indexterm>
        <indexterm>
<!--
          <primary>merging</primary>
          <secondary>right side</secondary>
-->
          <primary>Merging</primary>
          <secondary>rechte Seite</secondary>
        </indexterm>
        <indexterm>
<!--
          <primary>merging</primary>
          <secondary>target</secondary>
-->
          <primary>Merging</primary>
          <secondary>Ziel</secondary>
        </indexterm>

        <listitem>
<!--
          <para>An initial repository tree (often called the
            <firstterm>left side</firstterm> of the comparison)</para>
-->
          <para>Einen Startbaum im Projektarchiv (häufig
            <firstterm>linke Seite</firstterm> des Vergleichs
            genannt)</para>
        </listitem>
        <listitem>
<!--
          <para>A final repository tree (often called the
            <firstterm>right side</firstterm> of the
            comparison)</para>
-->
          <para>Einen Endbaum im Projektarchiv (häufig
            <firstterm>rechte Seite</firstterm> des Vergleichs
            genannt)</para>
        </listitem>
        <listitem>
<!--
          <para>A working copy to accept the differences as local
            changes (often called the <firstterm>target</firstterm> of
            the merge)</para>
-->
          <para>Eine Arbeitskopie, die die Unterschiede als lokale
            Änderungen aufnimmt (häufig <firstterm>Ziel</firstterm>
            der Zusammenführung genannt)</para>
        </listitem>
      </orderedlist>

<!--
      <para>Once these three arguments are specified, then the two trees
        are compared and the differences applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>
-->
      <para>Sobald diese drei Argumente angegeben sind, werden die
        zwei Bäume miteinander verglichen und die Unterschiede als
        lokale Änderungen auf das Ziel angewendet. ist der Befehl
        abgeschlodssen, sieht das Ergebnis so aus, als hätten
        Sie die Dateien manuell editiert oder verschiedene
        <command>svn add</command>- oder <command>svn
        delete</command>-Befehle ausgeführt. Wenn Ihnen das Ergebnis
        gefällt, können Sie es übertragen. Falls nicht, können Sie
        einfach alle Änderungen mit <command>svn revert</command>
        rückgängig machen.</para>

<!--
      <para>The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>
-->
      <para>Die Syntax von <command>svn merge</command> erlaubt Ihnen,
        die drei notwendigen Argumente auf eine recht flexible Weise
        anzugeben. Hier sind einige Beispiele:</para>

      <informalexample>
        <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>
      </informalexample>

<!--
      <para>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax is used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.
        <indexterm>
          <primary>merging</primary>
          <secondary>2-URL</secondary>
        </indexterm> This type of merge is referred to (for obvious
        reasons) as a <quote>2-URL</quote> merge.  The last syntax shows
        how the working copy argument is optional; if omitted, it
        defaults to the current directory.</para>
-->
      <para>Die erste Syntax führt alle drei Argumente explizit auf,
        indem jeder Baum mit dem Format <emphasis>URL@REV</emphasis>
        bezeichnet und die Ziel-Arbeitskopie angegeben wird. Die
        zweite Syntax wird als Kurzform verwendet, wenn Sie
        zwei unterschiedliche Revisionen desselben URL vergleichen.
        <indexterm>
          <primary>Merging</primary>
          <secondary>2-URL</secondary>
        </indexterm>Die letzte Syntax zeigt, dass das Arbeitskopie-Argument
        optional ist; entfällt es, wird das aktuelle Verzeichnis
        genommen.</para>

<!--
      <para>While the first example shows the <quote>full</quote>
        syntax of <command>svn merge</command>, use it
        very carefully;  it can result in merges which do not record
        any <literal>svn:mergeinfo</literal> metadata at all.  The
        next section talks a bit more about this.</para>
-->
      <para>Obwohl das erste Beispiel die <quote>vollständige</quote>
        Syntax von <command>svn merge</command> zeigt, verwenden Sie
        sie sehr sorgfältig; es können hierbei Merges entstehen, bei
        denen keinerlei <literal>svn:mergeinfo</literal>-Metadaten
        aufgezeichnet werden. Der nächste Abschnitt geht näher darauf
        ein.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.nomergedata">
<!--
      <title>Merges Without Mergeinfo</title>
-->
      <title>Mergen ohne Mergeinfo</title>

<!--
      <para>Subversion tries to generate merge metadata whenever it
        can, to make future invocations of <command>svn
        merge</command> smarter.  There are still situations, however,
        where <literal>svn:mergeinfo</literal> data is not created or
        changed.  Remember to be a bit wary of these scenarios:</para>
-->
      <para>Subversion versucht immer wenn es kann, Metadaten über das
        Zusammenführen zu erzeugen, um spätere Aufrufe von
        <command>svn merge</command> klüger zu machen. Trotzdem
        gibt es Situationen, in denen
        <literal>svn:mergeinfo</literal>-Daten nicht erzeugt oder
        geändert werden.  Denken Sie daran, vor diesen Szenarien auf
        der Hut zu sein:</para>

      <variablelist>
        <varlistentry>
<!--
          <term>Merging unrelated sources</term>
-->
          <term>Zusammenführen von Quellen ohne Beziehung</term>
          <listitem>
<!--
            <para>If you ask <command>svn merge</command> to compare
              two URLs that aren't related to each other, a patch is
              still generated and applied to your working copy, but
              no merging metadata is created.  There's no common
              history between the two sources, and
              future <quote>smart</quote> merges depend on that common
              history.</para>
-->
            <para>Falls Sie <command>svn merge</command> dazu
              auffordern, zwei URLs zu vergleichen, die nicht
              miteinander in Beziehung stehen, wird trotzdem ein Patch
              erzeugt und auf die Arbeitskopie angewendet, allerdings
              werden keine Metadaten erzeugt. Es gibt keine gemeinsame
              Geschichte der zwei Quellen, und spätere
              <quote>kluge</quote> Merges hängen von dieser
              gemeinsamen Geschichte ab.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term>Merging from foreign repositories</term>
-->
          <term>Zusammenführen aus fremden Projektarchiven</term>
          <listitem>
<!--
            <para>While it's possible to run a command such
              as <userinput>svn merge -r 100:200
              <replaceable>http://svn.foreignproject.com/repos/trunk</replaceable></userinput>,
              the resultant patch also lacks any historical merge
              metadata.  At the time of this writing, Subversion has no
              way of representing different repository URLs within
              the <literal>svn:mergeinfo</literal> property.</para>
-->
            <para>Obwohl es möglich ist, einen Befehl wie
              <userinput>svn merge -r 100:200
              <replaceable>http://svn.foreignproject.com/repos/trunk</replaceable></userinput>
              auszuführen, hat auch dieser resultierende Patch keine
              historischen Metadaten über die Zusammenführung.
              Zum gegenwärtigen Zeitpunkt hat Subversion keine
              Möglichkeit, unterschiedliche Projektarchiv-URLs
              mit Eigenschaft <literal>svn:mergeinfo</literal> zu
              repräsentieren.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term>Using <option>- -ignore-ancestry</option></term>
-->
          <term>Verwendung von <option>--ignore-ancestry</option></term>
          <listitem>
<!--
            <para>If this option is passed to <command>svn
              merge</command>, it causes the merging logic to
              mindlessly generate differences the same way
              that <command>svn diff</command> does, ignoring any
              historical relationships.  We discuss this later in this
              chapter in
              <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
-->
          <para>Wenn diese Option an <command>svn merge</command>
            übergeben wird, veranlasst das die Merge-Logik, ohne
            nachzudenken Unterschiede auf dieselbe Art zu erzeugen,
            wie es <command>svn diff</command> macht und ignoriert
            dabei irgendwelche historischen Verbindungen. Wir werden
            das später in diesem Kapitel in
            <xref linkend="svn.branchmerge.advanced.ancestry"/>
            erörtern.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term>Applying reverse merges from a target's natural history</term>
-->
          <term>Zusammenführen rückgängig machen</term>
          <listitem>
<!--
            <para>Earlier in this chapter
              (<xref linkend="svn.branchmerge.basicmerging.undo"/>) we
              discussed how to use <command>svn merge</command> to
              apply a <quote>reverse patch</quote> as a way of rolling
              back changes.  If this technique is used to undo a
              change to an object's personal history (e.g., commit r5
              to the trunk, then immediately roll back r5
              using <userinput>svn merge . -c -5</userinput>), this
              sort of merge doesn't affect the recorded
              mergeinfo.<footnote><para>Interestingly, after rolling
              back a revision like this, we wouldn't be able to
              reapply the revision using <userinput>svn merge . -c
              5</userinput>, since the mergeinfo would already list r5
              as being applied.  We would have to use
              the <option>- -ignore-ancestry</option> option to make
              the merge command ignore the existing
              mergeinfo!</para></footnote></para>
-->
            <para>Weiter oben in diesem Kapitel 
              (<xref linkend="svn.branchmerge.basicmerging.undo"/>)
              haben wir darüber gesprochen, wie man mit <command>svn
              merge</command> einen <quote>Rückwärts-Patch</quote>
              verwendet, um Änderungen rückgängig zu machen. Wenn
              diese Technik dazu verwendet wird, um eine Änderung in
              der Geschichte eines Objektes zurückzunehmen (z.B. r5
              an den Stamm übertragen, und dann sofort r5 mit
              <userinput>svn merge . -c -5</userinput> rückgängig
              machen), hat dies keine Auswirkungen auf die
              aufgezeichneten
              Mergeinfo.<footnote><para>Interessanterweise werden wir
              nach dem Zurücknehmen einer Revision auf diese Art nicht
              in der Lage sein, diese Revision erneut mit
              <userinput>svn merge . -c 5</userinput> anzuwenden, da
              aus den Metadaten hervorgeht, dass r5 bereits angewendet
              wurde. Wir müssten die Option
              <option>--ignore-ancestry</option> verwenden, damit der
              Befehl die bestehenden Metadaten
              ignoriert.</para></footnote></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <!-- TODO: We might need to introduce a glossary of merge
                 tracking terms into this chapter.  Here we use
                 "mergeinfo" to help defined "natural history", but
                 we've not really defined "mergeinfo" either.  -->

      <sidebar id="svn.branchmerge.nomergedata.impicit.mergeinfo">
<!--
        <title>Natural History and Implicit Mergeinfo</title>
-->
        <title>Natürliche Historie und implizite Mergeinfo</title>

<!--
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>implicit</secondary>
          </indexterm>
          <indexterm>
            <primary>natural history</primary>
            <see>mergeinfo, implicit</see>
          </indexterm>As we mentioned earlier when discussing
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>,
          a path that has the
          <literal>svn:mergeinfo</literal> property set on it is said to
          have <quote>explicit</quote> mergeinfo.  Yes, this implies a
          path can have <quote>implicit</quote> mergeinfo, too!  Implicit
          mergeinfo, or <firstterm>natural history</firstterm>, is
          simply a path's own history (see
          <xref linkend="svn.tour.history" />) interpreted as mergeinfo.
          While implicit mergeinfo is largely
          an implementation detail, it can be a useful abstraction for
          understanding merge tracking behavior.</para>
-->
        <para>
          <indexterm>
            <primary>Mergeinfo</primary>
            <secondary>implizit</secondary>
          </indexterm>
          <indexterm>
            <primary>natürliche Historie</primary>
            <see>Mergeinfo, implizit</see>
          </indexterm>Wie wir bei der Erörterung von
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>
          bereits erwähnten, sagt man, dass ein Pfad mit der gesetzten
          Eigenschaft <literal>svn:mergeinfo</literal>
          <quote>explizite</quote> Mergeinfo besitzt. Ja, das
          bedeutet, dass ein Pfad auch <quote>implizite</quote>
          Mergeinfo haben kann! Implizite Mergeinfo oder
          <firstterm>natürliche Historie</firstterm>, ist einfach die
          dem Pfad eigene Historie (siehe
          <xref linkend="svn.tour.history" />) die als Information zur
          Verfolgung von Zusammenführungen interpretiert wird. Obwohl
          es sich bei impliziter Mergeinfo größtenteils um Details der
          Implementierung handelt, kann es als nützliche Abstraktion
          für das Verstehen des Verhaltens des
          Merge-Trackings dienen.</para>

<!--
        <para>Let's say you created <filename>^/trunk</filename> in
          revision 100 and then later, in revision 201,
          created <filename>^/branches/feature-branch</filename> as
          a copy of <filename>^/trunk@200</filename>.  The natural
          history of <filename>^/branches/feature-branch</filename>
          contains all the repository paths and revision ranges
          through which the history of the new branch has ever
          passed:</para>
-->
        <para>Nehmen wir mal an, Sie hätten in Revision 100
          <filename>^/trunk</filename> erzeugt und dann in Revision
          201 <filename>^/branches/feature-branch</filename> als
          Kopie von <filename>^/trunk@200</filename> erzeugt. Die
          natürliche Historie von
          <filename>^/branches/feature-branch</filename>
          enthält all diejenigen Pfade im Projektarchiv und
          Revisionsintervalle, die die Historie des neuen Zweigs je
          berührt hat.</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201
</literallayout>
        </informalexample>

<!--
        <para>With each new revision added to the repository, the
          natural history&mdash;and thus, implicit mergeinfo&mdash;of
          the branch continues to expand to include those revisions
          until the day the branch is deleted.  Here's what the
          implicit mergeinfo of our branch would look like when
          the <literal>HEAD</literal> revision of the repository had
          grown to 234:</para>
-->
        <para>Mit jeder dem Projektarchiv hinzugefügten neuen Revision
          wird die natürliche Historie &ndash; und somit die implizite
          Mergeinfo &ndash; des Zweigs durch diese Revisionen stetig
          erweitert, bis zu dem Tag, an dem der Zweig gelöscht wird.
          So würde die implizite Mergeinfo unseres Zweiges aussehen,
          wenn die <literal>HEAD</literal>-Revision des Projektarchivs
          bis auf 234 angewachsen wäre:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201-234
</literallayout>
        </informalexample>

<!--
        <para>Implicit mergeinfo does not actually show up in the
          <literal>svn:mergeinfo</literal> property, but Subversion
          acts as if it does.  This is why if you check out
          <filename>^/branches/feature-branch</filename> and then
          run <userinput>svn merge ^/trunk -c 58</userinput> in the
          resulting working copy, nothing happens.  Subversion knows
          that the changes committed to <filename>^/trunk</filename>
          in revision 58 are already present in the target's natural
          history, so there's no need to try to merge them again.
          After all, avoiding repeated merges of
          changes <emphasis>is</emphasis> the primary goal of
          Subversion's merge tracking feature!</para>
-->
        <para>Implizite Mergeinfo taucht nicht wirklich in der
          Eigenschaft <literal>svn:mergeinfo</literal> auf, doch
          Subversion handelt so, als tauchte sie dort auf. Das ist
          der Grund dafür, dass nichts passiert, wenn Sie
          <filename>^/branches/feature-branch</filename> auschecken
          und dann <userinput>svn merge ^/trunk -c 58</userinput> in
          der so erstellten Arbeitskopie aufrufen. Subversion weiß,
          dass die in Revision 53 an <filename>^/trunk</filename>
          übertragenen Änderungen bereits in der natürlichen Historie
          des Ziels vorhanden sind, so dass sie nicht erneut
          zusammengeführt werden müssen. Letzten Endes
          <emphasis>ist</emphasis> es das primäre Ziel der
          Merge-Tracking-Funktionalität von Subversion, unnötige
          Zusammenführungen zu vermeiden!</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.mergeconflicts">
<!--
      <title>More on Merge Conflicts</title>
-->
      <title>Mehr über Konflikte beim Zusammenführen</title>

<!--
      <para>Just like the <command>svn update</command> command,
        <command>svn merge</command> applies changes to your working
        copy.  And therefore it's also capable of creating
        conflicts.  The conflicts produced by <command>svn
          merge</command>, however, are sometimes different, and this
        section explains those differences.</para>
-->
      <para>Wie der Befehl <command>svn update</command> wendet auch 
        <command>svn merge</command> Änderungen auf Ihre Arbeitskopie
        an.  Und deshalb kann er auch Konflikte erzeugen. Die von
        <command>svn merge</command> hervorgerufenen Konflikte sind
        jedoch manchmal anders geartet, und dieser Abschnitt erklärt
        diese Unterschiede.</para>

<!--
      <para>To begin with, assume that your working copy has no
        local edits.  When you <command>svn update</command> to a
        particular revision, the changes sent by the server
        always apply <quote>cleanly</quote> to your working copy.
        The server produces the delta by comparing two trees: a
        virtual snapshot of your working copy, and the revision tree
        you're interested in.  Because the left hand side of the
        comparison is exactly equal to what you already have, the
        delta is guaranteed to correctly convert your working copy
        into the right hand tree.</para>
-->
      <para>Zunächst gehen wir davon aus, dass Ihre Arbeitskopie keine
        lokalen Änderungen enthält. Wenn Sie mit <command>svn
        update</command> auf eine bestimmte Revision aktualisieren,
        werden die vom Server gesendeten Änderungen immer
        <quote>sauber</quote> auf Ihre Arbeitskopie angewendet. Der
        Server erzeugt das Delta, indem er zwei Bäume vergleicht: eine
        virtuelle Momentaufnahme Ihrer Arbeitskopie und der
        Revisionsbaum, an dem Sie interessiert sind. Da die linke
        Seite des Vergleichs völlig gleich zu dem ist, was Sie bereits
        haben, wird das Delta garantiert Ihre Arbeitskopie korrekt in
        den rechten Baum überführen.</para>

<!--
      <para>But <command>svn merge</command> has no such guarantees
        and can be much more chaotic: the advanced user can ask the
        server to compare <emphasis>any</emphasis> two trees at all,
        even ones that are unrelated to the working copy!  This means
        there's large potential for human error.  Users will sometimes
        compare the wrong two trees, creating a delta that doesn't
        apply cleanly. The <command>svn merge</command> subcommand does
        its best to apply as much of the delta as possible, but some
        parts may be impossible. A common sign that you merged the wrong
        delta is unexpected tree conflicts:</para>
-->
      <para><command>svn merge</command> jedoch kann das nicht
        gewährleisten und kann viel chaotischer sein: Der
        fortgeschrittene Benutzer kann den Server auffordern,
        <emphasis>irgendwelche</emphasis> zwei Bäume miteinander zu
        vergleichen, sogar solche, die nicht mit der Arbeitskopie in
        Beziehung stehen! Das bedeutet, dass ein hohes Potenzial für
        menschliche Fehler besteht. Benutzer werden manchmal die
        falschen zwei Bäume miteinander vergleichen, so dass ein Delta
        erzeugt wird, das sich nicht sauber anwenden lässt. Der
        Unterbefehl <command>svn merge</command> gibt sein Bestes,
        um soviel wie möglich vom Delta anzuwenden, doch bei einigen
        Teilen kann das unmöglich sein. Ein häufiges Anzeichen, dass
        Sie die falschen Unterschiede eingepflegt haben, sind
        unerwartete Baumkonflikte:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk -r104:115<!--
- - Merging r105 through r115 into '.':
-->
-- Zusammenführen von r105 bis r115 in ».«:
   C doc
   C src/button.c
   C src/integer.c
   C src/real.c
   C src/main.c<!--
- - Recording mergeinfo for merge of r105 through r115 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r105 bis r115 in ».«:
 U   .  <!--
Summary of conflicts:
  Tree conflicts: 3
-->
Konfliktübersicht:
  Baumkonflikte: 3

$ svn st
 M      .
!     C doc<!--
      >   local dir missing, incoming dir edit upon merge-->
      >   lokal Verzeichnis fehlend, empfangen Verzeichnis editiert bei Zusammenführung
!     C src/button.c<!--
      >   local file missing, incoming file edit upon merge-->
      >   lokal Datei fehlend, empfangen Verzeichnis editiert bei Zusammenführung
!     C src/integer.c<!--
      >   local file missing, incoming file edit upon merge-->
      >   lokal Datei fehlend, empfangen Verzeichnis editiert bei Zusammenführung
!     C src/main.c<!--
      >   local file missing, incoming file edit upon merge-->
      >   lokal Datei fehlend, empfangen Verzeichnis editiert bei Zusammenführung
!     C src/real.c<!--
      >   local file missing, incoming file edit upon merge-->
      >   lokal Datei fehlend, empfangen Verzeichnis editiert bei Zusammenführung<!--
Summary of conflicts:
  Tree conflicts: 5-->
Konfliktübersicht:
  Baumkonflikte: 5
</screen>
      </informalexample>

<!--
      <para>In the previous example, it might be the case that
        <filename>doc</filename> and the four <filename>*.c</filename>
        files all exist in both snapshots of the
        branch being compared.  The resultant delta wants to change
        the contents of the corresponding paths in your working copy,
        but those paths don't exist in the working copy.  Whatever the
        case, the preponderance of tree conflicts most likely means that
        the user compared the wrong two trees or that you are merging to
        the wrong working copy target; both are classic signs of user
        error.  When this happens, it's easy to recursively revert all
        the changes created by the merge
        (<userinput>svn revert . - -recursive</userinput>), delete any
        unversioned files or directories left behind after the
        revert, and rerun <command>svn merge</command> with the
        correct arguments.</para>
-->
      <para>Im vorangegangenen Beispiel kann es der Fall gewesen sein,
        dass <filename>doc</filename> und die vier
        <filename>*.c</filename>-Dateien alle in beiden
        Momentaufnahmen des Zweiges vorkommen, die verglichen werden.
        Das resultierende Delta will den Inhalt der entsprechenden
        Pfade in Ihrer Arbeitskopie verändern, doch sind diese Pfade
        in der Arbeitskopie aber nicht vorhanden. Wie auch immer, das
        Überwiegen von Baumkonflikten bedeutet höchstwahrscheinlich,
        dass der Benutzer die falschen Bäume miteinander verglichen
        hat oder Sie machen einen Merge auf das falsche Ziel in der
        Arbeitskopie; beides sind klassische Zeichen für einen
        Anwenderfehler. Falls dies passiert, ist es einfach, alle
        durch das Zusammenführen hervorgerufenen Änderungen rekursiv
        rückgängig zu machen (<userinput>svn revert .
        --recursive</userinput>), alle unversionierten Dateien oder
        Verzeichnisse zu löschen, die nach dem Rückgängigmachen
        zurückgeblieben sind und <command>svn merge</command> noch
        einmal mit unterschiedlichen Argumenten aufzurufen.</para>

<!--
      <para>Also keep in mind that a merge into a working copy with no
        local edits can still produce text conflicts.</para>
-->
      <para>Beachten Sie ebenfalls, dass eine Zusammenführung in eine
        Arbeitskopie ohne lokale Änderungen trotzdem Textkonflikte
        erzeugen kann.</para>

      <informalexample>
        <screen>
$ svn st

$ svn merge ^/paint/trunk -r289:291<!--
- - Merging r290 through r291 into '.':
-->
-- Zusammenführen von r290 bis r291 in ».«:
C    Makefile<!--
- - Recording mergeinfo for merge of r290 through r291 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r290 bis r291 in ».«:
 U   .  <!--
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'Makefile'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: p
-->
Konflikt in Datei »Makefile« entdeckt.
Auswahl: (p) später auflösen, (df) Änderungen anzeigen,
         (e) Dateibearbeiten, (m) Zusammenführung,
         (mc) eigene Seite des Konflikts,
         (tc) fremde Seite des Konflikts, (s) alle Optionen anzeigen: p
Konfliktübersicht:
  Textkonflikte: 1
$ svn st
 M      .
C       Makefile
?       Makefile.merge-left.r289
?       Makefile.merge-right.r291
?       Makefile.working<!--
Summary of conflicts:
  Text conflicts: 2
-->
Konfliktübersicht:
  Textkonflikte: 2
</screen>
      </informalexample>

<!--
      <para>How can a conflict possibly happen?  Again, because the user
        can request <command>svn merge</command> to define and apply any
        old delta to the working copy, that delta may contain textual
        changes that don't cleanly apply to a working file, even if
        the file has no local modifications.</para>
-->
      <para>Wie kann da ein Konflikt entstehen? Noch einmal: Weil der
        Benutzer <command>svn merge</command> dazu auffordern kann,
        ein altes Delta zu definieren und auf die Arbeitskopie
        anzuwenden, kann es sein, dass dieses alte Delta textuelle
        Änderungen enthält, die nicht sauber in eine Arbeitsdatei
        eingearbeitet werden können, selbst dann nicht, wenn die Datei
        keine lokalen Änderungen vorzuweisen hat.</para>

<!--
      <para>Another small difference between <command>svn
        update</command> and <command>svn merge</command> is the names
        of the full-text files created when a conflict happens.  In
        <xref linkend="svn.tour.cycle.resolve"/>, we saw that an
        update produces files named
        <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename>, and
        <filename>filename.rNEWREV</filename>.  When <command>svn
        merge</command> produces a conflict, though, it creates three
        files named <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename>, and
        <filename>filename.merge-right.rNEWREV</filename>.  In this case,
        the terms <quote>merge-left</quote> and <quote>merge-right</quote>
        are describing which side of the double-tree comparison the file
        came from, <quote>rOLDREV</quote> describes the revision of the
        left side, and <quote>rNEWREV</quote> the revision of the right
        side. In any case, these differing names help you distinguish
        between conflicts that happened as a result of an  update and
        ones that happened as a result of a merge.</para>
-->
      <para>Ein weiterer kleiner Unterschied zwischen <command>svn
        update</command> und <command>svn merge</command> sind die
        Namen der erzeugten Textdateien, falls ein Konflikt entsteht.
        In <xref linkend="svn.tour.cycle.resolve"/> sahen wir, dass
        bei einer Aktualisierung die Dateien namens
        <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename> und
        <filename>filename.rNEWREV</filename> erzeugt werden. Falls
        <command>svn merge</command> einen Konflikt hervorruft,
        erstellt es jedoch drei Dateien namens
        <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename> und
        <filename>filename.merge-right.rNEWREV</filename>.  In diesem
        Fall beschreiben die Begriffe  <quote>merge-left</quote> und
        <quote>merge-right</quote> von welcher Seite des Vergleichs
        zwischen den beiden Bäumen die Datei hergeleitet wurde,
        <quote>rOLDREV</quote> beschreibt die Revision auf der linken
        Seite und <quote>rNEWREV</quote> die Revision auf der rechten
        Seite. Auf alle Fälle werden Ihnen diese unterschiedlichen
        Namen dabei helfen, zwischen Konflikten zu unterscheiden, die
        durch eine Aktualisierung entstanden, und solchen die durch
        eine Zusammenführung hervorgerufen wurden .</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.blockchanges">
<!--
      <title>Blocking Changes</title>
-->
      <title>Änderungen blockieren</title>

<!--
      <para>Sometimes there's a particular changeset that you don't
        want automatically merged.  For example, perhaps your
        team's policy is to do new development work on
        <filename>/trunk</filename>, but is more conservative about
        backporting changes to a stable branch you use for releasing
        to the public.  On one extreme, you can manually cherrypick
        single changesets from the trunk to the branch&mdash;just the
        changes that are stable enough to pass muster.  Maybe things
        aren't quite that strict, though; perhaps most of the time
        you just let <command>svn merge</command>
        automatically merge most changes from trunk to branch.  In
        this case, you want a way to mask a few specific changes
        out, that is, prevent them from ever being automatically
        merged.</para>
-->
      <para>Manchmal gibt es eine bestimmte Änderungsmenge, die Sie
        nicht automatisch zusammengeführt haben wollen. Beispielsweise
        ist vielleicht die Vorgehensweise Ihres Teams dergestalt, dass
        Neuentwicklungen auf <filename>/trunk</filename> gemacht
        werden, aber konservativer, wenn es darum geht, Änderungen auf
        einen stabilen Zweig zurück zu portieren, den sie zur
        Veröffentlichung benutzen. Auf der einen Seite können Sie
        die Rosinen in Form von einzelnen Änderungsmengen manuell aus
        dem Stamm herauspicken und in den Zweig einpflegen &ndash; nur
        die Änderungen, die stabil genug sind, um die Qualitätsprüfung
        zu bestehen. Vielleicht ist es ja auch nicht ganz so streng,
        und Sie möchten normalerweise, dass <command>svn
        merge</command> die meisten Änderungen vom Stamm automatisch
        mit dem Zweig zusammenführt. In diesem Fall brauchen Sie ein
        Verfahren, dass es Ihnen erlaubt, einige bestimmte
        Änderungen auszulassen, d.h. zu vermeiden, dass sie
        automatisch in den Zweig eingebracht werden.</para>

<!--
      <para>To block a changeset you must make Subversion believe that the
        change has <emphasis>already</emphasis> been merged.  To do this,
        invoke the merge subcommand with the <option>- -record-only</option>
        option.  The option makes Subversion record mergeinfo as if it had
        actually performed the merge, but no difference is actually
        applied:</para>
-->
      <para>Um eine
        Änderungsmenge zu blockieren müssen Sie Subversion
        vorzugaukeln, dass die Änderung <emphasis>bereits</emphasis>
        eingearbeitet wurde. Dazu rufen Sie den Unterbefehl mit der Option
        <option>--record-only</option> auf. Das veranlasst Subversion
        dazu, Mergeinfo wie bei einem tatsächlichen Merge anzulegen,
        obwohl kein Diff angewendet worden ist:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn merge ^/calc/trunk -r386:388 --record-only <!--
- - Recording mergeinfo for merge of r387 through r388 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r387 bis r388 in ».«:
 U   .
 <!--
Only the mergeinfo is changed-->
Nur Mergeinfo wird geändert.
$ svn st
 M      .

$ svn pg svn:mergeinfo -vR<!--
Properties on '.':-->
Eigenschaften von ».«:
  svn:mergeinfo
    /calc/trunk:341-378,387-388

<!--
$ svn commit -m "Block r387-388 from being merged to my-calc-branch."
Sending        .

Committed revision 461.-->
$ svn commit -m "Das Zusammenführen von r387-388 mit my-calc-branch verhindern."
Sende              .

Revision 461 übertragen.
</screen>
      </informalexample>

<!--
      <para>Since Subversion 1.7, <option>- -record-only</option>
        merges are transitive.  This means that, in addition to recording
        mergeinfo describing the blocked revision(s), any
        <literal>svn:mergeinfo</literal> property differences in the
        merge source are also applied.  For example, let's say we want to
        block the 'paint-python-wrapper' feature from ever being merged from
        <filename>^/paint/trunk</filename> to the
        <filename>^/paint/branches/paint-1.0.x</filename> branch.  We know
        the work on this feature was done on its own branch, which was
        reintegrated to <filename>/paint/trunk</filename> in revision
        465:</para>
-->
      <para>Seit Subversion 1.7 sind Zusammenführungen mit
        <option>--record-only</option> transitiv. Das bedeutet, dass
        zusätzlich zur Aufzeichnung der Mergeinfo die die
        blockierte(n) Revision(en) beschreiben, alle Unterschiede der
        Eigenschaft <literal>svn:mergeinfo</literal> der Quelle
        ebenfalls angewendet werden. Sagen wir mal zum Beispiel, dass
        wir die Zusammenführung der Funktionalität
        "paint-python-wrapper" von <filename>^/paint/trunk</filename>
        mit unserem <filename>^/paint/branches/paint-1.0.x</filename>
        Zweig für immer blockieren möchten. Wir wissen, dass die
        gesamte Arbeit an dieser Funktionalität auf seinem eigenen
        Zweig gemacht wurde, der in Revision 465 wieder in
        <filename>/paint/trunk</filename> eingegliedert wurde:</para>

      <informalexample>
        <screen>
$ svn log -v -r465 ^/paint/trunk
------------------------------------------------------------------------<!--
r465 | joe | 2013-02-25 14:05:12 -0500 (Mon, 25 Feb 2013) | 1 line
Changed paths:
   M /paint/trunk
   A /paint/trunk/python (from /paint/branches/paint-python-wrapper/python:464)

Reintegrate Paint Python wrapper.
-->
r465 | joe | 2013-02-25 14:05:12 -0500 (Mo, 25. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /paint/trunk
   A /paint/trunk/python (von /paint/branches/paint-python-wrapper/python:464)

Paint Python Wrapper reintegriert.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Because revision 465 was a reintegrate merge we know
        that mergeinfo was recorded describing the merge:</para>
-->
      <para>Da Revision 465 eine Zusammenführung zur
        Wiedereingliederung war, wissen wir, dass beschreibende
        Informationen aufgezeichnet wurden:</para>

      <informalexample>
        <screen>
$ svn diff ^/paint/trunk --depth empty -c465
Index: .
===================================================================
--- .   (revision 464)
+++ .   (revision 465)
<!--
Property changes on: .
-->
Eigenschaftsänderungen: .
___________________________________________________________________ <!--
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
-->
Hinzugefügt: svn:mergeinfo
   Zusammengeführt /paint/branches/paint-python-wrapper:r463-464
</screen>
      </informalexample>

<!--
      <para>Now simply blocking merges of revision 465 from
        <filename>/paint/trunk</filename> isn't foolproof since someone could
        merge r462:464 directly from
        <filename>/paint/branches/paint-python-wrapper</filename>.
        Fortunately the transitive nature
        of <option>- -record-only</option> merges prevents this; the
        <option>- -record-only</option> merge
        applies the <literal>svn:mergeinfo</literal> diff from
        revision 465, thus blocking merges of that change directly from
        <filename>/paint/trunk</filename> <emphasis>and</emphasis> indirectly
        from <filename>/paint/branches/paint-python-wrapper</filename>:
        </para>
-->
      <para>Das einfache Blockieren der Zusammenführungen der Revision
        465 von <filename>/paint/trunk</filename> ist nicht
        narrensicher, da jemand 462:464 direkt von
        <filename>/paint/branches/paint-python-wrapper</filename>
        zusammenführen könnte. Glücklicherweise wird das durch die
        transitive Natur der Merges mit <option>--record-only</option>
        verhindert: die Zusammenführung mit
        <option>--record-only</option> wendet den
        <literal>svn:mergeinfo</literal>-Diff von Revision 465 an, und
        blockiert somit sowohl direkte Merges dieser Änderung von
        <filename>/paint/trunk</filename> <emphasis>als
        auch</emphasis> indirekte von
        <filename>/paint/branches/paint-python-wrapper</filename>:
        </para>

      <informalexample>
        <screen>
$ cd paint/branches/paint-1.0.x

$ svn merge ^/paint/trunk --record-only -c465<!--
- - Merging r465 into '.':
-->
-- Zusammenführen von r465 in ».«:
 U   .  <!--
- - Recording mergeinfo for merge of r465 into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung von r465 in ».«:
 G   .

$ svn diff --depth empty
Index: .
===================================================================<!--
- - .   (revision 462)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
   Merged /paint/trunk:r465
-->
--- .   (Revision 462)
+++ .   (Arbeitskopie)

Eigenschaftsänderungen: .
___________________________________________________________________
Hinzugefügt: svn:mergeinfo
   Zusammengeführt /paint/branches/paint-python-wrapper:r463-464
   Zusammengeführt /paint/trunk:r465
<!--
$ svn ci -m "Block the Python wrappers from the first release of paint."
Sending        .

Committed revision 466.
-->
$ svn ci -m "Die Python-Wrapper aus der ersten Release von Paint sperren."
Sende              .

Revision 466 übertragen.
</screen>
      </informalexample>

<!--
      <para>Now any subsequent attempts to merge the feature to <filename>
        /paint/trunk</filename> are inoperative:</para>
-->
      <para>Nun sind alle künftigen Versuche, die Funktionalität mit
        <filename>/paint/trunk</filename> zusammenzuführen,
        inoperativ:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465<!--
- - Recording mergeinfo for merge of r465 into '.':-->
-- Aufzeichnung der Informationen für Zusammenführung von r456 in ».«:
 U   .
<!--
$ svn st # No change!
-->
$ svn st # keine Änderung

$ svn merge ^/paint/branches/paint-python-wrapper -r462:464<!--
- - Recording mergeinfo for merge of r463 through r464 into '.':-->
-- Aufzeichnung der Informationen für Zusammenführung von r463 bis r464 in ».«:
 U   .
<!--
$ svn st  # No change!
-->
$ svn st # keine Änderung
$
</screen>
      </informalexample>

<!--
      <para>If at a later time you realize that you actually <emphasis>do
        </emphasis> need the blocked feature merged to <filename>/paint/trunk
        </filename> you have a couple of choices.  You can reverse merge r466,
        (the revision you blocked the feature), as we discussed in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.  Once you commit
        that change you can repeat the merge of r465 from <filename>
        /paint/trunk</filename>.  Alternatively, you can simply repeat the
        merge of r465 from <filename>/paint/trunk</filename> using the
        <option>- -ignore-ancestry</option> option, which will cause the merge
        to disregard any mergeinfo and simply apply the requested diff, see
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
-->
      <para>Falls Sie später feststellen, dass Sie die blockierte
        Funktionalität <emphasis>doch</emphasis> nach
        <filename>/paint/trunk </filename> herüberbringen müssen,
        haben Sie die Wahl. Sie können r466 (die Revision, in der die
        Funktionalität blockiert wurde) rückwärts patchen wie in
        <xref linkend="svn.branchmerge.basicmerging.undo"/> erörtert.
        Sobald Sie die Änderung übertragen haben, können Sie r465 die
        von <filename>/paint/trunk</filename> zusammenführen.
        Alternativ können Sie einfach r465 von
        <filename>/paint/trunk</filename> erneut zusammenführen, indem
        Sie die Option <option>--ignore-ancestry</option> verwenden,
        die beim Zusammenführen jegliche Mergeinfo ignoriert und den
        erwünschten Diff einfach anwendet; siehe
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465 --ignore-ancestry<!--
- - Merging r465 into '.':-->
-- Zusammenführen von r465 in ».«:
A    python
A    python/paint.py
 G   .
</screen>
      </informalexample>

<!--
      <para>Blocking changes with <option>- -record-only</option>
        works, but it's also a little bit
        dangerous.  The main problem is that we're not clearly
        differentiating between the ideas of <quote>I already have
        this change</quote> and <quote>I don't have this change, but
        don't currently want it.</quote> We're effectively lying to
        the system, making it think that the change was previously
        merged.  This puts the responsibility on you&mdash;the
        user&mdash;to remember that the change wasn't actually merged,
        it just wasn't wanted.  There's no way to ask Subversion for a
        list of <quote>blocked changelists.</quote> If you want to
        track them (so that you can unblock them someday) you'll need
        to record them in a text file somewhere, or perhaps in an
        invented property.</para>
-->
      <para>Das Blockieren von Änderungen mit
        <option>--record-only</option> funktioniert zwar, es ist
        allerdings auch ein wenig gefährlich. Das Hauptproblem ist,
        dass wir nicht klar unterscheiden zwischen <quote>ich habe
        diese Änderung bereits</quote> und <quote>ich habe diese
        Änderung nicht, aber ich will sie jetzt nicht</quote>. Wir
        belügen das System gewissermaßen, indem wir es glauben lassen,
        dass die Änderung schon eingearbeitet sei. Das schiebt die
        Verantwortung, sich daran zu erinnern, dass die Änderung
        tatsächlich gar nicht übernommen wurde sondern nicht gewünscht
        war, auf Sie &ndash; den Benutzer. Es gibt keine Möglichkeit,
        Subversion nach einer Liste <quote>blockierter
        Änderungen</quote> zu fragen. Wenn Sie sie verfolgen möchten
        (so dass Sie eines Tages die Blockierung aufheben können)
        müssen Sie sie irgendwo in eine Textdatei schreiben oder in
        einer erfundenen Eigenschaft festhalten.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.logblame">
<!--
      <title>Merge-Sensitive Logs and Annotations</title>
-->
      <title>Protokolle und Anmerkungen, die Zusammenführungen anzeigen</title>

<!--
      <para>One of the main features of any version control system is
        to keep track of who changed what, and when they did it.
        The <command>svn log</command> and <command>svn
        blame</command> subcommands are just the tools for this: when
        invoked on individual files, they show not only the history of
        changesets that affected the file, but also exactly which user
        wrote which line of code, and when she did it.</para>
-->
      <para>Ein Hauptmerkmal jedes Versions-Kontroll-Systems ist es,
        darüber Buch zu führen, wer was wann geändert hat. Die Unterbefehle
        <command>svn log</command> und <command>svn blame</command>
        sind die geeigneten Werkzeuge hierfür: Wenn sie auf
        individuelle Dateien angewendet werden, zeigen sie nicht nur
        die Geschichte der Änderungsmengen, die in diese Datei
        hineinflossen, sondern auch, welcher Benutzer wann welche
        Zeile im Quelltext geschrieben hat.</para>

<!--
      <para>When changes start getting replicated between branches,
        however, things start to get complicated.  For example, if you
        were to ask <command>svn log</command> about the history of
        your feature branch, it would show exactly every revision that ever
        affected the branch:</para>
-->
      <para>Wenn jedoch Änderungen über Zweige hinweg dupliziert
        werden, wird es schnell kompliziert. Wenn Sie z.B.
        <command>svn log</command> nach der Geschichte Ihres Zweigs
        fragen, wird es Ihnen exakt jede Revision anzeigen, die je in
        den Zweig hineingeflossen ist:</para>

<!--
      <informalexample>
        <screen>
$ cd my-calc-branch
$ svn log -q
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r461 | user | 2013-02-25 05:57:48 -0500 (Mon, 25 Feb 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r379 | user | 2013-02-18 10:56:35 -0500 (Mon, 18 Feb 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r378 | user | 2013-02-18 09:48:28 -0500 (Mon, 18 Feb 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
&hellip;
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r7 | bill | 2013-01-17 16:49:36 -0500 (Thu, 17 Jan 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
r3 | bill | 2013-01-17 09:07:04 -0500 (Thu, 17 Jan 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn log -q
------------------------------------------------------------------------
r461 | user | 2013-02-25 05:57:48 -0500 (Mo, 25. Feb 2013)
------------------------------------------------------------------------
r379 | user | 2013-02-18 10:56:35 -0500 (Mo, 18. Feb 2013)
------------------------------------------------------------------------
r378 | user | 2013-02-18 09:48:28 -0500 (Mo, 18. Feb 2013)
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Do, 17. Jan 2013)
------------------------------------------------------------------------
r7 | bill | 2013-01-17 16:49:36 -0500 (Do, 17. Jan 2013)
------------------------------------------------------------------------
r3 | bill | 2013-01-17 09:07:04 -0500 (Do, 17. Jan 2013)
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>But is this really an accurate picture of all the changes
        that happened on the branch?  What's left out here is
        the fact that revisions 352, 362, 372 and 379 were actually the
        results of merging changes from the trunk.  If you look at one
        of these logs in detail, the multiple trunk changesets that
        comprised the branch change are nowhere to be seen:</para>
-->
      <para>Aber ist das wirklich eine genaue Wiedergabe aller
        Änderungen, die auf dem Zweig stattgefunden haben? Was hier
        ausgelassen wird, ist, dass die Revisionen 352, 362, 372 und
        379 tatsächlich Ergebnisse des Zusammenführens von Änderungen
        aus dem Stamm waren. Wenn Sie sich eins dieser Protokolle im
        Detail anschauen, können Sie die verschiedenen Änderungsmengen
        vom Stamm, die die Änderungen auf dem Zweig ausmachen,
        nirgendwo sehen:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v
------------------------------------------------------------------------ <!--
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
-->
r352 | user | 2013-02-16 09:35:18 -0500 (Sa, 16. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Synchronisierung der letzten Änderungen von trunk mit my-calc-branch.
</screen>
      </informalexample>

<!--
      <para>We happen to know that this merge to the branch was
        nothing but a merge of trunk changes.  How can we see those
        trunk changes as well?  The answer is to use the
        <option>- -use-merge-history</option> (<option>-g</option>)
        option.  This option expands those <quote>child</quote>
        changes that were part of the merge.</para>
-->
      <para>Wir wissen, dass diese Zusammenführung in den Zweig nichts
        anderes war als ein Merge von Änderungen vom Stamm.  Wie
        können wir zusätzlich diese Änderungen sehen? Die Antwort
        lautet, die Option <option>--use-merge-history</option>
        (<option>-g</option>) zu verwenden. Diese Option expandiert
        diejenigen <quote>Teil</quote>-Änderungen, aus denen die
        Zusammenführung bestand.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v -g
------------------------------------------------------------------------ <!--
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
-->
r352 | user | 2013-02-16 09:35:18 -0500 (Sa, 16. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Synchronisierung der letzten Änderungen von trunk mit my-calc-branch.
------------------------------------------------------------------------ <!--
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/real.c
Merged via: r352

Trunk work on calc project.
-->
r351 | sally | 2013-02-16 08:04:22 -0500 (Sa, 16. Feb 2013) | 2 Zeilen
Geänderte Pfade:
   M /calc/trunk/src/real.c
Zusammengeführt mittels: r352

Arbeiten auf dem Stamm vom calc-Projekt.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r345 | sally | 2013-02-15 16:51:17 -0500 (Fr, 15. Feb 2013) | 2 Zeilen
Geänderte Pfade:
   M /calc/trunk/Makefile
   M /calc/trunk/src/integer.c
Zusammengeführt mittels: r352

Arbeiten auf dem Stamm vom calc-Projekt.
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fr, 15. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/trunk/src/integer.c<!--
Merged via: r352-->
Zusammengeführt mittels: r352
<!--
Refactor the bazzle functions.
-->
Die bazzle-Funktionen refaktoriert.
</screen>
      </informalexample>

<!--
      <para>By making the log operation use merge history, we see not
        just the revision we queried (r352), but also the other revisions
        that came along on the ride with it&mdash;Sally's work on trunk.
        This is a much more complete picture of history!</para>
-->
      <para>Dadurch, dass wir die Protokoll-Operation aufgefordert
        haben, die Geschichte der Zusammenführungen zu verwenden,
        sehen wir nicht nur die Revision, die wir abgefragt haben
        (r352), sondern auch die anderen Revisionen, die hier mitkamen
        &ndash; die Arbeit von Sally auf dem Stamm.  Das ist ein
        wesentlich vollständigeres Bild der Geschichte!</para>

<!--
      <para>The <command>svn blame</command> command also takes the
        <option>- -use-merge-history</option> (<option>-g</option>)
        option.  If this option is neglected, somebody looking at
        a line-by-line annotation of <filename>src/button.c</filename> may
        get the mistaken impression that you were responsible for a
        particular change:</para>
-->
      <para>Auch der <command>svn blame</command>-Befehl versteht die
        Option <option>--use-merge-history</option>
        (<option>-g</option>).  Falls diese Option vergessen wird,
        könnte jemand, der sich die zeilenweisen Anmerkungen von
        <filename>src/button.c</filename> ansieht, fälschlicherweise davon
        ausgehen, dass Sie für die Zeilen einer bestimmten Änderung
        verantwortlich sind:</para>

      <informalexample>
        <screen>
$ svn blame src/button.c
&hellip;
   352    user    retval = inverse_func(button, path);
   352    user    return retval;
   352    user    }
&hellip;
</screen>
      </informalexample>

<!--
      <para>And while it's true that you did actually commit those
        three lines in revision 352, two of them were actually written
        by Sally back in revision 348 and were brought into your branch
        via a sync merge:</para>
-->
      <para>Obwohl es zutrifft, dass Sie diese drei Zeilen in Revision
        352 übertragen haben, sind zwei davon tatsächlich von Sally in
        Revision 348 geschrieben worden und sind durch einen
        Synchronisierungs-Merge in Ihren Zweig geraten:</para>

      <informalexample>
        <screen>
$ svn blame button.c -g
&hellip;
G    348    sally   retval = inverse_func(button, path);
G    348    sally   return retval;
     352    user    }
&hellip;
</screen>
      </informalexample>

<!--
      <para>Now we know who to <emphasis>really</emphasis> blame for
        those two lines of code!</para>
-->
      <para>Nun wissen wir, wer <emphasis>wirklich</emphasis> für die
        zwei Zeilen Quelltext verantwortlich ist!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.ancestry">
<!--
      <title>Noticing or Ignoring Ancestry</title>
-->
      <title>Die Abstammung berücksichtigen oder ignorieren</title>

<!--
      <para>
        <indexterm>
          <primary>ancestry</primary>
        </indexterm>When conversing with a Subversion developer, you
        might very likely hear reference to the term
        <firstterm>ancestry</firstterm>.  This word is used to
        describe the relationship between two objects in a
        repository: if they're related to each other, one
        object is said to be an ancestor of the other.</para>
-->
      <para>
        <indexterm>
          <primary>Abstammung</primary>
        </indexterm>Wenn Sie sich mit einem Subversion-Entwickler
        unterhalten, wird wahrscheinlich auch der Begriff
        <firstterm>Abstammung</firstterm> erwähnt. Dieses Wort wird
        verwendet, um die Beziehung zwischen zwei Objekten im
        Projektarchiv zu beschreiben: Wenn sie in Beziehung zueinander
        stehen, heißt es, dass ein Objekt vom anderen abstammt.</para>

<!--
      <para>For example, suppose you commit revision 100, which
        includes a change to a file <filename>foo.c</filename>.
        Then <filename>foo.c@99</filename> is an
        <quote>ancestor</quote> of <filename>foo.c@100</filename>.
        On the other hand, suppose you commit the deletion of
        <filename>foo.c</filename> in revision 101, and then add a
        new file by the same name in revision 102.  In this case,
        <filename>foo.c@99</filename> and
        <filename>foo.c@102</filename> may appear to be related
        (they have the same path), but in fact are completely
        different objects in the repository.  They share no history
        or <quote>ancestry.</quote></para>
-->
      <para>Nehmen wir an, Sie übertragen Revision 100, die eine
        Änderung an der Datei <filename>foo.c</filename> beinhaltet.
        Dann ist  <filename>foo.c@99</filename> ein
        <quote>Vorfahre</quote> von <filename>foo.c@100</filename>.
        Wenn Sie dagegen in Revision 101 die Löschung von
        <filename>foo.c</filename> übertragen und in Revision 102 eine
        neue Datei mit demselben Namen hinzufügen, hat es zwar den
        Anschein, dass <filename>foo.c@99</filename> und
        <filename>foo.c@102</filename> in Beziehung zueinander stehen
        (sie haben denselben Pfad), es handelt sich allerdings um
        völlig unterschiedliche Objekte im Projektarchiv. Sie haben weder
        eine gemeinsame Geschichte noch
        <quote>Abstammung</quote>.</para>

<!--
      <para>The reason for bringing this up is to point out an
        important difference between <command>svn diff</command> and
        <command>svn merge</command>.  The former command ignores
        ancestry, while the latter command is quite sensitive to it.
        For example, if you asked <command>svn diff</command> to
        compare revisions 99 and 102 of <filename>foo.c</filename>,
        you would see line-based diffs; the <command>diff</command>
        command is blindly comparing two paths.  But if you asked
        <command>svn merge</command> to compare the same two objects,
        it would notice that they're unrelated and first attempt to
        delete the old file, then add the new file;  the output would
        indicate a deletion followed by an add:</para>
-->
      <para>Wir erwähnen das, um auf einen wichtigen Unterschied
        zwischen den Befehlen <command>svn diff</command> und
        <command>svn merge</command> hinzuweisen. Der erstere Befehl
        ignoriert die Abstammung, wohingegen letzterer diese beachtet.
        Wenn Sie beispielsweise mit <command>svn diff</command> die
        Revisionen 99 und 102 von <filename>foo.c</filename>
        vergleichen, werden Sie zeilenbasierte Unterschiede sehen; der
        Befehl <command>diff</command> vergleicht blind zwei Pfade.
        Wenn Sie aber dieselben Objekte mit <command>svn
        merge</command> vergleichen, wird es feststellen, dass sie
        nicht in Beziehung stehen und versuchen, die alte Datei zu
        löschen und dann die neue hinzuzufügen; die Ausgabe wird eine
        Löschung gefolgt von einer Hinzufügung anzeigen:</para>

      <informalexample>
        <screen>
D    foo.c
A    foo.c
</screen>
      </informalexample>

<!--
      <para>Most merges involve comparing trees that are ancestrally
        related to one another; therefore, <command>svn
        merge</command> defaults to this behavior.  Occasionally,
        however, you may want the <command>merge</command> command to
        compare two unrelated trees.  For example, you may have
        imported two source-code trees representing different vendor
        releases of a software project (see
        <xref linkend="svn.advanced.vendorbr"/>).  If you ask
        <command>svn merge</command> to compare the two trees, you'd
        see the entire first tree being deleted, followed by an add
        of the entire second tree!  In these situations, you'll want
        <command>svn merge</command> to do a path-based comparison
        only, ignoring any relations between files and directories.
        Add the <option>- -ignore-ancestry</option> option to your
        <command>merge</command> command, and it will behave just
        like <command>svn diff</command>.  (And conversely, the
        <option>- -notice-ancestry</option> option will cause
        <command>svn diff</command> to behave like the
        <command>svn merge</command> command.)</para>
-->
      <para>Die meisten Zusammenführungen vergleichen Bäume, die von
        der Abstammung  her miteinander in Beziehung stehen, deshalb
        verhält sich <command>svn merge</command> auf diese Weise.
        Gelegentlich möchten Sie jedoch mit dem
        <command>merge</command>-Befehl zwei Bäume vergleichen, die
        nicht miteinander in Beziehung stehen. Es kann z.B. sein, dass
        Sie zwei Quelltext-Bäume importiert haben, die unterschiedliche
        Lieferantenstände eines Software-Projektes repräsentieren
        (siehe <xref linkend="svn.advanced.vendorbr"/>).  Falls Sie 
        <command>svn merge</command> dazu aufforderten, die beiden Bäume
        miteinander zu vergleichen, würden Sie sehen, dass der
        vollständige erste Baum gelöscht und anschließend der
        vollständige zweite Baum hinzugefügt würde! In diesen
        Situationen möchten Sie, dass <command>svn merge</command>
        lediglich einen pfadbasierten Vergleich vornimmt und
        Beziehungen zwischen Dateien und Verzeichnissen außer Acht
        lässt. Fügen Sie die Option <option>--ignore-ancestry</option>
        dem <command>merge</command>-Befehl hinzu, und er wird sich
        verhalten wie <command>svn diff</command>.  (Auf der anderen
        Seite wird die Option <option>--notice-ancestry</option> den
        Befehl <command>svn diff</command> dazu veranlassen, sich wie
        <command>svn merge</command> zu verhalten.</para>

<!--
      <tip>
        <para>
        <indexterm>
          <primary>merge tracking</primary>
          <secondary>disabling</secondary>
        </indexterm>
        The <option>- -ignore-ancestry</option> option also disables
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This means that <literal>svn:mergeinfo</literal> is not considered
        when <command>svn merge</command> is determining what revisions
        to merge, nor is <literal>svn:mergeinfo</literal> recorded to
        describe the merge.</para>
      </tip>
-->
      <tip>
        <para>
        <indexterm>
          <primary>Merge-Tracking</primary>
          <secondary>unterbinden</secondary>
        </indexterm>
          Die Option <option>--ignore-ancestry</option>
          unterbindet auch 
          <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
          Das bedeutet, dass weder <literal>svn:mergeinfo</literal>
          berücksichtigt wird, wenn <command>svn merge</command>
          ermittelt, welche Revisionen zusammengeführt werden sollen,
          noch <literal>svn:mergeinfo</literal> aufgezeichnet wird, um
          die Zusammenführung zu beschreiben.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.moves">
<!--
      <title>Merges and Moves</title>
-->
      <title>Zusammenführen und Verschieben</title>

<!--
      <para>A common desire is to refactor source code, especially
        in Java-based software projects.  Files and directories are
        shuffled around and renamed, often causing great disruption
        to everyone working on the project.  Sounds like a perfect
        case to use a branch, doesn't it?  Just create a branch,
        shuffle things around, and then merge the branch back to the
        trunk, right?</para>
-->
      <para>Es ist ein verbreiteter Wunsch, Software zu refaktorieren,
        besonders in Java-basierten Software-Projekten. Dateien und
        Verzeichnisse werden hin und her geschoben und umbenannt, was
        häufig zu erheblichen Beeinträchtigungen für alle
        Projektmitarbeiter führt. Das hört sich an, als sei das der
        klassische Fall, um nach einem Zweig zu greifen, nicht wahr?
        Sie erzeugen einfach einen Zweig, schieben das Zeug herum und
        führen anschließend den Zweig mit dem Stamm zusammen.</para>

<!--
      <para>Alas, this scenario doesn't work so well right now and
        is considered one of Subversion's current weak spots.  The
        problem is that Subversion's <command>svn merge</command>
        command isn't as robust as it should be, particularly when
        dealing with copy and move operations.</para>
-->
      <para>Leider funktioniert dieses Szenario im Augenblick noch
        nicht so richtig und gilt als einer der Schwachpunkte von
        Subversion. Das Problem ist, das der Subversion-Befehl
        <command>svn merge</command> nicht so stabil ist, wie er sein
        sollte, besonders wenn es um Kopier- und Verschiebeoperationen
        geht.</para>

<!--
      <para>When you use <command>svn copy</command> to duplicate a
        file, the repository remembers where the new file came from,
        but it fails to transmit that information to the client which
        is running <command>svn update</command> or <command>svn
        merge</command>.  Instead of telling the client, <quote>Copy
        that file you already have to this new location,</quote> it
        sends down an entirely new file.  This can lead to
        problems, particularly tree conflicts in the case of renames,
        which involve not only the new copy, but a deletion of the old
        path&mdash;a lesser-known fact about Subversion is that
        it lacks <quote>true renames</quote>&mdash;the <command>svn
        move</command> command is nothing more than an aggregation
        of <command>svn copy</command> and <command>svn
        delete</command>.</para>
-->
      <para>Wenn Sie <command>svn copy</command> zum Duplizieren einer
        Datei verwenden, merkt sich das Projektarchiv, woher die neue
        Datei kam, versäumt aber, diese Information an den Client zu
        senden, der <command>svn update</command> oder <command>svn
        merge</command> ausführt. Statt dem Client mitzuteilen:
        <quote>Kopiere die Datei, die du bereits hast an diesen neuen
        Ort</quote>, sendet es eine völlig neue Datei. Das kann zu
        Problemen führen, im Falle von Umbenennungen besonders zu
        Baumkonflikten, die nicht nur die neue Kopie betreffen,
        sondern die Löschung des alten Pfades ^ndash; eine weniger
        bekannte Tatsache über Subversion ist, dass es keine
        <quote>echten Umbenennungen</quote> hat &ndash; der Befehl
        <command>svn move</command> ist weiter nichts als eine
        Verbindung von <command>svn copy</command> und <command>svn
        delete</command>.</para>

<!--
      <para>For example, suppose that you want to make some changes on
        your private branch <filename>/calc/branch/my-calc-branch
        </filename>.  First you perform an automatic sync merge with
        <filename>/calc/trunk</filename> and commit that in r470:</para>
-->
      <para>Nehmen wir beispielsweise an, dass Sie einige Änderungen
        an Ihrem privaten Zweig <filename>/calc/branch/my-calc-branch
        </filename> machen möchten. Zunächst führen Sie einen
        automatischen Synchronisierungs-Merge mit
        <filename>/calc/trunk</filename> durch und übertragen das
        Ergebnis in r470:</para>
      <informalexample>
        <screen>
$ cd calc/trunk

$ svn merge ^/calc/trunk <!--
- - - Merging differences between repository URLs into '.':
-->
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
U    doc/INSTALL
A    FAQ
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
 U   .  <!--
- - - Recording mergeinfo for merge between repository URLs into '.':
-->
-- Aufzeichnung der Informationen für Zusammenführung zwischen Projektarchiv-URLs in ».«:
 U   .
<!--
$ svn ci -m "Sync all changes from ^/calc/trunk through r469."
Sending        .
Sending        Makefile
Sending        README
Sending        FAQ
Sending        doc/INSTALL
Sending        src/main.c
Sending        src/button.c
Sending        src/integer.c
Transmitting file data ....
Committed revision 470.
-->
$ svn ci -m "Synchronisierung aller Änderungen von ^/calc/trunk bis r469."
Sende              .
Sende              Makefile
Sende              README
Sende              FAQ
Sende              doc/INSTALL
Sende              src/main.c
Sende              src/button.c
Sende              src/integer.c
Übertrage Daten ....
Revision 470 übertragen.
</screen>
      </informalexample>
<!--
      <para>Then you rename <filename>integer.c</filename> to <filename>
        whole.c</filename> in r471 and then make some edits to the same
        file in r473.  Effectively you've created a new file in your branch
        (that is a copy of the original file plus some edits) and deleted
        the original file.  Meanwhile, back on <filename>/calc/trunk
        </filename>, Sally has committed some improvements of her own to
        <filename>integer.c</filename> in r472:</para>
-->
      <para>Dann benennen Sie in r471 <filename>integer.c</filename>
        in <filename>whole.c</filename> um und editieren dieselbe
        Datei in r473. Tatsächlich haben Sie eine neue Datei auf Ihrem
        Zweig erzeugt (die eine Kopie der ursprünglichen Datei plus
        einiger Bearbeitungen ist) und die ursprüngliche Datei
        gelöscht.  Zwischenzeitlich hat Sally in r472 auf
        <filename>/calc/trunk</filename> selber einige Verbesserungen
        an <filename>integer.c</filename> übertragen:</para>

      <informalexample>
        <screen>
$ svn log -v -r472 ^/calc/trunk
------------------------------------------------------------------------<!--
r472 | sally | 2013-02-26 07:05:18 -0500 (Tue, 26 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Trunk work on integer.c.-->
r472 | sally | 2013-02-26 07:05:18 -0500 (Di, 26. Feb 2013) | 1 Zeile
Geänderte Pfade:
   M /calc/trunk/src/integer.c

Arbeit auf dem Stamm von integer.c.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Now you decide to merge your branch back to the trunk.
        How will Subversion combine the rename and edits you made
        with Sally's edits?</para>
-->
      <para>Nun entscheiden Sie sich, Ihren Zweig auf den Stamm
        zurückzuführen. Wie wird Subversion Ihre Umbenennung und
        Bearbeitung mit den Bearbeitungen durch Sally
        kombinieren?</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/my-calc-branch<!--
- - Merging differences between repository URLs into '.':-->
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
   C src/integer.c
 U   src/real.c
A    src/whole.c<!--
- - Recording mergeinfo for merge between repository URLs into '.':-->
-- Aufzeichnung der Informationen für Zusammenführung zwischen Projektarchiv-URLs in ».«:
 U   .<!--
Summary of conflicts:
  Tree conflicts: 1-->
Konfliktübersicht:
  Baumkonflikte: 1

$ svn st
 M      .
      C src/integer.c<!--
      >   local file edit, incoming file delete upon merge-->
      >   lokale Datei geändert, eingehendes Löschen einer Datei bei Zusammenführung
 M      src/real.c
A  +    src/whole.c<!--
Summary of conflicts:
  Tree conflicts: 1-->
Konfliktübersicht:
  Baumkonflikte: 1
</screen>
      </informalexample>

<!--
      <para>The answer is that Subversion <emphasis>won't</emphasis>
        combine those changes, but rather raises a tree conflict<footnote>
        <para>If Sally hadn't made her change in r472, then Subversion would
        notice that <filename>integer.c</filename> in the
        target working copy is identical to <filename>integer.c</filename>
        in the left-side of the merge and would allow your rename to
        succeed without a tree conflict:</para>-->
      <para>Die Antwort ist, dass Subversion diese Änderungen
        <emphasis>keineswegs</emphasis> kombiniert, sondern
        stattdessen einen Baumkonflikt erzeugt<footnote><para>Falls
        Sally ihre Änderung in  r472 nicht gemacht hätte, dann wäre
        Subversion aufgefallen, dass <filename>integer.c</filename> in
        der Ziel-Arbeitskopie identisch zu <filename>integer.c</filename>
        auf der linken Seite des Merge ist, und hätte Ihnen die
        Umbenennung ohne Baumkonflikt durchgehen lassen:</para>
        <informalexample>
          <screen>
$ svn merge ^/calc/branches/my-calc-branch<!--
- - Merging differences between repository URLs into '.':-->
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
 U   src/real.c
A    src/whole.c
D    src/integer.c<!--
- - Recording mergeinfo for merge between repository URLs into '.':-->
-- Aufzeichnung der Informationen für Zusammenführung zwischen Projektarchiv-URLs in ».«:
 U   .
</screen><!--
      </informalexample></footnote>because it needs your help
        to figure out what part of your changes and what part of Sally's
        changes should ultimately end up in <filename>whole.c</filename>
        or even if the rename should take place at all!</para>-->
        </informalexample></footnote>, da es Ihre Hilfe benötigt, um
        herauszufinden, welche Teile Ihrer Änderungen und welche Teile
        von Sallys Änderungen schließlich in
        <filename>whole.c</filename> landen sollen, oder ob die
        Umbenennung überhaupt stattfinden soll!</para>

<!--
      <para>You will need to resolve this tree conflict before committing
        the merge and this may require some manual intervention on your
        part, see <xref linkend="svn.tour.treeconflicts"/>.  The moral of
        this story is that until Subversion improves, be careful about
        merging copies and renames from one branch to another and when you
        do, be prepared for some manual resolution.</para>
-->
      <para>Vor der Übergabe werden Sie den Baumkonflikt auflösen
        müssen, was einiger manueller Eingriffe Ihrerseits bedarf,
        siehe <xref linkend="svn.tour.treeconflicts"/>. Die Moral der
        Geschichte ist, dass Sie dabei vorsichtig sein sollten, wenn Sie
        Kopien und Umbenennungen zwischen Zweigen zusammenführen, und
        auf manuelle Eingriffe vorbereitet sind,
        bis sich Subversion verbessert.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.pre1.5clients">
<!--
      <title>Preventing Naïve Clients from Committing Merges</title>
-->
      <title>Ahnungslose Clients vom Mergen abhalten</title>

<!--
      <para>If you've just upgraded your server to Subversion 1.5 or
        later, there's a risk that pre-1.5 Subversion
        clients can cause problems with
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This is because pre-1.5 clients don't support this feature;
        when one of these older clients performs <command>svn
        merge</command>, it doesn't modify the value of
        the <literal>svn:mergeinfo</literal> property at all.  So the
        subsequent commit, despite being the result of a merge,
        doesn't tell the repository about the duplicated
        changes&mdash;that information is lost.  Later on,
        when <quote>merge-aware</quote> clients attempt automatic
        merging, they're likely to run into all sorts of conflicts
        resulting from repeated merges.</para>
-->
      <para>Wenn Sie gerade Ihren Server auf Subversion 1.5 oder
        größer umgestellt haben, besteht ein Risiko,
        dass Subversion-Clients einer älteren Version als 1.5 Probleme
        mit
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
        bereiten können. Das liegt daran, dass Clients vor 1.5 diese
        Funktionalität nicht unterstützen; wenn einer dieser älteren
        Clients <command>svn merge</command> ausführt, modifiziert er
        nicht den Wert der Eigenschaft <literal>svn:mergeinfo</literal>.
        Obwohl die anschließende Übergabe das Ergebnis einer
        Zusammenführung ist, wird dem Projektarchiv nichts über die
        duplizierten Änderungen mitgeteilt &ndash; diese Information
        ist verloren. Wenn später Clients, die
        Mergeinfo auswerten, automatische
        Merges versuchen, werden Sie wahrscheinlich in alle
        möglichen Konflikte laufen, die durch wiederholtes
        Mergen hervorgerufen wurden.</para>

<!--
      <para>If you and your team are relying on the merge-tracking
        features of Subversion, you may want to configure your
        repository to prevent older clients from committing changes.
        The easy way to do this is by inspecting
        the <quote>capabilities</quote> parameter in
        the start-commit hook script.  If the
        client reports itself as having <literal>mergeinfo</literal>
        capabilities, the hook script can allow the commit to start.
        If the client doesn't report that capability, have the hook
        deny the commit.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> gives an
        example of such a hook script:</para>
-->
      <para>Wenn Sie und Ihr Team auf die Merge-Verfolgung von
        Subversion angewiesen sind, sollten Sie Ihr Projektarchiv
        dergestalt konfigurieren, dass ältere Clients daran gehindert
        werden, Änderungen zu übertragen. Die einfache Methode hierfür
        ist es, den <quote>Fähigkeiten</quote>-Parameter im
        start-commit-Hook-Skript zu untersuchen.
        Wenn der Client meldet, dass er mit
        <literal>mergeinfo</literal> umgehen kann, kann das Skript den
        Beginn der Übergabe erlauben.  Wenn der Client diese Fähigkeit
        nicht meldet, wird die Übergabe abgelehnt.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> zeigt ein
        Beispiel für ein solches Hook-Skript:</para>


<!--
      <example id="svn.branchmerge.advanced.hook-ex1">
        <title>Merge-tracking gatekeeper start-commit hook script</title>

        <programlisting>
#!/usr/bin/env python
import sys

# The start-commit hook is invoked immediately after a Subversion txn is
# created and populated with initial revprops in the process of doing a
# commit. Subversion runs this hook by invoking a program (script, 
# executable, binary, etc.) named 'start-commit' (for which this file
# is a template) with the following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] USER         (the authenticated user attempting to commit)
#   [3] CAPABILITIES (a colon-separated list of capabilities reported
#                     by the client; see note below)
#   [4] TXN-NAME     (the name of the commit txn just created)

capabilities = sys.argv[3].split(':')
if "mergeinfo" not in capabilities:
  sys.stderr.write("Commits from merge-tracking-unaware clients are "
                   "not permitted.  Please upgrade to Subversion 1.5 "
                   "or newer.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>
-->

      <example id="svn.branchmerge.advanced.hook-ex1">
        <title>Hook-Skript zum Start der Übertragung als Torwächter für die Merge-Verfolgung</title>

        <programlisting>
#!/usr/bin/env python
import sys

# Dieser Start-Commit-Hook wird aufgerufen, unmittelbar nachdem eine
# Subversion-Transaktion im Zuge einer Übergabe begonnen und mit den
# initialen Revisions-Eigenschaften versorgt wurde. Subversion führt
# diesen Hook aus, indem ein Programm (Skript, ausführbare Datei,
# Binärdatei, etc.) namens "start-commit" (für die diese Datei als
# Vorlage dient) mit den folgenden geordneten Argumenten aufgerufen
# wird:
#
#   [1] REPOS-PATH   (der Pfad zu diesem Projektarchiv)
#   [2] USER         (der authentisierte Anwender, der übertragen möchte)
#   [3] CAPABILITIES (eine vom Client durch Doppelpunkte getrennte
#                     Liste von Leistungsmerkmalen; siehe Anmerkung
#                     unten)
#   [4] TXN-NAME     (der Name der gerade erzeugten
#                     Übertraguns-Transaktion)

capabilities = sys.argv[3].split(':')
if "mergeinfo" not in capabilities:
  sys.stderr.write("Übertragungen von Clients, die keine"
                   "Zusammenführungs-Verfolgung unterstützen,"
                   "sind nicht erlaubt. Bitte auf Subversion 1.5 "
                   "oder neuer aktualisieren.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>

<!--
      <para>For more information about hook scripts, see
        <xref linkend="svn.reposadmin.hooks"/>.</para>
-->
      <para>Für weitergehende Informationen zu Hook-Skripten, siehe
        nächsten Kapitel erfahren; siehe
        <xref linkend="svn.reposadmin.hooks"/>.</para>

    </sect2>
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.finalword">
<!--
      <title>The Final Word on Merge Tracking</title>
-->
      <title>Das abschließende Wort zum Merge-Tracking</title>

<!--
      <para>The bottom line is that Subversion's merge-tracking
        feature has a complex internal implementation, and
        the <literal>svn:mergeinfo</literal> property is the only
        window the user has into the machinery.</para>
-->
      <para>Unter dem Strich bedeutet das, dass die Fähigkeit von
        Subversion zur Merge-Verfolgung eine komplexe interne
        Implementierung besitzt und die Eigenschaft
        <literal>svn:mergeinfo</literal> das einzige Fenster zu diesem
        Räderwerk ist.</para>

<!--
      <para>How and when mergeinfo is recorded by a merge can sometimes
        be difficult to understand.  Furthermore, the management of
        mergeinfo metadata has a whole set of taxonomies and behaviors
        around it, such as <quote>explicit</quote> versus <quote>implicit
        </quote> mergeinfo, <quote>operative</quote>
        versus <quote>inoperative</quote> revisions, specific
        mechanisms of mergeinfo <quote>elision,</quote> and
        even <quote>inheritance</quote> from parent to child
        directories.</para>
-->
      <para>Wie und wann Mergeinfo von einem Merge festgehalten wird,
        kann manchmal schwer zu verstehen sein.Darüber hinaus umgibt
        die Verwaltung der Mergeinfo-Metadaten eine ganze Menge von
        Systematiken und Verhalten, wie <quote>explizite</quote>
        gegenüber <quote>implizite</quote> Mergeinfo,
        <quote>operative</quote> gegenüber <quote>inoperative</quote>
        Revisionen, besondere Mechanismen von
        Mergeinfo-<quote>Auslassung</quote> und sogar
        <quote>Vererbung</quote> von Eltern- zu
        Kindverzeichnissen.</para>

<!--
      <para>We've chosen to only briefly cover, if at all, these detailed
        topics for a couple of reasons.  First, the level of detail is
        overwhelming for a typical user.  Second, and more
        importantly, the typical user <emphasis>doesn't</emphasis> need
        to understand these concepts; typically they remain in the
        background as implementation details.  All that said, if you
        enjoy this sort of thing, you can get a fantastic overview in a
        paper posted at CollabNet's website: <ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>
-->
      <para>Wir haben uns entschieden, diese detaillierten Themen aus
        einer Reihe von Gründen nur kurz anzureißen.
        Erstens ist der Detaillierungsgrad für einen normalen
        Benutzer erdrückend. Zweitens, und das ist wichtiger,
        <emphasis>muss</emphasis> der typische Benutzer diese
        Konzepte nicht verstehen; sie sollten als
        Implementierugsdetails im Hintergrund bleiben. Wenn
        Sie, nachdem dies gesagt ist, diese Dinge mögen, können Sie
        einen fantastischen Überblick in einer Arbeit nachlesen, die
        auf der Webseite von CollabNet veröffentlicht ist:<ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>

<!--
      <para>For now, if you want to steer clear of the complexities of
        merge tracking, we recommend that you follow these simple best
        practices:</para>
-->
      <para>Fürs Erste empfehlen wir, sich an die folgenden
        bewährten Praktiken zu halten, sofern Sie die Komplexität
        der Verfolgung von Zusammenführungen umgehen möchten:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>For short-term feature branches, follow the simple
            procedure described throughout
            <xref linkend="svn.branchmerge.basicmerging"/>.</para>
-->
          <para>Wenden Sie für kurzlebige Arbeitszweige das Verfahren
            an, das in <xref linkend="svn.branchmerge.basicmerging"/>
            beschrieben wird.</para>
        </listitem>
        <listitem>
<!--
          <para>Avoid subtree merges and subtree mergeinfo. Perform
            merges only on the root of your branches, not on
            subdirectories or files (see <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>)
            .</para>
-->
          <para>Vermeiden Sie Teilbaum-Merges und Teilbaum-Mergeinfo.
            Führen Sie Merges nur im Wurzelverzeichnis Ihrer Zweige
            durch und nicht in Unterverzeichnissen oder auf Dateien
            (siehe <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>).
          </para>
        </listitem>
        <listitem>
<!--
          <para>Don't ever edit the <literal>svn:mergeinfo</literal>
            property directly; use <command>svn
            merge</command> with the <option>- -record-only</option> option
            to effect a desired change to the metadata (as demonstrated in
            <xref linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
-->
          <para>Editieren Sie niemals direkt die Eigenschaft
            <literal>svn:mergeinfo</literal>; verwenden Sie
            <command>svn merge</command> mit der Option
            <option>--record-only</option>, um eine gewünschte
            Änderung an den Metadaten zu bewirken (wie in <xref
            linkend="svn.branchmerge.advanced.blockchanges"/>
            gezeigt).</para>
        </listitem>
        <listitem>
<!--
          <para>Your merge target should be a working copy which
            represents the root of a <emphasis>complete</emphasis> tree
            representing a <emphasis>single</emphasis> location in the
            repository at a single point in time:
-->
          <para>Das Ziel Ihrer Zusammenführung sollte eine
            Arbeitskopie sein, die einen
            <emphasis>vollständigen</emphasis> Baum eines
            <emphasis>einzigen</emphasis> Ortes zu einem einzelnen
            Zeitpunkt im Projektarchiv repräsentiert:
            <itemizedlist>
              <listitem>
<!--
                <para>Update before you merge!  Don't use the <option>
                - -allow-mixed-revisions</option> option to merge into
                mixed-revision working copies.</para>
-->
                <para>Aktualisieren Sie vor der Zusammenführung.
                  Verwenden Sie nicht die Option
                  <option>--allow-mixed-revisions</option>, um einen
                  Merge in Arbeitskopien mit gemischten Revisionen
                  zu machen.</para>
              </listitem>
              <listitem>
<!--
                <para>Don't merge to targets with <quote>switched</quote>
                subdirectories (as described next in
                <xref linkend="svn.branchmerge.switchwc"/>).</para>
-->
                <para>Führen Sie nicht auf Ziele mit
                  <quote>umgestellten</quote> Unterverzeichnissen
                  zusammen (wie gleich in 
                  <xref linkend="svn.branchmerge.switchwc"/> beschrieben
                  wird).</para>
              </listitem>
              <listitem>
<!--
                <para>Avoid merges to targets with sparse directories.
                  Likewise, don't merge to depths other than
                  <option>- -depth=infinity</option></para>
-->
                <para>Vermeiden Sie Zusammenführungen in Ziele mit
                  Teilverzeichnissen. Das Gleiche gilt für
                  Zusammenführungen mit anderen Tiefen als 
                  <option>--depth=infinity</option></para>
              </listitem>
              <listitem>
<!--
                <para>Be sure you have read access to all of the merge
                  source and read/write access to all of the merge
                  target.</para>
-->
                <para>Stellen Sie sicher, dass Sie vollständigen
                  Lesezugriff auf die Quellen sowie Lese- und
                  Schreibzugriff auf alle Ziele der Zusammenführung
                  haben.</para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>

<!--
      <para>Of course sometimes you may need to violate some of these
        best practices.  Don't worry if you need to, just be sure you
        understand the ramifications of doing so.</para>
-->
      <para>Natürlich müssen Sie manchmal einige dieser bewährten
        Praktiken verletzen. Machen Sie sich keine Sorgen, wenn das
        eintritt, verstehen Sie nur, was die Abweichungen nach sich
        ziehen.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
<!--
    <title>Traversing Branches</title>
-->
    <title>Zweige durchlaufen</title>

<!--
    <para>The <command>svn switch</command> command transforms an
      existing working copy to reflect a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut.  In one of our earlier examples,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>
-->
    <para>Der Befehl <command>svn switch</command> überführt eine
      bestehende Arbeitskopie, so dass sie einen anderen Zweig
      repräsentiert. Obwohl dieser Befehl strenggenommen für die
      Arbeit mit Zweigen nicht notwendig ist, stellt er eine nette
      Abkürzung dar. In einem unserer früheren Beispiele haben Sie nach dem
      Anlegen Ihres eigenen privaten Zweigs eine frische Arbeitskopie
      des neuen Projektarchiv-Verzeichnisses ausgecheckt. Stattdessen
      können Sie Subversion einfach mitteilen, dass es Ihre
      Arbeitskopie von <filename>/calc/trunk</filename> ändern soll,
      um den neuen Ort des Zweigs widerzuspiegeln:</para>

    <informalexample>
      <screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk
Relative URL: ^/calc/trunk
$ svn switch ^/calc/branches/my-calc-branch
U    integer.c
U    button.c
U    Makefile <!--
Updated to revision 341.
-->
Aktualisiert zu Revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
Relative URL: ^/calc/branches/my-calc-branch
$
</screen>
    </informalexample>

<!--
    <para><quote>Switching</quote> a working copy that has no local
      modifications to a different branch results in the working copy
      looking just as it would if you'd done a fresh checkout of the
      directory.  It's usually more efficient to
      use this command, because often branches differ by only a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>
-->
    <para><quote>Das Umschalten</quote> einer Arbeitskopie ohne lokale
      Änderungen auf einen anderen Zweig hat zur Folge, dass die
      Arbeitskopie genau so aussieht, als sei das Verzeichnis frisch
      ausgecheckt worden. Es ist gewöhnlicherweise effizienter, diesen
      Befehl zu verwenden, da sich Zweige oftmals nur in kleinen
      Teilen unterscheiden. Der Server sendet nur die minimale Menge
      von Änderungen, die notwendig sind, damit Ihre Arbeitskopie den
      Inhalt des Zweig-Verzeichnisses wiedergibt.</para>

<!--
    <para>The <command>svn switch</command> command also takes a
      <option>- -revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the
      <literal>HEAD</literal> of the branch.</para>
-->
    <para>Der Befehl <command>svn switch</command> versteht auch die
      Option <option>--revision</option> (<option>-r</option>), so
      dass Sie nicht immer gezwungen sind, Ihre Arbeitskopie auf den
      <literal>HEAD</literal> des Zweigs zu setzen.</para>

<!--
    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, and contain multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>
-->
    <para>Natürlich sind die meisten Projekte komplizierter als unser
      <filename>calc</filename>-Beispiel und enthalten mehrere
      Unterverzeichnisse. Subversion-Benutzer wenden bei der
      Verwendung von Zweigen häufig einen bestimmten Algorithmus
      an:</para>

    <orderedlist>
      <listitem>
<!--
        <para>Copy the project's entire <quote>trunk</quote> to a new
          branch directory.</para>
-->
        <para>Kopiere den vollständigen <quote>Stamm</quote> des
          Projektes in ein neues Zweig-Verzeichnis.</para>
        </listitem>
        <listitem>
<!--
        <para>Switch only <emphasis>part</emphasis> of the trunk
          working copy to mirror the branch.</para>
-->
        <para>Schalte nur einen <emphasis>Teil</emphasis> der
          Arbeitskopie vom Stamm auf den Zweig um.</para>
        </listitem>
      </orderedlist>

<!--
    <para>In other words, if a user knows that the branch work needs
      to happen on only a specific subdirectory, she uses
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, the user can continue to
      receive normal <quote>trunk</quote> updates to most of her
      working copy, but the switched portions will remain immune
      (unless someone commits a change to her branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote>&mdash;not only can working copies contain a
      mixture of working revisions, but they can also contain a
      mixture of repository locations as well.</para>
-->
    <para>In anderen Worten: Wenn ein Benutzer weiß, dass die Arbeit
      auf dem Zweig nur in einem bestimmten Unterverzeichnis
      stattfinden muss, verwendet er <command>svn switch</command>
      lediglich, um dieses Unterverzeichnis auf den Zweig zu bringen.
      (Manchmal schalten Benutzer sogar nur eine einzelne Datei auf
      den Zweig um!) Auf diese Art kann ein Benutzer für einen großen
      Teil der Arbeitskopie weiterhin normale Aktualisierungen auf dem
      <quote>Stamm</quote> erhalten, wohingegen die umgeschalteten
      Teile unberührt bleiben (es sei denn, jemand übergibt etwas an
      den Zweig). Diese Möglichkeit fügt dem Konzept einer
      <quote>gemischten Arbeitskopie</quote> eine völlig neue
      Dimension hinzu &ndash; Arbeitskopien können nicht nur eine
      Mischung unterschiedlicher Revisionen enthalten, sondern auch
      eine Mischung unterschiedlicher Projektarchiv-Orte.</para>

    <tip>
<!--
      <para>Typically switched subdirectories share common ancestry with
        the location which is switched <quote>away</quote> from.  However
        <command>svn switch</command> can switch a subdirectory to mirror
        a repository location which it shares no common ancestry with.
        To do this you need to use the
        <option>- -ignore-ancestry</option> option.
    </para>
-->
      <para>Typischerweise teilen sich umgestellte Unterverzeichnisse
        eine gemeinsame Herkunft mit dem Ort von dem sie
        <quote>wegbewegt</quote> werden. Allerdings kann ein
        Unterverzeichnis mit <command>svn switch</command> so
        umgestellt werden, dass es einen Ort im Projektarchiv
        widerspiegelt, mit dem es keinerlei gemeinsame Herkunft teilt.
        Um das zu bewerkstelligen, müssen Sie die Option
        <option>--ignore-ancestry</option> verwenden.
    </para>
    </tip>

<!--
    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes are still
      applied as a single, atomic change to the repository.</para>
-->
    <para>Falls Ihre Arbeitskopie eine Anzahl umgeschalteter
      Unterverzeichnisse aus unterschiedlichen Projektarchiv-Orten
      enthält, funktioniert sie immer noch normal. Wenn Sie
      aktualisieren, erhalten Sie entsprechende Patches für jeden
      Teilbaum. Wenn Sie übertragen, werden Ihre lokalen Änderungen
      nach wie vor als eine einzelne atomare Änderung auf das
      Projektarchiv angewendet.</para>

<!--
    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that feature is planned for the
      future.<footnote><para>You <emphasis>can</emphasis>, however,
      use <command>svn relocate</command> if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See <xref linkend="svn.ref.svn.c.relocate"/> in
      <xref linkend="svn.ref.svn"/> for more information and an
      example.</para></footnote></para>
-->
    <para>Beachten Sie, dass, obwohl es normal ist, dass eine
      Arbeitskopie eine Mischung unterschiedlicher Projektarchiv-Orte
      repräsentiert, all diese Orte sich innerhalb
      <emphasis>desselben</emphasis> Projektarchivs befinden.
      Subversion-Projektarchive können noch nicht miteinander
      kommunizieren; diese Möglichkeit ist für die Zukunft geplant.
      <footnote><para>Sie <emphasis>können</emphasis> jedoch
      <command>svn relocate</command> verwenden, falls sich der URL
      Ihres Servers geändert hat, und Sie die bestehende Arbeitskopie
      nicht aufgeben wollen.  Siehe
      <xref linkend="svn.ref.svn.c.relocate"/> in
      <xref linkend="svn.ref"/> für weitere Informationen und ein
      Beispiel.</para></footnote></para>

    <tip>
<!--
      <para>Administrators who need to change the URL of a repository
        which is accessed via HTTP are encouraged to add to
        their <filename>httpd.conf</filename> configuration file a
        permanent redirect from the old URL location to the new one
        (via the <literal>RedirectPermanent</literal> directive).
        Subversion clients will generally display the new repository
        URL in error messages generated when the user attempts to use
        working copies which still reflect the old URL location.  Since
        Subversion 1.7 clients will go a step further,
        automatically relocating the working copy to the new
        URL.</para>
-->
      <para>Administratoren, die den URL eines Projektarchivs ändern
        müssen, auf das über HTTP zugegriffen wird, sei empfohlen,
        ihrer Konfigurationsdatei <filename>httpd.conf</filename> eine
        ständige Weiterleitung vom alten URL zum neuen einzurichten
        (mit der Anweisung <literal>RedirectPermanent</literal>). Im
        Allgemeinen werden Subversion-Clients den neuen URL des
        Projektarchivs in Fehlermeldungen anzeigen, die erzeugt
        werden, falls der Anwender versucht, auf Arbeitskopien
        zuzugreifen, die immer noch den alten URL widerspiegeln.
        Seit Subversion 1.7 gehen Clients hier tatsächlich noch einen
        Schritt weiter, indem sie automatisch die Arbeitskopie auf den
        neuen URL umziehen lassen.</para>
    </tip>

    <sidebar>
<!--
      <title>Switches and Updates</title>
-->
      <title>Umschalten und Aktualisierungen</title>

<!--
      <para>Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> looks the
        same?  The switch command is actually a superset of the update
        command.</para>
-->
      <para>Ist Ihnen aufgefallen, dass die Ausgaben von <command>svn
        switch</command> und <command>svn update</command> gleich
        aussehen? Der switch-Befehl ist tatsächlich eine Obermenge des
        update-Befehls.</para>

<!--
      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        latter command always compares two identical repository
        paths.</para>
-->
      <para>Wenn Sie <command>svn update</command> aufrufen, fordern
        Sie das Projektarchiv auf, zwei Bäume zu vergleichen. Das
        Projektarchiv macht es und schickt eine Beschreibung der
        Unterschiede zurück an den Client. Der einzige Unterschied
        zwischen <command>svn switch</command> und <command>svn
        update</command> ist, dass letzterer Befehl stets zwei
        identische Projektarchiv-Pfade miteinander vergleicht.</para>

<!--
      <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch directory in the
        <literal>HEAD</literal> revision.</para>
-->
      <para>Das heißt, falls Ihre Arbeitskopie
        <filename>/calc/trunk</filename> widerspiegelt, wird
        <command>svn update</command> automatisch Ihre Arbeitskopie
        von <filename>/calc/trunk</filename> mit
        <filename>/calc/trunk</filename> in der Revision
        <literal>HEAD</literal> vergleichen. Falls Sie Ihre
        Arbeitskopie auf einen Zweig umschalten, wird <command>svn
        switch</command> Ihre Arbeitskopie von
        <filename>/calc/trunk</filename> mit einem
        <emphasis>anderen</emphasis> Zweig-Verzeichnis in der
        <literal>HEAD</literal>-Revision vergleichen.</para>

<!--
      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
-->
      <para>In anderen Worten: Eine Aktualisierung bewegt Ihre
        Arbeitskopie durch die Zeit. Eine Umschaltung bewegt Ihre
        Arbeitskopie durch die Zeit <emphasis>und</emphasis> den
        Raum.</para>
    </sidebar>

<!--
    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.</para>
-->
    <para>Da <command>svn switch</command> eigentlich eine Variante
      von <command>svn update</command> ist, teilt es dasselbe
      Verhalten; irgendwelche lokalen Änderungen Ihrer Arbeitskopie
      bleiben erhalten, wenn neue Daten aus dem Projektarchiv
      ankommen.</para>

    <tip>
<!--
      <para>Have you ever found yourself making some complex edits (in
        your <filename>/trunk</filename> working copy) and suddenly
        realized, <quote>Hey, these changes ought to be in their own
        branch?</quote> There is a great two step technique to do
        this:</para>
-->
        <para>Haben Sie sich jemals dabei ertappt, dass Sie (in Ihrer
          <filename>/trunk</filename>-Arbeitskopie) komplexe
          Änderungen gemacht haben und plötzlich feststellen:
          <quote>Verdammt, diese Änderungen sollten auf einen eigenen
          Zweig!</quote> Es gibt eine gute Technik, um das in zwei
          Schritten zu bewerkstelligen:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \ <!--
           -m "Create branch 'newbranch'."
Committed revision 353.
-->
           -m "Zweig 'newbranch' angelegt."
Revision 353 übertragen.
$ svn switch ^/calc/branches/newbranch <!--
At revision 353.
-->
Revision 353.
</screen>
      </informalexample>

<!--
      <para>The <command>svn switch</command> command, like
        <command>svn update</command>, preserves your local edits.  At
        this point, your working copy is now a reflection of the newly
        created branch, and your next <command>svn commit</command>
        invocation will send your changes there.</para>
    </tip>
-->
    <para>Der Befehl <command>svn switch</command> bewahrt wie
      <command>svn update</command> Ihre lokalen Änderungen. An dieser
      Stelle spiegelt Ihre Arbeitskopie den neu erzeugten Zweig
      wieder, und Ihr nächster Aufruf von <command>svn
      commit</command> wird Ihre Änderungen dorthin senden.</para>
    </tip>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
<!--
    <title>Tags</title>
-->
    <title>Tags</title>

    <para>
      <indexterm>
<!--
        <primary>tags</primary>
-->
        <primary>Tags</primary>
      </indexterm>
<!--
      Another common version control concept is a tag.  A tag is
      just a <quote>snapshot</quote> of a project in time.  In
      Subversion, this idea already seems to be everywhere.  Each
      repository revision is exactly that&mdash;a snapshot of the
      filesystem after each commit.</para>
-->
      Ein weiterer verbreiteter Begriff in der Versionskontrolle
      ist ein <firstterm>Tag</firstterm>. Ein Tag ist lediglich eine
      <quote>Momentaufnahme</quote> eines Projekts. In Subversion
      scheint dieses Konzept bereits überall vorhanden zu sein. Jede
      Revision im Projektarchiv ist genau das &ndash; eine Momentaufnahme
      des Dateisystems nach einer Übergabe.</para>

<!--
    <para>However, people often want to give more human-friendly names
      to tags, such as <literal>release-1.0</literal>.  And they want
      to make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release 1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>
-->
    <para>Allerdings möchten Menschen häufig sprechendere Namen für
      Tags vergeben, wie etwa <literal>release-1.0</literal>. Und sie
      möchten Momentaufnahmen kleinerer Unterverzeichnisse des
      Dateisystems erstellen. Schließlich ist es nicht gerade einfach,
      sich daran zu erinnern, dass Release 1.0 einer Software ein
      bestimmtes Unterverzeichnis der Revision 4822 ist.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
<!--
      <title>Creating a Simple Tag</title>
-->
      <title>Erzeugen eines einfachen Tags</title>

<!--
      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, make a copy of it:</para>
-->
      <para>Wieder einmal hilft Ihnen <command>svn copy</command> bei
        der Arbeit. Wenn Sie eine Momentaufnahme von
        <filename>/calc/trunk</filename> machen wollen, genau so, wie
        es in der Revision <literal>HEAD</literal> aussieht, machen
        Sie davon eine Kopie:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \ <!--
           -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 902.
-->
           -m "Ein Tag für die Ausgabe 1.0 des 'calc' Projektes anlegen."

Revision 902 übertragen.
</screen>
      </informalexample>

<!--
      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If
        it doesn't, you can create it using <command>svn
        mkdir</command>.)  After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the <filename>/trunk</filename> directory
        looked in the <literal>HEAD</literal> revision at the time you
        made the copy.  Of course, you might want to be more precise
        about exactly which revision you copy, in case somebody else
        may have committed changes to the project when you weren't
        looking.  So if you know that revision 901 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 901</option> to
        the <command>svn copy</command> command.</para>
-->
      <para>Dieses Beispiel geht davon aus, dass ein Verzeichnis
        <filename>/calc/tags</filename> bereits besteht. (Falls nicht,
        können Sie es mit <command>svn mkdir</command> erstellen.)
        Nach Abschluss der Kopie ist das neue Verzeichnis
        <filename>release-1.0</filename> für immer eine Momentaufnahme
        des Verzeichnisses <filename>/trunk</filename> in der Revision
        <literal>HEAD</literal> zum Zeitpunkt, an dem Sie die Kopie
        erstellt haben. Natürlich können Sie auch angeben, welche
        Revision Sie genau kopieren möchten, für den Fall, dass jemand
        anderes Änderungen an das Projekt übertragen haben könnte,
        während Sie nicht hingeschaut haben. Wenn Sie also wissen,
        dass Revision 901 von <filename>/calc/trunk</filename> genau
        die Momentaufnahme ist, die Sie möchten, können Sie sie mit
        der Option <option>-r 901</option> an den Befehl <command>svn
        copy</command> übergeben.</para>

<!--
      <para>But wait a moment: isn't this tag creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>
-->
      <para>Moment mal: ist die Erstellung eines Tags nicht dasselbe
        Vorgehen wie bei der Erstellung eines Zweigs? Ja, es ist es
        tatsächlich. In Subversion gibt es keinen Unterschied zwischen
        einem Tag und einem Zweig. Beides sind gewöhnliche
        Verzeichnisse, die durch Kopieren erzeugt werden. Genauso wie
        bei Zweigen, ist der einzige Grund warum ein kopiertes
        Verzeichnis ein <quote>Tag</quote> ist, weil
        <emphasis>Menschen</emphasis> sich entschieden haben, es so zu
        betrachten: Solange niemand etwas an das Verzeichnis übergibt,
        bleibt es für immer eine Momentaufnahme. Wenn jemand damit
        beginnt, etwas dorthin zu übertragen, wird es ein Zweig.</para>

<!--
      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy.  (That is, make sure
        they know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags area (see
        <xref linkend="svn.serverconfig"/>).  The paranoid approach,
        however, isn't usually necessary.  If a user accidentally
        commits a change to a tag directory, you can simply undo the
        change as discussed in the previous section.  This is version
        control, after all!</para>
-->
      <para>Wenn Sie ein Projektarchiv verwalten, gibt es zwei Ansätze
        für den Umgang mit Tags. Der erste Ansatz ist <quote>Hände
        weg</quote>: Als Vereinbarung im Projekt entscheiden Sie, wohin
        Sie Ihre Tags kopieren möchten; stellen Sie sicher, dass alle
        Benutzer wissen, wie sie ihre zu kopierenden Verzeichnisse
        behandeln sollen, d.h., stellen Sie sicher, dass sie nichts
        dorthin übertragen. Der zweite Ansatz ist etwas paranoider: Sie
        können eins der Zugriffskontrollskripte verwenden, die mit
        Subversion ausgeliefert werden, um zu verhindern, dass
        irgendjemand etwas anderes im Tag-Bereich macht, als dort neue
        Kopien zu erzeugen (siehe <xref linkend="svn.serverconfig"/>).
        Der paranoide Ansatz ist normalerweise nicht notwendig. Falls
        ein Benutzer versehentlich eine Änderung an ein
        Tag-Verzeichnis übertragen hat, können Sie die Änderung einfach
        rückgängig machen, wie im vorhergehenden Abschnitt
        beschrieben. Schließlich handelt es sich um
        Versionskontrolle!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
<!--
      <title>Creating a Complex Tag</title>
-->
      <title>Erzeugen eines komplexen Tags</title>

<!--
      <para>Sometimes you may want a <quote>snapshot</quote> that is
        more complicated than a single directory at a single
        revision.</para>
-->
      <para>Manchmal möchten Sie vielleicht eine
        <quote>Momentaufnahme</quote> machen, die komplizierter ist
        als ein einzelnes Verzeichnis mit einer einzigen
        Revision.</para>

<!--
      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn
        update</command> with the <option>-r</option> option
        liberally), by switching files and directories to particular
        branches (making use of <command>svn switch</command>), or
        even just by making a bunch of local changes.  When you're
        done, your working copy is a hodgepodge of repository
        locations from different revisions.  But after testing, you
        know it's the precise combination of data you need to
        tag.</para>
-->
      <para>Stellen Sie sich beispielsweise vor, Ihr Projekt sei viel
        größer als unser <filename>calc</filename> Beispiel: Nehmen
        wir an, es enthalte eine große Zahl von Unterverzeichnissen
        und viel mehr Dateien. Während Ihrer Arbeit könnte es sein,
        dass Sie sich entscheiden, eine Arbeitskopie anzulegen, die
        bestimmte Merkmale und Fehlerbehebungen beinhaltet. Sie können
        dies hinbekommen, indem Sie selektiv Dateien oder
        Verzeichnisse auf bestimmte Revisionen zurückdatieren (unter
        Verwendung von <command>svn update</command> mit der Option
        <option>-r</option>), indem Sie Dateien und Verzeichnisse auf
        bestimmte Zweige umschalten (mit <command>svn
        switch</command>) oder sogar, indem Sie ein paar lokale
        Änderungen vornehmen. Wenn Sie fertig sind, ist Ihre
        Arbeitskopie ein Mischmasch aus Projektarchiv-Quellen
        verschiedener Revisionen. Nach dem Testen wissen Sie jedoch,
        dass das genau die Kombination ist, die Sie mit einem Tag
        versehen möchten.</para>

<!--
      <para>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (see <xref linkend="svn.ref.svn.c.copy"/> in <xref
        linkend="svn.ref.svn"/>), including the ability to copy a
        working copy tree to the repository:</para>
-->
      <para>Nun ist es an der Zeit, eine Momentaufnahme zu machen.
        Einen URL auf einen anderen zu kopieren hilft hier nicht
        weiter. In diesem Fall möchten Sie eine Momentaufnahme der
        exakten Anordnung Ihrer Arbeitskopie machen und sie im
        Projektarchiv speichern. Glücklicherweise besitzt <command>svn
        copy</command> vier verschiedene Anwendungsfälle (siehe <xref
        linkend="svn.ref.svn.c.copy"/> in <xref
        linkend="svn.ref.svn"/>), zu denen auch die Fähigkeit gehört,
        einen Arbeitskopie-Baum ins Projektarchiv zu kopieren:</para>

      <informalexample>
        <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \ <!--
           -m "Tag my existing working copy state."

Committed revision 940.
-->
           -m "Ein Tag für den Zustand meines Arbeitsverzeichnisses anlegen."

Revision 940 übertragen.
</screen>
      </informalexample>

<!--
      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, URLs,
        local changes, and all.</para>
-->
      <para>Nun gibt es ein neues Verzeichnis im Projektarchiv,
        <filename>/calc/tags/mytag</filename>, das eine exakte
        Momentaufnahme Ihrer Arbeitskopie ist &ndash; gemischte
        Revisionen, URLs, lokale Änderungen, usw.</para>

<!--
      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        directory or symlink changes), you can
        use <command>svn copy</command> to <quote>upload</quote> your
        working copy to a private area of the repository.  Your
        collaborator can then either check out a verbatim copy of your
        working copy or use <command>svn merge</command> to receive
        your exact changes.</para>
-->
      <para>Andere Benutzer haben interessante Anwendungsfälle für
        diese Fähigkeit von Subversion gefunden. Manchmal gibt es
        Situationen, in denen Sie ein paar lokale Änderungen in Ihrer
        Arbeitskopie gemacht haben, die ein Mitarbeiter sehen soll.
        Statt <command>svn diff</command> aufzurufen und eine
        Patch-Datei zu versenden (die allerdings weder Änderungen an
        Verzeichnissen oder symbolischen Links beinhaltet),
        können Sie <command>svn copy</command> verwenden, um Ihre
        Arbeitskopie in einen privaten Bereich des Projektarchivs
        <quote>abzulegen</quote>. Ihr Mitarbeiter kann dann entweder
        eine exakte Kopie Ihrer Arbeitskopie auschecken oder
        <command>svn merge</command> verwenden, um genau Ihre
        Änderungen zu empfangen.</para>

<!--
      <para>While this is a nice method for uploading a quick snapshot
        of your working copy, note that this is <emphasis>not</emphasis>
        a good way to initially create a branch.  Branch creation should
        be an event unto itself, and this method conflates the creation
        of a branch with extra changes to files, all within a single revision.
        This makes it very difficult (later on) to identify a single
        revision number as a branch point.</para>
-->
      <para>Obwohl dies eine nette Methode ist, schnell eine
        Momentaufnahme Ihrer Arbeitskopie anzulegen, sollten Sie
        beachten, dass es <emphasis>keine</emphasis> gute
        Vorgehensweise ist, einen Zweig zu erstellen. Die Erzeugung
        eines Zweigs sollte ein Ereignis für sich sein, wohingegen
        diese Methode die Erzeugung eines Zweigs mit zusätzlichen
        Änderungen an Dateien innerhalb einer einzelnen Revision
        verbindet. Das macht es später sehr schwer, eine einzelne
        Revisionsnummer als Verzweigungspunkt zu
        identifizieren.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
<!--
    <title>Branch Maintenance</title>
-->
    <title>Verwaltung von Zweigen</title>

<!--
    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>
-->
    <para>Sie haben mittlerweile vielleicht festgestellt, dass
      Subversion äußerst flexibel ist. Da Zweigen und Tags derselbe
      Mechanismus zugrunde liegt (Verzeichniskopien) und weil Zweige
      und Tags im normalen Dateisystem auftauchen, finden viele Leute
      Subversion einschüchternd. Es ist beinahe
      <emphasis>zu</emphasis> flexibel. In diesem Abschnitt machen wir
      einige Vorschläge, wie Sie Ihre Daten im Laufe der Zeit
      organisieren und verwalten können.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
<!--
      <title>Repository Layout</title>
-->
      <title>Aufbau des Projektarchivs</title>

<!--
      <para>There are some standard, recommended ways to organize the
        contents of a repository.  Most people create a
        <filename>trunk</filename> directory to hold the <quote>main
        line</quote> of development, a <filename>branches</filename>
        directory to contain branch copies, and
        a <filename>tags</filename> directory to contain tag copies.
        If a repository holds only one project, often people create
        these top-level directories:</para>
-->
      <para>Es gibt einige empfohlene Standards, den Inhalt eines
        Projektarchiv zu organisieren. Die meisten Leute erzeugen ein
        <filename>trunk</filename>-Verzeichnis, um die Hauptlinie der
        Entwicklung aufzunehmen, ein
        <filename>branches</filename>-Verzeichnis für Zweig-Kopien und
        ein <filename>tags</filename>-Verzeichnis für Tag-Kopien.
        Falls ein Projektarchiv nur ein Projekt beinhaltet, werden oft
        diese Verzeichnisse auf der obersten Ebene angelegt:</para>

      <informalexample>
        <literallayout>
/
   trunk/
   branches/
   tags/
</literallayout>
      </informalexample>

<!--
      <para>If a repository contains multiple projects, admins
        typically index their layout by project.  See <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>, but here's an example of such a
        layout:</para>
-->
      <para>Falls ein Projektarchiv mehrere Projekte enthält, teilen
        Administratoren das Projektarchiv üblicherweise nach den
        Projekten ein. Lesen Sie in <xref
        linkend="svn.reposadmin.projects.chooselayout"/> mehr über
        <quote>Projekt-Wurzelverzeichnisse</quote>; hier ist ein
        Beispiel für ein solches Layout:</para>

      <informalexample>
        <literallayout>
/
   paint/
      trunk/
      branches/
      tags/
   calc/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

<!--
      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>
-->
      <para>Natürlich ist es Ihnen freigestellt, diese verbreiteten
        Strukturen zu ignorieren. Sie können alle möglichen
        Variationen erzeugen, die am besten für Sie oder Ihr Team
        funktionieren. Denken Sie daran, dass es, wie auch immer Sie
        sich entscheiden, nicht für die Ewigkeit sein muss. Sie können
        jederzeit Ihr Projektarchiv umorganisieren. Da Zweige und Tags
        gewöhnliche Verzeichnisse sind, kann der Befehl <command>svn
        move</command> sie nach Belieben verschieben oder umbenennen.
        Die Umstrukturierung ist einfach eine Sache von serverseitigen
        Verschiebebefehlen. Wenn Ihnen der Aufbau des Projektarchivs
        nicht zusagt, jonglieren Sie einfach mit den Verzeichnissen
        herum.</para>

<!--
      <para>Remember, though, that while moving directories is
        easy to do, you need to be considerate of other users as well.
        Your juggling can disorient users with existing
        working copies.  If a user has a working copy of a particular
        repository directory and your <command>svn move</command>
        subcommand removes the path from the latest revision, then
        when the user next runs <command>svn update</command>, she is
        told that her working copy represents a path that no
        longer exists.  She is then forced to <command>svn
        switch</command> to the new location.</para>
-->
      <para>Obwohl es einfach ist, Verzeichnisse zu verschieben,
        sollten Sie Rücksicht auf andere Benutzer nehmen. Ihr Jonglieren
        kann Benutzer mit bestehenden Arbeitskopien verwirren.
        Falls ein Benutzer eine Arbeitskopie eines bestimmten
        Projektarchiv-Verzeichnisses hat, könnte Ihre <command>svn
        move</command>-Operation den Pfad von der letzten Revision
        entfernen. Wenn der Benutzer beim nächsten Mal <command>svn
        update</command> aufruft, wird ihm mitgeteilt, dass die
        Arbeitskopie einen Pfad repräsentiere, der nicht mehr bestehe,
        so dass er gezwungen ist, mit <command>svn switch</command>
        auf den neuen Ort umzuschalten.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
<!--
      <title>Data Lifetimes</title>
-->
      <title>Lebensdauer von Daten</title>

<!--
      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>
-->
      <para>Eine weitere nette Eigenschaft des Subversion-Modells ist
        die Möglichkeit, Zweigen und Tags eine begrenzte Lebensdauer
        zu geben, so wie jedem anderen versionierten Objekt. Nehmen
        wir beispielsweise an, dass Sie letztendlich Ihre Arbeit auf
        dem persönlichen Zweig des <filename>calc</filename>-Projektes
        abschließen. Nachdem Sie all Ihre Änderungen zurück nach
        <filename>/calc/trunk</filename> gebracht haben, braucht Ihr
        privater Zweig nicht mehr herumzuliegen:</para>

      <informalexample>
        <screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \ <!--
             -m "Removing obsolete branch of calc project."

Committed revision 474.
-->
             -m "Veralteten Zweig des Projekts calc gelöscht."

Revision 474 übertragen.
</screen>
      </informalexample>

      <tip>
<!--
        <para>Recall from the previous section that if the repository
          location your working copy refers to is deleted, then when
          you try to update you will receive an error:</para>
-->
        <para>Erinnern Sie sich aus dem vorhergehenden Abschnitt, dass
          sie eine Fehlermeldung bekommen, wenn Sie versuchen, Ihre
          Arbeitskopie zu aktualisieren und diese sich auf einen Ort
          im Projektarchiv bezieht, der gelöscht wurde:</para>
        <informalexample>
          <screen>
$ svn up<!--
Updating '.':
svn: E160005: Target path '/calc/branches/my-calc-branch' does not exist-->
Aktualisiere ».«:
Zielpfad »/calc/branches/my-calc-branch« existiert nicht
</screen>
        </informalexample>

<!--
        <para>All you need to do in this situation is switch your working
          copy to a location that still exits:</para>
-->
        <para>In dieser Situation müssen Sie nur Ihre Arbeitskopie auf
          einen noch existierenden Ort wechseln:</para>

        <informalexample>
          <screen>
$ svn sw ^/calc/trunk
D    src/whole.c
 U   src/real.c
A    src/integer.c
 U   .<!--
Updated to revision 474.-->
Aktualisiert zu Revision 474.
</screen>
        </informalexample>
      </tip>

<!--
      <para>And now your branch is gone.  Of course, it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you can still see
        your old branch.</para>
-->
      <para>Nun ist Ihr Zweig verschwunden. Selbstverständlich ist er
        nicht wirklich verschwunden: das Verzeichnis fehlt einfach in
        der <literal>HEAD</literal>-Revision, so dass es niemanden
        mehr ablenken kann. Wenn Sie <command>svn checkout</command>,
        <command>svn switch</command> oder <command>svn list</command>
        verwenden, um sich eine frühere Revision anzusehen, können Sie
        immer noch Ihren alten Zweig sehen.</para>

<!--
      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy</command> to copy it from the old
        revision:</para>
-->
      <para>Falls es nicht ausreichen sollte, im gelöschten
        Verzeichnis zu stöbern, können Sie es jederzeit wieder
        zurückholen. Das Wiederbeleben von Daten in Subversion ist
        sehr einfach. Falls ein gelöschtes Verzeichnis (oder eine
        gelöschte Datei) wieder nach <literal>HEAD</literal> gebracht
        werden soll, verwenden Sie einfach <command>svn copy</command>
        zum Kopieren aus der alten Revision:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/branches/my-calc-branch@473 \
           ^/calc/branches/my-calc-branch \ <!--
           -m "Restore my-calc-branch."

Committed revision 475.
-->
           -m "my-calc-branch wiederhergestellt."

Revision 475 übertragen.
</screen>
      </informalexample>

<!--
      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side by side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>
-->
      <para>In unserem Beispiel hatte Ihr persönlicher Zweig eine
        relativ kurze Lebensdauer: Sie haben ihn vielleicht angelegt,
        um einen Fehler zu beseitigen oder eine neue Funktion
        einzubauen. Wenn Ihr Arbeitspaket abgeschlossen ist, kann auch
        der Zweig geschlossen werden. In der Software-Entwicklung ist
        es allerdings auch üblich, zwei <quote>Haupt</quote>-Zweige zu
        haben, die für lange Zeit nebeneinander bestehen. Es ist zum
        Beispiel an der Zeit, eine stabile Version des
        <filename>calc</filename>-Projektes zu veröffentlichen, und
        Sie wissen, dass es wohl noch ein paar Monate dauern wird, um
        Fehler aus der Software zu entfernen. Sie wollen weder, dass
        dem Projekt neue Funktionen hinzugefügt werden, noch möchten
        Sie alle Entwicklern auffordern, das Programmieren
        einzustellen. Stattdessen erstellen Sie einen
        <quote>stabilen</quote> Zweig der Software, auf dem sich nicht
        viel verändern wird:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/stable-1.0 \ <!--
           -m "Creating stable branch of calc project."

Committed revision 476.
-->
           -m "Stabilen Zweig für Projekt calc angelegt."

Revision 476 übertragen.
</screen>
      </informalexample>

<!--
      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        cherrypicks bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.  We'll
        discuss this more in the next section.</para>
-->
      <para>Nun können Entwickler die neuesten (oder experimentellen)
        Funktionen <filename>/calc/trunk</filename> hinzufügen,
        während Sie zum Grundsatz erklären, dass ausschließlich
        Fehlerbehebungen an
        <filename>/calc/branches/stable-1.0</filename> übertragen
        werden. Das heißt, während auf dem Stamm weitergearbeitet
        wird, pickt jemand selektiv Fehlerbehebungen hinüber auf den
        stabilen Zweig. Selbst wenn die Software von hier bereits
        ausgeliefert worden ist, werden Sie diesen Zweig
        wahrscheinlich noch für eine lange Zeit pflegen &ndash; das
        heißt, so lange, wie Sie diese Auslieferung beim Kunden
        unterstützen werden. Wir werden das im nächsten Abschnitt
        näher erörtern.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonpatterns">
<!--
    <title>Common Branching Patterns</title>
-->
    <title>Verbreitete Verzweigungsmuster</title>

<!--
    <para>There are many different uses for branching and <command>svn
        merge</command>, and this section describes the most
        common.</para>
-->
    <para>Es gibt zahlreiche unterschiedliche Anwendungsfälle für  das
      Verzweigen und <command>svn merge</command>; dieser Abschnitt
      beschreibt die verbreitetesten.</para>

<!--
    <para>Version control is most often used for software
      development, so here's a quick peek at two of the most common
      branching/merging patterns used by teams of programmers.  If
      you're not using Subversion for software development, feel
      free to skip this section.  If you're a software developer
      using version control for the first time, pay close attention,
      as these patterns are often considered best practices by
      experienced folk.  These processes aren't specific to
      Subversion; they're applicable to any version control system.
      Still, it may help to see them described in Subversion
      terms.</para>
-->
    <para>Am häufigsten wird Versionskontrolle in der
      Software-Entwicklung verwendet, so dass wir an dieser Stelle
      kurz zwei der gebräuchlichsten Verzweigungs-  und
      Zusammenführungsmuster vorstellen, die von Entwicklerteams
      benutzt werden. Falls Sie Subversion nicht in der
      Software-Entwicklung verwenden, können Sie den Abschnitt getrost
      überspringen. Falls Sie ein Software-Entwickler sind, der
      Versionskontrolle das erste Mal verwendet, sollten Sie gut
      aufpassen, da es sich bei diesen Mustern um bewährte
      Vorgehensweisen handelt, die von erfahrenen Menschen empfohlen
      werden. Diese Prozesse sind nicht spezifisch für Subversion; sie
      sind anwendbar auf alle Versions-Kontroll-Systeme. Trotzdem
      mag es hilfreich sein, wenn sie anhand von Subversion erklärt
      werden.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.release">
<!--
      <title>Release Branches</title>
-->
      <title>Release-Zweige</title>

<!--
      <para>Most software has a typical life cycle: code, test,
        release, repeat.  There are two problems with this process.
        First, developers need to keep writing new features while
        quality assurance teams take time to test supposedly stable
        versions of the software.  New work cannot halt while the
        software is tested.  Second, the team almost always needs to
        support older, released versions of software; if a bug is
        discovered in the latest code, it most likely exists in
        released versions as well, and customers will want to get
        that bug fix without having to wait for a major new
        release.</para>
-->
      <para>Die meiste Software hat einen typischen Lebenszyklus:
        Erstellung, Test, Freigabe und wieder von vorne. Bei diesem
        Prozess gibt es zwei Probleme. Erstens müssen Entwickler neue
        Funktionen schreiben, während das Qualitätssicherungsteam sich
        Zeit zum Testen der vermeintlich stabilen Software nimmt.  Die
        Arbeit kann allerdings nicht liegenbleiben während die
        Software getestet wird. Zweitens muss das Team fast immer
        ältere, bereits an den Kunden herausgegebene Software
        unterstützen; falls im neuesten Quelltext ein Fehler entdeckt
        wird, besteht der Fehler wahrscheinlich auch in der
        herausgegebenen Version. Die Kunden möchten dann eine
        Fehlerbehebung, ohne auf ein größeres, neues Release zu
        warten.</para>

<!--
      <para>Here's where version control can help.  The typical
        procedure looks like this:</para>
-->
      <para>Hier kann Versionskontrolle helfen. Die typische
        Vorgehensweise ist wie folgt:</para>

      <orderedlist>

        <listitem>
<!--
          <para><emphasis>Developers commit all new work to the
            trunk.</emphasis>  Day-to-day changes are committed to
            <filename>/trunk</filename>: new features, bug fixes, and
            so on.</para>
-->
          <para><emphasis>Entwickler übertragen alles Neue an den
            Stamm.</emphasis> Tägliche Änderungen werden an
            <filename>/trunk</filename> übertragen: neue Funktionen,
            Fehlerbehebungen usw.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>The trunk is copied to a
            <quote>release</quote> branch.</emphasis>  When the team
            thinks the software is ready for release (say, a 1.0
            release), <filename>/trunk</filename> might be copied to
            <filename>/branches/1.0</filename>.</para>
-->
          <para><emphasis>Der Stamm wird in einen
            <quote>Release</quote>-Zweig kopiert.</emphasis> Wenn das
            Team der Auffassung ist, dass die Software reif für eine
            Freigabe ist (z.B. Release 1.0 ), kann
            <filename>/trunk</filename> nach
            <filename>/branches/1.0</filename> kopiert werden.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>Teams continue to work in
            parallel.</emphasis>  One team begins rigorous testing of
            the release branch, while another team continues new work
            (say, for version 2.0) on <filename>/trunk</filename>.  If
            bugs are discovered in either location, fixes are cherrypicked
            back and forth as necessary.  At some point, however, even
            that process stops.  The branch is <quote>frozen</quote>
            for final testing right before a release.</para>
-->
          <para><emphasis>Die Teams arbeiten parallel.</emphasis> Ein
            Team beginnt, den Release-Zweig sorgfältig zu testen,
            während ein anderes Team mit der Arbeit (z.B. für Release
            2.0) in <filename>/trunk</filename> fortfährt. Falls hier
            oder dort Fehler entdeckt werden sollten, werden die
            Fehlerbehebungen nach Bedarf hin oder her kopiert. Zu
            einem gegebenen Zeitpunkt hört jedoch sogar dieser Prozess
            auf. Der Zweig wird für die Abschlusstests vor der
            Freigabe <quote>eingefroren</quote>.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>The branch is tagged and
            released.</emphasis>  When testing is complete,
            <filename>/branches/1.0</filename> is copied to
            <filename>/tags/1.0.0</filename> as a reference
            snapshot.  The tag is packaged and released to
            customers.</para>
-->
          <para><emphasis>Der Zweig wird markiert und
            freigegeben.</emphasis> Nach dem Abschluss der Tests
            wird <filename>/branches/1.0</filename> als Momentaufnahme
            nach <filename>/tags/1.0.0</filename> kopiert. Das Tag
            wird paketiert und an den Kunden ausgeliefert.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>The branch is maintained over
            time.</emphasis>  While work continues
            on <filename>/trunk</filename> for version 2.0, bug fixes
            continue to be ported from <filename>/trunk</filename> to
            <filename>/branches/1.0</filename>.  When enough
            bug fixes have accumulated, management may decide to do a
            1.0.1 release: <filename>/branches/1.0</filename> is
            copied to <filename>/tags/1.0.1</filename>, and the tag
            is packaged and released.</para>
-->
          <para><emphasis>Der Zweig wird gepflegt.</emphasis> Während
            die Arbeit für Version 2.0 in <filename>/trunk</filename>
            weitergeht, werden weiterhin Fehlerbehebungen von
            <filename>/trunk</filename> nach
            <filename>/branches/1.0</filename> portiert. Wenn sich
            ausreichend Fehlerbehebungen angesammelt haben, könnte
            sich das Management entschließen, ein Release 1.0.1
            herauszugeben: <filename>/branches/1.0</filename> wird
            nach <filename>/tags/1.0.1</filename> kopiert, und das Tag
            wird paketiert und freigegeben.</para>
        </listitem>

      </orderedlist>

<!--
      <para>This entire process repeats as the software matures:
        when the 2.0 work is complete, a new 2.0 release branch is
        created, tested, tagged, and eventually released.  After
        some years, the repository ends up with a number of release
        branches in <quote>maintenance</quote> mode, and a number
        of tags representing final shipped versions.</para>
-->
      <para>Der gesamte Prozess wiederholt sich während die Software
        reift: Wenn die Arbeit an 2.0 fertig ist, wird ein neuer 2.0
        Release-Zweig erstellt, getestet, markiert und schließlich
        freigegeben. Nach einigen Jahren füllt sich das Projektarchiv mit
        einer Anzahl von Release-Zweigen, die weiterhin
        <quote>gepflegt</quote> werden, und einer Zahl von Tags, die
        den endgültigen, ausgelieferten Versionen entsprechen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.feature">
<!--
      <title>Feature Branches</title>
-->
      <title>Funktions-Zweige</title>

<!--
      <para>
        <indexterm>
          <primary>branches</primary>
          <secondary>feature branches</secondary>
        </indexterm>A <firstterm>feature branch</firstterm> is the sort of
        branch that's been the dominant example in this chapter (the
        one you've been working on while Sally continues to work on
        <filename>/trunk</filename>).  It's a temporary branch created
        to work on a complex change without interfering with the
        stability of <filename>/trunk</filename>.  Unlike release
        branches (which may need to be supported forever), feature
        branches are born, used for a while, merged back to the trunk,
        and then ultimately deleted.  They have a finite span of
        usefulness.</para>
-->
      <para>
        <indexterm>
          <primary>Zweige</primary>
          <secondary>Funktions-Zweige</secondary>
        </indexterm>Ein <firstterm>Funktions-Zweig</firstterm> ist die Art von
        Zweig, wie er im Hauptbeispiel dieses Kapitels vorkam (der
        Zweig, auf dem Sie gearbeitet haben, während Sally auf
        <filename>/trunk</filename> arbeitete). Es ist ein
        vorübergehender Zweig, der angelegt wird, um an einer
        komplexen Änderung zu arbeiten, ohne
        <filename>/trunk</filename> zu stören. Anders als
        Release-Zweige (die vielleicht ewig gepflegt werden müssen),
        werden Funktions-Zweige erstellt, eine Zeit lang genutzt,
        zurück in den Stamm integriert und schließlich gelöscht. Sie
        haben einen zeitlich begrenzten Nutzen.</para>

<!--
      <para>Again, project policies vary widely concerning exactly
        when it's appropriate to create a feature branch.  Some
        projects never use feature branches at all: commits to
        <filename>/trunk</filename> are a free-for-all.  The
        advantage to this system is that it's simple&mdash;nobody
        needs to learn about branching or merging.  The disadvantage
        is that the trunk code is often unstable or unusable.  Other
        projects use branches to an extreme: no change is
        <emphasis>ever</emphasis> committed to the trunk directly.
        Even the most trivial changes are created on a short-lived
        branch, carefully reviewed, and merged to the trunk.  Then
        the branch is deleted.  This system guarantees an
        exceptionally stable and usable trunk at all times, but at
        the cost of tremendous process overhead.</para>
-->
      <para>In Projekten gehen die Meinungen oft auseinander, wann der
        richtige Zeitpunkt zum Anlegen eines Funktions-Zweiges
        gekommen ist. Manche Projekte benutzen nie Funktions-Zweige:
        jeder darf Änderungen in <filename>/trunk</filename>
        übertragen. Der Vorteil hier ist, dass es einfach ist &ndash;
        niemand benötigt eine Schulung im Verzweigen und
        Zusammenführen. Der Nachteil ist, dass der Code oft instabil
        oder nicht nutzbar ist. Andere Projekte verwenden
        ausschließlich Zweige: Eine Änderung darf
        <emphasis>niemals</emphasis> direkt in
        <filename>/trunk</filename> übertragen werden. Selbst die
        trivialsten Änderungen werden auf einem kurzlebigen Zweig
        durchgeführt, sorgfältig geprüft und in den Stamm
        zurückgeführt. Danach wird der Zweig gelöscht. Dieses Vorgehen
        garantiert einen außerordentlich stabilen und nutzbaren Stamm,
        jedoch zum Preis eines erheblichen Prozessaufwands.</para>

<!--
      <para>Most projects take a middle-of-the-road approach.  They
        commonly insist that <filename>/trunk</filename> compile and
        pass regression tests at all times.  A feature branch is
        required only when a change requires a large number of
        destabilizing commits.  A good rule of thumb is to ask this
        question: if the developer worked for days in isolation and
        then committed the large change all at once (so that
        <filename>/trunk</filename> were never destabilized), would it
        be too large a change to review?  If the answer to that
        question is <quote>yes,</quote> the change should be
        developed on a feature branch.  As the developer commits
        incremental changes to the branch, they can be easily reviewed
        by peers.</para>
-->
      <para>Die meisten Projekte bewegen sich irgendwo dazwischen.
        Gewöhnlich bestehen sie darauf, dass
        <filename>/trunk</filename> stets compilierfähig bleibt und
        Regressionstests besteht. Ein Funktions-Zweig wird nur dann
        benötigt, falls eine Änderung eine große Anzahl
        destabilisierender Übergaben erfordert. Eine gute Faustregel
        ist, diese Frage zu stellen: Wäre, falls ein Entwickler nach Tagen
        isolierter Entwicklung die große Änderung auf einmal übergäbe
        (so dass <filename>/trunk</filename> nie instabil würde), die
        Änderung zu umfangreich zum Überprüfen? Falls die Antwort auf
        diese Frage <quote>ja</quote> lautet, sollte die Änderung auf
        einem Funktions-Zweig durchgeführt werden. Während der
        Entwickler schrittweise Änderungen in den Zweig übergibt,
        können sie auf einfache Weise von den Kollegen geprüft
        werden.</para>

<!--
      <para>Finally, there's the issue of how to best keep a feature
        branch in <quote>sync</quote> with the trunk as work
        progresses.  As we mentioned earlier, there's a great risk to
        working on a branch for weeks or months; trunk changes may
        continue to pour in, to the point where the two lines of
        development differ so greatly that it may become a nightmare
        trying to merge the branch back to the trunk.</para>
-->
      <para>Schließlich stellt sich die Frage, wie ein Funktions-Zweig
        am besten mit dem Stamm <quote>synchron</quote> gehalten
        werden kann während die Arbeit weitergeht. Wie wir vorher
        bereits bemerkten, besteht ein großes Risiko, wenn wochen-
        oder monatelang auf dem Zweig gearbeitet wird; währenddessen
        ändert sich auch der Stamm, so dass ein Punkt erreicht werden
        kann, an dem sich die beiden Entwicklungslinien so sehr
        unterscheiden, dass es zu einem Albtraum ausarten kann, den
        Zweig zurück auf den Stamm zu führen.</para>

<!--
      <para>This situation is best avoided by regularly running an
        automatic merge from trunk to the branch.  Make up a policy:
        once a week, merge the last week's worth of trunk changes to
        the branch.</para>
-->
      <para>Diese Situation wird am besten vermieden, indem regelmäßig
        ein automatischer Merge vom Stamm auf den Zweig gemacht wird.
        Machen Sie es zur Gewohnheit: Arbeiten Sie wöchentlich die
        Änderungen der vergangenen Woche vom Stamm in den Zweig
        ein.</para>

<!--
      <para>When you are eventually ready to merge the
        <quote>synchronized</quote> feature branch back to the trunk,
        begin by doing a final automatic merge of the latest trunk
        changes to the branch.  When that's done, the latest versions
        of branch and trunk are absolutely identical except for
        your branch changes.  You can then run an automatic reintegrate
        merge from the branch back to the trunk:</para>
-->
      <para>Wenn Sie schließlich bereit sind, den
        <quote>synchronisierten</quote> Funktions-Zweig zurück in den
        Stamm zu führen, machen Sie ein letztes Mal einen
        automatischen Merge der jüngsten Änderungen vom Stamm auf den
        Zweig. Danach werden die letzten Versionen auf dem Stamm und
        dem Zweig, bis auf Ihre Änderungen auf dem Zweig, absolut
        gleich sein. Sie können dann einen automatischen
        Reintegrations-Merge vom Zweig zurück auf den Stamm
        machen:</para>

      <informalexample>
        <screen>
$ cd trunk-working-copy

$ svn update <!--
Updating '.':
At revision 1910.
-->
Aktualisiere '.':
Revision 1910.

$ svn merge ^/calc/branches/mybranch <!--
- - Merging differences between repository URLs into '.':
-->
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
U    real.c
U    integer.c
A    newdirectory
A    newdirectory/newfile
 U   .
&hellip;
</screen>
      </informalexample>

<!--
      <para>Another way of thinking about this pattern is that your
        weekly sync of trunk to branch is analogous to running
        <command>svn update</command> in a working copy, while the
        final merge step is analogous to running <command>svn
        commit</command> from a working copy.  After all, what else
        <emphasis>is</emphasis> a working copy but a very shallow
        private branch?  It's a branch that's capable of
        storing only one change at a time.</para>
-->
      <para>Aus einem anderen Winkel betrachtet ist dieser
        wöchentliche Abgleich vom Stamm auf den Zweig analog zum
        Ausführen von <command>svn update</command> in einer
        Arbeitskopie, wobei das finale Zusammenführen <command>svn
        commit</command> in einer Arbeitskopie entspricht.
        <emphasis>Ist</emphasis> denn letztendlich eine Arbeitskopie
        nicht ein sehr flacher privater Zweig? Es ist ein Zweig, der
        nur eine Änderung gleichzeitig aufnehmen kann.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
<!--
    <title>Vendor Branches</title>
-->
    <title>Lieferanten-Zweige</title>

<!--
    <para>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&mdash;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</para>
-->
    <para>
      <indexterm>
        <primary>Zweige</primary>
        <secondary>Lieferanten-Zweige</secondary>
      </indexterm>Besonders in der Software-Entwicklung haben Ihre
      versionsverwalteten Daten oft einen engen Bezug zu Daten aus
      anderen Quellen oder sind vielleicht sogar davon abhängig. Im
      allgemeinen wird es ihr Projekt erfordern, dass Sie hinsichtlich
      dieser externen Datenquelle so aktuell wie möglich bleiben, ohne
      dabei die Stabilität des Projektes zu opfern. Dieses Szenario
      taucht immer dort auf, wo die von einer Gruppe erzeugten
      Informationen direkte Auswirkungen auf diejenigen Informationen
      haben, die von einer anderen Gruppe erstellt werden.</para>

<!--
    <para>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see <xref linkend="svn.developer.usingapi.apr" />).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <quote>bleeding edge</quote> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</para>
-->
    <para>Software-Entwickler könnten beispielsweise an
      einer Anwendung arbeiten, die die Bibliothek eines
      Drittanbieters benötigt. Subversion hat eine solche Abhängigkeit
      von der Bibliothek Apache Portable Runtime (APR) (siehe <xref
      linkend="svn.developer.usingapi.apr" />). Der Quelltext von
      Subversion hängt zur Gewährleistung der Portabilität von der
      APR-Bibliothek ab. In der frühen Phase der Entwicklung von
      Subversion hing das Projekt ziemlich nah am wechselnden API der
      APR, indem es immer die neueste Version des Quelltextes
      verwendete. Nun, da sowohl APR und Subversion gereift sind,
      versucht sich Subversion nur zu wohldefinierten Zeitpunkten mit
      dem APR-API zu synchronisieren, nämlich wenn dieses ausreichend
      getestet und stabil ist.</para>

<!--
    <para>Now, if your project depends on someone else's information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions of
      that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <quote>pin down</quote> specific
      versions of that information to some location in your own
      working copy (see <xref linkend="svn.advanced.externals"
      />).</para>
-->
    <para>Falls nun Ihr Projekt von den Informationen anderer
      abhängt, können Sie diese Informationen auf mehrere Arten mit
      Ihren synchronisieren. Am umständlichsten ist es, wenn Sie
      mündliche oder schriftliche Anweisungen an alle
      Projektmitarbeiter ausgeben, dass sie sicherzustellen haben,
      stets über die für Ihr Projekt benötigten Versionen der
      Drittanbieter zu verfügen. Falls die Daten des Drittanbieters
      sich in einem Subversion-Projektarchiv befinden, können Sie auch
      mithilfe der Subversion-Externals-Definition bestimmte Versionen
      dieser Daten mit Ihrer eigenen Arbeitskopie verbinden (siehe
      <xref linkend="svn.advanced.externals" />).</para>

<!--
    <para>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</para>
-->
    <para>Allerdings möchten Sie von Zeit zu Zeit spezielle
      Anpassungen des Drittanbieter-Codes in Ihrem eigenen
      Versions-Kontroll-System verwalten. Um auf unser Beispiel aus
      der Software-Entwicklung zurückzukommen, müssen Entwickler
      manchmal die Bibliothek der Drittanbieter für ihre Zwecke
      verändern.  Diese Änderungen können neue Funktionalitäten oder
      Fehlerbehebungen umfassen und werden nur solange intern
      verwaltet, bis sie eines Tages Teil einer offiziellen
      Auslieferung der Bibliothek werden. Es kann aber auch sein, dass
      diese Änderungen niemals an die Entwickler der Bibliothek
      zurückgegeben werden, sondern lediglich als spezielle
      Anpassungen für die Bedürfnisse der Software-Entwickler bestehen
      bleiben.</para>

<!--
    <para>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</para>
-->
    <para>Nun sind Sie in einer interessanten Situation: Ihr Projekt
      könnte seine Änderungen an den Daten von Drittanbietern auf
      getrennte Art und Weise verwalten, etwa in Form von
      Patch-Dateien oder als vollständig alternative Versionen. Jedoch
      wird so etwas schnell zu einem Albtraum, wenn es um die Pflege
      geht, und es wird ein Mechanismus benötigt, um die Änderungen
      auf den Code des Drittanbieters anzuwenden und diese Anpassung
      bei jeder Folgelieferung zu wiederholen.</para>

<!--
    <para>
      <indexterm>
        <primary>vendor drop</primary>
      </indexterm>The solution to this problem is to
      use <firstterm>vendor branches</firstterm>.  A vendor branch is
      a directory tree in your own version control system that
      contains information provided by a third-party entity, or
      vendor.  Each version of the vendor's data that you decide to
      absorb into your project is called a <firstterm>vendor
      drop</firstterm>.</para> 
-->
    <para>
      <indexterm>
        <primary>Zulieferung</primary>
      </indexterm>Die Lösung dieses Problems besteht in der Verwendung von
      <firstterm>Lieferanten-Zweigen</firstterm>.  Ein
      Lieferanten-Zweig ist ein Verzeichnisbaum in Ihrem eigenen
      Versions-Kontroll-System, der Informationen enthält, die von einem
      Drittanbieter &ndash; oder Lieferanten &ndash; bereitgestellt
      wird. Jede Version der Lieferantendaten, die Sie in Ihr Projekt
      aufnehmen wollen, wird <firstterm>Zulieferung</firstterm>
      genannt.</para> 

<!--
    <para>Vendor branches provide two benefits.  First, by storing the
      currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need
      to question whether they have the right version of the vendor's
      data.  They simply receive that correct version as part of their
      regular working copy updates.  Second, because the data lives in
      your own Subversion repository, you can store your custom
      changes to it in-place&mdash;you have no more need of an
      automated (or worse, manual) method for swapping in your
      customizations.</para>
-->
    <para>Lieferanten-Zweige bieten zwei Vorteile. Erstens, wird durch
      das Vorhalten der aktuellen Zulieferung in Ihrem eigenen
      Versions-Kontroll-System sichergestellt, dass für Ihre
      Projektmitarbeiter stets die richtige Version der
      Lieferantendaten verfügbar ist. Sie erhalten die richtige
      Version automatisch beim Aktualisieren ihrer Arbeitskopien.
      Zweitens, da die Daten in Ihrem eigenen Subversion-Projektarchiv
      liegen, können Sie dort auch Ihre Anpassungen speichern &ndash;
      es besteht somit keine Notwendigkeit mehr, Ihre Änderungen
      automatisch (oder schlimmer noch, manuell) in die Zulieferungen
      einzuarbeiten.</para>

<!--
    <para>Unfortunately, there is no single best way to manage vendor
      branches in Subversion.  The flexibility of the system offers
      several different approaches, each of which has its advantages
      and disadvantages, and none of which can be clearly considered
      a <quote>silver bullet</quote> for the problem.  We'll cover a
      few of these approaches at a high level in the following
      sections, using the common example of a software project which
      depends on a third-party library.</para>
-->
    <para>Unglücklicherweise existiert kein Königsweg, um
      Lieferanten-Zweige in Subversion zu verwalten. Die Flexibilität
      des Systems bietet mehrere verschiedene Ansätze, die alle ihre
      Vor- und Nachteile haben, und von denen keiner als
      <quote>Patentrezept</quote> für das Problem bezeichnet werden
      kann. Wir werden einige dieser Ansätze in den nächsten
      Abschnitten auf einer hohen Ebene behandeln und dabei als
      Beispiel ein Software-Projekt verwenden, das von einer
      Bibliothek eines Drittanbieters abhängt.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
<!--
      <title>General Vendor Branch Management Procedure</title>
-->
      <title>Allgemeines Vorgehen für die Verwaltung von Lieferanten-Zweigen</title>

<!--
      <para>Maintaining customizations to a third-party library
        involves three data sources: the version of the third-party
        library upon which your modifications were last based, the
        customized version (that is, the actual vendor branch) of that
        library which is used by your project, and any new version of
        the vendor's library to which you may be hoping to upgrade.
        Managing the vendor branch (which should live within your
        source code repository per our definition of the thing), then,
        essentially boils down to performing merge operations (in the
        general sense).  But different teams take different approaches
        to the other data sources&mdash;the pristine versions of the
        third-party library code.  Thus, there are likewise different
        specific ways to perform the requisite merges.</para>
-->
      <para>Die Fortführung von Anpassungen an einer Bibliothek von
        Drittanbietern erfordert drei Datenquellen: die Version der
        Bibliothek des Drittanbieters, auf die die Anpassungen zuletzt
        aufgesetzt haben, die angepasste Version (d.h., der
        eigentliche Lieferanten-Zweig) der Bibliothek, die von Ihrem
        Projekt verwendet wird und irgendeine neue Version der
        Bibliothek, auf die Sie zu aktualisieren hoffen. Die
        Verwaltung des Lieferanten-Zweigs (der nach unserer Definition
        innerhalb Ihres Quelltext-Projektarchivs leben sollte) besteht
        dann im Wesentlichen aus Merge-Operationen (im allgemeinen
        Sinn). Doch verfolgen unterschiedliche Teams auch
        unterschiedliche Ansätze gegenüber den anderen Datenquellen
        &ndash; den unveränderten Versionen des Quelltextes der
        Drittanbieter-Bibliothek. Aus diesem Grund gibt es
        wahrscheinlich verschiedene besondere Wege, die benötigten
        Merges auszuführen.</para>

<!--
      <para>Strictly speaking, there are a couple of different ways
        that those merges can be performed in the general sense.  For
        the sake of simplicity and with the goal of at least providing
        <emphasis>something</emphasis> concrete in this section of the
        book, we'll assume that there is but a single vendor branch
        which is upgraded to each successive new release of the
        third-party library by receiving updates that describe the
        differences between the current and new pristine versions of
        that library.</para>
-->
      <para>Strenggenommen können diese Merges im allgemeinen Sinn auf
        verschiedene Weisen durchgeführt werden. Aus Gründen der
        Einfachheit und mit dem Ziel, wenigstens
        <emphasis>etwas</emphasis> Konkretes in diesem Abschnitt des
        Buches zu liefern, gehen wir davon aus, dass es lediglich
        einen einzigen Lieferanten-Zweig gibt, der ständig Upgrades
        auf die neueste herausgegebene Version der Drittanbieter-Bibliothek
        erhält, indem er Aktualisierungen bekommt, die die
        Unterschiede zwischen der gegenwärtigen und der neuen
        unveränderten Version der Bibliothek beschreiben.</para>

<!--
      <note>
        <para>Another approach is to create new vendor branches for
          each successive pristine library version, applying the
          differences between the current pristine library and the
          customized version thereof (from the current vendor branch)
          to the new branch.  There's nothing wrong with that
          approach&mdash;we just don't feel compelled to document
          every legitimate possibility in this space.</para>
      </note>
-->
      <note>
        <para>Ein weiterer Ansatz ist es, neue Lieferanten-Zweige für
          jede nachfolgende unveränderte Version der Bibliothek
          anzulegen und die Unterschiede zwischen der aktuellen
          unveränderten und ihrer angepassten Version (vom aktuellen
          Lieferanten-Zweig) auf den neuen Zweig anzuwenden. An diesem
          Ansatz gibt es nichts auszusetzen, jedoch sind wir der
          Meinung, dass wir nicht jede berechtigte Möglichkeit an
          dieser Stelle dokumentieren müssen.</para>
      </note>

<!--
      <para>The following sections examine how to create and manage a
        vendor branch in a few different scenarios.  In the examples
        which follow, we'll assume that the third-party library is
        called libcomplex, and that we will be implementing a vendor
        branch based on libcomplex 1.0.0 which lives in our repository
        at <filename>^/vendor/libcomplex-custom</filename>.  We'll
        then look at how we can upgrade to libcomplex 1.0.1 while
        still preserving our customizations to the library.</para>
-->
      <para>Die folgenden Abschnitte untersuchen, wie
        Lieferanten-Zweige in ein paar unterschiedlichen Szenarios
        erzeugt und verwaltet werden. In den folgenden Beispielen
        nehmen wir an, dass die Bibliothek des Drittanbieters
        libcomplex heißt, und wir einen Lieferanten-Zweig basierend
        auf libcomplex 1.0.0 anlegen, der in unserem Projektarchiv
        unter <filename>^/vendor/libcomplex-custom</filename> liegt.
        Wir werden uns dann ansehen, wie wir einen Upgrade auf
        libcomplex 1.0.1 machen können und gleichzeitig unsere
        Anpassungen an die Bibliothek bewahren können.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.foreign-repos">
<!--
      <title>Vendor Branches from Foreign Repositories</title>
-->
      <title>Lieferanten-Zweige aus fremden Projektarchiven</title>

<!--
      <para>Let's look first at a vendor branch management approach
        that is possible when the original third-party library is
        itself Subversion-accessible.  For the sake of the example,
        we'll assume that the libcomplex library we previously
        discussed is developed in a publicly accessible Subversion
        repository, and that its developers use sane release
        procedures which include the creation of tags for each stable
        release version.</para>
-->
      <para>Sehen wir uns zunächst einen Ansatz zur Verwaltung von
        Lieferanten-Zweigen an, der möglich ist, falls die originale
        Drittanbieter-Bibliothek selbst über Subversion erreichbar
        ist. Für das Beispiel nehmen wir an, dass die besprochene
        Bibliothek libcomplex in einem öffentlich zugänglichen
        Subversion-Projektarchiv entwickelt wird und deren Entwickler
        vernünftige Freigabeverfahren verwenden, zu denen die
        Erzeugung von Tags für jede stabile freigegebene Version
        zählt.</para>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>foreign repository merges</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository merges</primary>
          <see>merging, foreign repository merges</see>
        </indexterm>
        <indexterm>
          <primary>copying</primary>
          <secondary>foreign repository copies</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository copies</primary>
          <see>copying, foreign repository copies</see>
        </indexterm>Since Subversion 1.5, <command>svn merge</command>
        has been able to perform so-called <firstterm>foreign
        repository merges</firstterm>, where the sources of the merge
        live in a different repository than the repository from which
        the merge target working copy was checked out.  And in
        Subversion 1.8, the behavior of <command>svn copy</command>
        was changed so that when you perform a copy from a foreign
        repository into an existing working copy, the resulting tree
        is incorporated into that working copy and scheduled for
        addition.  It's this <firstterm>foreign repository
        copy</firstterm> functionality that we'll use to bootstrap our
        vendor branch.</para>
-->
      <para>
        <indexterm>
          <primary>Merging</primary>
          <secondary>Merges aus fremden Projektarchiven</secondary>
        </indexterm>
        <indexterm>
          <primary>Merges aus fremden Projektarchiven</primary>
          <see>Merging, Merges aus fremden Projektarchiven</see>
        </indexterm>
        <indexterm>
          <primary>Kopieren</primary>
          <secondary>Kopien aus fremden Projektarchiven</secondary>
        </indexterm>
        <indexterm>
          <primary>Kopien aus fremden Projektarchiven</primary>
          <see>Kopieren, Kopien aus fremden Projektarchiven</see>
        </indexterm>Seit Subversion 1.5 kann <command>svn merge</command>
        sogenannte <firstterm>Merges aus fremden
        Projektarchiven</firstterm> ausführen, wobei die Quellen des
        Merges in einem anderen Projektarchiv liegen, als das
        Projektarchiv, aus dem die Arbeitskopie des Merge-Ziels
        ausgecheckt wurde. Und in Subversion 1.8 wurde das Verhalten
        von <command>svn copy</command> dergestalt geändert, dass beim
        Kopieren aus einem fremden Projektarchiv in eine bestehende
        Arbeitskopie der so entstandene Baum in diese Arbeitskopie
        aufgenommen wird und zum Hinzufügen vorgemerkt wird. Mit genau
        dieser Funktionalität der <firstterm>Kopie aus fremden
        Projektarchiven</firstterm> werden wir unseren
        Lieferanten-Zweig aufsetzen.</para>

<!--
      <para>So let's create our vendor branch.  We'll begin by
        creating a placeholder directory for all such vendor branches
        in our repository, and then checking out a working copy of
        that location.</para>
-->
      <para>Lassen Sie uns also unseren Lieferanten-Zweig erstellen.
        Wir beginnen damit, ein Verzeichnis als Platzhalter für alle
        derartigen Lieferanten-Zweige in unserem Projektarchiv
        anzulegen und dann eine Arbeitskopie daraus
        auszuchecken.</para>

      <informalexample>
        <screen>
$ svn mkdir http://svn.example.com/projects/vendor \<!--
            -m "Create a container for vendor branches."-->
            -m "Einen Container für Lieferanten-Zweige erstellen."<!--
Committed revision 1160.-->
Revision 1160 übertragen.
$ svn checkout http://svn.example.com/projects/vendor \
               /path/to/vendor<!--
Checked out revision 1160.-->
Ausgecheckt, Revision 1160.
$
</screen>
      </informalexample>

<!--
      <para>Now, we'll take advantage of Subversion's foreign
        repository copy support to get an exact copy of libcomplex
        1.0.0&mdash;including any Subversion properties stored on its
        files and directories&mdash;from the vendor repository.</para>
-->
      <para>Nun nutzen wir Subversions Unterstützung für Kopien aus
        fremden Projektarchiven, um eine exakte Kopie von libcomplex
        1.0.0 aus dem Projektarchiv des Drittanbieters zu bekommen
        &ndash; inklusive aller Subversion-Eigenschaften an den
        Dateien und Verzeichnissen.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn copy http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
           libcomplex-custom<!--
- - Copying from foreign repository URL 'http://svn.othervendor.com/repos/lib\
complex/tags/1.0.0':-->
-- Kopieren aus fremdem Projektarchiv bei URL »http://svn.othervendor.com/rep\
os/libcomplex/tags/1.0.0«:
A    libcomplex-custom
A    libcomplex-custom/README
A    libcomplex-custom/LICENSE
&hellip;
A    libcomplex-custom/src/code.c
A    libcomplex-custom/tests
A    libcomplex-custom/tests/TODO<!--
$ svn commit -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1161.-->
$ svn commit -m "Initialisierung des Lieferanten-Zweigs libcomplex aus libcomplex 1.0.0."
Füge hinzu         libcomplex-custom
Füge hinzu         libcomplex-custom/README
Füge hinzu         libcomplex-custom/LICENSE
&hellip;
Füge hinzu         libcomplex-custom/src
Füge hinzu         libcomplex-custom/src/code.h
Füge hinzu         libcomplex-custom/src/code.c
Übertrage Daten .......................................
Revision 1161 übertragen.
$
</screen>
      </informalexample>

      <note>
<!--
        <para>If you happen to be using an older version of
          Subversion, the closest available approximation of the new
          foreign repository copy support in <command>svn
          copy</command> is to instead import (via <command>svn
          import</command>) a working copy of the vendor's tag,
          including the <option>- -no-auto-props</option>
          and <option>- -no-ignore</option> options so that the
          complete tree and any of its versioned properties are
          accurately replicated in your own repository.</para>
-->
        <para>Sollten Sie eine ältere Version von Subversion
          verwenden, ist die Vorgehensweise, die der neuen
          Unterstützung von Kopien aus fremden Projektarchiven durch
          <command>svn copy</command> am
          nächsten kommt, eine Arbeitskopie des Lieferanten-Tags
          zu importieren (mit <command>svn import</command>), und
          dabei die Optionen <option>--no-auto-props</option> und
          <option>--no-ignore</option> zu verwenden, so dass der
          komplette Baum und alle versionierten Eigenschaften akkurat
          in Ihrem Projektarchiv repliziert werden.</para>
      </note>

<!--
      <para>Now that we have a vendor branch based on libcomplex 1.0.0,
        we can begin making the customizations to libcomplex required
        for our purposes, committing them directly to the vendor
        branch we've created.  And of course, we can begin using
        libcomplex in our own application.</para>
-->
      <para>Da wir nun einen Lieferanten-Zweig basierend auf
        libcomplex 1.0.0 haben, können wir mit den für unsere Zwecke
        notwendigen Anpassungen an libcomplex beginnen und sie direkt
        in den erstellten Lieferanten-Zweig übertragen.
        Selbstverständlich können wir anfangen, libcomplex in unseren
        eigenen Anwendungen zu verwenden.</para>

<!--
      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  Here is where Subversion's
        foreign repository merge operation is useful.  We have in our
        vendor branch the original libcomplex 1.0.0 plus our
        customizations to it.  What we need now is to get the set of
        changes the vendor has made between 1.0.0 and 1.0.1 into our
        vendor branch, ideally without clobbering our own
        customizations.  This is precisely what the 2-URL form of
        the <command>svn merge</command> command is for.</para>
-->
      <para>Nach einer Weile wird libcomplex 1.0.1 freigegeben.
        Nachdem wir uns die Änderungen angesehen haben, entscheiden
        wir uns, unseren Lieferanten-Zweig auf den Stand der neuen
        Version zu bringen. Hierbei ist Subversions Merge-Operation aus
        fremden Projektarchiven von Nutzen. Auf unserem
        Lieferanten-Zweig befindet sich die originale libcomplex 1.0.0
        plus unserer Anpassungen daran. Wir müssen nun die Menge der
        Änderungen, die der Drittanbieter zwischen 1.0.0 und 1.0.1
        gemacht hat, auf unseren Lieferanten-Zweig bringen,
        idealerweise, ohne dabei unsere Anpassungen zu überschreiben.
        Genau hierfür eignet sich die 2-URL-Form des Befehls
        <command>svn merge</command>.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn merge http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
            http://svn.othervendor.com/repos/libcomplex/tags/1.0.1 \
            libcomplex-custom<!--
- - Merging differences between foreign repository URLs into '.':-->
-- Zusammenführen der Unterschiede zwischen fremden Projektarchiv-URLs in ».«:
U    libcomplex-custom/src/code.h
C    libcomplex-custom/src/code.c
U    libcomplex-custom/README<!--
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'libcomplex-custom/src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: -->
Konfliktübersicht:
  Textkonflikte: 1
Konflikt in Datei »libcomplex-custom/src/code.c« entdeckt.
Auswahl: (p) später auflösen, (df) Änderungen anzeigen,
         (e) Dateibearbeiten, (m) Zusammenführung,
         (mc) eigene Seite des Konflikts,
         (tc) fremde Seite des Konflikts, (s) alle Optionen anzeigen: 
</screen>
      </informalexample>

<!--
      <para>As you can see, <command>svn merge</command> has merged
        the changes required to make libcomplex 1.0.0 look like
        libcomplex 1.0.1 into our working copy.  In our example, it has
        even noticed and flagged a conflict on one file.   It seems
        the vendor modified a region of one of the files we also
        customized.  Subversion safely detects this conflict, and
        gives us the opportunity to resolve it so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  (See <xref linkend="svn.tour.cycle.resolve" />
        for more on resolving conflicts of this sort.)</para>
-->
      <para>Wie Sie sehen können, hat <command>svn merge</command> die
        Änderungen, die notwendig sind, libcomplex 1.0.0 wie
        libcomplex 1.0.1 aussehen zu lassen, mit unserer Arbeitskopie
        zusammengeführt. In unserem Beispiel ist sogar ein Konflikt
        erkannt und markiert worden. Es schaut aus, als habe der
        Drittanbieter einen Bereich einer Datei geändert, den wir auch
        angepasst haben. Subversion entdeckt den Konflikt zuverlässig
        und bietet uns die Möglichkeit, ihn aufzulösen, so dass unsere
        Anpassungen auch mit der jetzigen libcomplex 1.0.1 immer noch
        sinnvoll sind. (Siehe <xref linkend="svn.tour.cycle.resolve" />
        für Weiteres zum Auflösen derartiger Konflikte.)</para>

<!--
      <para>Once we've resolved the conflicts and performed any
        testing or review we need, we can commit the changes to our
        vendor branch.</para>
-->
      <para>Sobald wir die Konflikte aufgelöst sowie notwendige Tests und
        Überprüfungen gemacht haben, können wir die Änderungen in
        unseren Lieferanten-Zweig übertragen.</para>

      <informalexample>
        <screen>
$ svn status libcomplex-custom
M       libcomplex-custom/src/code.h
M       libcomplex-custom/src/code.c
M       libcomplex-custom/README<!--
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-custom
Sending        libcomplex-custom/README
Sending        libcomplex-custom/src/code.h
Sending        libcomplex-custom/src/code.c
Transmitting file data ...
Committed revision 1282.-->
$ svn commit -m "Lieferanten-Zweig au Stand libcomplex 1.0.1 bringen." \
             libcomplex-custom
Sende              libcomplex-custom/README
Sende              libcomplex-custom/src/code.h
Sende              libcomplex-custom/src/code.c
Übertrage Daten ...
Revision 1282 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>That, in a nutshell, is how to manage vendor branches when
        the original source is Subversion-accessible.  There are some
        notable shortcomings, though.  First, foreign repository
        merges are not automatically tracked by Subversion itself like
        same-repository merges are.  This means the burden falls to
        the user to know which merges have been performed on their
        vendor branch, and just how to construct the next merge when
        upgrading that branch.  Also, as is the case for all of
        Subversion's merge support, renames in the merge sources can
        cause no small amount of complication and frustration.
        Unfortunately, at this time, we don't have a particularly
        solid recommendation to offer to alleviate that pain.</para>
-->
      <para>Das ist kurz und bündig, wie Lieferanten-Zweige verwaltet
        werden, falls die Original-Quellen für Subversion erreichbar
        sind. Es gibt jedoch einige erwähnenswerte Schwächen. Zunächst
        werden Merges aus fremden Projektarchiven nicht automatisch
        von Subversion verfolgt wie Merges innerhalb des eigenen
        Projektarchivs. Das bedeutet, der Anwender trägt die Last und
        muss wissen, welche Merges auf dem Lieferanten-Zweig
        stattgefunden haben und wie der nächste Merge aufzusetzen ist,
        wenn der Zweig aktualisiert werden soll. Ebenso, was für die
        gesamte Unterstützung von Merges durch Subversion gilt, können
        Umbenennungen der Merge-Quellen zu nicht geringen
        Komplikationen und Frustrationen führen. Unglücklicherweise
        sehen wir uns momentan außerstande, eine besonders
        zuverlässige Empfehlung zur Linderung dieses Schmerzes zu
        geben.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.mirrored-sources">
<!--
      <title>Vendor Branches from Mirrored Sources</title>
-->
      <title>Lieferanten-Zweige aus gespiegelten Quellen</title>

<!--
      <para>In the previous section
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) we
        looked at how to implement and maintain a vendor branch when
        the vendor drops are accessible via Subversion, which is the
        ideal scenario when it comes to vendor branches.  Subversion
        is pretty good at handling merges of stuff that's been
        Subversion-managed.  Unfortunately, it's not always the case
        that third-party libraries are publicly accessible via
        Subversion.  Many times, a project depends on a library which
        is delivered via only non-Subversion mechanisms, such as a
        source code release distribution tarball.  In such
        circumstances, we strongly recommend that you do all you can
        to get that non-Subversion information into Subversion as
        cleanly as possible.  So let's examine an approach to vendor
        branches in which the third-party library's various releases
        are mirrored within our own repository.</para>
-->
      <para>Im vorhergehenden Abschnitt
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) haben
        wir uns angesehen, wie ein Lieferanten-Zweig angelegt und
        verwaltet wird, wenn die Zulieferungen über Subversion zu
        erreichen sind, was der Idealfall bei Lieferanten-Zweigen ist.
        Subversion kann sehr gut mit Merges von Dingen umgehen, die
        von Subversion verwaltet wurden. Unglücklicherweise trifft es
        nicht immer zu, dass Bibliotheken von Drittanbietern
        öffentlich über Subversion zugreifbar sind. Oftmals hängt ein
        Projekt von einer Bibliothek ab, die über Wege außerhalb von
        Subversion ausgeliefert wird, wie etwa Quelltext-Tarballs.
        Unter derartigen Umständen empfehlen wir dringend, alles zu
        tun, um diese Informationen außerhalb von Subversion möglichst
        sauber in Subversion einzupflegen. Lassen Sie uns nun einen
        Ansatz für Lieferanten-Zweige untersuchen, bei dem die
        verschiedenen freigegebenen Versionen der
        Drittanbieter-Bibliothek innerhalb unseres eigenen
        Projektarchivs gespiegelt werden.</para>

<!--
      <para>Setting up the vendor branch the first time is pretty
        simple, really.  For our example, we'll assume that libcomplex
        1.0.0 is delivered via the common tarball mechanism.  To
        create our vendor branch, we'll first get the contents of the
        libcomplex 1.0.0 tarball into our repository as a read-only
        (by convention only) vendor tag of sorts.</para>
-->
      <para>Das erstmalige Aufsetzen des Lieferanten-Zweiges ist
        wirklich recht einfach. Für unser Beispiel nehmen wir an, dass
        libcomplex 1.0.0 über den verbreiteten Tarball-Mechanismus
        verteilt wird. Um unseren Lieferanten-Zweig zu erstellen,
        holen wir zunächst den Inhalt des libcomplex 1.0.0 Tarballs
        als nur-lesbaren (durch Konvention) Lieferanten-Tag in
        unser Projektarchiv.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.0.tar.gz
libcomplex-1.0.0/
libcomplex-1.0.0/README
libcomplex-1.0.0/LICENSE
&hellip;
libcomplex-1.0.0/src/code.c
libcomplex-1.0.0/tests
libcomplex-1.0.0/tests/TODO
$ svn import libcomplex-1.0.0 \
             http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
             --no-ignore --no-auto-props \<!--
             -m "Import libcomplex 1.0.0 sources."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1160.-->
             -m "libcomplex 1.0.0 Quellen importieren."
Füge hinzu         libcomplex-custom
Füge hinzu         libcomplex-custom/README
Füge hinzu         libcomplex-custom/LICENSE
&hellip;
Füge hinzu         libcomplex-custom/src
Füge hinzu         libcomplex-custom/src/code.h
Füge hinzu         libcomplex-custom/src/code.c
Übertrage Daten .......................................
Revision 1160 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>Note that in our example, we used
        the <option>- -no-ignore</option> option during import so that
        Subversion is sure to pick up every file in the vendor drop
        and not to omit any of them.  We also supply
        the <option>- -no-auto-props</option> option so that our client
        doesn't manufacture property information which isn't present
        in the vendor drop.<footnote><para>Technically, we could let
        the auto-props feature do its thing, but the key to making
        that work well is ensuring that each vendor drop gets
        identical auto-prop treatment.</para></footnote>.</para>
-->
      <para>Beachten Sie, dass wir in unserem Beispiel während des
        Imports die Option <option>--no-ignore</option> verwendeten,
        damit Subversion zuverlässig jede Datei der Zulieferung
        aufnimmt und keine ausläßt. Wir geben auch die Option
        <option>--no-auto-props</option> an, damit unser Client keine
        nicht in der Zulieferung enthaltene Eigenschafts-Informationen
        erzeugt.<footnote><para>Technisch gesehen, könnten wir die
        Funktionalität der auto-props gewähren lassen, jedoch ist der
        Schlüssel des guten Gelingens, dass jede Zulieferung bezüglich
        auto-prop gleich behandelt wird.</para></footnote>.</para>

<!--
      <para>Now that the first vendor release drop is present in our
        repository, we can create our vendor branch from it just as we
        would create any other branch&mdash;using <command>svn
        copy</command>.</para>
-->
      <para>Nun, da sich die erste Zulieferung des Drittanbieters in
        unserem Projektarchiv befindet, können wir daraus unseren
        Lieferanten-Zweig anlegen, genauso, wie jeden anderen Zweig
        &ndash; mit <command>svn copy</command>.</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-custom \
           -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."<!--
Committed revision 1161.-->
Revision 1161 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>Okay.  At this point we have a vendor branch based on
        libcomplex 1.0.0.  We are now poised to begin making the
        customizations to libcomplex required for our
        purposes&mdash;committing them directly to the vendor branch
        we've created&mdash;and then to start using our customized
        libcomplex in our own application.</para>
-->
      <para>Okay. An dieser Stelle haben wir einen Lieferanten-Zweig
        basierend auf libcomplex 1.0.0. Wir sind bereit, die für
        unsere Zwecke notwendigen Anpassungen an libcomplex
        vorzunehmen &ndash; indem wir sie direkt in den
        Lieferanten-Zweig übertragen &ndash; und unsere angepasste
        libcomplex in eigenen Applikationen zu verwenden.</para>

<!--
      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  In order to perform that
        upgrade on our branch, we need to essentially apply the same
        set of changes the vendor has made between 1.0.0 and 1.0.1 to
        our vendor branch without clobbering our own customizations.
        The safest way to perform that application is to first get
        libcomplex 1.0.1 into our repository <emphasis>as a delta
        against the libcomplex 1.0.0 code in our
        repository</emphasis>.  Afterwards, we'll use the 2-URL form
        of the <command>svn merge</command> command to replicate those
        same changes into our vendor branch.</para>
-->
      <para>Nach einer Weile wird libcomplex 1.0.1 freigegeben.
        Nachdem wir uns die Änderungen angesehen haben, entscheiden
        wir uns, unseren Lieferanten-Zweig auf den Stand der neuen
        Version zu bringen. Um diese Aktualisierung auf unserem Zweig
        vornehmen zu können, müssen wir im Prinzip dieselben
        Änderungsmengen auf unseren Lieferanten-Zweig anwenden, die
        der Lieferant zwischen 1.0.0 und 1.0.1 erstellt hat, ohne
        dabei unsere Anpassungen zu überschreiben. Die sicherte Weise,
        auf der das geschehen kann, ist es, zunächst libcomplex 1.0.1
        in unser Projektarchiv zu holen <emphasis>als Delta zum
        Quelltext von 1.0.0 in unserem Projektarchiv</emphasis>.
        Anschließend verwenden wir die 2-URL-Form des Befehls
        <command>svn merge</command> zum Replizieren derselben
        Änderungen auf den Lieferanten-Zweig.</para>


<!--
      <para>As it turns out, there are several different approaches we
        can take to to get libcomplex 1.0.1 into our repository in the
        right way.<footnote><para>Using another <command>svn
        import</command> operation would be
        an <emphasis>incorrect</emphasis> approach, as the libcomplex
        1.0.0 and 1.0.1 branches would not have any common
        ancestry.</para></footnote>  The approach we'll describe here
        is relatively rudimentary, but it will serve our illustrative
        needs.</para>
-->
      <para>Es stellt sich heraus, dass es mehrere unterschiedliche
        Ansätze gibt, die wir verfolgen können, um libcomplex 1.0.1
        auf die richtige Weise in unser Projektarchiv zu bekommen.
        <footnote><para>Die nochmalige Verwendung der Operation
        <command>svn import</command> Operation wäre ein
        <emphasis>falscher</emphasis> Ansatz, da die Zweige für
        libcomplex 1.0.0 und 1.0.1 keinen gemeinsamen Stammbaum
        hätten.</para></footnote> Der Ansatz, den wir hier
        beschreiben, ist relativ rudimentär, jedoch ist er unserer
        Beschreibung dienlich.</para>

<!--
      <para>Remember, we want our mirror of the libcomplex 1.0.1
        vendor drop to share ancestry with our 1.0.0 vendor drop,
        which will produce the best results later when we need to
        merge the changes between those drops to our vendor branch.
        So we'll start by creating a libcomplex-1.0.1 branch as copy
        of our previously created libcomplex-1.0.0 <quote>vendor
        tag</quote>&mdash;a copy which will eventually become a
        replica of libcomplex 1.0.1.</para>
-->
      <para>Erinnern Sie sich, dass wir möchten, dass die Spiegelung
        der Zulieferung von libcomplex 1.0.1 einen gemeinsamen
        Stammbaum mit unserer Zulieferung von 1.0.0 hat, was später zu
        den besten Ergebnissen führen wird, wenn wir die Änderungen
        zwischen diesen Zulieferungen in unseren Lieferanten-Zweig
        einbringen möchten. Wir beginnen also damit, einen Zweig für
        libcomplex-1.0.1 als Kopie unseres vorher erstellten
        libcomplex-1.0.0 <quote>Lieferanten-Tags</quote> &ndash; eine
        Kopie, die schließlich eine Replik von libcomplex 1.0.1
        wird.</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-1.0.1 \<!--
           -m "Setup a construction zone for libcomplex 1.0.1."
Committed revision 1282.-->
           -m "Einrichten eines Baugeländes für libcomplex 1.0.1."
Revision 1282 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>What we need now is to make a working copy of our
        libcomplex-1.0.1 branch, and then to make it actually look
        like libcomplex 1.0.1.  To do this, we'll take advantage of
        the fact that <command>svn checkout</command> can overlay an
        existing directory and, if the <option>- -force</option> option
        is provided, do so in manner that allows the differences
        between the checked-out tree and the target tree that the
        checkout overlayed to remain as local modifications in the new
        working copy.</para>
-->
      <para>Nun müssen wir eine Arbeitskopie unseres libcomplex-1.0.1
        Zweiges erstellen and ihn dann so herrichten, dass er
        eigentlich wie like libcomplex 1.0.1 aussieht. Um das zu
        erreichen, nutzen wir die Tatsache aus, das <command>svn
        checkout</command> ein bereits bestehendes Verzeichnis
        überlagern kann; wenn die Option <option>--force</option>
        angegeben wird, geschieht das auf eine Art und Weise, dass die
        Unterschiede zwischen dem ausgecheckten Baum und dem durch den
        Checkout überlagerten Zielbaum als lokale Änderungen in der
        Arbeitskopie verbleiben.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.1.tar.gz
libcomplex-1.0.1/
libcomplex-1.0.1/README
libcomplex-1.0.1/LICENSE
&hellip;
libcomplex-1.0.1/src/code.c
libcomplex-1.0.1/tests
libcomplex-1.0.1/tests/TODO
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
               libcomplex-1.0.1 \
               --force
E    libcomplex-1.0.1/README
E    libcomplex-1.0.1/LICENSE
E    libcomplex-1.0.1/INSTALL
&hellip;
E    libcomplex-1.0.1/src/code.c
E    libcomplex-1.0.1/tests
E    libcomplex-1.0.1/tests/TODO<!--
Checked out revision 1282.-->
Ausgecheckt, Revision 1282.
$ svn status libcomplex-1.0.1
M       libcomplex-1.0.1/src/code.h
M       libcomplex-1.0.1/src/code.c
M       libcomplex-1.0.1/README
$
</screen>
      </informalexample>

<!--
      <para>As you can see, after checking out what was really
        libcomplex 1.0.0 atop the libcomplex 1.0.1 exploded tarball,
        we are left with a working copy that contains local
        modifications&mdash;those modifications required to morph our
        previous vendor release drop into our new one.</para>
-->
      <para>Wie Sie sehen können, bleibt nach dem Auschecken von der
        eigentlichen libcomplex 1.0.0 über den ausgepackten libcomplex
        1.0.1 eine Arbeitskopie mit lokalen Änderungen zurück &ndash;
        diejenigen Änderungen, die benötigt werden, um unsere
        bisherige freigegebene Zulieferung in unsere neue zu
        verwandeln.</para>

<!--
      <para>Admittedly, this is a pretty simple example.  The changes
        required to perform this particular upgrade involved merely
        content changes to existing files.  In reality, new versions
        of third-party libraries might also add or remove files or
        directories, might rename files or directories, and so on.  In
        those situations, it can be much more challenging to morph the
        new vendor tag into a state where it accurately reflects the
        vendor drop it claims to reflect.  We'll leave the details of
        such transformations as an exercise to the
        reader.<footnote><para>Here's a hint, though: <userinput>svn
        add - -force /path/to/working-copy - -no-ignore
        - -no-auto-props</userinput> is super handy for adding any new
        vendor drop items to version control in this
        situation.</para></footnote></para>
-->
      <para>Das ist zugegebenermaßen ein ziemlich einfaches Beispiel.
        Die für die Aktualisierung notwendigen Änderungen waren
        lediglich inhaltliche Änderungen an bestehenden Dateien. In
        der Realität könnten neue Versionen der Bibliotheken von
        Drittanbietern auch sowohl Dateien als auch Verzeichnisse
        hinzufügen oder entfernen, Dateien oder Verzeichnisse
        umbenennen, usw. In solchen Situationen kann es eine viel
        größere Herausforderung sein, das neue Lieferanten-Tag in
        einen Zustand zu überführen, in dem es exakt die Zulieferung
        wiedergibt, die es verspricht. Wir überlassen die Details
        derartiger Transformationen dem Leser als Übung.<footnote>
        <para>Trotzdem ein Hinweis: <userinput>svn add --force
        /path/to/working-copy --no-ignore --no-auto-props</userinput>
        ist außerordentlich praktisch, um in dieser Situation alle
        neuen Objekte einer Zulieferung unter Versions-Kontrolle zu
        stellen.</para></footnote></para>

<!--
      <para>However we make it happen, once our new vendor tag working
        copy is reconciled with the original source distribution, we
        can commit those changes to our repository.</para>
-->
      <para>Wie auch immer wir es schaffen, sobald unsere neue auf dem
        Lieferanten-Tag basierende Arbeitskopie mit dem
        Original-Quellpaket abgeglichen ist, können wir diese
        Änderungen in unser Projektarchiv übertragen.</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-1.0.1
Sending        libcomplex-1.0.1/README
Sending        libcomplex-1.0.1/src/code.h
Sending        libcomplex-1.0.1/src/code.c
Transmitting file data ...
Committed revision 1283.-->
$ svn commit -m "Aktualisierung Lieferanten-Zweig auf libcomplex 1.0.1." \
             libcomplex-1.0.1
Sende              libcomplex-1.0.1/README
Sende              libcomplex-1.0.1/src/code.h
Sende              libcomplex-1.0.1/src/code.c
Übertrage Daten ...
Revision 1283 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>We're finally ready to upgrade our vendor branch.
        Remember, our goal is to get the changes made by the vendor
        between the 1.0.0 and 1.0.1 releases of their library into our
        vendor branch.  There is where a 2-URL <command>svn
        merge</command> operation, applied to a working copy of our
        vendor branch, comes into play.</para>
-->
      <para>Wir sind schließlich soweit, dass wir unseren
        Lieferanten-Zweig aktualisieren können. Wenn Sie sich
        entsinnen, besteht unser Ziel darin, die vom Lieferanten
        zwischen den Versionen 1.0.0 und 1.0.1 ihrer Bibliothek
        gemachten Änderungen in unseren Lieferanten-Zweig zu bekommen.
        our vendor branch. An diesem Punkt betritt eine <command>svn
        merge</command>-Operation mit 2 URLs die Bühne, die auf eine
        Arbeitskopie unseres Lieferanten-Zweig angewendet wird.</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-custom \
               libcomplex-custom
E    libcomplex-custom/README
E    libcomplex-custom/LICENSE
E    libcomplex-custom/INSTALL
&hellip;
E    libcomplex-custom/src/code.c
E    libcomplex-custom/tests
E    libcomplex-custom/tests/TODO<!--
Checked out revision 1283.-->
Ausgecheckt, Revision 1283.
$ cd libcomplex-custom
$ svn merge ^/vendor/libcomplex-1.0.0 \
            ^/vendor/libcomplex-1.0.1<!--
- - Merging differences between repository URLs into '.':-->
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
U    src/code.h
C    src/code.c
U    README<!--
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: -->
Konfliktübersicht:
  Textkonflikte: 1
Konflikt in Datei »src/code.c« entdeckt.
Auswahl: (p) später auflösen, (df) Änderungen anzeigen,
         (e) Dateibearbeiten, (m) Zusammenführung,
         (mc) eigene Seite des Konflikts,
         (tc) fremde Seite des Konflikts, (s) alle Optionen anzeigen: 
</screen>
      </informalexample>

<!--
      <para>As you can see, <command>svn merge</command> has merged
        the requisite changes into our working copy, flagging a
        conflict where the vendor modified the same region of one of
        the files as we did during our customizations.  Subversion
        detects this conflict, and gives us the opportunity to resolve
        it (using the methods described in
        <xref linkend="svn.tour.cycle.resolve" />) so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  Once we've resolved the conflicts and performed
        any testing or review we need, we can commit the changes to
        our vendor branch.</para>
-->
      <para>Wie Sie sehen können, hat <command>svn merge</command> die
        erforderlichen Änderungen in unsere Arbeitskopie gebracht und
        einen Konflikt markiert, bei dem der Lieferant den gleichen
        Bereich einer der Dateien geändert hat wie wir während unserer
        Anpassungen. Subversion entdeckt diesen Konflikt und bietet
        uns die Gelegenheit zur Auflösung (mittels der in
        <xref linkend="svn.tour.cycle.resolve" /> beschriebenen
        Methoden), so dass unsere Anpassungen an, mittlerweile,
        libcomplex 1.0.1 weiterhin einen Sinn ergeben.  Sobald wir die
        Konflikte aufgelöst sowie notwendige Tests und Überprüfungen
        gemacht haben, können wir die Änderungen in unseren
        Lieferanten-Zweig übertragen.</para>

      <informalexample>
        <screen>
$ svn status
M       src/code.h
M       src/code.c
M       README<!--
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1."
Sending        README
Sending        src/code.h
Sending        src/code.c
Transmitting file data ...
Committed revision 1284.-->
$ svn commit -m "Aktualisierung des Lieferanten-Zweigs auf libcomplex 1.0.1."
Sende              README
Sende              src/code.h
Sende              src/code.c
Übertrage Daten ..."
Revision 1294 übertragen.
$
</screen>
      </informalexample>

<!--
      <para>Our vendor branch upgrade is complete.  And the next time
        we need to upgrade that branch, we'll follow the same
        procedure we used to upgrade it this time.</para>
-->
      <para>Die Aktualisierung unseres Lieferanten-Zweiges ist
        vollbracht. Wenn wir beim nächsten Mal diesen Zweig
        aktualisieren müssen verfolgen wir die selbe Vorgehensweise,
        die wir bei der jetzigen Aktualisierung eingeschlagen
        sind.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.when">
<!--
    <title>To Branch or Not to Branch?</title>
-->
    <title>Verzweigen oder nicht verzweigen?</title>

<!--
    <para>To branch or not to branch&mdash;that is an interesting
      question.  This chapter has provided thus far a pretty deep dive
      into the waters of branching and merging, topics which have
      historically been the premier source of Subversion user
      confusion.  As if the rote actions involved in branching and
      branch management aren't sometimes tricky enough, some users get
      hung up on deciding whether they need to branch at all.  As
      you've learned, Subversion can handle common branching and
      branch management scenarios.  So, the decision of whether or not
      to branch a project's history is rarely a technical one.
      Rather, the social impact of the decision often carries more
      weight.  Let's examine some of the benefits and costs of using
      branches in a software project.</para>
-->
    <para>Verzweigen oder nicht verzweigen &ndash; das ist eine
      interessante Frage. Bis hierhin hat dieses Kapitel einen
      ziemlich tiefen Tauchgang in die Tiefen des Verzweigens und
      Zusammenführens geboten. Themen, die historisch die Hauptquellen
      für die Verwirrung von Subversion-Anwendern waren. Als wären die
      routinemäßigen Aktionen zum Verzweigen und Verwalten von Zweigen
      manchmal noch nicht kompliziert genug, bleiben einige Anwender
      bei der Entscheidung hängen, ob sie überhaupt Verzweigen
      sollten. Wie Sie gelernt haben, beherrscht Subversion die
      üblichen Szenarien zum Verzweigen und für die Verwaltung von
      Zweigen. Die Entscheidung für oder wider das Verzweigen ist also
      selten technischer Natur. Stattdessen haben die sozialen
      Auswirkungen ein höheres Gewicht. Lassen Sie uns einmal einige
      der Vorteile und Kosten der Verwendung von Zweigen in einem
      Software-Projekt einmal untersuchen.</para>

<!--
    <para>The most obvious benefit of working on a branch is
      isolation.  Changes made to the branch don't affect the other
      lines of development in the project; changes made to those other
      lines don't affect the branch.  In this way, a branch can serve
      as a great place to experiment with new features, complex bug
      fixes, major code rewrites, and so on.  No matter how much stuff
      Sally breaks on her branch, Harry and the rest of the team can
      continue with their work unhindered outside the branch.</para>
-->
    <para>Der offensichtlichste Vorteil des Arbeitens auf einem Zweig
      ist Isolation. Auf dem Zweig gemachte Änderungen berühren nicht
      die anderen Entwicklungslinien des Projektes: Änderungen an
      diesen anderen Linien berühren nicht den Zweig. Auf diese Weise
      kann ein Zweig als großartiger Ort zum Experimentieren mit neuen
      Funktionalitäten, komplizierten Fehlerbehebungen, größeren
      Refaktorierungen usw. dienen. Egal, wie viel Sally auf ihrem
      Zweig kaputt macht, Harry und der Rest der Mannschaft können mit
      ihrer Arbeit ungehindert außerhalb des Zweigs
      weitermachen.</para>

<!--
    <para>Branches also provide a great way to organize related
      changes into readily identifiable collections.  For example, the
      changes which comprise the complete solution to a particular bug
      might be a list of non-sequential revision numbers.  You might
      describe them in human language as <quote>revisions 1534, 1543,
      1587 and 1588</quote>.  You'd probably reproduce those numbers
      manually (or otherwise) in the issue tracker artifact which
      tracks the bug.  When porting the bug fix to other product
      versions, you'd need to make sure to port all those revisions.
      But had those changes been made on a unique branch, you'd find
      yourself referring only to that branch by its name in
      conversation, in issue tracker comments, and when porting
      changes.</para>
-->
    <para>Zweige bieten auch eine großartige Möglichkeit, verwandte
      Änderungen in leicht handhabbare Sammlungen zu organisieren.
      Beispielsweise könnten die Änderungen, die die Komplettlösung
      eines bestimmten Fehlers ausmachen, eine Liste
      nicht-aufeinanderfolgender Revisionsnummern sein. Sie könnten
      diese natürlichsprachlich als <quote>Revisionen 1534, 1543,
      1587 und 1588</quote> bezeichnen. Sehr wahrscheinlich werden Sie
      diese Nummern manuell (oder auf andere Weise) in einem
      Fehlerverfolgungs-Dokument festhalten. Wenn Sie die
      Fehlerbehebung auf andere Produktversionen anwenden möchten,
      müssen Sie sicherstellen, dass all diese Revisionen
      berücksichtigt werden. Wären diese Änderungen jedoch auf einem
      eindeutigen Zweig gemacht worden, könnten Sie sich bei
      Gesprächen, in Fehlerverfolgungs-Kommentaren und beim Portieren
      von Änderungen lediglich auf den Namen dieses Zweigs
      beziehen.</para>

<!--
    <para>The unfortunate downside of branches, though, is that the
      very isolation that makes them so
      useful <emphasis>can</emphasis> be at odds with the
      collaborative needs of the project team.  Depending on the work
      habits of your project peers, changes made to branches might not
      get the kind of constructive review, criticism, and testing that
      changes made to the main line of development do.  The isolation
      of a branch can encourage users to forsake certain version
      control <quote>best practices</quote>, leading to version
      history which is difficult to review <foreignphrase>post
      facto</foreignphrase>.  Developers on long-lived branches
      sometimes need to work extra hard to ensure that the
      evolutionary direction of their isolated copy of the codebase is
      in harmony with the direction their peers are steering the main
      code lines.  Now, these drawbacks might be less of an issue for
      true exploratory branches aimed at experimenting with the future
      of a codebase with no expectation of reintegrating the results
      back into the main development lines&mdash;mere policy needn't
      be a vision-killer!  But the simple fact remains that projects
      generally benefit from an orderly approach to version control
      where code and code changes enjoy the review and comprehension
      of more than one team member.</para>
-->
    <para>Es ist jedoch die unglückliche Kehrseite von Zweigen, dass
      eben jene Isolation, die sie so nützlich macht, zum Nachteil der
      kollaborativen Bedürfnisse der Projektmitarbeiter gereichen
      <emphasis>kann</emphasis>. Abhängig von den Arbeitsgewohnheiten
      Ihrer Kollegen im Projekt, könnte es sein, dass Änderungen, die
      auf Zweigen gemacht werden, nicht die Art konstruktiver
      Durchsicht, Kritik und Überprüfung erfahren, wie Änderungen an
      der Hauptentwicklungslinie. Die Isolation eines Zweigs kann
      Anwender dazu verleiten, bestimmte <quote>beste
      Vorgehensweisen</quote> bei der Versionskontrolle aufzugeben,
      was zu einer Versionsgeschichte führt, die nachträglich
      schwierig zu überprüfen ist. Entwickler auf langlebigen Zweigen
      müssen manchmal besonders schwer arbeiten, um sicherzustellen,
      dass die Richtung der Entwicklung ihrer isolierten Kopie der
      Quellen immer noch mit der Richtung harmoniert, die ihre
      Kollegen auf den Hauptentwicklungslinien einschlagen. Diese
      Nachteile mögen für wahre Versuchszweige weniger problematisch
      sein, die zum Experimentieren mit den künftigen Quellen ohne die
      Absicht der Rückführung in die Hauptentwicklungslinie angelegt
      werden &ndash; bloße Richtlinien brauchen keine Visionen
      abwürgen! Doch es bleibt die einfache Tatsache, dass Projekte
      allgemein von einem geordneten Ansatz für Versionskontrolle
      profitieren, bei dem der Quelltext und Änderungen daran die
      Begutachtung und das Verstehen von mehr als einem Teammitglied
      genießen.</para>

<!--
    <para>That's not to say that there are no technical penalties to
      branching.  Pardon us while we <quote>go meta</quote> for a bit
      here.  If you think about it, every time you checkout a
      Subversion working copy, you're creating a branch of sorts of
      your project.  It's a special sort of branch.  It lives only on
      your client machine; not in the repository.  You synchronize
      this branch with changes made in the repository
      using <command>svn update</command>&mdash;which acts almost like
      a special-cased, simplified form of an <command>svn
      merge</command> command.<footnote><para>Actually, you
      <emphasis>could</emphasis> use <userinput>svn merge
      -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>
      in your working copy to quite literally merge in all the
      repository changes since your last update if really wanted
      to!</para></footnote> You effectively reintegrate your branch
      each time you run <command>svn commit</command>.  So, in that
      special sense, Subversion users deal with branches and merges
      all the time.  Given the similarities between updating and
      merging, it's no surprise, then, that the areas in which
      Subversion seems to have the most shortcomings&mdash;namely,
      handling file and directory renames and dealing with tree
      conflicts in general&mdash;are problematic for both
      the <command>svn update</command> and <command>svn
      merge</command> operations.  Unfortunately, <command>svn
      merge</command> has a harder time of it precisely because of the
      fact that, for every way in which <command>svn update</command>
      is a special-cased, simplified kind of generic merge operation,
      a true Subversion merge is neither special-cased nor simplified.
      For this reason, merges perform much more slowly than updates,
      require explicit tracking (via
      the <literal>svn:mergeinfo</literal> property we've discussed in
      this chapter) and history-crunching arithmetic, and generally
      offer more opportunities for something to go awry.</para>
-->
    <para>Das bedeutet nicht, dass es beim Verzweigen keine Einbußen
      gibt. Verzeihen Sie bitte, wenn wir hier für einen Augenblick
      auf <quote>die Metaebene gehen</quote>. Wenn Sie darüber
      nachdenken, erzeugen Sie jedes Mal irgendwie einen Zweig, wenn
      Sie eine Subversion-Arbeitskopie auschecken. Es ist ein
      besonderer Zweig. Er lebt nur auf Ihrem Client-Rechner, nicht im
      Projektarchiv. Sie synchronisieren diesen Zweig mit Änderungen
      im Projektarchiv, indem Sie <command>svn update</command>
      aufrufen &ndash; das sich beinahe als Spezialfall wie eine
      vereinfachte Form eines <command>svn merge</command>-Befehls
      verhält.<footnote><para>Tatsächlich <emphasis>könnten</emphasis>
      Sie <userinput>svn merge
      -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>
      in Ihrer Arbeitskopie verwenden,  um buchstäblich alle
      Änderungen im Projektarchiv seit Ihrer letzten Aktualisierung
      hineinzubringen, wenn Sie wollten!</para></footnote>
      Gewissermaßen reintegrieren Sie Ihren Zweig jedes Mal, wenn Sie
      <command>svn commit</command> aufrufen. In diesem Sinn haben
      Anwender von Subversion ständig mit Zweigen und Merges zu tun.
      Angesichts der Ähnlichkeiten der Aktualisierung und
      Zusammenführung ist es deshalb nicht überraschend, dass die
      Bereiche in denen Subversion die meisten Schwächen zu haben
      scheint &ndash; nämlich die Behandlung von Umbenennungen von
      Dateien und Verzeichnissen sowie, generell, bei Baumkonflikten
      &ndash; sowohl für die Operationen <command>svn update</command>
      und <command>svn merge</command> problematisch sind.
      Unglücklicherweise hat es hierbei <command>svn merge</command>
      schwerer, da im Gegensatz zum vereinfachten Sonderfall einer
      Merge-Operation mit <command>svn update</command> eine echte
      Zusammenführung in Subversion weder ein besonderer Fall noch
      vereinfacht ist. Aus diesem Grund verlaufen Merges auch
      wesentlich langsamer als Aktualisierungen, erfordern die
      explizite Aufzeichnung (über die Eigenschaft
      <literal>svn:mergeinfo</literal>, die wir in diesem Kapitel
      erörtert haben) sowie Arithmetik zur Geschichtsbearbeitung und
      bieten im Allgemeinen viel mehr Angriffsfläche für etwas, das
      schiefgehen kann.</para>

<!--
    <para>To branch or not to branch?  Ultimately, that depends on
      what your team needs in order to find that sweet balance of
      collaboration and isolation.</para>
-->
    <para>Verzweigen oder nicht verzweigen? Letztendlich hängt es
      davon ab, was Ihr Team benötigt, um das süße Gleichgewicht
      zwischen Zusammenarbeit und Isolation zu finden.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
<!--
    <title>Summary</title>
-->
    <title>Zusammenfassung</title>

<!--
    <para>We covered a lot of ground in this chapter.  We
      discussed the concepts of tags and branches and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We showed how
      to use <command>svn merge</command> to copy changes from one
      branch to another or roll back bad changes.  We went over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>
-->
    <para>Wir haben in diesem Kapitel sehr viel durchgenommen. Wir
      haben die Konzepte hinter Tags und Zweigen besprochen und
      gezeigt, wie Subversion diese Konzepte durch das Kopieren von
      Verzeichnissen mit dem Befehl <command>svn copy</command>
      umsetzt. Wir zeigten, wie mit <command>svn merge</command>
      Änderungen von einem Zweig in einen anderen überführt werden
      können oder fehlerhafte Änderungen rückgängig gemacht werden.
      Wir besprachen, wie mit <command>svn switch</command>
      Arbeitskopien aus verschiedenen Projektarchiv-Quellen erstellt
      werden können. Und wir sprachen darüber, wie Zweige in einem
      Projektarchiv verwaltet werden können.</para>

<!--
    <para>Remember the Subversion mantra: branches and tags are cheap.
      So don't be afraid to use them when needed!</para>
-->
    <para>Erinnern Sie sich an das Mantra von Subversion: Zweige und
      Tags sind billig.  Scheuen Sie nicht, sie bei Bedarf zu
      nutzen!</para>

<!--
    <para>As a helpful reminder of all the operations we discussed,
      here is handy reference table you can consult as
      you begin to make use of branches.</para>
-->
    <para>Als eine hilfreiche Erinnerung an die besprochenen
      Operationen sei hier noch einmal eine Referenztabelle angeführt,
      die Sie benutzen können, während Sie damit beginnen, Zweige zu
      verwenden.</para>

    <table id="svn.branchmerge.summary.tbl-1">
<!--
      <title>Branching and merging commands</title>
-->
      <title>Befehle zum Verzweigen und Zusammenführen</title>
      <tgroup cols="2">
        <thead>
          <row>
<!--
            <entry>Action</entry>
            <entry>Command</entry>
-->
            <entry>Aktion</entry>
            <entry>Befehl</entry>
          </row>
        </thead>
        <tbody>
          <row>
<!--
            <entry>Create a branch or tag</entry>
-->
            <entry>Erstellung eines Zweigs oder eines Tags</entry>
            <entry><userinput>svn copy <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Switch a working copy to a branch or tag</entry>
-->
            <entry>Umschalten einer Arbeitskopie auf einen Zweig oder
              ein Tag</entry>
            <entry><userinput>svn switch <replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Synchronize a branch with trunk</entry>
-->
            <entry>Synchronisierung eines Zweigs mit dem Stamm</entry>
            <entry><userinput>svn merge <replaceable>trunkURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>See merge history or eligible changesets</entry>
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
-->
            <entry>Anzeige der Merge-Geschichte oder in
              Frage kommender Änderungsmengen</entry>
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Merge a branch back into trunk</entry>
-->
            <entry>Zurückführen des Zweigs in den Stamm</entry>
            <entry><userinput>svn merge <replaceable>branchURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Merge one specific change</entry>
-->
            <entry>Einarbeiten einer bestimmten Änderung</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Merge a range of changes</entry>
-->
            <entry>Einarbeiten einer Serie von Änderungen</entry>
            <entry><userinput>svn merge -r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Block a change from automatic merging</entry>
-->
            <entry>Eine Änderung für das automatische Zusammenführen
              blockieren</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> --record-only <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Preview a merge</entry>
-->
            <entry>Vorschau einer Zusammenführung</entry>
            <entry><userinput>svn merge <replaceable>URL</replaceable> --dry-run</userinput></entry>
          </row>

          <row>
<!--
            <entry>Abandon merge results</entry>
-->
            <entry>Verwerfen des Ergebnisses einer Zusammenführung</entry>
            <entry><userinput>svn revert -R .</userinput></entry>
          </row>

          <row>
<!--
            <entry>Resurrect something from history</entry>
-->
            <entry>Etwas aus der Geschichte wiederbeleben</entry>
            <entry><userinput>svn copy <replaceable>URL</replaceable>@<replaceable>REV</replaceable> <replaceable>localPATH</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Undo a committed change</entry>
-->
            <entry>Eine übertragene Änderung rückgängig machen</entry>
            <entry><userinput>svn merge -c -<replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Examine merge-sensitive history</entry>
-->
            <entry>Anzeige der Geschichte unter Berücksichtigung von
              Zusammenführungen</entry>
            <entry><userinput>svn log -g; svn blame -g</userinput></entry>
          </row>

          <row>
<!--
            <entry>Create a tag from a working copy</entry>
-->
            <entry>Erzeugen eines Tags aus einer Arbeitskopie</entry>
            <entry><userinput>svn copy . <replaceable>tagURL</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Rearrange a branch or tag</entry>
-->
            <entry>Einen Zweig oder ein Tag verschieben</entry>
            <entry><userinput>svn move <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Remove a branch or tag</entry>
-->
            <entry>Einen Zweig oder ein Tag löschen</entry>
            <entry><userinput>svn delete <replaceable>URL</replaceable></userinput></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->


