<!-- -*- sgml -*- -->

<chapter id="svn.basic">
  <!--
  <title>Fundamental Concepts</title>
-->
  <title>Основные понятия</title>

  <!--
  <para>This chapter is a short, casual introduction to Subversion and
    its approach to version control.  We begin with a discussion of
    general version control concepts, work our way into the specific
    ideas behind Subversion, and show some simple examples of
    Subversion in use.</para>
-->
  <para>Эта глава представляет собой краткое и поверхностное введение в
    Subversion и его подходу к управлению версиями.  Мы начнём с обсуждения
    общих понятий управления версиями, разберёмся с особыми идеями
    лежащими в основе Subversion и покажем несколько простых примеров
    использования Subversion.</para>

  <!--
  <para>Even though the examples in this chapter show people sharing
    collections of program source code, keep in mind that Subversion
    can manage any sort of file collection&mdash;it's not limited to
    helping computer programmers.</para>
-->
  <para>Не смотря на то, что примеры в этой главе показывают как люди
    совместно работают над исходным кодом программы, имейте в виду, что
    Subversion справляется с любым набором файлов &ndash; его применение
    не ограничено разработкой программного обеспечения.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.version-control-basics">
    <!--
    <title>Version Control Basics</title>
-->
    <title>Азы управления версиями</title>

    <!--
    <para>
      <indexterm>
        <primary>version control systems</primary>
      </indexterm>A version control system (or revision control
      system) is a system that tracks incremental versions (or
      revisions) of files and, in some cases, directories over time.
      Of course, merely tracking the various versions of a user's (or
      group of users') files and directories isn't very interesting in
      itself.  What makes a version control system useful is the fact
      that it allows you to explore the changes which resulted in each
      of those versions and facilitates the arbitrary recall of the
      same.</para>
-->
    <para>
      <indexterm>
        <primary>Системы управления версиями</primary>
      </indexterm>Система управления версиями это система которая
      отслеживает постепенное изменение версий (иначе ревизий) файлов и
      в некоторых случаях папок.  Конечно же, банальное отслеживание
      различных версий файлов и папок пользователя (или группы
      пользователей) само по себе не очень интересно.  Что делает систему
      контроля версий полезной так это то, что она позволяет исследовать
      и восстанавливать изменения привнесённые каждой из версий.</para>

    <!--
    <para>In this section, we'll introduce some fairly high-level
      version control system components and concepts.  We'll limit our
      discussion to modern version control systems&mdash;in today's
      interconnected world, there is very little point in
      acknowledging version control systems which cannot
      operate across wide-area networks.</para>
-->
    <para>В этом разделе мы рассмотрим относительно высокоуровневые
      компоненты и понятия системы управления версиями.  Мы ограничим
      обсуждение современными системами управления версиями &mdash;
      в современном мире нет смысла знакомиться с системами управления
      версиями которые не могут работать по глобалной сети (т.е. через
      Интернет).</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.repository">
      <!--
      <title>The Repository</title>
-->
      <title>Репозиторий</title>

      <!--
      <para>
        <indexterm>
          <primary>repositories</primary>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem tree</secondary>
        </indexterm>
        <indexterm>
          <primary>version control systems</primary>
          <secondary>clients</secondary>
        </indexterm>At the core of the version control system is a
        repository, which is the central store of that system's data.
        The repository usually stores information in the form of a
        <firstterm>filesystem tree</firstterm>&mdash;a hierarchy of
        files and directories.  Any number of
        <firstterm>clients</firstterm> connect to the repository, and
        then read or write to these files.  By writing data, a client
        makes the information available to others; by reading data,
        the client receives information from others.
        <xref linkend="svn.basic.repository.dia-1"/> illustrates
        this.</para>
-->
      <para>
        <indexterm>
          <primary>репозиторий</primary>
        </indexterm>
        <indexterm>
          <primary>репозиторий</primary>
          <secondary>дерево файловой системы</secondary>
        </indexterm>
        <indexterm>
          <primary>система управления версиями</primary>
          <secondary>клиенты</secondary>
        </indexterm>Ядром системы управления версиями является репозиторий,
        который представляет собой главное хранилище данных системы.
        Репозиторий обычно хранит информацию в виде <firstterm> дерева
        файловой системы</firstterm> &mdash; иерархии файлов и папок.
        Прочитать и записать файлы, подключившись к репозиторию, может любое
        количество <firstterm>клиентов</firstterm>.  Записывая данные,
        клиент делает информацию доступной для остальных. Читая данные,
        клиент получает информацию от остальных.
        <xref linkend="svn.basic.repository.dia-1"/> иллюстрирует это.
      </para>

      <figure id="svn.basic.repository.dia-1">
        <!--
        <title>A typical client/server system</title>
-->
        <title>Обычная клиент-серверная система</title>
        <graphic fileref="images/ch02dia1.png"/>
      </figure>

      <!--
      <para>Why is this interesting?  So far, this sounds like the
        definition of a typical file server.  And indeed, the
        repository <emphasis>is</emphasis> a kind of file server, but
        it's not your usual breed.  What makes the repository special
        is that as the files in the repository are changed, the
        repository remembers each version of those files.</para>
-->

      <para>Ну и что же в этом интересного?  Как-то не особо отличается от
        определения обычного файлового сервера, да?  В действительности,
        репозиторий это в некотором роде файловый сервер.  Только он иного
        сорта чем тот к которому вы привыкли.  Отличительной чертой
        репозитория является то, что он запоминает каждую версию изменений
        файлов.</para>

      <!--
      <para>When a client reads data from the repository, it normally
        sees only the latest version of the filesystem tree.  But what
        makes a version control client interesting is that it also has
        the ability to request previous states of the filesystem from
        the repository.  A version control client can ask historical
        questions such as <quote>What did this directory contain last
        Wednesday?</quote> and <quote>Who was the last person to
        change this file, and what changes did he make?</quote>
        These are the sorts of questions that are at the heart of any
        version control system.</para>
-->

      <para>Когда клиент читает данные из репозитория, он обычно видит
        только последнюю версию дерева файловой системы.  А вот что делает
        клиент управления версиями интересным, так это его способность
        запросить у репозитория предыдущее состояние файловой системы.
        Клиент управления версиями может задавать вопросы вроде
        <quote>Что было в этой папке в прошлую среду?</quote> и
        <quote>Кто последним изменял этот файл и какие изменения он внёс?
        </quote>.  Способность отвечать на такие вопросы заложена в
        основу любой системы управления версиями.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.working-copy">
<!--
      <title>The Working Copy</title>
-->
      <title>Рабочая копия</title>

      <!--
      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A version control system's value comes from the
        fact that it tracks versions of files and directories, but the
        rest of the software universe doesn't operate
        on <quote>versions of files and directories</quote>.  Most
        software programs understand how to operate only on
        a <emphasis>single</emphasis> version of a specific type of
        file.  So how does a version control user interact with an
        abstract&mdash;and, often, remote&mdash;repository full of
        multiple versions of various files in a concrete fashion?  How
        does his or her word processing software, presentation
        software, source code editor, web design software, or some
        other program&mdash;all of which trade in the currency of
        simple data files&mdash;get access to such files?  The answer
        is found in the version control construct known as
        a <firstterm>working copy</firstterm>.</para>
-->
      <para>
        <indexterm>
          <primary>рабочая копия</primary>
        </indexterm>Система контроля версий ценится за способность
        отслеживать версии файлов и папок в то время как в остальной части
        вселенной программного обеспечения приложения не работают с
        <quote>версиями файлова и папок</quote>.  Большинство программ
        знают как работать только с <emphasis>одной</emphasis> версией
        какого-то определённого типа файлов.  Так как же в действительности
        пользователь системы управления версиями взаимодействует с
        абстрактным и чаще всего удалённым репозиторием, наполненным
        множеством версий файлов?  Как программы обработки текстов,
        программы подготовки презентаций, редакторы исходного кода,
        инструменты веб-дизайнера или любая другая программа, распознающая
        данные, получают доступ к версиям из репозитория?  Ответ мы можем
        найти в образе <firstterm>рабочей копии</firstterm>.</para>

      <!--
      <para>A working copy is, quite literally, a local copy of a
        particular version of a user's VCS-managed data upon which
        that user is free to work.  Working copies<footnote><para>The
        term <quote>working copy</quote> can be generally applied to
        any one file version's local instance.  When most folks use
        the term, though, they are referring to a whole directory tree
        containing files and subdirectories managed by the version
        control system.</para></footnote> appear to other software
        just as any other local directory full of files, so those
        programs don't have to be <quote>version-control-aware</quote>
        in order to read from and write to that data.  The task of
        managing the working copy and communicating changes made to
        its contents to and from the repository falls squarely to the
        version control system's client software.</para>
-->
      <para>В буквальном смысле рабочая копия представляет собой
        локальную копию определённой версии пользовательских данных,
        хранящихся в системе управления версиями.  С этими данными
        пользователь волен обращаться как ему заблогарассудится.
        Рабочая копия<footnote><para>Термин <quote>рабочая копия</quote>
        может применяться к локальному файлу в определённой версии. Но
        обычно этот термин применяется для обозначения целого дерева папок,
        содержащего версионированные файлы и подпапки.</para></footnote>
        выглядит для любого другого программного обеспечения как обычная
        папка с файлами. Поэтому те программы не должны знать о
        существовании системы управления версий для того чтобы иметь
        возможность читать или записывать в неё данные.  Это уже клиент
        системы управления версий отвечает за управление рабочей копией и
        передачу изменений из и в репозиторий.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models">
<!--
      <title>Versioning Models</title>
-->
      <title>Модели версионирования</title>

<!--
      <para>If the primary mission of a version control system is to
        track the various versions of digital information over time, a
        very close secondary mission in any modern version control
        system is to enable collaborative editing and sharing of that
        data.  But different systems use different strategies to
        achieve this.  It's important to understand these different
        strategies, for a couple of reasons.  First, it will help you
        compare and contrast existing version control systems, in case
        you encounter other systems similar to Subversion.  Beyond
        that, it will also help you make more effective use of
        Subversion, since Subversion itself supports a couple of
        different ways of working.</para>
-->
      <para>Главной задачей системы управления версиями является
        отслеживание различный версий информации представленной в цифровом
        формате.  Но есть ещё и вторая, очень близкая задача любой
        современной системы управления версиями&mdash;обеспечение
        возможности совместного редактирования и использования данных.
        Разные системы используют разные подходы к выполнению этой задачи.
        Важно знать и понимать эти подходы по друм причинам.  Во первых, это
        поможет вам сравнивать и различать существующие системы управления
        версиями если вы столкнётесь с другими системами похожими на
        Subversion.  Во вторых, это поможет вам эффективнее использовать
        Subversion, так как он поддерживает несколько различных моделей
        работы.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.problem-sharing">
<!--
        <title>The problem of file sharing</title>
-->
        <title>Вопрос совместного использования файлов</title>

<!--
        <para>All version control systems have to solve the same
          fundamental problem: how will the system allow users to
          share information, but prevent them from accidentally
          stepping on each other's feet?  It's all too easy for users
          to accidentally overwrite each other's changes in the
          repository.</para>
-->
        <para>Все системы управления версиями должны решить один и тот же
          основной вопрос: как позволить пользователям совместно
          использовать данные, но предотвратить ситуацию когда
          пользователи начнут нечаянно наступать друг другу на пятки
          в процессе изменения данных?  Ведь так просто случайно переписать
          изменения друг-друга в репозитории.</para>

<!--
        <para>Consider the scenario shown in
          <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
          Suppose we have two coworkers, Harry and Sally.  They each
          decide to edit the same repository file at the same time.
          If Harry saves his changes to the repository first, it's
          possible that (a few moments later) Sally could accidentally
          overwrite them with her own new version of the file.  While
          Harry's version of the file won't be lost forever (because
          the system remembers every change), any changes Harry made
          <emphasis>won't</emphasis> be present in Sally's newer version
          of the file, because she never saw Harry's changes to begin
          with.  Harry's work is still effectively lost&mdash;or at
          least missing from the latest version of the file&mdash;and
          probably by accident.  This is definitely a situation we want
          to avoid!</para>
-->
        <para>Рассмотрим ситуацию которую иллюстрирует
          <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
          Предположим, что есть двое коллег&mdash;Гарри и Салли.
          Каждый из них решает отредактировать один и тот же файл в
          репозитории в один и тот же момент.  Если Гарри сохранит свои
          изменения первым, то есть возможность, что Салли нечаянно
          перепишет их изменениями которые вносит она уже в своей версии
          файла.  Хотя версия Гарри не будет утеряна (потому что системы
          управления  версиями помнят каждое изменение), любые изменения
          которые внёс Гарри <emphasis>не будут</emphasis> отображены в
          новой версии файла от Салли.  Это произойдёт просто потому что она
          ещё не видела изменений которые внёс Гарри.  По существу, работа
          Гарри потеряна или попросту отсутствует в последней версии файла.
          И скорее всего эта ситуация произошла непредумышленно.  Вот эту 
          ситуацию мы как раз и хотим предотвратить!</para>

        <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
<!--
          <title>The problem to avoid</title>
-->
          <title>Ситуация которую мы должны предотвратить</title>
          <graphic fileref="images/ch02dia2.png"/>
        </figure>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.lock-unlock">
<!--
        <title>The lock-modify-unlock solution</title>
-->
        <title>Решение lock-modify-unlock</title>

<!--
        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>lock-modify-unlock</tertiary>
          </indexterm>Many version control systems use a
          <firstterm>lock-modify-unlock</firstterm> model to address
          the problem of many authors clobbering each other's work.
          In this model, the repository allows only one person to
          change a file at a time.  This exclusivity policy is managed
          using locks.  Harry must <quote>lock</quote> a file before
          he can begin making changes to it.  If Harry has locked a
          file, Sally cannot also lock it, and therefore cannot make
          any changes to that file.  All she can do is
          wait for Harry to finish his changes, save the file and
          release his lock.  After Harry unlocks the file, Sally
          can take her turn by locking the file.  Then she may read
          the latest version of the file and edit it.
          <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
          demonstrates this simple solution.</para>
-->
        <para>
          <indexterm>
            <primary>управление версиями</primary>
            <secondary>модель</secondary>
            <tertiary>lock-modify-unlock</tertiary>
          </indexterm>Многие системы управления версиями используют модель
          <firstterm>lock-modify-unlock</firstterm> для решения проблемы
          затирания изменений при работе множества авторов над одними и теми
          же даннами.  При использовании этой модели в один момент времени
          репозиторий позволяет вносить изменения в файл только одному
          человеку.  Этот принцип исключительности работает с помощью локов.
          Гарри должен <quote>залочить</quote> файл перед тем как начать
          вносить в него изменения.  Если Гарри уже залочил файл, то Салли
          не может тоже его залочить и соответственно не может вносить
          изменения в этот файл.  Она только может дождаться пока Гарри
          закончит вносить изменения, сохранит файл и разлочит его.  После
          того как Гарри разлочит файл, наступает очередь Салли делать свой
          ход и залочить файл.  Затем она может прочитать последнюю версию
          файла и отредактировать её.
          <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
          иллюстрирует это простое решение.</para>

        <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
<!--
          <title>The lock-modify-unlock solution</title>
-->
          <title>Решение lock-modify-unlock</title>
          <graphic fileref="images/ch02dia3.png"/>
        </figure>

<!--
        <para>The problem with the lock-modify-unlock model is that it's
          a bit restrictive and often becomes a roadblock for
          users:</para>
-->
        <para>У решения lock-modify-unlock есть проблемы.  Оно несколько
          ограничивающее и часто создаёт препятствия для
          пользователей:</para>

        <itemizedlist>
          <listitem>
<!--
            <para><emphasis>Locking may cause administrative
              problems.</emphasis>

              Sometimes Harry will lock a file and then forget about it.
              Meanwhile, because Sally is still waiting to edit the file,
              her hands are tied.  And then Harry goes on vacation.  Now
              Sally has to get an administrator to release Harry's lock.
              The situation ends up causing a lot of unnecessary delay
              and wasted time.</para>
-->
            <para><emphasis>Locking может вызывать проблемы с
              адмнистрированием.</emphasis>

              Гарри может залочить файл и забыть об этом.  Напомним, Салли
              всё ещё ждёт своей очереди и руки у неё связяны.  А теперь
              Гарри ещё и в отпуск ушёл.  В такой ситуации Салли необходимо
              обратиться к администратору что бы тот разлочил файл над
              которым работал Гарри.  Всё это приводит к задержке и напрасно
              потраченному времени.
              </para>
          </listitem>

          <listitem>
<!--
            <para><emphasis>Locking may cause unnecessary
              serialization.</emphasis>

              What if Harry is editing the beginning of a text file,
              and Sally simply wants to edit the end of the same file?
              These changes don't overlap at all.  They could easily
              edit the file simultaneously, and no great harm would
              come, assuming the changes were properly merged together.
              There's no need for them to take turns in this
              situation.</para>
-->
            <para><emphasis>Locking может привести к излишней сериализации
              действий пользователей.</emphasis>

              Что если Гарри редактирует начало текстового файла, а Салли
              просто хочет отредактировать конец этого же файла?  Эти
              изменения не будут перескаться.  Они могли бы редактировать
              этот файл одновременно без какого-либо вреда.  В этой ситуации
              им нет необходимости ждать своей очереди.</para>
          </listitem>

          <listitem>
<!--
            <para><emphasis>Locking may create a false sense of
              security.</emphasis>

              Suppose Harry locks and edits file A, while Sally
              simultaneously locks and edits file B.  But what if A and
              B depend on one another, and the changes made to each are
              semantically incompatible?  Suddenly A and B don't work
              together anymore.  The locking system was powerless to
              prevent the problem&mdash;yet it somehow provided a false
              sense of security.  It's easy for Harry and Sally to
              imagine that by locking files, each is beginning a safe,
              insulated task, and thus they need not bother discussing
              their incompatible changes early on.  Locking often
              becomes a substitute for real communication.</para>
-->
            <para><emphasis>Locking может создать ложное ощущение
              безопасности.</emphasis>

              Предположим, что Гарри залочил и редактирует файл A.  Салли в
              в это же самое время залочила и редактирует файл B.  Но что
              если A и B зависят друг от друга?  Что если внесённые
              изменения несовместимы по смыслу?  Тогда A и B перестанут
              работать вместе.  Locking решение не смогло предотвратить
              такую ситуацию.  Хотя оно в некоторой степени создало ложное
              ощущение безопасности.  Для Гарри и Салли легко вообразить,
              что залочив файлы, каждый из них начинает работу над полностью
              изолированной задачей и следовательно им не нужно заранее
              обсуждать и согласовать изменения которые они оба собираются
              внести.  Locking часто заменяет живое общение.</para>
          </listitem>
        </itemizedlist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.copy-merge">
<!--
        <title>The copy-modify-merge solution</title>
-->
        <title>Решение copy-modify-merge</title>

        <!--
        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>copy-modify-merge</tertiary>
          </indexterm>Subversion, CVS, and many other version control
          systems use a <firstterm>copy-modify-merge</firstterm> model
          as an alternative to locking.  In this model, each user's
          client contacts the project repository and creates a
          personal working copy.  Users then work simultaneously and
          independently, modifying their private copies.  Finally, the
          private copies are merged together into a new, final
          version.  The version control system often assists with the
          merging, but ultimately, a human being is responsible for
          making it happen correctly.</para>
-->
        <para>
          <indexterm>
            <primary>управление версиями</primary>
            <secondary>модель</secondary>
            <tertiary>copy-modify-merge</tertiary>
          </indexterm>Subversion, CVS и другие системы управления версиями
          используют модель <firstterm>copy-modify-merge</firstterm> как
          альтернативу lock-modify-unlock.  В этой модели клиент каждого
          пользователя доступается до репоизтория проекта и создаёт
          персональную рабочую копию.  Затем пользователи работают
          одновременно и независимо друг от друга, внося изменения в свои
          локальные рабочие копии.  В результате их рабочие копии слияются
          вместе в новую конечную версию.  Система управления версиями часто
          оказывает помощь при слиянии, но, прежде всего, именно человек
          отвечает за то, что бы слияние прошло правильно.</para>

        <!--
        <para>
          <indexterm>
            <primary>out of date</primary>
          </indexterm>Here's an example.  Say that Harry and Sally
          each create working copies of the same project, copied from
          the repository.  They work concurrently and make changes to
          the same file A within their copies.  Sally saves her
          changes to the repository first.  When Harry attempts to
          save his changes later, the repository informs him that his
          file A is <firstterm>out of date</firstterm>.  In other
          words, file A in the repository has somehow changed since he
          last copied it.  So Harry asks his client to merge any new
          changes from the repository into his working copy of file A.
          Chances are that Sally's changes don't overlap with his own;
          once he has both sets of changes integrated, he saves his
          working copy back to the repository.
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/> show
          this process.</para>
-->
        <para>
          <indexterm>
            <primary>устаревший</primary>
          </indexterm>Давайте рассмотрим пример.  Представим, что Гарри и
          Салли получили из репозитория рабочие копии одного и того же
          проекта.  Они работают параллельно и вносят изменения в файл A
          в своих рабочих копиях.  Салли записывает свои изменения в
          репозиторий первой.  Затем, когда Гарри пытается записать свои
          изменения, репозиторий сообщает ему, что его файл A уже
          <firstterm>устарел</firstterm>  Иначе говоря;, файл A в
          репозитории был изменён с того момента как Гарри получил свою
          локальную копию.  Поэтому Гарри указывает своему клиенту слиять
          любые новые входящие изменения из репозитория с его рабочей копией
          файла A.  Скорее всего, изменений которые внесла Салли не
          пересекаются с изменениями Гарри и, как только оба набора
          изменений объединены, Гарри записывает свои изменения в
          репозиторий.
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> и
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/>
          иллюстрируют этот процесс.</para>

        <figure id="svn.basic.vsn-models.copy-merge.dia-1">
          <!--
          <title>The copy-modify-merge solution</title>
          -->
          <title>Решение copy-modify-merge</title>
          <graphic fileref="images/ch02dia4.png"/>
        </figure>

        <figure id="svn.basic.vsn-models.copy-merge.dia-2">
          <!--
          <title>The copy-modify-merge solution (continued)</title>
          -->
          <title>Решение copy-modify-merge (продолжение)</title>
          <graphic fileref="images/ch02dia5.png"/>
        </figure>

<!--
        <para>
          <indexterm>
            <primary>conflicts</primary>
          </indexterm>But what if Sally's changes
          <emphasis>do</emphasis> overlap with Harry's changes?  What
          then?  This situation is called a
          <firstterm>conflict</firstterm>, and it's usually not much
          of a problem.  When Harry asks his client to merge the
          latest repository changes into his working copy, his copy of
          file A is somehow flagged as being in a state of conflict:
          he'll be able to see both sets of conflicting changes and
          manually choose between them.  Note that software can't
          automatically resolve conflicts; only humans are capable of
          understanding and making the necessary intelligent choices.
          Once Harry has manually resolved the overlapping
          changes&mdash;perhaps after a discussion with Sally&mdash;he
          can safely save the merged file back to the
          repository.</para>
-->
        <para>
          <indexterm>
            <primary>конфликты</primary>
          </indexterm>А что произойдёт если изменения Салли на самом деле
          <emphasis>пересекаются</emphasis> с изменениями которые внёс
          Гарри?  Что тогда?  Такая ситуация называется
          <firstterm>конфликт</firstterm> и решить её обычно достаточно
          просто.  Когда Гарри указывает своему клиенту слиять последние
          изменения из репозитория с его рабочей копией, то его копия файла
          A помечается как находящаяся в состоянии конфликта.  В этот момент
          Гарри может просмотреть оба набора конфликтующих изменений и
          вручную выбрать те измнения которые нужно сохранить в итоговой 
          версии.  Необходимо отметить, что программное обеспечение
          не может решить конфликт автоматически.  Только человек способен
          осознать и понимать и совершать осознанный выбор.  Как только
          Гарри вручную решил конфликт пересекающихся изменений, например
          после обсуждения с Салли, то он может безопасно сохранить итоговую
          версию файла А в репозиторий.</para>

<!--
        <para>The copy-modify-merge model may sound a bit chaotic, but
          in practice, it runs extremely smoothly.  Users can work in
          parallel, never waiting for one another.  When they work on
          the same files, it turns out that most of their concurrent
          changes don't overlap at all; conflicts are infrequent.  And
          the amount of time it takes to resolve conflicts is usually
          far less than the time lost by a locking system.</para>
-->
        <para>Описание модели copy-modify-merge может звучать несколько
          беспорядочно, но на практике она работает невероятно гладко.
          Пользователи могут работать параллельно и ждать друг-друга
          никогда не потребуется.  Когда они работают над одними и теми же
          файлами, то в большинстве случаев оказывается, что
          изменения, которые они вносят одновременно, вообще не
          пересекаются и конфликты возникают редко.  А решение конфликтов
          обычно занимает намного меньше времени чем потерянное при
          использованиии lock-modify-unlock модели.</para>

<!--
        <para>In the end, it all comes down to one critical factor:
          user communication.  When users communicate poorly, both
          syntactic and semantic conflicts increase.  No system can
          force users to communicate perfectly, and no system can
          detect semantic conflicts.  So there's no point in being
          lulled into a false sense of security that a locking system
          will somehow prevent conflicts; in practice, locking seems
          to inhibit productivity more than anything else.</para>
-->
        <para>В конечном счёте, это всё сводится к одному важнейшему
          условию: общение пользователей.  Когда процесс обмена информацией
          между пользователями нарушен, то количество синтаксических и 
          смысловых конфликтов неизбежно увеличивается.  Никакая система не
          может заставить пользователей эффективно обмениваться информацией
          о задачах которые они выполняют.  Поэтому не стоит поддаваться
          ложному ощущению, что lock-modify-unlock модель предотвратит
          конфликты. На практике, lock-modify-unlock модель пагубно влияет
          на продуктивность больше чем чтобы то ни было.</para>

        <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
<!--
          <title>When Locking Is Necessary</title>
-->
          <title>Когда необходимо использовать модель lock-modify-unlock</title>

<!--
          <para>While the lock-modify-unlock model is considered
            generally harmful to collaboration, sometimes
            locking is appropriate.</para>
-->
          <para>Хотя модель lock-modify-unlock считается пагубной для
            совместной работы, иногда использовать её вполне уместно.</para>

<!--
          <para>The copy-modify-merge model is based on the assumption
            that files are contextually mergeable&mdash;that is, that the
            majority of the files in the repository are line-based text
            files (such as program source code).  But for files with
            binary formats, such as artwork or sound, it's often
            impossible to merge conflicting changes.  In these
            situations, it really is necessary for users to take strict
            turns when changing the file.  Without serialized access,
            somebody ends up wasting time on changes that are ultimately
            discarded.</para>
-->
          <para>Модель copy-modify-merge основывается на предположении, что
            редактируемые файлы поддаются слиянию в зависимости от
            контекста.  Имеется ввиду, что большинство файлов в репозитории
            являются обычными текстовыми файлами (например как исходный
            код).  Но для файлов в двоичном формате, таких как графические
            изображения или аудио, часто невозможно провести слияние
            конфликтующих изменений.  Без полседовательного доступа,
            кто-то может потратить время на внесение изменений которые в
            итоге так и не будут сохранены в репозиторий.</para>

<!--
          <para>While Subversion is primarily a copy-modify-merge
            system, it still recognizes the need to lock an occasional
            file, and thus provides mechanisms for this.  We discuss
            this feature in <xref linkend="svn.advanced.locking"/>.</para>
-->
          <para>Хотя главная модель в Subversion это copy-modify-merge,
            он предоставляет механизмы для локирования файлов и полностью
            поддерживает модель lock-modify-unlock.  Мы обсуждаем
            локирование в <xref linkend="svn.advanced.locking"/>.</para>

        </sidebar>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <title>Version Control the Subversion Way</title>

    <para>We've mentioned already that Subversion is a modern,
      network-aware version control system.  As we described in
      <xref linkend="svn.basic.version-control-basics"/> (our
      high-level version control overview), a repository serves as the
      core storage mechanism for Subversion's versioned data, and it's
      via working copies that users and their software programs
      interact with that data.  In this section, we'll begin to
      introduce the specific ways in which Subversion implements
      version control.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.svn-repositories">
      <title>Subversion Repositories</title>

      <para>Subversion implements the concept of a version control
        repository much as any other modern version control system
        would.  Unlike a working copy, a Subversion repository is an
        abstract entity, able to be operated upon almost exclusively
        by Subversion's own libraries and tools.  As most of a user's
        Subversion interactions involve the use of the Subversion
        client and occur in the context of a working copy, we spend
        the majority of this book discussing the Subversion working
        copy and how to manipulate it.  For the finer details of the
        repository, though, check out
        <xref linkend="svn.reposadmin"/>.</para>

      <warning id="svn.basic.svn-repositories.not-working-copy">
        <para>In Subversion, the client-side object which every user
          of the system has&mdash;the directory of versioned files,
          along with metadata that enables the system to track them
          and communicate with the server&mdash;is called
          a <emphasis>working copy</emphasis>.  Although other version
          control systems use the term <quote>repository</quote> for
          the client-side object, it is both incorrect and a common
          source of confusion to use the term in that way in the
          context of Subversion.</para>

        <para>Working copies are described later, in
          <xref linkend="svn.basic.in-action.wc"/>.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <title>Revisions</title>

      <para>A Subversion client commits (that is, communicates the
        changes made to) any number of files and directories as a
        single atomic transaction.  By atomic transaction, we mean
        simply this: either all of the changes are accepted into the
        repository, or none of them is.  Subversion tries to retain
        this atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>
        <indexterm>
          <primary>revisions</primary>
        </indexterm>Each time the repository accepts a commit, this
        creates a new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number assigned to
        the previous revision.  The initial revision of a freshly
        created repository is numbered 0 and consists of nothing but
        an empty root directory.</para>

      <para><xref linkend="svn.basic.in-action.revs.dia-1"/>
        illustrates a nice way to visualize the repository.  Imagine
        an array of revision numbers, starting at 0, stretching from
        left to right.  Each revision number has a filesystem tree
        hanging below it, and each tree is a <quote>snapshot</quote>
        of the way the repository looked after a commit.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>Tree changes over time</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>

        <para>
          <indexterm>
            <primary>revisions</primary>
            <secondary>global</secondary>
          </indexterm>Unlike most version control systems,
          Subversion's revision numbers apply to <emphasis>the entire
          repository tree</emphasis>, not individual files.  Each
          revision number selects an entire tree, a particular state
          of the repository after some committed change.  Another way
          to think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename>,</quote> they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Many
          other version control systems use per-file revision numbers,
          so this concept may seem unusual at first. (Former CVS users
          might want to see <xref linkend="svn.forcvs"/> for more
          details.)</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
      <title>Addressing the Repository</title>

      <para>
        <indexterm>
          <primary>repository URL</primary>
        </indexterm>Subversion client programs use URLs to identify
        versioned files and directories in Subversion repositories.
        For the most part, these URLs use the standard syntax,
        allowing for server names and port numbers to be specified as
        part of the URL.</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>http://svn.example.com/svn/project</simpara>
          </listitem>
          <listitem>
            <simpara>http://svn.example.com:9834/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Subversion repository URLs aren't limited to only
        the <literal>http://</literal> variety.  Because Subversion
        offers several different ways for its clients to communicate
        with its servers, the URLs used to address the repository
        differ subtly depending on which repository access mechanism
        is employed.  <xref linkend="svn.basic.in-action.wc.tbl-1"/>
        describes how different URL schemes map to the available
        repository access methods.  For more details about
        Subversion's server options, see
        <xref linkend="svn.serverconfig"/>.</para>

      <table id="svn.basic.in-action.wc.tbl-1">
        <title>Repository access URLs</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Schema</entry>
              <entry>Access method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>file:///</literal></entry>
              <entry>Direct repository access (on local disk)</entry>
            </row>
            <row>
              <entry><literal>http://</literal></entry>
              <entry>Access via WebDAV protocol to Subversion-aware
                Apache server</entry>
            </row>
            <row>
              <entry><literal>https://</literal></entry>
              <entry>Same as <literal>http://</literal>, but with
                SSL encryption</entry>
            </row>
            <row>
              <entry><literal>svn://</literal></entry>
              <entry>Access via custom protocol to an
                <literal>svnserve</literal> server</entry>
            </row>
            <row>
              <entry><literal>svn+ssh://</literal></entry>
              <entry>Same as <literal>svn://</literal>, but through
                an SSH tunnel</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Subversion's handling of URLs has some notable nuances.
        For example, URLs containing the <literal>file://</literal>
        access method (used for local repositories) must, in
        accordance with convention, have either a server name
        of <literal>localhost</literal> or no server name at
        all:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file://localhost/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Also, users of the <literal>file://</literal> scheme on
        Windows platforms will need to use an unofficially
        <quote>standard</quote> syntax for accessing repositories
        that are on the same machine, but on a different drive than
        the client's current working drive.  Either of the two
        following URL path syntaxes will work, where
        <literal>X</literal> is the drive on which the repository
        resides:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///X:/var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file:///X|/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Note that a URL uses forward slashes even though the
        native (non-URL) form of a path on Windows uses backslashes.
        Also note that when using
        the <literal>file:///<replaceable>X</replaceable>|/</literal>
        form at the command line, you need to quote the URL (wrap it
        in quotation marks) so that the vertical bar character is not
        interpreted as a pipe.</para>

      <note>
        <para>You cannot use Subversion's <literal>file://</literal> URLs
          in a regular web browser the way you can use typical
          <literal>file://</literal> URLs.  When you attempt to view
          a <literal>file://</literal> URL in a regular web browser, it
          reads and displays the contents of the file at that location
          by examining the filesystem directly.  However, Subversion's
          resources exist in a virtual filesystem (see <xref
          linkend="svn.developer.layerlib.repos" />), and your browser
          will not understand how to interact with that
          filesystem.</para>
      </note>

      <para>The Subversion client will automatically encode URLs as
        necessary, just like a web browser does.  For example, the URL
        <literal>http://host/path with space/project/españa</literal>
        &mdash; which contains both spaces and upper-ASCII characters
        &mdash; will be automatically interpreted by Subversion as if
        you'd provided
        <literal>http://host/path%20with%20space/project/espa%C3%B1a</literal>.
        If the URL contains spaces, be sure to place it within
        quotation marks at the command line so that your shell treats
        the whole thing as a single argument to the program.</para>

      <para>There is one notable exception to Subversion's handling of
        URLs which also applies to its handling of local paths in many
        contexts, too.  If the final path component of your URL or
        local path contains an at sign (<literal>@</literal>), you need
        to use a special syntax&mdash;described in
        <xref linkend="svn.advanced.pegrevs" />&mdash;in order to make
        Subversion properly address that resource.</para>

      <para>
        <indexterm>
          <primary>repository-relative URL</primary>
        </indexterm>
        <indexterm>
          <primary>caret syntax</primary>
        </indexterm>
        <indexterm>
          <primary>^</primary>
          <see>caret syntax</see>
        </indexterm>In Subversion 1.6, a new caret (<literal>^</literal>)
        notation was introduced as a shorthand for <quote>the URL of
        the repository's root directory</quote>.  For example, you can
        use the <literal>^/tags/bigsandwich/</literal> to refer to the
        URL of the <filename>/tags/bigsandwich</filename> directory in
        the root of the repository.  Such a URL is called a
        <firstterm>repository-relative URL</firstterm>.  Note
        that this URL syntax works only when your current working
        directory is a working copy&mdash;the command-line client
        knows the repository's root URL by looking at the working
        copy's metadata.  Also note that when you wish to refer
        precisely to the root directory of the repository, you must do
        so using <literal>^/</literal> (with the trailing slash
        character), not merely
        <literal>^</literal>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Subversion Working Copies</title>

      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A Subversion working copy is an ordinary directory
        tree on your local system, containing a collection of files.
        You can edit these files however you wish, and if they're
        source code files, you can compile your program from them in
        the usual way.  Your working copy is your own private work
        area: Subversion will never incorporate other people's
        changes, nor make your own changes available to others, until
        you explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>

      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes (by writing to the repository), thereby making them
        available to the other people working with you on your
        project.  If other people publish their own changes,
        Subversion provides you with commands to merge those changes
        into your own working copy (by reading from the repository).
        Notice that the central repository is the broker for
        everybody's changes in Subversion&mdash;changes aren't passed
        directly from working copy to working copy in the typical
        workflow.</para>

      <para>
        <indexterm>
          <primary>administrative directory</primary>
        </indexterm>
        <indexterm>
          <primary>.svn</primary>
          <see>administrative directory</see>
        </indexterm>A working copy also contains some extra files,
        created and maintained by Subversion, to help it carry out
        these commands.  In particular, each working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy's <firstterm>administrative
        directory</firstterm>.  The files in the administrative
        directory help Subversion recognize which of your versioned
        files contain unpublished changes, and which files are out of
        date with respect to others' work.</para>

      <note>
        <para>Prior to version 1.7, Subversion
          maintained <filename>.svn</filename> administrative
          subdirectories in <emphasis>every</emphasis> versioned
          directory of your working copy.  Subversion 1.7 offers a
          completely new approach to how working copy metadata is
          stored and maintained, and chief among the visible changes
          to this approach is that each working copy now has only
          one <filename>.svn</filename> subdirectory which is an
          immediate child of the root of that working copy.</para>
      </note>
      
      <tip>
        <para>While <filename>.svn</filename> is the de facto name of
          the Subversion administrative directory, Windows users may
          run into problems with the ASP.NET Web application framework
          disallowing access to directories whose names begin with a
          dot (<literal>.</literal>).  As a special consideration to
          users in such situations, Subversion will instead use
          <literal>_svn</literal> as the administrative directory name
          if it finds a variable
          named <literal>SVN_ASP_DOT_NET_HACK</literal> in its
          operating environment.  Throughout this book, any reference
          you find to <filename>.svn</filename> applies also
          to <literal>_svn</literal> when this <quote>ASP.NET
          hack</quote> is in use.</para>
      </tip>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.track-repos">
        <title>How the working copy works</title>

        <para>For each file in a working directory, Subversion records
          (among other things) two essential pieces of information:</para>

        <itemizedlist>
          <indexterm>
            <primary>revisions</primary>
            <secondary>working</secondary>
          </indexterm>

          <listitem>
            <para>What revision your working file is based on (this is
              called the file's <firstterm>working
              revision</firstterm>)</para>
          </listitem>
          <listitem>
            <para>A timestamp recording when the local copy was last
              updated by the repository</para>
          </listitem>
        </itemizedlist>

        <para>Given this information, by talking to the repository,
          Subversion can tell which of the following four states a
          working file is in:</para>

        <variablelist>
          <varlistentry>
            <term>Unchanged, and current</term>
            <listitem>
              <para>The file is unchanged in the working directory, and
                no changes to that file have been committed to the
                repository since its working revision.  An <command>svn
                commit</command> of the file will do nothing, and an
                <command>svn update</command> of the file will do
                nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Locally changed, and current</term>
            <listitem>
              <para>The file has been changed in the working directory,
                and no changes to that file have been committed to the
                repository since you last updated.  There are local
                changes that have not been committed to the repository;
                thus an <command>svn commit</command> of the file will
                succeed in publishing your changes, and an <command>svn
                update</command> of the file will do nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Unchanged, and out of date</term>
            <listitem>
              <para>The file has not been changed in the working
                directory, but it has been changed in the repository.
                The file should eventually be updated in order to make
                it current with the latest public revision.
                An <command>svn commit</command> of the file will do
                nothing, and an
                <command>svn update</command> of the file will fold the
                latest changes into your working copy.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Locally changed, and out of date</term>
            <listitem>
              <para>The file has been changed both in the working
                directory and in the repository.  An <command>svn
                commit</command> of the file will fail with an
                <quote>out-of-date</quote> error.  The file should be
                updated first; an <command>svn update</command> command
                will attempt to merge the public changes with the local
                changes.  If Subversion can't complete the merge in a
                plausible way automatically, it leaves it to the user to
                resolve the conflict.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.wc-funcdamentals">
        <title>Fundamental working copy interactions</title>

        <para>A typical Subversion repository often holds the files (or
          source code) for several projects; usually, each project is a
          subdirectory in the repository's filesystem tree.  In this
          arrangement, a user's working copy will usually correspond to
          a particular subtree of the repository.</para>

        <para>For example, suppose you have a repository that contains
          two software projects, <literal>paint</literal> and
          <literal>calc</literal>.  Each project lives in its own
          top-level subdirectory, as shown in <xref
          linkend="svn.basic.in-action.wc.dia-1"/>.</para>

        <figure id="svn.basic.in-action.wc.dia-1">
          <title>The repository's filesystem</title>
          <graphic fileref="images/ch02dia6.png"/>
        </figure>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>checkout</tertiary>
          </indexterm>
          <indexterm>
            <primary>checking out</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>creating</secondary>
            <see>checking out</see>
          </indexterm>To get a working copy, you must <firstterm>check
          out</firstterm> some subtree of the repository.  (The term
          <emphasis>check out</emphasis> may sound like it has something to do
          with locking or reserving resources, but it doesn't; it simply
          creates a working copy of the project for you.)  For example,
          if you check out <filename>/calc</filename>, you will get a
          working copy like this:</para>

        <informalexample>
          <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.
$ ls -A calc
Makefile  button.c integer.c .svn/
$
</screen>
        </informalexample>

        <para>The list of letter <literal>A</literal>s in the left
          margin indicates that Subversion is adding a number of items
          to your working copy.  You now have a personal copy of the
          repository's <filename>/calc</filename> directory, with one
          additional entry&mdash;<filename>.svn</filename>&mdash;which
          holds the extra information needed by Subversion, as mentioned
          earlier.</para>

        <para>
          <indexterm>
            <primary>committing</primary>
          </indexterm>
          <indexterm>
            <primary>checking in</primary>
            <see>committing</see>
          </indexterm>Suppose you make changes
          to <filename>button.c</filename>.  Since
          the <filename>.svn</filename> directory remembers the file's
          original modification date and contents, Subversion can tell
          that you've changed the file.  However, Subversion does not
          make your changes public until you explicitly tell it to.
          The act of publishing your changes is more commonly known as
          <firstterm>committing</firstterm> (or <firstterm>checking
          in</firstterm>) changes to the repository.</para>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>commit</tertiary>
          </indexterm>
          <indexterm>
            <primary>committing</primary>
          </indexterm>To publish your changes, you can use
          Subversion's <command>svn commit</command> command:</para>

        <informalexample>
          <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
$
</screen>
        </informalexample>

        <para>Now your changes to <filename>button.c</filename> have
          been committed to the repository, with a note describing your
          change (namely, that you fixed a typo).  If another user
          checks out a working copy of <filename>/calc</filename>, she
          will see your changes in the latest version of the
          file.</para>

        <para>Suppose you have a collaborator, Sally, who checked out a
          working copy of <filename>/calc</filename> at the same time
          you did.  When you commit your change to
          <filename>button.c</filename>, Sally's working copy is left
          unchanged; Subversion modifies working copies only at the
          user's request.</para>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>update</tertiary>
          </indexterm>
          <indexterm>
            <primary>updating</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>updating</secondary>
            <see>updating</see>
          </indexterm>To bring her project up to date, Sally can ask
          Subversion to <firstterm>update</firstterm> her working
          copy, by using the <command>svn update</command> command.
          This will incorporate your changes into her working copy, as
          well as any others that have been committed since she
          checked it out.</para>

        <informalexample>
          <screen>
$ pwd
/home/sally/calc
$ ls -A
Makefile button.c integer.c .svn/
$ svn update
Updating '.':
U    button.c
Updated to revision 57.
$
</screen>
        </informalexample>

        <para>The output from the <command>svn update</command> command
          indicates that Subversion updated the contents of
          <filename>button.c</filename>.  Note that Sally didn't need to
          specify which files to update; Subversion uses the information
          in the <filename>.svn</filename> directory as well as further
          information in the repository, to decide which files need to
          be brought up to date.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs">
        <title>Mixed-revision working copies</title>

        <para>
          <indexterm>
            <primary>working copies</primary>
            <secondary>mixed-revision</secondary>
          </indexterm>As a general principle, Subversion tries to be
          as flexible as possible.  One special kind of flexibility is
          the ability to have a working copy containing files and
          directories with a mix of different working revision
          numbers.  Subversion working copies do not always correspond
          to any single revision in the repository; they may contain
          files from several different revisions.  For example,
          suppose you check out a working copy from a repository whose
          most recent revision is 4:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:4
</literallayout>
        </informalexample>

        <para>At the moment, this working directory corresponds exactly
          to revision 4 in the repository.  However, suppose you make a
          change to <filename>button.c</filename>, and commit that
          change.  Assuming no other commits have taken place, your
          commit will create revision 5 of the repository, and your
          working copy will now look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:5
</literallayout>
        </informalexample>

        <para>Suppose that, at this point, Sally commits a change to
          <filename>integer.c</filename>, creating revision 6.  If you
          use <command>svn update</command> to bring your working copy
          up to date, it will look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:6
   integer.c:6
   button.c:6
</literallayout>
        </informalexample>

        <para>Sally's change to <filename>integer.c</filename> will
          appear in your working copy, and your change will still be
          present in <filename>button.c</filename>.  In this example,
          the text of <filename>Makefile</filename> is identical in
          revisions 4, 5, and 6, but Subversion will mark your working
          copy of <filename>Makefile</filename> with revision 6 to
          indicate that it is still current.  So, after you do a clean
          update at the top of your working copy, it will generally
          correspond to exactly one revision in the repository.</para>
  
        <sect4 id="svn.basic.in-action.mixedrevs.update-commit">
          <title>Updates and commits are separate</title>

          <para>One of the fundamental rules of Subversion is that
            a <quote>push</quote> action does not cause
            a <quote>pull</quote> nor vice versa.  Just
            because you're ready to submit new changes to the repository
            doesn't mean you're ready to receive changes that others
            have checked in.  And if you have new changes still in progress,
            <command>svn update</command> should gracefully merge
            repository changes into your own, rather than forcing you to
            publish them.</para>

          <para>The main side effect of this rule is that it means a
            working copy has to do extra bookkeeping to track mixed
            revisions as well as be tolerant of the mixture.  It's made
            more complicated by the fact that directories themselves are
            versioned.</para>

          <para>For example, suppose you have a working copy entirely
            at revision 10, while others have been committing their
            changes so that the youngest revision in the repository is
            now revision 14.  You edit the file
            <filename>foo.html</filename> and then perform
            an <command>svn commit</command>, which creates revision
            15 in the repository.  After the commit succeeds, many new
            users would expect the working copy to be entirely at
            revision 15, but that's not the case!  Any number of
            changes might have happened in the repository between
            revisions 10 and 15.  The client knows nothing of those
            changes in the repository, since you haven't yet
            run <command>svn update</command>, and <command>svn
            commit</command> doesn't pull down new changes.  If, on
            the other hand, <command>svn commit</command> were to
            automatically download the newest changes, it would be
            possible to set the entire working copy to revision
            15&mdash;but then we'd be breaking the fundamental rule
            of <quote>push</quote> and <quote>pull</quote> remaining
            separate actions.  Therefore, the only safe thing the
            Subversion client can do is mark the one
            file&mdash;<filename>foo.html</filename>&mdash;as being at
            revision 15.  The rest of the working copy remains at
            revision 10.  Only by running <command>svn
            update</command> can the latest changes be downloaded and
            the whole working copy be marked as revision 15.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.normal">
          <title>Mixed revisions are normal</title>

          <para>The fact is, <emphasis>every time</emphasis> you run
            <command>svn commit</command> your working copy ends up
            with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions than
            everything else.  After several commits (with no updates
            in between), your working copy will contain a whole mixture
            of revisions.  Even if you're the only person using the
            repository, you will still see this phenomenon.  To examine
            your mixture of working revisions, use the <command>svn
            status</command> command with the <option>--verbose</option>
            (<option>-v</option>) option (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information).</para>

          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to the
            working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, he expects
            to see the entire history of the object.  But if the
            object's working revision is quite old (often because
            <command>svn update</command> hasn't been run in a long
            time), the history of the <emphasis>older</emphasis>
            version of the object is shown.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.useful">
          <title>Mixed revisions are useful</title>

          <para>
            <indexterm>
              <primary>backdating</primary>
            </indexterm>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to
            forcibly <firstterm>backdate</firstterm> (or update to a
            revision older than the one you already have) portions of
            your working copy to an earlier revision; you'll learn how
            to do that in <xref linkend="svn.tour"/>.  Perhaps you'd
            like to test an earlier version of a submodule contained
            in a subdirectory, or perhaps you'd like to figure out
            when a bug first came into existence in a specific file.
            This is the <quote>time machine</quote> aspect of a
            version control system&mdash;the feature that allows you
            to move any portion of your working copy forward and
            backward in history.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.limits">
          <title>Mixed revisions have limitations</title>

          <para>However you make use of mixed revisions in your working
            copy, there are limitations to this flexibility.</para>

          <para>First, you cannot commit the deletion of a file or
            directory that isn't fully up to date.  If a newer version
            of the item exists in the repository, your attempt to delete
            will be rejected to prevent you from accidentally
            destroying changes you've not yet seen.</para>

          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up to date.  You'll learn about
            attaching <quote>properties</quote> to items in <xref
            linkend="svn.advanced"/>.  A directory's working revision
            defines a specific set of entries and properties, and thus
            committing a property change to an out-of-date directory may
            destroy properties you've not yet seen.</para>

          <para>Finally, beginning in Subversion 1.7, you cannot by
            default use a mixed-revision working copy as the target of
            a merge operation.  (This new requirement was introduced
            to prevent common problems which stem from doing so.)</para>

        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Summary</title>
    
    <para>We covered a number of fundamental Subversion concepts in
      this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We saw some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
      </listitem>

      <listitem>
        <para>We talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>

    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to move into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
