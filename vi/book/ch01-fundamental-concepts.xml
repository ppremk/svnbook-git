<!-- -*- sgml -*- -->

<chapter id="svn.basic">
<!--   <title>Fundamental Concepts</title> -->
  <title>Những khái niệm cơ bản</title>

<!--
  <para>This chapter is a short, casual introduction to Subversion and
    its approach to version control.  We begin with a discussion of
    general version control concepts, work our way into the specific
    ideas behind Subversion, and show some simple examples of
    Subversion in use.</para>
-->
  <para>Đây là một chương ngắn, giới thiệu sơ lược về Subversion và hướng tiếp cận của nó để kiểm soát phiên bản. Chúng tôi bắt đầu với một cuộc thảo luận về những khái niệm chung trong kiểm soát phiên bản, làm việc theo cách của chúng tôi vào những ý tưởng cụ thể phía sau Subversion và trình bày một số ví dụ đơn giản của việc ứng dụng Subversion.</para>

<!--
  <para>Even though the examples in this chapter show people sharing
    collections of program source code, keep in mind that Subversion
    can manage any sort of file collection&mdash;it's not limited to
    helping computer programmers.</para>
-->
  <para>Mặc dù những ví dụ trong chương này trình bày cách mọi người chia sẽ những bộ sưu tập của mã nguồn chương trình, nên nhớ rằng Subversion có thể quản lý loại bộ sưu tập tập tin bất kỳ&mdash;nó không phải chỉ giới hạn trong việc hỗ trợ những lập trình viên máy tính.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.version-control-basics">
<!--     <title>Version Control Basics</title> -->
    <title>Cản bản kiểm soát phiên bản</title>

<!--
    <para>
      <indexterm>
        <primary>version control systems</primary>
      </indexterm>A version control system (or revision control
      system) is a system that tracks incremental versions (or
      revisions) of files and, in some cases, directories over time.
      Of course, merely tracking the various versions of a user's (or
      group of users') files and directories isn't very interesting in
      itself.  What makes a version control system useful is the fact
      that it allows you to explore the changes which resulted in each
      of those versions and facilitates the arbitrary recall of the
      same.</para>
-->
    <para>
      <indexterm>
        <primary>hệ thống kiểm soát phiên bản</primary>
      </indexterm>Một hệ thống kiểm soát phiên bản (hay hệ thống kiểm soát thay đổi) là một hệ thống mà theo dõi xuyên suốt thời gian những phiên bản tăng dần (hay thay đổi) của những tập tin và trong một vài trường hợp, của những thư mục. Dĩ nhiên, chỉ theo dõi những phiên bản khác nhau của những tập tin và thư mục của người sử dụng (hoặc nhóm người sử dụng) không được thú vị cho lắm. Điều làm cho hệ thống kiểm soát phiên bản hữu dụng đó là thực tế nó cho phép bạn khám phá những thay đổi mà kết quả là mỗi phiên bản đó và cũng như thế tạo điều kiện cho việc thu hồi tùy ý.</para>

<!--
    <para>In this section, we'll introduce some fairly high-level
      version control system components and concepts.  We'll limit our
      discussion to modern version control systems&mdash;in today's
      interconnected world, there is very little point in
      acknowledging version control systems which cannot
      operate across wide-area networks.</para>
-->
    <para>Trong phần này, chúng tôi sẽ giới thiệu một số thành phần và khái niệm tương đối cao cấp. Chúng tôi sẽ thảo luận giới hạn trong những hệ thống kiểm soát phiên bản hiện đại&mdash;trong thế giới liên kết ngày nay, có rất ít điểm trong những hệ thống kiểm soát phiên bản mà không thể hoạt động thông qua hệ thống mạng diện rộng.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.repository">
<!--       <title>The Repository</title> -->
      <title>Kho lưu trữ</title>

<!--
      <para>
        <indexterm>
          <primary>repositories</primary>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem tree</secondary>
        </indexterm>
        <indexterm>
          <primary>version control systems</primary>
          <secondary>clients</secondary>
        </indexterm>At the core of the version control system is a
        repository, which is the central store of that system's data.
        The repository usually stores information in the form of a
        <firstterm>filesystem tree</firstterm>&mdash;a hierarchy of
        files and directories.  Any number of
        <firstterm>clients</firstterm> connect to the repository, and
        then read or write to these files.  By writing data, a client
        makes the information available to others; by reading data,
        the client receives information from others.
        <xref linkend="svn.basic.repository.dia-1"/> illustrates
        this.</para>
-->
      <para>
        <indexterm>
          <primary>kho lưu trữ</primary>
        </indexterm>
        <indexterm>
          <primary>kho lưu trữ</primary>
          <secondary>cây hệ thống tập tin</secondary>
        </indexterm>
        <indexterm>
          <primary>hệ thống kiểm soát phiên bản</primary>
          <secondary>khách</secondary>
        </indexterm>Ở trung tâm của hệ thống kiểm soát phiên bản là một kho lưu trữ, là kho trung tâm của dữ liệu hệ thống. Kho lưu trữ thường lưu trữ thông tin ở dạng <firstterm>cây hệ thống tập tin</firstterm>&mdash;một cấu trúc phân cấp của những tập tin và thư mục. Bất kỳ <firstterm>ứng dụng khách</firstterm> nào cũng có thể kết nối vào kho để đọc và ghi vào những tập tin này. Với việc ghi dữ liệu, ứng dụng khách làm cho thông tin có sẵn cho những ứng dụng khách khác; với việc đọc dữ liệu, ứng dụng khách nhận thông tin từ các ứng dụng khách khác. <xref linkend="svn.basic.repository.dia-1"/> minh hoạ điều này.</para>

      <figure id="svn.basic.repository.dia-1">
<!--         <title>A typical client/server system</title> -->
        <title>Một hệ thống chủ/khách kinh điển</title>
        <graphic fileref="images/ch02dia1.png"/>
      </figure>

<!--
      <para>Why is this interesting?  So far, this sounds like the
        definition of a typical file server.  And indeed, the
        repository <emphasis>is</emphasis> a kind of file server, but
        it's not your usual breed.  What makes the repository special
        is that as the files in the repository are changed, the
        repository remembers each version of those files.</para>
-->
      <para>Vì sao điều này thú vị? Điều này có vẻ như định nghĩa của một máy chủ tập tin thông thường. Và thực sự, kho lưu trữ <emphasis>là</emphasis> một dạng máy chủ tập tập tin, nhưng không phải là loại tập tin thông thường. Điều làm cho kho lưu trữ đặc biệt đó là khi những tập tin trong kho lưu trữ bị thay đổi, kho ghi nhớ từng phiên bản của những tập tin này.</para>

<!--
      <para>When a client reads data from the repository, it normally
        sees only the latest version of the filesystem tree.  But what
        makes a version control client interesting is that it also has
        the ability to request previous states of the filesystem from
        the repository.  A version control client can ask historical
        questions such as <quote>What did this directory contain last
        Wednesday?</quote> and <quote>Who was the last person to
        change this file, and what changes did he make?</quote>
        These are the sorts of questions that are at the heart of any
        version control system.</para>
-->
      <para>Khi một ứng dụng khách đọc dữ liệu từ kho, nó thông thường chỉ nhìn thấy phiên bản mới nhất của cây hệ thống tập tin. Những điều thú vị của ứng dụng khách kiểm soát phiên bản đó là nó có khả năng yêu cầu những trạng thái trước đó của hệ thống tập tin từ kho. Ứng dụng khách kiểm soát phiên bản có thể hỏi những câu hỏi mang tính lịch sử như là <quote>Thư mục này chứa những gì vào thứ Tư trước?</quote> và <quote>Ai là người cuối cùng thay đổi tập tin này, và thực hiện những thay đổi nào?</quote> Đây là những loại câu hỏi mà ở trung tâm của bất kỳ hệ thống kiểm soát phiên bản nào.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.working-copy">
<!--       <title>The Working Copy</title> -->
      <title>Bản sao làm việc</title>

<!--
      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A version control system's value comes from the
        fact that it tracks versions of files and directories, but the
        rest of the software universe doesn't operate
        on <quote>versions of files and directories</quote>.  Most
        software programs understand how to operate only on
        a <emphasis>single</emphasis> version of a specific type of
        file.  So how does a version control user interact with an
        abstract&mdash;and, often, remote&mdash;repository full of
        multiple versions of various files in a concrete fashion?  How
        does his or her word processing software, presentation
        software, source code editor, web design software, or some
        other program&mdash;all of which trade in the currency of
        simple data files&mdash;get access to such files?  The answer
        is found in the version control construct known as
        a <firstterm>working copy</firstterm>.</para>
-->
      <para>
        <indexterm>
          <primary>Những bản sao làm việc</primary>
        </indexterm>Giá trị của một hệ thống kiểm soát phiên bản đến từ thực tế là nó theo dõi những phiên bản của những tập tin và thư mục, trong khi phần còn lại của thế giới phần mềm không hoạt động trên <quote>các phiên bản của những tập tin và thư mục</quote>. Đa số những chương trình phần mềm hiểu cách hoạt động chỉ trên một phiên bản <emphasis>duy nhất</emphasis> của một loại tập tin cụ thể. Vậy làm cách nào người sử dụng kiểm soát phiên bản tương tác với một kho lưu trữ trừu tượng&mdash;và, thường là ở xa&mdash;với đầy những phiên bản của những tập tin khác nhau? Làm cách nào phần mềm xử lý văn bản, phần mềm trình chiếu, trình soạn thảo mã nguồn, phần mềm thiết kế web hoặc những chương trình khác &mdash;tất cả đều thao tác trên những tập tin dữ liệu đơn giản&mdash;của anh ấy hay cô ấy truy cập vào những tập tin này? Câu trả lời được tìm thấy trong cấu trúc kiểm soát phiên bản được biết đến là <firstterm>bản sao làm việc</firstterm>.</para>
        
     <!-- ### TODO: need to find a better way to translate the sentence "all of which trade in the currency of
        simple data files" ### -->

<!--
      <para>A working copy is, quite literally, a local copy of a
        particular version of a user's VCS-managed data upon which
        that user is free to work.  Working copies<footnote><para>The
        term <quote>working copy</quote> can be generally applied to
        any one file version's local instance.  When most folks use
        the term, though, they are referring to a whole directory tree
        containing files and subdirectories managed by the version
        control system.</para></footnote> appear to other software
        just as any other local directory full of files, so those
        programs don't have to be <quote>version-control-aware</quote>
        in order to read from and write to that data.  The task of
        managing the working copy and communicating changes made to
        its contents to and from the repository falls squarely to the
        version control system's client software.</para>
-->
      <para>Một bản sao làm việc, theo đúng nghĩa đen, một bản sao cục bộ của một phiên bản cụ thể của dữ liệu VCS-quản lý trên đó người sử dụng đó tự do thay đổi. Bản sao làm việc<footnote><para>Thuật ngữ <quote>bản sao làm việc</quote> nói chung có thể được áp dụng cho phiên bản cục bộ của phiên bản tập tin. Tuy nhiên, khi hầu hết mọi người sử dụng những thuật ngữ, họ đang đề cập đến toàn bộ một cây thư mục chứa các tập tin và thư mục con mà được quản lý bởi hệ thống kiểm soát phiên bản.</para></footnote> xuất hiện với các phần mềm khác cũng giống như bất kỳ thư mục cục bộ khác với đầy đủ các tập tin, như vậy những chương trình đó không cần thiết phải <quote>quan-tâm-kiểm-soát-phiên-bản</quote> để đọc và ghi dữ liệu đó. Nhiệm vụ quản lý bản sao làm việc và giao tiếp những thay đổi trên nội dung của nó đến và đi từ các kho lưu trữ rơi thẳng vào ứng dụng kiểm soát phiên bản khách.</para>
        
     <!-- ### TODO: The task of managing the working copy and communicating changes made to its contents to and from the repository falls squarely to the version control system's client software. ### -->
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models">
<!--       <title>Versioning Models</title> -->
      <title>Mô hình phiên bản</title>

<!--
      <para>If the primary mission of a version control system is to
        track the various versions of digital information over time, a
        very close secondary mission in any modern version control
        system is to enable collaborative editing and sharing of that
        data.  But different systems use different strategies to
        achieve this.  It's important to understand these different
        strategies, for a couple of reasons.  First, it will help you
        compare and contrast existing version control systems, in case
        you encounter other systems similar to Subversion.  Beyond
        that, it will also help you make more effective use of
        Subversion, since Subversion itself supports a couple of
        different ways of working.</para>
-->
      <para>Nếu nhiệm vụ chính của một hệ thống kiểm soát phiên bản là theo dõi những phiên bản khác nhau của thông tin kỹ thuật số xuyên suốt thời gian, một nhiệm vụ phụ rất gần trong bất kỳ hệ kiểm soát phiên bản nào đó là cho phép hợp tác chỉnh sửa và chia sẽ dữ liệu đó. Những những hệ thống khác nhau sử dụng những chiến thuật khác nhau để đạt được điều đó. Việc hiểu rõ những chiến thuật khác biệt này là cần thiết vì một vài lý do. Trước tiên, nó sẽ giúp bạn so sánh và đối chiếu những hệ kiểm soát phiên bản đang tồn tại, trong trường hợp bạn tiếp cận những hệ thống khác tương tự như Subversion. Xa hơn nữa, nó cũng sẽ giúp bạn sử dúng Subversion hiệu quả hơn, bởi vì Subversion bản thân nó hỗ trợ một vài cách làm việc khác nhau.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.problem-sharing">
<!--         <title>The problem of file sharing</title> -->
        <title>Vấn đề của việc chia sẽ tập tin</title>

<!--
        <para>All version control systems have to solve the same
          fundamental problem: how will the system allow users to
          share information, but prevent them from accidentally
          stepping on each other's feet?  It's all too easy for users
          to accidentally overwrite each other's changes in the
          repository.</para>
-->
        <para>Tất cả các hệ kiểm soát phiên bản đều phải giải quyết cùng một vấn đề cơ bản: hệ thống sẽ cho phép người dùng chia sẽ thông tin như thế nào mà ngăn không để họ giẫm chân lên nhau? Rất dễ xảy ra việc người sử dụng ghi đè lên những thay đổi của người khác trong kho lưu trữ một cách vô ý.</para>

<!--
        <para>Consider the scenario shown in
          <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
          Suppose we have two coworkers, Harry and Sally.  They each
          decide to edit the same repository file at the same time.
          If Harry saves his changes to the repository first, it's
          possible that (a few moments later) Sally could accidentally
          overwrite them with her own new version of the file.  While
          Harry's version of the file won't be lost forever (because
          the system remembers every change), any changes Harry made
          <emphasis>won't</emphasis> be present in Sally's newer version
          of the file, because she never saw Harry's changes to begin
          with.  Harry's work is still effectively lost&mdash;or at
          least missing from the latest version of the file&mdash;and
          probably by accident.  This is definitely a situation we want
          to avoid!</para>
-->
        <para>Xem xét kịch bản thể hiện trong <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>. Giả sử chúng ta có hai người đồng nghiệp, Harry và Sally. Mỗi người đều quyết định sẽ chỉnh sửa cùng một tập tin cùng thời điểm. Nếu Harry lưu những thay đổi của anh ấy vào kho lưu trữ trước, thì có nhiều khả năng là (một lát sau) Sally có thể ghi đè lên những thay đổi này với phiên bản tập tin mới hơn của cô ấy một cách vô tình. Mặc dù phiên bản của Harry sẽ không bị mất hẵn (bởi vì hệ thống ghi nhớ mỗi thay đổi), bất kỳ thay đổi nào mà Harry tạo ra <emphasis>sẽ không</emphasis> được hiện diện trong phiên bản tập tin mới hơn của Sally, bởi vì cô ấy không biết về những thay đổi của Harry để tiếp tục nối vào. Những thay đổi của Harry vẫn bị mất&mdash;hoặc ít nhất là không có mặt trong phiên bản mới nhất của tập ti&mdash;và có lẽ bởi sự vô ý. Đó chắc chắn là một tình huống mà chúng ta cần tránh!</para>

        <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
<!--           <title>The problem to avoid</title> -->
          <title>Vấn đề cần tránh</title>
          <graphic fileref="images/ch02dia2.png"/>
        </figure>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.lock-unlock">
<!--         <title>The lock-modify-unlock solution</title> -->
        <title>Giải pháp khoá-sửa đổi-mở khoá</title>

<!--
        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>lock-modify-unlock</tertiary>
          </indexterm>Many version control systems use a
          <firstterm>lock-modify-unlock</firstterm> model to address
          the problem of many authors clobbering each other's work.
          In this model, the repository allows only one person to
          change a file at a time.  This exclusivity policy is managed
          using locks.  Harry must <quote>lock</quote> a file before
          he can begin making changes to it.  If Harry has locked a
          file, Sally cannot also lock it, and therefore cannot make
          any changes to that file.  All she can do is
          wait for Harry to finish his changes, save the file and
          release his lock.  After Harry unlocks the file, Sally
          can take her turn by locking the file.  Then she may read
          the latest version of the file and edit it.
          <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
          demonstrates this simple solution.</para>
-->
        <para>
          <indexterm>
            <primary>kiểm soát phiên bản</primary>
            <secondary>mô hình</secondary>
            <tertiary>khoá-sửa đổi-mở khoá</tertiary>
          </indexterm>Nhiều hệ thống kiểm soát phiên bản sử dụng mô hình <firstterm>khoá-sửa đổi-mở khoá</firstterm> để giải quyết vấn đề nhiều tác giả đụng độ liên tục những thay đổi của nhau. Trong mô hình này, kho lưu trữ chỉ cho phép thay đổi của một người duy nhất ở một thời điểm. Chính sách độc quyền này được thực thi bằng việc sử dụng khóa. Harry cần phải <quote>khóa</quote> một tập tin trước khi anh ấy có thể bắt đầu hiệu chỉnh nó. Nếu Harry đã khóa tập tin, Sally không thể khóa nó, và như vậy là không thể tạo ra bất kỳ thay đổi nào trên tập tin đó. Tất cả những điều cô ấy có thể làm là đợi Harry hoàn thành những thay đổi của anh ấy, lưu tập tin và mở khóa. Sau khi Harry mở khóa tập tin, Sally tới lượt mình có thể khóa tập tin. Tiếp theo cô ấy có thể đọc phiên bản mới nhất của tập tin và hiệu chỉnh nó. <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>trình bày giải pháp đơn giản nà.</para>
     <!-- ### TODO: "many authors clobbering each other's work": need a better way to translate this ### -->

        <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
<!--           <title>The lock-modify-unlock solution</title> -->
          <title>Giải pháp khoá-sửa đổi-mở khoá</title>
          <graphic fileref="images/ch02dia3.png"/>
        </figure>

<!--
        <para>The problem with the lock-modify-unlock model is that it's
          a bit restrictive and often becomes a roadblock for
          users:</para>
-->
        <para>Vấn đề của mô hình khoá-sửa đổi-mở khoá này là nó hơi hạn chế và thường trở thành một rào cản đối với người sử dụng:</para>

        <itemizedlist>
          <listitem>
<!--
            <para><emphasis>Locking may cause administrative
              problems.</emphasis>

              Sometimes Harry will lock a file and then forget about it.
              Meanwhile, because Sally is still waiting to edit the file,
              her hands are tied.  And then Harry goes on vacation.  Now
              Sally has to get an administrator to release Harry's lock.
              The situation ends up causing a lot of unnecessary delay
              and wasted time.</para>
-->
            <para><emphasis>Khóa có thể làm phát sinh những vấn đề hành chính.</emphasis>

              Đôi khi Harry khóa một tập tin và quên nó hoàn toàn. Trong lúc đó, bởi vì Sally vẫn đang đợi để điều chỉnh tập tin, cố ấy sẽ phải chờ đợi mỏi mòn. Và sau đó Harry có kỳ nghỉ. Lúc này Sally phải nhờ người quản trị để mở khóa của Harry. Tình huống gây nên việc đình trệ không cần thiết và tốn thời gian.</para>
          </listitem>

          <listitem>
<!--
            <para><emphasis>Locking may cause unnecessary
              serialization.</emphasis>

              What if Harry is editing the beginning of a text file,
              and Sally simply wants to edit the end of the same file?
              These changes don't overlap at all.  They could easily
              edit the file simultaneously, and no great harm would
              come, assuming the changes were properly merged together.
              There's no need for them to take turns in this
              situation.</para>
-->
            <para><emphasis>Khóa có thể gây nên sự nối tiếp hóa (serialization) không cần thiết.</emphasis>

              Điều gì sẽ xảy ra nếu Harry đang chỉnh sửa phần đầu của một tập tin văn bản, và Sally muốn chỉnh sửa phần cuối của cùng tập tin? Những thay đổi này không bị chồng lên nhau. Họ có thể dễ dàng chỉnh sửa tập tin đồng thời và sẽ không có tổn hại nào xuất hiện với giả sử rằng những thay đổi được hợp nhất với nhau một cách đúng đắn. Trong tình huống này họ không cần thiết phải thay phiên nhau.</para>
          </listitem>

          <listitem>
<!--
            <para><emphasis>Locking may create a false sense of
              security.</emphasis>

              Suppose Harry locks and edits file A, while Sally
              simultaneously locks and edits file B.  But what if A and
              B depend on one another, and the changes made to each are
              semantically incompatible?  Suddenly A and B don't work
              together anymore.  The locking system was powerless to
              prevent the problem&mdash;yet it somehow provided a false
              sense of security.  It's easy for Harry and Sally to
              imagine that by locking files, each is beginning a safe,
              insulated task, and thus they need not bother discussing
              their incompatible changes early on.  Locking often
              becomes a substitute for real communication.</para>
-->
            <para><emphasis>Khóa có thể tạo ra một cảm giác sai về bảo mật.</emphasis>

              Giả sử Harry khóa và chỉnh sửa tập tin A, trong khi đó Sally cũng khóa và chỉnh sửa tập tin B. Những sẽ như thế nào nếu cả A và B phụ thuộc vào nhau và những thay đổi được thực hiện trên mỗi tập tin là không tương thích về mặt ngữ nghĩa? Đột nhiên A và B không làm việc với nhau nữa. Hệ thống khóa đã bất lực không thể ngăn vấn đề xảy ra&mdash;nó tạo nên một ấn tượng sai về bảo mật. Nó rất dễ gây cho Harry và Sally suy nghĩ rằng bằng cách khóa những tập tin, mỗi người có thể bắt đầu công việc một cách an toàn, tác vụ tách biệt nhau, và do đó họ không cần bận tâm thảo luận về những thay đổi không tương thích ngay từ đầu. Khóa đôi khi trở thành một sự thay thế cho giao tiếp thực tế.</para>
          </listitem>
        </itemizedlist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.copy-merge">
<!--         <title>The copy-modify-merge solution</title> -->
        <title>Giải pháp sao chép-sửa đổi-hợp nhất</title>

<!--
        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>copy-modify-merge</tertiary>
          </indexterm>Subversion, CVS, and many other version control
          systems use a <firstterm>copy-modify-merge</firstterm> model
          as an alternative to locking.  In this model, each user's
          client contacts the project repository and creates a
          personal working copy.  Users then work simultaneously and
          independently, modifying their private copies.  Finally, the
          private copies are merged together into a new, final
          version.  The version control system often assists with the
          merging, but ultimately, a human being is responsible for
          making it happen correctly.</para>
-->
        <para>
          <indexterm>
            <primary>kiểm soát phiên bản</primary>
            <secondary>mô hình</secondary>
            <tertiary>sao chép-sửa đổi-hợp nhất</tertiary>
          </indexterm>Subversion, CVS và nhiều hệ kiểm soát phiên bản khác sử dụng mô hình <firstterm>sao chép-sửa đổi-hợp nhất</firstterm> như là phương án thay thế cho khóa. Trong hình này, mỗi ứng dụng khách của người sử dụng kết nối với kho lưu trữ dự án và tạo một bản sao làm việc riêng. Người sử dụng sau đó làm việc đồng thời và độc lập với nhau chỉnh sửa phiên bản sao chép riêng của họ. Sau cùng, những bản sao riêng lẻ được hợp nhất với nhau thành một bản mới, phiên bản cuối cùng. Hệ thống kiểm soát phiên bản thường hỗ trợ việc hợp nhất, nhưng cuối cùng, con người có trách nhiệm làm cho việc đó xảy ra một cách chính xác.</para>

<!--
        <para>
          <indexterm>
            <primary>out of date</primary>
          </indexterm>Here's an example.  Say that Harry and Sally
          each create working copies of the same project, copied from
          the repository.  They work concurrently and make changes to
          the same file A within their copies.  Sally saves her
          changes to the repository first.  When Harry attempts to
          save his changes later, the repository informs him that his
          file A is <firstterm>out of date</firstterm>.  In other
          words, file A in the repository has somehow changed since he
          last copied it.  So Harry asks his client to merge any new
          changes from the repository into his working copy of file A.
          Chances are that Sally's changes don't overlap with his own;
          once he has both sets of changes integrated, he saves his
          working copy back to the repository.
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/> show
          this process.</para>
-->
        <para>
          <indexterm>
            <primary>quá hạn</primary>
          </indexterm>Đây là một ví dụ. Giả sử rằng Harry và Sally mỗi người tạo một bản sao làm việc của cùng một dự án, sao chép từ kho lưu trữ. Họ làm việc đồng thời và thay đổi trên cùng một tập tin A trong bản sao của họ. Sally lưu những thay đổi của cô ấy vào kho lưu trữ trước. Khi Harry cố gắng để lưu những thay đổi của anh ấy sau đó, kho lưu trữ thông báo với anh ấy rằng tập tin A của anh ấy <firstterm>quá hạn</firstterm>. Nói cách khác, tập tin A trong kho lưu trữ đã bị thay đổi theo cách nào đó kể từ lúc anh ấy sao lưu nó. Vì vậy Harry ra lệnh cho ứng dụng khách của anh ấy hợp nhất bất kỳ thay đổi mới nào từ trên kho lưu trữ vào trong bản sao làm việc của tập tin A của anh ấy. Nhiều khả năng là những thay đổi của Sally không bị chồng chéo với những thay đổi của riêng anh ấy; khi hai phần đã được tích hợp vào với nhau, anh ấy lưu bản sao làm việc của anh ấy vào trong kho lưu trữ. <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> và <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/> biểu diễn quy trình này.</para>

        <figure id="svn.basic.vsn-models.copy-merge.dia-1">
<!--           <title>The copy-modify-merge solution</title> -->
          <title>Giải pháp sao chép-sửa đổi-hợp nhất</title>
          <graphic fileref="images/ch02dia4.png"/>
        </figure>

        <figure id="svn.basic.vsn-models.copy-merge.dia-2">
          <title>Giải pháp sao chép-sửa đổi-hợp nhất (tiếp theo)</title>
          <graphic fileref="images/ch02dia5.png"/>
        </figure>

<!--
        <para>
          <indexterm>
            <primary>conflicts</primary>
          </indexterm>But what if Sally's changes
          <emphasis>do</emphasis> overlap with Harry's changes?  What
          then?  This situation is called a
          <firstterm>conflict</firstterm>, and it's usually not much
          of a problem.  When Harry asks his client to merge the
          latest repository changes into his working copy, his copy of
          file A is somehow flagged as being in a state of conflict:
          he'll be able to see both sets of conflicting changes and
          manually choose between them.  Note that software can't
          automatically resolve conflicts; only humans are capable of
          understanding and making the necessary intelligent choices.
          Once Harry has manually resolved the overlapping
          changes&mdash;perhaps after a discussion with Sally&mdash;he
          can safely save the merged file back to the
          repository.</para>
-->
        <para>
          <indexterm>
            <primary>xung đột</primary>
          </indexterm>Nhưng sẽ như thế nào nếu thay đổi của Sally <emphasis>thật sự</emphasis> chồng chéo với thay đổi của Harry? Điều gì sau đó? Tình huống này gọi là <firstterm>xung đột</firstterm>, và thông thường thì nó không hẵn là một vấn đề. Khi Harry ra lệnh cho ứng dụng khách của anh ấy hợp nhất những thay đổi mới nhất trên kho vào trong bản sao làm việc của anh ấy, bản sao của tập tin A của anh ấy theo cách nào đó được đánh dấu như là đang ở trạng thái xung đột: anh ấy có thể thấy cả hai phần của những thay đổi đang gặp xung đột và chọn một trong hai một cách thủ công. Lưu ý rằng phần mềm không thể giải quyết xung đột một cách tự động; chỉ có con người mới có khả năng hiểu và thực hiện việc chọn lựa cần thiết một cách thông minh. Khi Harry đã giải quyết vấn đề những thay đổi chồng chéo một cách thủ công&mdash;có lẽ sau khi thảo luận với Sally&mdash;anh ấy có thể lưu tập tin được hợp nhất ngược lại vào trong kho lưu trữ.</para>

<!--
        <para>The copy-modify-merge model may sound a bit chaotic, but
          in practice, it runs extremely smoothly.  Users can work in
          parallel, never waiting for one another.  When they work on
          the same files, it turns out that most of their concurrent
          changes don't overlap at all; conflicts are infrequent.  And
          the amount of time it takes to resolve conflicts is usually
          far less than the time lost by a locking system.</para>
-->
        <para>Mô hình sao chép-sửa đổi-hợp nhất nghe có vẻ hơi hỗn loạn, nhưng trên thực tế, nó hoạt động rất mượt. Người sử dụng có thể làm việc song song, không bao giờ phải chờ đợi nhau. Khi họ làm việc trên cùng một tập tin, hoá ra rằng hầu hết những thay đổi đồng thời của họ không hoàn toàn không chồng lấn; xung đột là không thường xuyên. Và thời gian nó tiêu tốn để giải quyết xung đột thường là ít hơn nhiều so với thời gian bị mất bởi hệ thống khoá.</para>

<!--
        <para>In the end, it all comes down to one critical factor:
          user communication.  When users communicate poorly, both
          syntactic and semantic conflicts increase.  No system can
          force users to communicate perfectly, and no system can
          detect semantic conflicts.  So there's no point in being
          lulled into a false sense of security that a locking system
          will somehow prevent conflicts; in practice, locking seems
          to inhibit productivity more than anything else.</para>
-->
        <para>Cuối cùng, tất cả dẫn đến một yếu tố quan trọng: giao tiếp người sử dụng. Khi người dùng giao tiếp kém, cả hai loại xung đột cú pháp và xung đột ngữ nghĩa tăng. Không có hệ thống nào có thể bắt buộc người sử dụng phải giao tiếp một cách hoàn hảo, và không có hệ thống nào có thể phát hiện những xung đột ngữ nghĩa. Vì vậy, khó để bị ru ngủ vào một cảm giác sai về bảo mật rằng một hệ thống khoá bằng cách nào đó ngăn chặn xung đột; trong thực tế, khoá dường như ngăn cản năng xuất nhiều hơn bất cứ thứ gì khác.</para>

        <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
<!--           <title>When Locking Is Necessary</title> -->
          <title>Khi khoá là cần thiết</title>

<!--
          <para>While the lock-modify-unlock model is considered
            generally harmful to collaboration, sometimes
            locking is appropriate.</para>
-->
          <para>Trong khi mô hình khoá-sửa đổi-mở khoá nói chung được xem là có hại cho sự hợp tác, đôi khi khoá là thích hợp.</para>

<!--
          <para>The copy-modify-merge model is based on the assumption
            that files are contextually mergeable&mdash;that is, that the
            majority of the files in the repository are line-based text
            files (such as program source code).  But for files with
            binary formats, such as artwork or sound, it's often
            impossible to merge conflicting changes.  In these
            situations, it really is necessary for users to take strict
            turns when changing the file.  Without serialized access,
            somebody ends up wasting time on changes that are ultimately
            discarded.</para>
-->
          <para>Mô hình khoá-sửa đổi-mở khoá được dựa trên sự giả định rằng những tập tin là có thể hợp nhất được theo ngữ cảnh&mdash;đó là, đa số các tập tin trong kho lưu trữ là tập tin văn bản dựa trên dòng (như là mã nguồn chương trình). Nhưng với tập tin có định dạng nhị phân, như là nội dung đồ hoạ hay âm thanh, thường là không thể hợp nhất những thay đổi gặp xung đột. Trong những tình huống này, nó thực sự là cần thiết cho người dùng để thay phiên nhau chặt chẽ khi thay đổi các tập tin. Không có tuần tự truy cập, ai đó lãng phí thời gian vào những thay đổi mà cuối cùng bị loại bỏ.</para>

<!--
          <para>While Subversion is primarily a copy-modify-merge
            system, it still recognizes the need to lock an occasional
            file, and thus provides mechanisms for this.  We discuss
            this feature in <xref linkend="svn.advanced.locking"/>.</para>
-->
          <para>Trong khi Subversion chủ yếu là một hệ thống sao chép-sửa đổi-hợp nhất, nó vẫn ghi nhận sự cần thiết việc khoá một vài tập tin, và vì vậy cung cấp cơ chế cho việc khoá này. Chúng ta bàn về tính năng này trong <xref linkend="svn.advanced.locking"/>.</para>

        </sidebar>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
<!--     <title>Version Control the Subversion Way</title> -->
    <title>Kiểm soát phiên bản theo cách của Subversion</title>

<!--
    <para>We've mentioned already that Subversion is a modern,
      network-aware version control system.  As we described in
      <xref linkend="svn.basic.version-control-basics"/> (our
      high-level version control overview), a repository serves as the
      core storage mechanism for Subversion's versioned data, and it's
      via working copies that users and their software programs
      interact with that data.  In this section, we'll begin to
      introduce the specific ways in which Subversion implements
      version control.</para>
-->
    <para>Chúng tôi đã đề cập rằng Subversion là một hệ thống kiểm soát phiên bản hiện đại, liên quan đến mạng. Như chúng tôi có mô tả trong <xref linkend="svn.basic.version-control-basics"/> (tổng quan ở cấp độ cao về kieerm soát phiên bản), kho lưu trữ đóng vai trò cơ chế lưu trữ trung tâm cho dữ liệu phiên bản của Subversion, và thông qua bản sao làm việc mà người sử dụng và phần mềm của họ tương tác với dữ liệu đó. Trong phần này, chúng ta sẽ bắt đầu giới thiệu những cách cụ thể mà Subversion thực hiện kiểm soát phiên bản.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.svn-repositories">
<!--       <title>Subversion Repositories</title> -->
      <title>Những kho lưu trữ Subversion</title>

      <para>Subversion hiện thực khái niệm kho lưu trữ của kiểm soát phiên bản nhiều như bất kỳ hệ thống kiểm soát phiên bản hiện đại nào khác. Không giống như bản sao làm việc, kho lưu trữ Subversion là một thực thể trừu tượng, có khả năng được vận hành gần như độc quyền của những thư viện và công cụ riêng của Subversion. Vì đa số những tương tác Subversion của người sử dụng có liên quan đến việc sử dụng ứng dụng khách Subversion và xảy ra trong bối cảnh của bản sao làm việc, chúng ta sẽ dành phần lớn trong cuốn sách này thảo luận bản sao làm việc Subversion và làm cách nào để thao tác trên nó. Để có thông tin chi tiết hơn về kho lưu trữ, kiểm tr <xref linkend="svn.reposadmin"/>.</para>

      <warning id="svn.basic.svn-repositories.not-working-copy">
<!--
        <para>In Subversion, the client-side object which every user
          of the system has&mdash;the directory of versioned files,
          along with metadata that enables the system to track them
          and communicate with the server&mdash;is called
          a <emphasis>working copy</emphasis>.  Although other version
          control systems use the term <quote>repository</quote> for
          the client-side object, it is both incorrect and a common
          source of confusion to use the term in that way in the
          context of Subversion.</para>
-->
        <para>Trong Subversion, đối tượng phía máy khách mà mỗi người sử dụng của hệ thống đều có&mdash;thư mục chứa những tập tin phiên bản, đi kèm với siêu dữ liệu mà cho phép hệ thống theo dõi chúng và giao tiếp với máy chủ&mdash;gọi là <emphasis>bản sao làm việc</emphasis>. Mặc dù những hệ thống kiểm soát phiên bản khác sử dụng khái niệm <quote>kho lưu trữ</quote> cho đối tượng phía máy khách, cả hai đều không chính xác và là nguồn gốc phổ biến gây nhầm lẫn của việc sử dụng thuật ngữ theo cách này trong ngữ cảnh của Subversion.</para>

<!--
        <para>Working copies are described later, in
          <xref linkend="svn.basic.in-action.wc"/>.</para>
-->
        <para>Bản sao làm việc được mô tả sau trong <xref linkend="svn.basic.in-action.wc"/>.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
<!--       <title>Revisions</title> -->
      <title>Phiên bản</title>

<!--
      <para>A Subversion client commits (that is, communicates the
        changes made to) any number of files and directories as a
        single atomic transaction.  By atomic transaction, we mean
        simply this: either all of the changes are accepted into the
        repository, or none of them is.  Subversion tries to retain
        this atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>
-->
      <para>
	      A Subversion client commits (that is, communicates the
        changes made to) any number of files and directories as a
        single atomic transaction.  By atomic transaction, we mean
        simply this: either all of the changes are accepted into the
        repository, or none of them is.  Subversion tries to retain
        this atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>
        <indexterm>
          <primary>revisions</primary>
        </indexterm>Each time the repository accepts a commit, this
        creates a new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number assigned to
        the previous revision.  The initial revision of a freshly
        created repository is numbered 0 and consists of nothing but
        an empty root directory.</para>

      <para><xref linkend="svn.basic.in-action.revs.dia-1"/>
        illustrates a nice way to visualize the repository.  Imagine
        an array of revision numbers, starting at 0, stretching from
        left to right.  Each revision number has a filesystem tree
        hanging below it, and each tree is a <quote>snapshot</quote>
        of the way the repository looked after a commit.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>Tree changes over time</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>

        <para>
          <indexterm>
            <primary>revisions</primary>
            <secondary>global</secondary>
          </indexterm>Unlike most version control systems,
          Subversion's revision numbers apply to <emphasis>the entire
          repository tree</emphasis>, not individual files.  Each
          revision number selects an entire tree, a particular state
          of the repository after some committed change.  Another way
          to think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename>,</quote> they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Many
          other version control systems use per-file revision numbers,
          so this concept may seem unusual at first. (Former CVS users
          might want to see <xref linkend="svn.forcvs"/> for more
          details.)</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
      <title>Addressing the Repository</title>

      <para>
        <indexterm>
          <primary>repository URL</primary>
        </indexterm>Subversion client programs use URLs to identify
        versioned files and directories in Subversion repositories.
        For the most part, these URLs use the standard syntax,
        allowing for server names and port numbers to be specified as
        part of the URL.</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>http://svn.example.com/svn/project</simpara>
          </listitem>
          <listitem>
            <simpara>http://svn.example.com:9834/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Subversion repository URLs aren't limited to only
        the <literal>http://</literal> variety.  Because Subversion
        offers several different ways for its clients to communicate
        with its servers, the URLs used to address the repository
        differ subtly depending on which repository access mechanism
        is employed.  <xref linkend="svn.basic.in-action.wc.tbl-1"/>
        describes how different URL schemes map to the available
        repository access methods.  For more details about
        Subversion's server options, see
        <xref linkend="svn.serverconfig"/>.</para>

      <table id="svn.basic.in-action.wc.tbl-1">
        <title>Repository access URLs</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Schema</entry>
              <entry>Access method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>file:///</literal></entry>
              <entry>Direct repository access (on local disk)</entry>
            </row>
            <row>
              <entry><literal>http://</literal></entry>
              <entry>Access via WebDAV protocol to Subversion-aware
                Apache server</entry>
            </row>
            <row>
              <entry><literal>https://</literal></entry>
              <entry>Same as <literal>http://</literal>, but with
                SSL encapsulation (encryption and authentication)</entry>
            </row>
            <row>
              <entry><literal>svn://</literal></entry>
              <entry>Access via custom protocol to an
                <literal>svnserve</literal> server</entry>
            </row>
            <row>
              <entry><literal>svn+ssh://</literal></entry>
              <entry>Same as <literal>svn://</literal>, but through
                an SSH tunnel</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Subversion's handling of URLs has some notable nuances.
        For example, URLs containing the <literal>file://</literal>
        access method (used for local repositories) must, in
        accordance with convention, have either a server name
        of <literal>localhost</literal> or no server name at
        all:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file://localhost/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Also, users of the <literal>file://</literal> scheme on
        Windows platforms will need to use an unofficially
        <quote>standard</quote> syntax for accessing repositories
        that are on the same machine, but on a different drive than
        the client's current working drive.  Either of the two
        following URL path syntaxes will work, where
        <literal>X</literal> is the drive on which the repository
        resides:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///X:/var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file:///X|/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Note that a URL uses forward slashes even though the
        native (non-URL) form of a path on Windows uses backslashes.
        Also note that when using
        the <literal>file:///<replaceable>X</replaceable>|/</literal>
        form at the command line, you need to quote the URL (wrap it
        in quotation marks) so that the vertical bar character is not
        interpreted as a pipe.</para>

      <note>
        <para>You cannot use Subversion's <literal>file://</literal> URLs
          in a regular web browser the way you can use typical
          <literal>file://</literal> URLs.  When you attempt to view
          a <literal>file://</literal> URL in a regular web browser, it
          reads and displays the contents of the file at that location
          by examining the filesystem directly.  However, Subversion's
          resources exist in a virtual filesystem (see <xref
          linkend="svn.developer.layerlib.repos" />), and your browser
          will not understand how to interact with that
          filesystem.</para>
      </note>

      <para>The Subversion client will automatically encode URLs as
        necessary, just like a web browser does.  For example, the URL
        <literal>http://host/path with space/project/españa</literal>
        &mdash; which contains both spaces and upper-ASCII characters
        &mdash; will be automatically interpreted by Subversion as if
        you'd provided
        <literal>http://host/path%20with%20space/project/espa%C3%B1a</literal>.
        If the URL contains spaces, be sure to place it within
        quotation marks at the command line so that your shell treats
        the whole thing as a single argument to the program.</para>

      <para>There is one notable exception to Subversion's handling of
        URLs which also applies to its handling of local paths in many
        contexts, too.  If the final path component of your URL or
        local path contains an at sign (<literal>@</literal>), you need
        to use a special syntax&mdash;described in
        <xref linkend="svn.advanced.pegrevs" />&mdash;in order to make
        Subversion properly address that resource.</para>

      <para>
        <indexterm>
          <primary>repository-relative URL</primary>
        </indexterm>
        <indexterm>
          <primary>caret syntax</primary>
        </indexterm>
        <indexterm>
          <primary>^</primary>
          <see>caret syntax</see>
        </indexterm>In Subversion 1.6, a new caret (<literal>^</literal>)
        notation was introduced as a shorthand for <quote>the URL of
        the repository's root directory</quote>.  For example, you can
        use the <literal>^/tags/bigsandwich/</literal> to refer to the
        URL of the <filename>/tags/bigsandwich</filename> directory in
        the root of the repository.  Such a URL is called a
        <firstterm>repository-relative URL</firstterm>.  Note
        that this URL syntax works only when your current working
        directory is a working copy&mdash;the command-line client
        knows the repository's root URL by looking at the working
        copy's metadata.  Also note that when you wish to refer
        precisely to the root directory of the repository, you must do
        so using <literal>^/</literal> (with the trailing slash
        character), not merely
        <literal>^</literal>.  Windows users should not forget that
        a caret is an escape character on their platform.  Therefore,
        use a double caret <literal>^^</literal> if you run the
        Subversion client on a Windows machine.
      </para>

        
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Subversion Working Copies</title>

      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A Subversion working copy is an ordinary directory
        tree on your local system, containing a collection of files.
        You can edit these files however you wish, and if they're
        source code files, you can compile your program from them in
        the usual way.  Your working copy is your own private work
        area: Subversion will never incorporate other people's
        changes, nor make your own changes available to others, until
        you explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>

      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes (by writing to the repository), thereby making them
        available to the other people working with you on your
        project.  If other people publish their own changes,
        Subversion provides you with commands to merge those changes
        into your own working copy (by reading from the repository).
        Notice that the central repository is the broker for
        everybody's changes in Subversion&mdash;changes aren't passed
        directly from working copy to working copy in the typical
        workflow.</para>

      <para>
        <indexterm>
          <primary>administrative directory</primary>
        </indexterm>
        <indexterm>
          <primary>.svn</primary>
          <see>administrative directory</see>
        </indexterm>A working copy also contains some extra files,
        created and maintained by Subversion, to help it carry out
        these commands.  In particular, each working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy's <firstterm>administrative
        directory</firstterm>.  The files in the administrative
        directory help Subversion recognize which of your versioned
        files contain unpublished changes, and which files are out of
        date with respect to others' work.</para>

      <note>
        <para>Prior to version 1.7, Subversion
          maintained <filename>.svn</filename> administrative
          subdirectories in <emphasis>every</emphasis> versioned
          directory of your working copy.  Subversion 1.7 offers a
          completely new approach to how working copy metadata is
          stored and maintained, and chief among the visible changes
          to this approach is that each working copy now has only
          one <filename>.svn</filename> subdirectory which is an
          immediate child of the root of that working copy.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.track-repos">
        <title>How the working copy works</title>

        <para>For each file in a working directory, Subversion records
          (among other things) two essential pieces of information:</para>

        <itemizedlist>
          <indexterm>
            <primary>revisions</primary>
            <secondary>working</secondary>
          </indexterm>

          <listitem>
            <para>What revision your working file is based on (this is
              called the file's <firstterm>working
              revision</firstterm>)</para>
          </listitem>
          <listitem>
            <para>A timestamp recording when the local copy was last
              updated by the repository</para>
          </listitem>
        </itemizedlist>

        <para>Given this information, by talking to the repository,
          Subversion can tell which of the following four states a
          working file is in:</para>

        <variablelist>
          <varlistentry>
            <term>Unchanged, and current</term>
            <listitem>
              <para>The file is unchanged in the working directory, and
                no changes to that file have been committed to the
                repository since its working revision.  An <command>svn
                commit</command> of the file will do nothing, and an
                <command>svn update</command> of the file will do
                nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Locally changed, and current</term>
            <listitem>
              <para>The file has been changed in the working directory,
                and no changes to that file have been committed to the
                repository since you last updated.  There are local
                changes that have not been committed to the repository;
                thus an <command>svn commit</command> of the file will
                succeed in publishing your changes, and an <command>svn
                update</command> of the file will do nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Unchanged, and out of date</term>
            <listitem>
              <para>The file has not been changed in the working
                directory, but it has been changed in the repository.
                The file should eventually be updated in order to make
                it current with the latest public revision.
                An <command>svn commit</command> of the file will do
                nothing, and an
                <command>svn update</command> of the file will fold the
                latest changes into your working copy.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Locally changed, and out of date</term>
            <listitem>
              <para>The file has been changed both in the working
                directory and in the repository.  An <command>svn
                commit</command> of the file will fail with an
                <quote>out-of-date</quote> error.  The file should be
                updated first; an <command>svn update</command> command
                will attempt to merge the public changes with the local
                changes.  If Subversion can't complete the merge in a
                plausible way automatically, it leaves it to the user to
                resolve the conflict.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.wc-funcdamentals">
        <title>Fundamental working copy interactions</title>

        <para>A typical Subversion repository often holds the files (or
          source code) for several projects; usually, each project is a
          subdirectory in the repository's filesystem tree.  In this
          arrangement, a user's working copy will usually correspond to
          a particular subtree of the repository.</para>

        <para>For example, suppose you have a repository that contains
          two software projects, <literal>paint</literal> and
          <literal>calc</literal>.  Each project lives in its own
          top-level subdirectory, as shown in <xref
          linkend="svn.basic.in-action.wc.dia-1"/>.</para>

        <figure id="svn.basic.in-action.wc.dia-1">
          <title>The repository's filesystem</title>
          <graphic fileref="images/ch02dia6.png"/>
        </figure>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>checkout</tertiary>
          </indexterm>
          <indexterm>
            <primary>checking out</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>creating</secondary>
            <see>checking out</see>
          </indexterm>To get a working copy, you must <firstterm>check
          out</firstterm> some subtree of the repository.  (The term
          <emphasis>check out</emphasis> may sound like it has something to do
          with locking or reserving resources, but it doesn't; it simply
          creates a working copy of the project for you.)  For example,
          if you check out <filename>/calc</filename>, you will get a
          working copy like this:</para>

        <informalexample>
          <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.
$ ls -A calc
Makefile  button.c integer.c .svn/
$
</screen>
        </informalexample>

        <para>The list of letter <literal>A</literal>s in the left
          margin indicates that Subversion is adding a number of items
          to your working copy.  You now have a personal copy of the
          repository's <filename>/calc</filename> directory, with one
          additional entry&mdash;<filename>.svn</filename>&mdash;which
          holds the extra information needed by Subversion, as mentioned
          earlier.</para>

        <para>
          <indexterm>
            <primary>committing</primary>
          </indexterm>
          <indexterm>
            <primary>checking in</primary>
            <see>committing</see>
          </indexterm>Suppose you make changes
          to <filename>button.c</filename>.  Since
          the <filename>.svn</filename> directory remembers the file's
          original modification date and contents, Subversion can tell
          that you've changed the file.  However, Subversion does not
          make your changes public until you explicitly tell it to.
          The act of publishing your changes is more commonly known as
          <firstterm>committing</firstterm> (or <firstterm>checking
          in</firstterm>) changes to the repository.</para>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>commit</tertiary>
          </indexterm>
          <indexterm>
            <primary>committing</primary>
          </indexterm>To publish your changes, you can use
          Subversion's <command>svn commit</command> command:</para>

        <informalexample>
          <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
$
</screen>
        </informalexample>

        <para>Now your changes to <filename>button.c</filename> have
          been committed to the repository, with a note describing your
          change (namely, that you fixed a typo).  If another user
          checks out a working copy of <filename>/calc</filename>, she
          will see your changes in the latest version of the
          file.</para>

        <para>Suppose you have a collaborator, Sally, who checked out a
          working copy of <filename>/calc</filename> at the same time
          you did.  When you commit your change to
          <filename>button.c</filename>, Sally's working copy is left
          unchanged; Subversion modifies working copies only at the
          user's request.</para>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>update</tertiary>
          </indexterm>
          <indexterm>
            <primary>updating</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>updating</secondary>
            <see>updating</see>
          </indexterm>To bring her project up to date, Sally can ask
          Subversion to <firstterm>update</firstterm> her working
          copy, by using the <command>svn update</command> command.
          This will incorporate your changes into her working copy, as
          well as any others that have been committed since she
          checked it out.</para>

        <informalexample>
          <screen>
$ pwd
/home/sally/calc
$ ls -A
Makefile button.c integer.c .svn/
$ svn update
Updating '.':
U    button.c
Updated to revision 57.
$
</screen>
        </informalexample>

        <para>The output from the <command>svn update</command> command
          indicates that Subversion updated the contents of
          <filename>button.c</filename>.  Note that Sally didn't need to
          specify which files to update; Subversion uses the information
          in the <filename>.svn</filename> directory as well as further
          information in the repository, to decide which files need to
          be brought up to date.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs">
        <title>Mixed-revision working copies</title>

        <para>
          <indexterm>
            <primary>working copies</primary>
            <secondary>mixed-revision</secondary>
          </indexterm>As a general principle, Subversion tries to be
          as flexible as possible.  One special kind of flexibility is
          the ability to have a working copy containing files and
          directories with a mix of different working revision
          numbers.  Subversion working copies do not always correspond
          to any single revision in the repository; they may contain
          files from several different revisions.  For example,
          suppose you check out a working copy from a repository whose
          most recent revision is 4:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:4
</literallayout>
        </informalexample>

        <para>At the moment, this working directory corresponds exactly
          to revision 4 in the repository.  However, suppose you make a
          change to <filename>button.c</filename>, and commit that
          change.  Assuming no other commits have taken place, your
          commit will create revision 5 of the repository, and your
          working copy will now look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:5
</literallayout>
        </informalexample>

        <para>Suppose that, at this point, Sally commits a change to
          <filename>integer.c</filename>, creating revision 6.  If you
          use <command>svn update</command> to bring your working copy
          up to date, it will look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:6
   integer.c:6
   button.c:6
</literallayout>
        </informalexample>

        <para>Sally's change to <filename>integer.c</filename> will
          appear in your working copy, and your change will still be
          present in <filename>button.c</filename>.  In this example,
          the text of <filename>Makefile</filename> is identical in
          revisions 4, 5, and 6, but Subversion will mark your working
          copy of <filename>Makefile</filename> with revision 6 to
          indicate that it is still current.  So, after you do a clean
          update at the top of your working copy, it will generally
          correspond to exactly one revision in the repository.</para>
  
        <sect4 id="svn.basic.in-action.mixedrevs.update-commit">
          <title>Updates and commits are separate</title>

          <para>One of the fundamental rules of Subversion is that
            a <quote>push</quote> action does not cause
            a <quote>pull</quote> nor vice versa.  Just
            because you're ready to submit new changes to the repository
            doesn't mean you're ready to receive changes that others
            have checked in.  And if you have new changes still in progress,
            <command>svn update</command> should gracefully merge
            repository changes into your own, rather than forcing you to
            publish them.</para>

          <para>The main side effect of this rule is that it means a
            working copy has to do extra bookkeeping to track mixed
            revisions as well as be tolerant of the mixture.  It's made
            more complicated by the fact that directories themselves are
            versioned.</para>

          <para>For example, suppose you have a working copy entirely
            at revision 10, while others have been committing their
            changes so that the youngest revision in the repository is
            now revision 14.  You edit the file
            <filename>foo.html</filename> and then perform
            an <command>svn commit</command>, which creates revision
            15 in the repository.  After the commit succeeds, many new
            users would expect the working copy to be entirely at
            revision 15, but that's not the case!  Any number of
            changes might have happened in the repository between
            revisions 10 and 15.  The client knows nothing of those
            changes in the repository, since you haven't yet
            run <command>svn update</command>, and <command>svn
            commit</command> doesn't pull down new changes.  If, on
            the other hand, <command>svn commit</command> were to
            automatically download the newest changes, it would be
            possible to set the entire working copy to revision
            15&mdash;but then we'd be breaking the fundamental rule
            of <quote>push</quote> and <quote>pull</quote> remaining
            separate actions.  Therefore, the only safe thing the
            Subversion client can do is mark the one
            file&mdash;<filename>foo.html</filename>&mdash;as being at
            revision 15.  The rest of the working copy remains at
            revision 10.  Only by running <command>svn
            update</command> can the latest changes be downloaded and
            the whole working copy be marked as revision 15.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.normal">
          <title>Mixed revisions are normal</title>

          <para>The fact is, <emphasis>every time</emphasis> you run
            <command>svn commit</command> your working copy ends up
            with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions than
            everything else.  After several commits (with no updates
            in between), your working copy will contain a whole mixture
            of revisions.  Even if you're the only person using the
            repository, you will still see this phenomenon.  To examine
            your mixture of working revisions, use the <command>svn
            status</command> command with the <option>--verbose</option>
            (<option>-v</option>) option (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information).</para>

          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to the
            working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, he expects
            to see the entire history of the object.  But if the
            object's working revision is quite old (often because
            <command>svn update</command> hasn't been run in a long
            time), the history of the <emphasis>older</emphasis>
            version of the object is shown.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.useful">
          <title>Mixed revisions are useful</title>

          <para>
            <indexterm>
              <primary>backdating</primary>
            </indexterm>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to
            forcibly <firstterm>backdate</firstterm> (or update to a
            revision older than the one you already have) portions of
            your working copy to an earlier revision; you'll learn how
            to do that in <xref linkend="svn.tour"/>.  Perhaps you'd
            like to test an earlier version of a submodule contained
            in a subdirectory, or perhaps you'd like to figure out
            when a bug first came into existence in a specific file.
            This is the <quote>time machine</quote> aspect of a
            version control system&mdash;the feature that allows you
            to move any portion of your working copy forward and
            backward in history.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.limits">
          <title>Mixed revisions have limitations</title>

          <para>However you make use of mixed revisions in your working
            copy, there are limitations to this flexibility.</para>

          <para>First, you cannot commit the deletion of a file or
            directory that isn't fully up to date.  If a newer version
            of the item exists in the repository, your attempt to delete
            will be rejected to prevent you from accidentally
            destroying changes you've not yet seen.</para>

          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up to date.  You'll learn about
            attaching <quote>properties</quote> to items in <xref
            linkend="svn.advanced"/>.  A directory's working revision
            defines a specific set of entries and properties, and thus
            committing a property change to an out-of-date directory may
            destroy properties you've not yet seen.</para>

          <para>Finally, beginning in Subversion 1.7, you cannot by
            default use a mixed-revision working copy as the target of
            a merge operation.  (This new requirement was introduced
            to prevent common problems which stem from doing so.)</para>

        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Summary</title>
    
    <para>We covered a number of fundamental Subversion concepts in
      this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We saw some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
      </listitem>

      <listitem>
        <para>We talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>

    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to move into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
