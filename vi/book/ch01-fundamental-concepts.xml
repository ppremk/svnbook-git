<!-- -*- sgml -*- -->

<chapter id="svn.basic">
<!--   <title>Fundamental Concepts</title> -->
  <title>Những Khái Niệm Cơ Bản</title>

<!--
  <para>This chapter is a short, casual introduction to Subversion and
    its approach to version control.  We begin with a discussion of
    general version control concepts, work our way into the specific
    ideas behind Subversion, and show some simple examples of
    Subversion in use.</para>
-->
  <para>Đây là một chương ngắn, giới thiệu sơ lược về Subversion và hướng tiếp cận của nó trong kiểm soát phiên bản. Chúng tôi bắt đầu với một cuộc thảo luận về những khái niệm chung trong kiểm soát phiên bản, làm việc theo cách của chúng tôi vào những ý tưởng cụ thể phía sau Subversion và trình bày một số ví dụ đơn giản của việc ứng dụng Subversion.</para>

<!--
  <para>Even though the examples in this chapter show people sharing
    collections of program source code, keep in mind that Subversion
    can manage any sort of file collection&mdash;it's not limited to
    helping computer programmers.</para>
-->
  <para>Mặc dù những ví dụ trong chương này trình bày cách mọi người chia sẽ những bộ sưu tập của mã nguồn chương trình, nên nhớ rằng Subversion có thể quản lý loại bộ sưu tập tập tin bất kỳ&mdash;nó không phải chỉ giới hạn trong việc hỗ trợ những lập trình viên máy tính.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.version-control-basics">
<!--     <title>Version Control Basics</title> -->
    <title>Căn Bản Kiểm Soát Phiên Bản</title>

<!--
    <para>
      <indexterm>
        <primary>version control systems</primary>
      </indexterm>A version control system (or revision control
      system) is a system that tracks incremental versions (or
      revisions) of files and, in some cases, directories over time.
      Of course, merely tracking the various versions of a user's (or
      group of users') files and directories isn't very interesting in
      itself.  What makes a version control system useful is the fact
      that it allows you to explore the changes which resulted in each
      of those versions and facilitates the arbitrary recall of the
      same.</para>
-->
    <para>
      <indexterm>
        <primary>hệ thống kiểm soát phiên bản</primary>
      </indexterm>Một hệ thống kiểm soát phiên bản (hay hệ thống kiểm soát thay đổi) là một hệ thống mà theo dõi xuyên suốt thời gian những phiên bản tăng dần (hay thay đổi) của những tập tin và trong một vài trường hợp, của những thư mục. Việc chỉ theo dõi những phiên bản khác nhau của những tập tin và thư mục của người sử dụng (hoặc nhóm người sử dụng) không đáng kể lắm. Điều làm cho hệ thống kiểm soát phiên bản hữu dụng đó là thực tế nó cho phép bạn khám phá những thay đổi trên mỗi phiên bản đó và tạo điều kiện cho việc thu hồi những mục giống nhau.</para>

<!--
    <para>In this section, we'll introduce some fairly high-level
      version control system components and concepts.  We'll limit our
      discussion to modern version control systems&mdash;in today's
      interconnected world, there is very little point in
      acknowledging version control systems which cannot
      operate across wide-area networks.</para>
-->
    <para>Trong phần này, chúng tôi sẽ giới thiệu một số thành phần và khái niệm tương đối cao cấp. Chúng tôi sẽ giới hạn việc thảo luận trong những hệ thống kiểm soát phiên bản hiện đại&mdash;trong thế giới kết nối ngày nay, có rất trong số những hệ thống kiểm soát phiên bản mà không thể hoạt động thông qua hệ thống mạng diện rộng.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.repository">
<!--       <title>The Repository</title> -->
      <title>Kho lưu trữ</title>

<!--
      <para>
        <indexterm>
          <primary>repositories</primary>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem tree</secondary>
        </indexterm>
        <indexterm>
          <primary>version control systems</primary>
          <secondary>clients</secondary>
        </indexterm>At the core of the version control system is a
        repository, which is the central store of that system's data.
        The repository usually stores information in the form of a
        <firstterm>filesystem tree</firstterm>&mdash;a hierarchy of
        files and directories.  Any number of
        <firstterm>clients</firstterm> connect to the repository, and
        then read or write to these files.  By writing data, a client
        makes the information available to others; by reading data,
        the client receives information from others.
        <xref linkend="svn.basic.repository.dia-1"/> illustrates
        this.</para>
-->
      <para>
        <indexterm>
          <primary>kho lưu trữ</primary>
        </indexterm>
        <indexterm>
          <primary>kho lưu trữ</primary>
          <secondary>cây hệ thống tập tin</secondary>
        </indexterm>
        <indexterm>
          <primary>hệ thống kiểm soát phiên bản</primary>
          <secondary>khách</secondary>
        </indexterm>Ở trung tâm của hệ thống kiểm soát phiên bản là một kho lưu trữ, là kho trung tâm của dữ liệu hệ thống. Kho lưu trữ thường lưu trữ thông tin ở dạng <firstterm>cây hệ thống tập tin</firstterm>&mdash;là một cấu trúc phân cấp của những tập tin và thư mục. Bất kỳ <firstterm>ứng dụng khách</firstterm> nào cũng có thể kết nối vào kho để đọc và ghi vào những tập tin này. Với việc ghi dữ liệu, ứng dụng khách làm cho thông tin có sẵn cho những ứng dụng khách khác; với việc đọc dữ liệu, ứng dụng khách nhận thông tin từ các ứng dụng khách khác. <xref linkend="svn.basic.repository.dia-1"/> minh hoạ điều này.</para>

      <figure id="svn.basic.repository.dia-1">
<!--         <title>A typical client/server system</title> -->
        <title>Một hệ thống chủ/khách kinh điển</title>
        <graphic fileref="images/ch02dia1.png"/>
      </figure>

<!--
      <para>Why is this interesting?  So far, this sounds like the
        definition of a typical file server.  And indeed, the
        repository <emphasis>is</emphasis> a kind of file server, but
        it's not your usual breed.  What makes the repository special
        is that as the files in the repository are changed, the
        repository remembers each version of those files.</para>
-->
      <para>Có gì thú vị ở đây? Đây dường như là định nghĩa của một máy chủ tập tin thông thường. Thực sự, kho lưu trữ <emphasis>là</emphasis> một dạng máy chủ tập tập tin, nhưng không phải là loại tập tin thông thường. Điều làm cho kho lưu trữ đặc biệt đó là khi những tập tin trong kho lưu trữ bị thay đổi, kho ghi nhớ từng phiên bản của những tập tin này.</para>

<!--
      <para>When a client reads data from the repository, it normally
        sees only the latest version of the filesystem tree.  But what
        makes a version control client interesting is that it also has
        the ability to request previous states of the filesystem from
        the repository.  A version control client can ask historical
        questions such as <quote>What did this directory contain last
        Wednesday?</quote> and <quote>Who was the last person to
        change this file, and what changes did he make?</quote>
        These are the sorts of questions that are at the heart of any
        version control system.</para>
-->
      <para>Khi một ứng dụng khách đọc dữ liệu từ kho, thông thường nó chỉ thấy phiên bản mới nhất của cây hệ thống tập tin. Nhưng điều thú vị của ứng dụng khách kiểm soát phiên bản đó là nó có khả năng yêu cầu những trạng thái trước đó của hệ thống tập tin từ kho. Ứng dụng khách có thể hỏi những câu hỏi mang tính lịch sử như là <quote>Thư mục này chứa những gì vào thứ Tư trước?</quote> và <quote>Ai là người cuối cùng thay đổi tập tin này, và đã thực hiện những thay đổi nào?</quote> Đây là những loại câu hỏi kinh điển của bất kỳ hệ thống kiểm soát phiên bản nào.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.working-copy">
<!--       <title>The Working Copy</title> -->
      <title>Bản sao làm việc</title>

<!--
      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A version control system's value comes from the
        fact that it tracks versions of files and directories, but the
        rest of the software universe doesn't operate
        on <quote>versions of files and directories</quote>.  Most
        software programs understand how to operate only on
        a <emphasis>single</emphasis> version of a specific type of
        file.  So how does a version control user interact with an
        abstract&mdash;and, often, remote&mdash;repository full of
        multiple versions of various files in a concrete fashion?  How
        does his or her word processing software, presentation
        software, source code editor, web design software, or some
        other program&mdash;all of which trade in the currency of
        simple data files&mdash;get access to such files?  The answer
        is found in the version control construct known as
        a <firstterm>working copy</firstterm>.</para>
-->
      <para>
        <indexterm>
          <primary>Những bản sao làm việc</primary>
        </indexterm>Giá trị của một hệ thống kiểm soát phiên bản đến từ thực tế là nó theo dõi những phiên bản của những tập tin và thư mục, trong khi phần còn lại của thế giới phần mềm không hoạt động trên <quote>các phiên bản của những tập tin và thư mục</quote>. Đa số những chương trình phần mềm chỉ có thể hoạt động trên một phiên bản <emphasis>duy nhất</emphasis> của một loại tập tin cụ thể. Vậy làm cách nào người sử dụng kiểm soát phiên bản tương tác với một kho lưu trữ trừu tượng&mdash;và, thường là ở xa&mdash;với đầy những phiên bản của những tập tin khác nhau? Làm cách nào phần mềm xử lý văn bản, phần mềm trình chiếu, trình soạn thảo mã nguồn, phần mềm thiết kế web hoặc những chương trình khác &mdash;tất cả đều thao tác trên những tập tin dữ liệu đơn giản&mdash;của anh ấy hay cô ấy truy cập vào những tập tin này? Câu trả lời được tìm thấy trong cấu trúc kiểm soát phiên bản được biết đến là <firstterm>bản sao làm việc</firstterm>.</para>

<!--
      <para>A working copy is, quite literally, a local copy of a
        particular version of a user's VCS-managed data upon which
        that user is free to work.  Working copies<footnote><para>The
        term <quote>working copy</quote> can be generally applied to
        any one file version's local instance.  When most folks use
        the term, though, they are referring to a whole directory tree
        containing files and subdirectories managed by the version
        control system.</para></footnote> appear to other software
        just as any other local directory full of files, so those
        programs don't have to be <quote>version-control-aware</quote>
        in order to read from and write to that data.  The task of
        managing the working copy and communicating changes made to
        its contents to and from the repository falls squarely to the
        version control system's client software.</para>
-->
      <para>Một bản sao làm việc, theo đúng nghĩa đen là một bản sao cục bộ của một phiên bản cụ thể của dữ liệu kiểm soát phiên bản mà trên đó người sử dụng được tự do thay đổi. Bản sao làm việc<footnote><para>Thuật ngữ <quote>bản sao làm việc</quote> nói chung có thể được áp dụng cho bất kỳ phiên bản cục bộ nào của tập tin. Tuy nhiên, hầu hết mọi người khi sử dụng những thuật ngữ này họ đang đề cập đến toàn bộ cây thư mục chứa các tập tin và thư mục con mà được quản lý bởi hệ thống kiểm soát phiên bản.</para></footnote> hiện diện với các phần mềm khác cũng giống như bất kỳ thư mục cục bộ bình thường khác với đầy đủ các tập tin, như vậy những chương trình đó không cần thiết phải <quote>quan-tâm-kiểm-soát-phiên-bản</quote> để đọc và ghi dữ liệu đó. Nhiệm vụ quản lý bản sao làm việc và giao tiếp những thay đổi trên nội dung của nó đến và đi từ các kho lưu trữ là do ứng dụng kiểm soát phiên bản khách đảm trách.</para>
        
     <!-- ### TODO: The task of managing the working copy and communicating changes made to its contents to and from the repository falls squarely to the version control system's client software. ### -->
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models">
<!--       <title>Versioning Models</title> -->
      <title>Mô hình phiên bản</title>

<!--
      <para>If the primary mission of a version control system is to
        track the various versions of digital information over time, a
        very close secondary mission in any modern version control
        system is to enable collaborative editing and sharing of that
        data.  But different systems use different strategies to
        achieve this.  It's important to understand these different
        strategies, for a couple of reasons.  First, it will help you
        compare and contrast existing version control systems, in case
        you encounter other systems similar to Subversion.  Beyond
        that, it will also help you make more effective use of
        Subversion, since Subversion itself supports a couple of
        different ways of working.</para>
-->
      <para>Nếu nhiệm vụ chính của một hệ thống kiểm soát phiên bản là theo dõi những phiên bản khác nhau của thông tin kỹ thuật số xuyên suốt thời gian, một nhiệm vụ phụ cũng rất quan trọng trong bất kỳ hệ kiểm soát phiên bản nào hiện đại nào đó là cho phép hợp tác chỉnh sửa và chia sẽ dữ liệu. Những hệ thống khác nhau sử dụng những chiến thuật khác nhau để đạt được điều đó. Việc hiểu rõ những chiến thuật khác biệt này là cần thiết vì một vài lý do. Trước tiên, nó sẽ giúp bạn so sánh và đối chiếu những hệ kiểm soát phiên bản đang tồn tại, trong trường hợp bạn tiếp cận những hệ thống khác tương tự như Subversion. Xa hơn nữa, nó cũng sẽ giúp bạn sử dụng Subversion hiệu quả hơn, bởi vì Subversion bản thân nó hỗ trợ một vài cách làm việc khác nhau.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.problem-sharing">
<!--         <title>The problem of file sharing</title> -->
        <title>Vấn đề của việc chia sẽ tập tin</title>

<!--
        <para>All version control systems have to solve the same
          fundamental problem: how will the system allow users to
          share information, but prevent them from accidentally
          stepping on each other's feet?  It's all too easy for users
          to accidentally overwrite each other's changes in the
          repository.</para>
-->
        <para>Tất cả các hệ kiểm soát phiên bản đều phải giải quyết một vấn đề cơ bản: bằng cách nào hệ thống cho phép người dùng chia sẽ thông tin nhưng vẫn có thể ngăn không để họ giẫm chân lên nhau? Rất dễ xảy ra việc người sử dụng ghi đè lên những thay đổi của người khác trong kho lưu trữ một cách vô ý.</para>

<!--
        <para>Consider the scenario shown in
          <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
          Suppose we have two coworkers, Harry and Sally.  They each
          decide to edit the same repository file at the same time.
          If Harry saves his changes to the repository first, it's
          possible that (a few moments later) Sally could accidentally
          overwrite them with her own new version of the file.  While
          Harry's version of the file won't be lost forever (because
          the system remembers every change), any changes Harry made
          <emphasis>won't</emphasis> be present in Sally's newer version
          of the file, because she never saw Harry's changes to begin
          with.  Harry's work is still effectively lost&mdash;or at
          least missing from the latest version of the file&mdash;and
          probably by accident.  This is definitely a situation we want
          to avoid!</para>
-->
        <para>Xem xét kịch bản thể hiện ở <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>. Giả sử chúng ta có hai người đồng nghiệp, Harry và Sally. Mỗi người đều quyết định sẽ chỉnh sửa cùng một tập tin cùng thời điểm. Nếu Harry lưu những thay đổi của anh ấy vào kho lưu trữ trước, thì có nhiều khả năng là (một lát sau) Sally có thể ghi đè lên những thay đổi này với phiên bản tập tin mới hơn của cô ấy một cách vô tình. Mặc dù phiên bản của Harry sẽ không bị mất hẵn (bởi vì hệ thống ghi nhớ mỗi thay đổi), bất kỳ thay đổi nào mà Harry tạo ra <emphasis>sẽ không</emphasis> được hiện diện trong phiên bản tập tin mới hơn của Sally, bởi vì cô ấy không biết về những thay đổi của Harry để tiếp tục nối vào. Những thay đổi của Harry vẫn bị mất&mdash;hoặc ít nhất là không có mặt trong phiên bản mới nhất của tập tin&mdash;chắc chắn chỉ vì vô ý. Đó hiển nhiên là một tình huống mà chúng ta cần tránh!</para>

        <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
<!--           <title>The problem to avoid</title> -->
          <title>Vấn đề cần tránh</title>
          <graphic fileref="images/ch02dia2.png"/>
        </figure>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.lock-unlock">
<!--         <title>The lock-modify-unlock solution</title> -->
        <title>Giải pháp khoá-sửa đổi-mở khoá</title>

<!--
        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>lock-modify-unlock</tertiary>
          </indexterm>Many version control systems use a
          <firstterm>lock-modify-unlock</firstterm> model to address
          the problem of many authors clobbering each other's work.
          In this model, the repository allows only one person to
          change a file at a time.  This exclusivity policy is managed
          using locks.  Harry must <quote>lock</quote> a file before
          he can begin making changes to it.  If Harry has locked a
          file, Sally cannot also lock it, and therefore cannot make
          any changes to that file.  All she can do is
          wait for Harry to finish his changes, save the file and
          release his lock.  After Harry unlocks the file, Sally
          can take her turn by locking the file.  Then she may read
          the latest version of the file and edit it.
          <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
          demonstrates this simple solution.</para>
-->
        <para>
          <indexterm>
            <primary>kiểm soát phiên bản</primary>
            <secondary>mô hình</secondary>
            <tertiary>khoá-sửa đổi-mở khoá</tertiary>
          </indexterm>Nhiều hệ thống kiểm soát phiên bản sử dụng mô hình <firstterm>khoá-sửa đổi-mở khoá</firstterm> để giải quyết vấn đề nhiều tác giả đụng độ liên tục những thay đổi của nhau. Trong mô hình này, kho lưu trữ chỉ cho phép thay đổi của một người duy nhất ở một thời điểm. Chính sách độc quyền này được thực thi bằng việc sử dụng khóa. Harry cần phải <quote>khóa</quote> một tập tin trước khi anh ấy có thể bắt đầu hiệu chỉnh nó. Nếu Harry đã khóa tập tin, Sally không thể khóa nó, và như vậy là không thể tạo ra bất kỳ thay đổi nào trên tập tin đó. Tất cả những điều cô ấy có thể làm là đợi Harry hoàn thành những thay đổi của anh ấy, lưu tập tin và mở khóa. Sau khi Harry mở khóa tập tin, Sally tới lượt mình có thể khóa tập tin. Tiếp theo cô ấy có thể lấy phiên bản mới nhất của tập tin và hiệu chỉnh nó. <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>trình bày giải pháp đơn giản này.</para>
     <!-- ### TODO: "many authors clobbering each other's work": need a better way to translate this ### -->

        <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
<!--           <title>The lock-modify-unlock solution</title> -->
          <title>Giải pháp khoá-sửa đổi-mở khoá</title>
          <graphic fileref="images/ch02dia3.png"/>
        </figure>

<!--
        <para>The problem with the lock-modify-unlock model is that it's
          a bit restrictive and often becomes a roadblock for
          users:</para>
-->
        <para>Vấn đề của mô hình khoá-sửa đổi-mở khoá này là nó hơi hạn chế và thường hay trở thành một rào cản đối với người sử dụng:</para>

        <itemizedlist>
          <listitem>
<!--
            <para><emphasis>Locking may cause administrative
              problems.</emphasis>

              Sometimes Harry will lock a file and then forget about it.
              Meanwhile, because Sally is still waiting to edit the file,
              her hands are tied.  And then Harry goes on vacation.  Now
              Sally has to get an administrator to release Harry's lock.
              The situation ends up causing a lot of unnecessary delay
              and wasted time.</para>
-->
            <para><emphasis>Khóa có thể làm phát sinh những vấn đề về quản trị.</emphasis>

              Đôi khi Harry khóa một tập tin và quên nó hoàn toàn. Trong lúc đó, bởi vì Sally vẫn đang đợi để điều chỉnh tập tin, cô ấy sẽ phải chờ đợi mỏi mòn. Sau đó Harry lại có kỳ nghỉ. Lúc này Sally phải nhờ người quản trị để mở khóa của Harry. Tình huống gây nên việc đình trệ không cần thiết và tốn thời gian.</para>
          </listitem>

          <listitem>
<!--
            <para><emphasis>Locking may cause unnecessary
              serialization.</emphasis>

              What if Harry is editing the beginning of a text file,
              and Sally simply wants to edit the end of the same file?
              These changes don't overlap at all.  They could easily
              edit the file simultaneously, and no great harm would
              come, assuming the changes were properly merged together.
              There's no need for them to take turns in this
              situation.</para>
-->
            <para><emphasis>Khóa có thể gây nên sự nối tiếp hóa (serialization) không cần thiết.</emphasis>

              Điều gì sẽ xảy ra nếu Harry đang chỉnh sửa phần đầu của một tập tin văn bản, và Sally muốn chỉnh sửa phần cuối của cùng tập tin? Những thay đổi này không bị chồng lên nhau. Họ có thể dễ dàng chỉnh sửa tập tin đồng thời và sẽ không có tổn hại nào xuất hiện với giả sử rằng những thay đổi được hợp nhất với nhau một cách đúng đắn. Trong tình huống này họ không cần thiết phải thay phiên nhau.</para>
          </listitem>

          <listitem>
<!--
            <para><emphasis>Locking may create a false sense of
              security.</emphasis>

              Suppose Harry locks and edits file A, while Sally
              simultaneously locks and edits file B.  But what if A and
              B depend on one another, and the changes made to each are
              semantically incompatible?  Suddenly A and B don't work
              together anymore.  The locking system was powerless to
              prevent the problem&mdash;yet it somehow provided a false
              sense of security.  It's easy for Harry and Sally to
              imagine that by locking files, each is beginning a safe,
              insulated task, and thus they need not bother discussing
              their incompatible changes early on.  Locking often
              becomes a substitute for real communication.</para>
-->
            <para><emphasis>Khóa có thể tạo ra một cảm giác sai về bảo mật.</emphasis>

              Giả sử Harry khóa và chỉnh sửa tập tin A, trong khi đó Sally cũng khóa và chỉnh sửa tập tin B. Nhưng sẽ như thế nào nếu cả A và B phụ thuộc vào nhau và những thay đổi được thực hiện trên mỗi tập tin là không tương thích về mặt ngữ nghĩa? Đột nhiên A và B không làm việc với nhau nữa. Hệ thống khóa đã bất lực không thể ngăn vấn đề xảy ra&mdash;nó tạo nên một ấn tượng sai về bảo mật. Nó rất dễ gây cho Harry và Sally suy nghĩ rằng bằng cách khóa những tập tin, mỗi người có thể bắt đầu công việc một cách an toàn, tác vụ tách biệt nhau, và do đó họ không cần bận tâm thảo luận về những thay đổi không tương thích ngay từ đầu. Khóa đôi khi trở thành một sự thay thế cho giao tiếp thực tế.</para>
          </listitem>
        </itemizedlist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.copy-merge">
<!--         <title>The copy-modify-merge solution</title> -->
        <title>Giải pháp sao chép-sửa đổi-hợp nhất</title>

<!--
        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>copy-modify-merge</tertiary>
          </indexterm>Subversion, CVS, and many other version control
          systems use a <firstterm>copy-modify-merge</firstterm> model
          as an alternative to locking.  In this model, each user's
          client contacts the project repository and creates a
          personal working copy.  Users then work simultaneously and
          independently, modifying their private copies.  Finally, the
          private copies are merged together into a new, final
          version.  The version control system often assists with the
          merging, but ultimately, a human being is responsible for
          making it happen correctly.</para>
-->
        <para>
          <indexterm>
            <primary>kiểm soát phiên bản</primary>
            <secondary>mô hình</secondary>
            <tertiary>sao chép-sửa đổi-hợp nhất</tertiary>
          </indexterm>Subversion, CVS và nhiều hệ kiểm soát phiên bản khác sử dụng mô hình <firstterm>sao chép-sửa đổi-hợp nhất</firstterm> như là phương án thay thế cho khóa. Trong mô hình này, mỗi ứng dụng khách của người sử dụng kết nối với kho lưu trữ dự án và tạo một bản sao làm việc riêng. Người sử dụng sau đó làm việc đồng thời và độc lập với nhau chỉnh sửa phiên bản sao chép riêng của họ. Sau cùng, những bản sao riêng lẻ được hợp nhất với nhau thành một bản mới, phiên bản cuối cùng. Hệ thống kiểm soát phiên bản thường hỗ trợ việc hợp nhất, nhưng sau cùng, người quản trị có trách nhiệm thực hiện việc hợp nhất một cách chính xác.</para>

<!--
        <para>
          <indexterm>
            <primary>out of date</primary>
          </indexterm>Here's an example.  Say that Harry and Sally
          each create working copies of the same project, copied from
          the repository.  They work concurrently and make changes to
          the same file A within their copies.  Sally saves her
          changes to the repository first.  When Harry attempts to
          save his changes later, the repository informs him that his
          file A is <firstterm>out of date</firstterm>.  In other
          words, file A in the repository has somehow changed since he
          last copied it.  So Harry asks his client to merge any new
          changes from the repository into his working copy of file A.
          Chances are that Sally's changes don't overlap with his own;
          once he has both sets of changes integrated, he saves his
          working copy back to the repository.
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/> show
          this process.</para>
-->
        <para>
          <indexterm>
            <primary>quá hạn</primary>
          </indexterm>Đây là một ví dụ. Giả sử rằng Harry và Sally mỗi người tạo một bản sao làm việc của cùng một dự án, sao chép từ kho lưu trữ. Họ làm việc đồng thời và thay đổi trên cùng một tập tin A trong bản sao của họ. Sally lưu những thay đổi của cô ấy vào kho lưu trữ trước. Khi Harry cố gắng để lưu những thay đổi của anh ấy sau đó, kho lưu trữ thông báo với anh ấy rằng tập tin A của anh ấy <firstterm>quá hạn</firstterm>. Nói cách khác, tập tin A trong kho lưu trữ đã bị thay đổi theo cách nào đó kể từ lúc anh ấy sao lưu nó. Vì vậy Harry ra lệnh cho ứng dụng khách của anh ấy hợp nhất bất kỳ thay đổi mới nào từ trên kho lưu trữ vào trong bản sao làm việc của tập tin A của anh ấy. Nhiều khả năng là những thay đổi của Sally không bị chồng chéo với những thay đổi của riêng anh ấy; khi hai phần đã được tích hợp vào với nhau, anh ấy lưu bản sao làm việc của anh ấy vào trong kho lưu trữ. <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> và <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/> biểu diễn quy trình này.</para>

        <figure id="svn.basic.vsn-models.copy-merge.dia-1">
<!--           <title>The copy-modify-merge solution</title> -->
          <title>Giải pháp sao chép-sửa đổi-hợp nhất</title>
          <graphic fileref="images/ch02dia4.png"/>
        </figure>

        <figure id="svn.basic.vsn-models.copy-merge.dia-2">
          <title>Giải pháp sao chép-sửa đổi-hợp nhất (tiếp theo)</title>
          <graphic fileref="images/ch02dia5.png"/>
        </figure>

<!--
        <para>
          <indexterm>
            <primary>conflicts</primary>
          </indexterm>But what if Sally's changes
          <emphasis>do</emphasis> overlap with Harry's changes?  What
          then?  This situation is called a
          <firstterm>conflict</firstterm>, and it's usually not much
          of a problem.  When Harry asks his client to merge the
          latest repository changes into his working copy, his copy of
          file A is somehow flagged as being in a state of conflict:
          he'll be able to see both sets of conflicting changes and
          manually choose between them.  Note that software can't
          automatically resolve conflicts; only humans are capable of
          understanding and making the necessary intelligent choices.
          Once Harry has manually resolved the overlapping
          changes&mdash;perhaps after a discussion with Sally&mdash;he
          can safely save the merged file back to the
          repository.</para>
-->
        <para>
          <indexterm>
            <primary>xung đột</primary>
          </indexterm>Nhưng sẽ như thế nào nếu thay đổi của Sally <emphasis>thật sự</emphasis> chồng chéo với thay đổi của Harry? Điều gì sau đó? Tình huống này gọi là <firstterm>xung đột</firstterm>, và thông thường thì nó không hẵn là một vấn đề. Khi Harry ra lệnh cho ứng dụng khách của anh ấy hợp nhất những thay đổi mới nhất trên kho vào trong bản sao làm việc của anh ấy, bản sao của tập tin A của anh ấy theo cách nào đó được đánh dấu như là đang ở trạng thái xung đột: anh ấy có thể thấy cả hai phần của những thay đổi đang gặp xung đột và chọn một trong hai một cách thủ công. Lưu ý rằng phần mềm không thể giải quyết xung đột một cách tự động; chỉ có con người mới có khả năng hiểu và thực hiện việc chọn lựa cần thiết một cách thông minh. Khi Harry đã giải quyết vấn đề những thay đổi chồng chéo một cách thủ công&mdash;có lẽ sau khi thảo luận với Sally&mdash;anh ấy có thể lưu tập tin được hợp nhất ngược lại vào trong kho lưu trữ.</para>

<!--
        <para>The copy-modify-merge model may sound a bit chaotic, but
          in practice, it runs extremely smoothly.  Users can work in
          parallel, never waiting for one another.  When they work on
          the same files, it turns out that most of their concurrent
          changes don't overlap at all; conflicts are infrequent.  And
          the amount of time it takes to resolve conflicts is usually
          far less than the time lost by a locking system.</para>
-->
        <para>Mô hình sao chép-sửa đổi-hợp nhất nghe có vẻ hơi hỗn loạn, nhưng trên thực tế, nó hoạt động rất mượt. Người sử dụng có thể làm việc song song, không bao giờ phải chờ đợi nhau. Khi họ làm việc trên cùng một tập tin, hoá ra rằng hầu hết những thay đổi đồng thời của họ không hoàn toàn không chồng lấn; xung đột là không thường xuyên. Và thời gian nó tiêu tốn để giải quyết xung đột thường là ít hơn nhiều so với thời gian bị mất bởi hệ thống khoá.</para>

<!--
        <para>In the end, it all comes down to one critical factor:
          user communication.  When users communicate poorly, both
          syntactic and semantic conflicts increase.  No system can
          force users to communicate perfectly, and no system can
          detect semantic conflicts.  So there's no point in being
          lulled into a false sense of security that a locking system
          will somehow prevent conflicts; in practice, locking seems
          to inhibit productivity more than anything else.</para>
-->
        <para>Cuối cùng, tất cả dẫn đến một yếu tố quan trọng: giao tiếp người sử dụng. Khi người dùng giao tiếp kém, cả hai loại xung đột cú pháp và xung đột ngữ nghĩa tăng. Không có hệ thống nào có thể bắt buộc người sử dụng phải giao tiếp một cách hoàn hảo, và không có hệ thống nào có thể phát hiện những xung đột ngữ nghĩa. Vì vậy, khó để bị ru ngủ vào một cảm giác sai về bảo mật rằng một hệ thống khoá bằng cách nào đó ngăn chặn xung đột; trong thực tế, khoá dường như ngăn cản năng xuất nhiều hơn bất cứ thứ gì khác.</para>

        <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
<!--           <title>When Locking Is Necessary</title> -->
          <title>Khi khoá là cần thiết</title>

<!--
          <para>While the lock-modify-unlock model is considered
            generally harmful to collaboration, sometimes
            locking is appropriate.</para>
-->
          <para>Trong khi mô hình khoá-sửa đổi-mở khoá nói chung được xem là có hại cho sự hợp tác, đôi khi khoá là thích hợp.</para>

<!--
          <para>The copy-modify-merge model is based on the assumption
            that files are contextually mergeable&mdash;that is, that the
            majority of the files in the repository are line-based text
            files (such as program source code).  But for files with
            binary formats, such as artwork or sound, it's often
            impossible to merge conflicting changes.  In these
            situations, it really is necessary for users to take strict
            turns when changing the file.  Without serialized access,
            somebody ends up wasting time on changes that are ultimately
            discarded.</para>
-->
          <para>Mô hình khoá-sửa đổi-mở khoá được dựa trên sự giả định rằng những tập tin là có thể hợp nhất được theo ngữ cảnh&mdash;đó là, đa số các tập tin trong kho lưu trữ là tập tin văn bản dựa trên dòng (như là mã nguồn chương trình). Nhưng với tập tin có định dạng nhị phân, như là nội dung đồ hoạ hay âm thanh, thường là không thể hợp nhất những thay đổi gặp xung đột. Trong những tình huống này, nó thực sự là cần thiết cho người dùng để thay phiên nhau chặt chẽ khi thay đổi các tập tin. Không có tuần tự truy cập, ai đó sẽ lãng phí thời gian vào những thay đổi mà cuối cùng bị loại bỏ.</para>

<!--
          <para>While Subversion is primarily a copy-modify-merge
            system, it still recognizes the need to lock an occasional
            file, and thus provides mechanisms for this.  We discuss
            this feature in <xref linkend="svn.advanced.locking"/>.</para>
-->
          <para>Trong khi Subversion chủ yếu là một hệ thống sao chép-sửa đổi-hợp nhất, nó vẫn ghi nhận sự cần thiết việc khoá một vài tập tin, và vì vậy cung cấp cơ chế cho việc khoá này. Chúng ta bàn về tính năng này trong <xref linkend="svn.advanced.locking"/>.</para>

        </sidebar>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
<!--     <title>Version Control the Subversion Way</title> -->
    <title>Kiểm Soát Phiên Bản Theo Cách Của Subversion</title>

<!--
    <para>We've mentioned already that Subversion is a modern,
      network-aware version control system.  As we described in
      <xref linkend="svn.basic.version-control-basics"/> (our
      high-level version control overview), a repository serves as the
      core storage mechanism for Subversion's versioned data, and it's
      via working copies that users and their software programs
      interact with that data.  In this section, we'll begin to
      introduce the specific ways in which Subversion implements
      version control.</para>
-->
    <para>Chúng tôi đã đề cập rằng Subversion là một hệ thống kiểm soát phiên bản hiện đại, thiết kế cho mạng lưới. Như chúng tôi có mô tả trong <xref linkend="svn.basic.version-control-basics"/> (tổng quan về kiểm soát phiên bản ở cấp độ cao), kho lưu trữ đóng vai trò cơ chế lưu trữ trung tâm cho dữ liệu phiên bản của Subversion, và thông qua bản sao làm việc mà người sử dụng và phần mềm của họ tương tác với dữ liệu đó. Trong phần này, chúng ta sẽ bắt đầu giới thiệu những cách cụ thể mà Subversion thực hiện kiểm soát phiên bản.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.svn-repositories">
<!--       <title>Subversion Repositories</title> -->
      <title>Kho lưu trữ Subversion</title>

<!--
      <para>Subversion implements the concept of a version control
        repository much as any other modern version control system
        would.  Unlike a working copy, a Subversion repository is an
        abstract entity, able to be operated upon almost exclusively
        by Subversion's own libraries and tools.  As most of a user's
        Subversion interactions involve the use of the Subversion
        client and occur in the context of a working copy, we spend
        the majority of this book discussing the Subversion working
        copy and how to manipulate it.  For the finer details of the
        repository, though, check out
        <xref linkend="svn.reposadmin"/>.</para>
-->
        
      <para>Subversion hiện thực khái niệm kho lưu trữ của kiểm soát phiên bản tương tự như những hệ thống kiểm soát phiên bản hiện đại khác. Không giống như bản sao làm việc, kho lưu trữ Subversion là một thực thể trừu tượng, có khả năng được vận hành gần như độc quyền bởi những thư viện và công cụ riêng của Subversion. Vì đa số những tương tác Subversion của người sử dụng có liên quan đến việc sử dụng ứng dụng khách Subversion và xảy ra trong phạm vi của bản sao làm việc, chúng ta sẽ dành phần lớn trong cuốn sách này thảo luận về bản sao làm việc Subversion và làm cách nào để thao tác trên nó. Để có thông tin chi tiết hơn về kho lưu trữ, kiểm tra <xref linkend="svn.reposadmin"/>.</para>

      <warning id="svn.basic.svn-repositories.not-working-copy">
<!--
        <para>In Subversion, the client-side object which every user
          of the system has&mdash;the directory of versioned files,
          along with metadata that enables the system to track them
          and communicate with the server&mdash;is called
          a <emphasis>working copy</emphasis>.  Although other version
          control systems use the term <quote>repository</quote> for
          the client-side object, it is both incorrect and a common
          source of confusion to use the term in that way in the
          context of Subversion.</para>
-->
        <para>Trong Subversion, đối tượng phía máy khách mà mỗi người sử dụng của hệ thống đều có&mdash;thư mục chứa những tập tin phiên bản, đi kèm với siêu dữ liệu mà cho phép hệ thống theo dõi chúng và giao tiếp với máy chủ&mdash;gọi là <emphasis>bản sao làm việc</emphasis>. Mặc dù những hệ thống kiểm soát phiên bản khác sử dụng khái niệm <quote>kho lưu trữ</quote> cho đối tượng phía máy khách, cả hai đều không chính xác và là nguồn gốc gây nhầm lẫn phổ biến của việc sử dụng thuật ngữ theo cách này trong ngữ cảnh của Subversion.</para>

<!--
        <para>Working copies are described later, in
          <xref linkend="svn.basic.in-action.wc"/>.</para>
-->
        <para>Bản sao làm việc được mô tả sau trong <xref linkend="svn.basic.in-action.wc"/>.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
<!--       <title>Revisions</title> -->
      <title>Phiên bản</title>

<!--
      <para>A Subversion client commits (that is, communicates the
        changes made to) any number of files and directories as a
        single atomic transaction.  By atomic transaction, we mean
        simply this: either all of the changes are accepted into the
        repository, or none of them is.  Subversion tries to retain
        this atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>
-->
      <para>Ứng dụng khách Subversion chuyển giao (đó là, truyền những thay đổi được thực hiện) số lượng tập tin và thư mục bất kỳ bởi một giao dịch đơn nguyên tử. Khi đề cập đến giao dịch nguyên tử, chúng tôi đơn giản muốn thể hiện là: hoặc là tất cả các thay đổi được chấp nhận vào trong kho lưu trữ, hoặc không có bất kỳ thay đổi nào. Subversion sẽ cố gắng để giữ lại tính nguyên tử này trong những tình huống chương trình bị treo, hệ thống treo, vấn đề về mạng, và hành động của người dùng khác.</para>

<!--
      <para>
        <indexterm>
          <primary>revisions</primary>
        </indexterm>Each time the repository accepts a commit, this
        creates a new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number assigned to
        the previous revision.  The initial revision of a freshly
        created repository is numbered 0 and consists of nothing but
        an empty root directory.</para>
-->
      <para>
        <indexterm>
          <primary>phiên bản</primary>
        </indexterm>Mỗi khi kho lưu trữ tiếp nhận một chuyển giao (commit), việc này tạo nên một trạng thái mới của cây hệ thống tập tin, được gọi là <firstterm>phiên bản</firstterm>. Mỗi phiên bản được gán một số tự nhiên không trùng lặp, mỗi số sẽ lớn hơn số được gán cho phiên bản kế trước. Phiên bản ban đầu của một kho lưu trữ vừa tạo được đánh số 0 và nó chỉ là một thư mục gốc rỗng.</para>

<!--
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/>
        illustrates a nice way to visualize the repository.  Imagine
        an array of revision numbers, starting at 0, stretching from
        left to right.  Each revision number has a filesystem tree
        hanging below it, and each tree is a <quote>snapshot</quote>
        of the way the repository looked after a commit.</para>
-->
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> minh hoạ một cách đơn giản để hình dung kho lưu trữ. Tưởng tượng có một dãy của những số phiên bản, bắt đầu từ 0, kéo dài từ trái sang phải. Mỗi số phiên bản có một cây hệ thống tập tin treo dưới nó và mỗi cây là một <quote>ảnh chụp</quote> của cách kho lưu trữ làm việc sau mỗi chuyển giao.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
<!--         <title>Tree changes over time</title> -->
        <title>Cây thay đổi theo thời gian</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
<!--         <title>Global Revision Numbers</title> -->
        <title>Số phiên bản toàn cục</title>

<!--
        <para>
          <indexterm>
            <primary>revisions</primary>
            <secondary>global</secondary>
          </indexterm>Unlike most version control systems,
          Subversion's revision numbers apply to <emphasis>the entire
          repository tree</emphasis>, not individual files.  Each
          revision number selects an entire tree, a particular state
          of the repository after some committed change.  Another way
          to think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename>,</quote> they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Many
          other version control systems use per-file revision numbers,
          so this concept may seem unusual at first. (Former CVS users
          might want to see <xref linkend="svn.forcvs"/> for more
          details.)</para>
-->
        <para>
          <indexterm>
            <primary>phiên bản</primary>
            <secondary>toàn cục</secondary>
          </indexterm>Không giống như đa số những hệ kiểm soát phiên bản khác, số phiên bản của Subversion áp dụng cho <emphasis>toàn bộ cây kho lưu trữ</emphasis>, không phải cho những tập tin riêng lẽ. Mỗi số phiên bản đại diện cho toàn bộ cây, là một trạng thái riêng biệt của kho lưu trữ sau khi mỗi thay đổi được chuyển giao. Cách khác để suy nghĩ về nó là phiên bản N đại diện cho trạng thái của hệ thống tập tin kho lưu trữ sau chuyển giao thứ N. Khi người sử dụng Subversion đề cập đến <quote>phiên bản 5 của <filename>foo.c</filename>,</quote> họ thực sự muốn đề cập <quote><filename>foo.c</filename> khi nó xuất hiện trong phiên bản 5.</quote> Lưu ý rằng, thông thường phiên bản N và M của một tập tin <emphasis>không</emphasis> nhất thiết phải khác nhau! Nhiều hệ thống kiểm soát phiên bản khác sử dụng số phiên bản theo-tập-tin, vì vậy khái niệm này lúc ban đầu có vẻ không bình thường. (Những người đã từng sử dụng CVS có thể muốn xem <xref linkend="svn.forcvs"/> để biết thêm thông tin chi tiết.)</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
<!--      <title>Addressing the Repository</title>-->
      <title>Địa chỉ kho lưu trữ</title>

<!--
      <para>
        <indexterm>
          <primary>repository URL</primary>
        </indexterm>Subversion client programs use URLs to identify
        versioned files and directories in Subversion repositories.
        For the most part, these URLs use the standard syntax,
        allowing for server names and port numbers to be specified as
        part of the URL.</para>
-->
      <para>
        <indexterm>
          <primary>URL kho lưu trữ</primary>
        </indexterm>Ứng dụng khách Subversion dùng URL để xác định những tập tin và thư mục đã được đánh phiên bản trong kho lưu trữ Subversion. Hầu hết những URL này sử dụng cú pháp chuẩn, cho phép tên máy chủ và cổng được xác định như một phần của URL.</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>http://svn.example.com/svn/project</simpara>
          </listitem>
          <listitem>
            <simpara>http://svn.example.com:9834/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

<!--
      <para>Subversion repository URLs aren't limited to only
        the <literal>http://</literal> variety.  Because Subversion
        offers several different ways for its clients to communicate
        with its servers, the URLs used to address the repository
        differ subtly depending on which repository access mechanism
        is employed.  <xref linkend="svn.basic.in-action.wc.tbl-1"/>
        describes how different URL schemes map to the available
        repository access methods.  For more details about
        Subversion's server options, see
        <xref linkend="svn.serverconfig"/>.</para>
-->
      <para>URL của kho lưu trữ Subversion không chỉ giới hạn với <literal>http://</literal>. Bởi vì Subversion cung cấp nhiều phương thức khác nhau để những ứng dụng khách của nó có thể giao tiếp với máy chủ, URL được dùng để xác định địa chỉ của kho khác biệt một chút tùy thuộc vào cơ chế truy cập kho mà nó sử dụng. <xref linkend="svn.basic.in-action.wc.tbl-1"/> miêu tả những lược đồ URL khác nhau ánh xạ vào những phương thức truy cập kho lưu trữ có sẵn. Để biết thêm chi tiết về các tùy chọn máy chủ Subversion, xem <xref linkend="svn.serverconfig"/>.</para>

<!--
      <table id="svn.basic.in-action.wc.tbl-1">
        <title>Repository access URLs</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Schema</entry>
              <entry>Access method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>file:///</literal></entry>
              <entry>Direct repository access (on local disk)</entry>
            </row>
            <row>
              <entry><literal>http://</literal></entry>
              <entry>Access via WebDAV protocol to Subversion-aware
                Apache server</entry>
            </row>
            <row>
              <entry><literal>https://</literal></entry>
              <entry>Same as <literal>http://</literal>, but with
                SSL encapsulation (encryption and authentication)</entry>
            </row>
            <row>
              <entry><literal>svn://</literal></entry>
              <entry>Access via custom protocol to an
                <literal>svnserve</literal> server</entry>
            </row>
            <row>
              <entry><literal>svn+ssh://</literal></entry>
              <entry>Same as <literal>svn://</literal>, but through
                an SSH tunnel</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
-->
      <table id="svn.basic.in-action.wc.tbl-1">
        <title>URL truy cập kho lưu trữ</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Giao thức</entry>
              <entry>Phương thức truy cập</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>file:///</literal></entry>
              <entry>Truy cập trực tiếp kho lưu trữ (trên đĩa cục bộ)</entry>
            </row>
            <row>
              <entry><literal>http://</literal></entry>
              <entry>Truy cập thông qua giao thức WebDAV tới máy chủ Apache Subversion</entry>
            </row>
            <row>
              <entry><literal>https://</literal></entry>
              <entry>Tương tự như <literal>http://</literal>, nhưng với đóng gói SSL (mã hóa và xác thực)</entry>
            </row>
            <row>
              <entry><literal>svn://</literal></entry>
              <entry>Truy cập thông qua giao thức tùy chỉnh tới máy chủ <literal>svnserve</literal></entry>
            </row>
            <row>
              <entry><literal>svn+ssh://</literal></entry>
              <entry>Tương tự như <literal>svn://</literal>, nhưng thông qua SSH</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

<!--
      <para>Subversion's handling of URLs has some notable nuances.
        For example, URLs containing the <literal>file://</literal>
        access method (used for local repositories) must, in
        accordance with convention, have either a server name
        of <literal>localhost</literal> or no server name at
        all:</para>
-->
      <para>Việc xử lý URL của Subversion có một số điểm đáng chú ý. Ví dụ: URL chứa phương thức truy cập <literal>file://</literal> (được sử dụng cho kho lưu trữ cục bộ) để phù hợp với quy ước cần phải có hoặc tên máy chủ <literal>localhost</literal> hoặc hoàn toàn không chứa tên máy chủ:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file://localhost/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

<!--
      <para>Also, users of the <literal>file://</literal> scheme on
        Windows platforms will need to use an unofficially
        <quote>standard</quote> syntax for accessing repositories
        that are on the same machine, but on a different drive than
        the client's current working drive.  Either of the two
        following URL path syntaxes will work, where
        <literal>X</literal> is the drive on which the repository
        resides:</para>
-->
      <para>Ngoài ra, những người sử dụng giao thức <literal>file://</literal> trên nền tảng Windows sẽ cần phải sử dụng một cú pháp <quote>chuẩn</quote> không chính thức để truy cập kho lưu trữ ở trên cùng một máy nhưng khác ổ đĩa với ổ đĩa của thư mục làm việc. Cả hai cú pháp đường dẫn URL bên dưới sẽ hoạt động, với <literal>X</literal> là ổ đĩa mà kho lưu trữ được chứa trong:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///X:/var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file:///X|/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

<!--
      <para>Note that a URL uses forward slashes even though the
        native (non-URL) form of a path on Windows uses backslashes.
        Also note that when using
        the <literal>file:///<replaceable>X</replaceable>|/</literal>
        form at the command line, you need to quote the URL (wrap it
        in quotation marks) so that the vertical bar character is not
        interpreted as a pipe.</para>
-->
      <para>Lưu ý rằng URL sử dụng dấu gạch chéo xuôi mặc dù dạng đường dẫn gốc (không-URL) trên Windows sử dụng dấu gạch chéo ngược. Ngoài ra cũng lưu ý khi sử dụng dạng <literal>file:///<replaceable>X</replaceable>|/</literal> ở giao diện dòng lệnh, bạn cần phải trích dẫn URL (bao quanh bằng dấu ngoặc kép) để ký tự thanh đứng không bị thông dịch như ký tự đường ống.</para>

<!--
      <note>
        <para>You cannot use Subversion's <literal>file://</literal> URLs
          in a regular web browser the way you can use typical
          <literal>file://</literal> URLs.  When you attempt to view
          a <literal>file://</literal> URL in a regular web browser, it
          reads and displays the contents of the file at that location
          by examining the filesystem directly.  However, Subversion's
          resources exist in a virtual filesystem (see <xref
          linkend="svn.developer.layerlib.repos" />), and your browser
          will not understand how to interact with that
          filesystem.</para>
      </note>
-->
      <note>
        <para>Bạn không thể sử dụng URL <literal>file://</literal> của Subversion với trình duyệt web thông thường theo cách mà bạn thường sử dụng. Khi bạn cố xem URL <literal>file://</literal> trên một trình duyệt web thông thường, nó đọc và hiển thị nội dung của tập tin ở vị trí đó bằng cách kiểm tra trực tiếp hệ thống tập tin. Tuy nhiên, tài nguyên Subversion tồn tại trên một hệ thống tập tin ảo (xem <xref linkend="svn.developer.layerlib.repos" />) và trình duyệt của bạn sẽ không hiểu làm cách nào để tương tác với hệ thống tập tin đó.</para>
      </note>

<!--
      <para>The Subversion client will automatically encode URLs as
        necessary, just like a web browser does.  For example, the URL
        <literal>http://host/path with space/project/españa</literal>
        &mdash; which contains both spaces and upper-ASCII characters
        &mdash; will be automatically interpreted by Subversion as if
        you'd provided
        <literal>http://host/path%20with%20space/project/espa%C3%B1a</literal>.
        If the URL contains spaces, be sure to place it within
        quotation marks at the command line so that your shell treats
        the whole thing as a single argument to the program.</para>
-->
      <para>Ứng dụng khách Subversion sẽ mã hóa URL một cách tự động giống như cách mà trình duyệt web thực hiện. Lấy ví dụ, URL <literal>http://host/path with space/project/españa</literal> &mdash; mà chứa cả khoảng trắng và ký tự ASCII in hoa &mdash; sẽ được Subversion tự động thông dịch giống như khi bạn nhập <literal>http://host/path%20with%20space/project/espa%C3%B1a</literal>. Nếu URL chứa khoảng trắng, hãy nhớ đặt nó vào trong dấu ngoặc kép khi sử dụng ở giao diện dòng lệnh để Shell của bạn xử lý toàn bộ như là một tham số duy nhất cho chương trình.</para>

<!--
      <para>There is one notable exception to Subversion's handling of
        URLs which also applies to its handling of local paths in many
        contexts, too.  If the final path component of your URL or
        local path contains an at sign (<literal>@</literal>), you need
        to use a special syntax&mdash;described in
        <xref linkend="svn.advanced.pegrevs" />&mdash;in order to make
        Subversion properly address that resource.</para>
-->
      <para>Có một ngoại lệ đáng chú ý trong cách Subversion quản lý URL mà cũng được áp dụng trong cách nó quản lý đường dẫn cục bộ trong nhiều ngữ cảnh. Nếu thành phần cuối cùng của URL hoặc đường dẫn cục bộ chứa dấu a-còng (<literal>@</literal>), bạn cần phải sử dụng một cú pháp đặc biệt&mdash;được mô tả trong <xref linkend="svn.advanced.pegrevs" />&mdash; để có thể làm cho Subversion định địa chỉ tài nguyên đó một cách bình thường.</para>

<!--
      <para>
        <indexterm>
          <primary>repository-relative URL</primary>
        </indexterm>
        <indexterm>
          <primary>caret syntax</primary>
        </indexterm>
        <indexterm>
          <primary>^</primary>
          <see>caret syntax</see>
        </indexterm>In Subversion 1.6, a new caret (<literal>^</literal>)
        notation was introduced as a shorthand for <quote>the URL of
        the repository's root directory</quote>.  For example, you can
        use the <literal>^/tags/bigsandwich/</literal> to refer to the
        URL of the <filename>/tags/bigsandwich</filename> directory in
        the root of the repository.  Such a URL is called a
        <firstterm>repository-relative URL</firstterm>.  Note
        that this URL syntax works only when your current working
        directory is a working copy&mdash;the command-line client
        knows the repository's root URL by looking at the working
        copy's metadata.  Also note that when you wish to refer
        precisely to the root directory of the repository, you must do
        so using <literal>^/</literal> (with the trailing slash
        character), not merely
        <literal>^</literal>.  Windows users should not forget that
        a caret is an escape character on their platform.  Therefore,
        use a double caret <literal>^^</literal> if you run the
        Subversion client on a Windows machine.
      </para>
-->
      <para>
        <indexterm>
          <primary>URL tương đối của kho lưu trữ</primary>
        </indexterm>
        <indexterm>
          <primary>cú pháp mũ</primary>
        </indexterm>
        <indexterm>
          <primary>^</primary>
          <see>cú pháp mũ</see>
        </indexterm>Trong Subversion 1.6, một ký hiệu mũ (<literal>^</literal>) được giới thiệu như là một ký hiệu viết tắt cho <quote>URL của thư mục gốc của kho lưu trữ</quote>. Ví dụ, bạn có thể sử dụng <literal>^/tags/bigsandwich/</literal> để tham khảo đến URL của thư mục <filename>/tags/bigsandwich</filename> ở gốc của kho lưu trữ. Loại URL này được gọi là <firstterm>URL tương đối của kho lưu trữ</firstterm>. Lưu ý rằng cú pháp URL này chỉ hoạt động khi thư mục làm việc hiện hành của bạn là bản sao làm việc&mdash;ứng dụng khách Subversion giao-diện-dòng-lệnh nhận biết URL gốc của kho lưu trữ bằng cách tham khảo siêu dữ liệu của bản sao làm việc. Ngoài ra cũng lưu ý rằng khi bạn mong muốn tham khảo đến thư mục gốc của kho lưu trữ, bạn cần phải dùng <literal>^/</literal> (với dấu gạch chéo ở đuôi), không chỉ đơn thuần <literal>^</literal>. Người sử dụng Windows cần phải lưu ý rằng dấu mũ là một ký tự thoát (escape character). Vì thể, dùng dấu mũ đôi <literal>^^</literal> nếu bạn sử dụng ứng dụng khách Subversion trên máy chạy Windows.</para>

        
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
<!--       <title>Subversion Working Copies</title> -->
      <title>Bản sao làm việc Subversion</title>

<!--
      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A Subversion working copy is an ordinary directory
        tree on your local system, containing a collection of files.
        You can edit these files however you wish, and if they're
        source code files, you can compile your program from them in
        the usual way.  Your working copy is your own private work
        area: Subversion will never incorporate other people's
        changes, nor make your own changes available to others, until
        you explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>
-->
      <para>
        <indexterm>
          <primary>bản sao làm việc</primary>
        </indexterm>Một bản sao làm việc Subversion là một cây thư mục bình thường trong hệ thống cục bộ của bạn, nó chứa một bộ sưu tập tập những tập tin. Bạn có thể hiệu chỉnh những tập tin này tùy ý và nếu chúng là những tập tin mã nguồn, bạn có thể biên dịch chương trình của bạn từ những tập tin này theo cách thông thường. Bản sao làm việc của bạn là khu vực làm việc của riêng bạn: Subversion sẽ không bao giờ kết hợp thay đổi của những người khác và cũng không làm cho những thay đổi của riêng bạn có sẵn đối với những người khác, cho tới khi bạn yêu cầu nó làm việc đó một cách rõ ràng. Bạn thậm chí có thể có nhiều hơn một bản sao làm việc của cùng một dự án.</para>

<!--
      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes (by writing to the repository), thereby making them
        available to the other people working with you on your
        project.  If other people publish their own changes,
        Subversion provides you with commands to merge those changes
        into your own working copy (by reading from the repository).
        Notice that the central repository is the broker for
        everybody's changes in Subversion&mdash;changes aren't passed
        directly from working copy to working copy in the typical
        workflow.</para>
-->
      <para>Sau khi bạn thực hiện một số thay đổi trên những tập tin trong bản sao làm việc của bạn và đã xác nhận rằng chúng hoạt động bình thường, Subversion cung cấp lệnh để bạn <quote>phát hành</quote> những thay đổi của bạn (bằng cách ghi vào kho lưu trữ), bằng cách đó làm cho chúng có sẵn với những người khác đang làm việc với bạn trong dự án. Nếu những người khác phát hành những thay đổi của riêng họ, Subversion cung cấp lệnh để hợp nhất những thay đổi đó vào trong bản sao làm việc của riêng bạn (bằng cách đọc từ kho lưu trữ). Lưu ý rằng trong Subversion, kho lưu trữ trung tâm là trung gian cho tất cả những thay đổi của tất cả mọi người&mdash;những thay đổi không được chuyển trực tiếp từ bản sao làm việc này tới bản sao làm việc khác trong các quy trình làm việc điển hình.</para>

<!--
      <para>
        <indexterm>
          <primary>administrative directory</primary>
        </indexterm>
        <indexterm>
          <primary>.svn</primary>
          <see>administrative directory</see>
        </indexterm>A working copy also contains some extra files,
        created and maintained by Subversion, to help it carry out
        these commands.  In particular, each working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy's <firstterm>administrative
        directory</firstterm>.  The files in the administrative
        directory help Subversion recognize which of your versioned
        files contain unpublished changes, and which files are out of
        date with respect to others' work.</para>
-->
      <para>
        <indexterm>
          <primary>thư mục quản trị</primary>
        </indexterm>
        <indexterm>
          <primary>.svn</primary>
          <see>thư mục quản trị</see>
        </indexterm>Bản sao làm việc cũng lưu trữ một vài tập tin phụ, được tạo ra và duy trì bởi Subversion, để hỗ trợ thực hiện các lệnh. Đặc biệt, mỗi bản sao làm việc chứa một thư mục con với tên <filename>.svn</filename>, được biết như là <firstterm>thư mục quản trị</firstterm> của bản sao làm việc. Những tập tin trong thư mục quản trị này hỗ trợ Subversion nhận diện được những tập tin được đánh phiên bản nào chứa những thay đổi chưa được phát hành, và những tập tin nào là quá hạn so với công việc của những người khác.</para>

<!--
      <note>
        <para>Prior to version 1.7, Subversion
          maintained <filename>.svn</filename> administrative
          subdirectories in <emphasis>every</emphasis> versioned
          directory of your working copy.  Subversion 1.7 offers a
          completely new approach to how working copy metadata is
          stored and maintained, and chief among the visible changes
          to this approach is that each working copy now has only
          one <filename>.svn</filename> subdirectory which is an
          immediate child of the root of that working copy.</para>
      </note>
-->
      <note>
        <para>Trước phiên bản 1.7, Subversion duy trì thư mục quản trị con <filename>.svn</filename> trong <emphasis>mỗi</emphasis> thư mục được đánh phiên bản trong bản sao làm việc của bạn. Subversion 1.7 cung cấp một cách tiếp cận hoàn toàn mới về cách siêu dữ liệu được lưu trữ và duy trì, và trọng yếu trong những thay đổi hiện hữu trong cách tiếp cận này là mỗi bản sao làm việc chỉ có duy nhất một thư mực con <filename>.svn</filename> là thư mục con trực tiếp của gốc của bản sao làm việc đó.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.track-repos">
<!--         <title>How the working copy works</title> -->
        <title>Bản sao làm việc hoạt động như thế nào</title>

<!--
        <para>For each file in a working directory, Subversion records
          (among other things) two essential pieces of information:</para>
-->
        <para>Với mỗi tập tin trong thư mục làm việc, Subversion ghi nhận hai loại thông tin (trong số những thông tin khác) quan trọng:</para>

<!--
        <itemizedlist>
          <indexterm>
            <primary>revisions</primary>
            <secondary>working</secondary>
          </indexterm>

          <listitem>
            <para>What revision your working file is based on (this is
              called the file's <firstterm>working
              revision</firstterm>)</para>
          </listitem>
          <listitem>
            <para>A timestamp recording when the local copy was last
              updated by the repository</para>
          </listitem>
        </itemizedlist>
-->
        <itemizedlist>
          <indexterm>
            <primary>phiên bản</primary>
            <secondary>làm việc</secondary>
          </indexterm>

          <listitem>
            <para>Tập tin đang làm việc dựa trên phiên bản nào (được gọi là <firstterm>phiên bản làm việc</firstterm> của tập tin)</para>
          </listitem>
          <listitem>
            <para>Dấu thời gian ghi nhận lần cuối bản sao cục bộ được cập nhật từ kho lư trữ</para>
          </listitem>
        </itemizedlist>

<!--
        <para>Given this information, by talking to the repository,
          Subversion can tell which of the following four states a
          working file is in:</para>
-->
        <para>Tiếp nhận được thông tin này, bằng cách giao tiếp với kho lưu trữ, Subversion có thể cho biết trạng thái của một tập tin làm việc thuộc trạng thái nào trong bốn trạng thái bên dưới:</para>

<!--
        <variablelist>
          <varlistentry>
            <term>Unchanged, and current</term>
            <listitem>
              <para>The file is unchanged in the working directory, and
                no changes to that file have been committed to the
                repository since its working revision.  An <command>svn
                commit</command> of the file will do nothing, and an
                <command>svn update</command> of the file will do
                nothing.</para>
            </listitem>
          </varlistentry>
-->
        <variablelist>
          <varlistentry>
            <term>Không thay đổi, và hiện hành</term>
            <listitem>
              <para>Tập tin trong thư mục làm việc không bị thay đổi, không có thay đổi nào trong tập tin đó được chuyển giao vào kho lưu trữ kể từ phiên bản làm việc của nó. Thực thi lệnh <command>svn commit</command> trên tập tin sẽ không trả về kết quả nào, và thực thi lệnh <command>svn update</command> cũng sẽ không trả về kết quả nào.</para>
            </listitem>
          </varlistentry>

<!--
          <varlistentry>
            <term>Locally changed, and current</term>
            <listitem>
              <para>The file has been changed in the working directory,
                and no changes to that file have been committed to the
                repository since you last updated.  There are local
                changes that have not been committed to the repository;
                thus an <command>svn commit</command> of the file will
                succeed in publishing your changes, and an <command>svn
                update</command> of the file will do nothing.</para>
            </listitem>
          </varlistentry>
-->
          <varlistentry>
            <term>Được thay đổi cục bộ, và hiện hành</term>
            <listitem>
              <para>Tập tin được thay đổi trong thư mục làm việc, không có thay đổi nào trong tập tin đó được chuyển giao vào kho lưu trữ kể từ lần cuối bạn cập nhật. Một số thay đổi cục bộ chưa được chuyển giao vào kho lưu trữ; vì vậy thực thi lệnh <command>svn commit</command> trên tập tin sẽ phát hành thành công những thay đổi của bạn, và thực thi lệnh <command>svn update</command> trên tập tin sẽ không trả về kết quả nào.</para>
            </listitem>
          </varlistentry>

<!--
          <varlistentry>
            <term>Unchanged, and out of date</term>
            <listitem>
              <para>The file has not been changed in the working
                directory, but it has been changed in the repository.
                The file should eventually be updated in order to make
                it current with the latest public revision.
                An <command>svn commit</command> of the file will do
                nothing, and an
                <command>svn update</command> of the file will fold the
                latest changes into your working copy.</para>
            </listitem>
          </varlistentry>
-->
          <varlistentry>
            <term>Không thay đổi, và quá hạn</term>
            <listitem>
              <para>Tập tin không được thay đổi trong thư mục làm việc nhưng nó được thay đổi trên kho lưu trữ. Tập tin cuối cùng sẽ được cập nhật để làm nó hiện hành với phiên bản công khai mới nhất. Thực thi lệnh <command>svn commit</command> trên tập tin sẽ không trả về kết quả nào, và thực thi lệnh <command>svn update</command> trên tập tin sẽ trộn những thay đổi mới nhất vào trong bản sao làm việc của bạn.</para>
            </listitem>
          </varlistentry>

<!--
          <varlistentry>
            <term>Locally changed, and out of date</term>
            <listitem>
              <para>The file has been changed both in the working
                directory and in the repository.  An <command>svn
                commit</command> of the file will fail with an
                <quote>out-of-date</quote> error.  The file should be
                updated first; an <command>svn update</command> command
                will attempt to merge the public changes with the local
                changes.  If Subversion can't complete the merge in a
                plausible way automatically, it leaves it to the user to
                resolve the conflict.</para>
            </listitem>
          </varlistentry>
        </variablelist>
-->
          <varlistentry>
            <term>Được thay đổi cục bộ, và quá hạn</term>
            <listitem>
              <para>Tập tin được thay đổi cả trong thư mục làm việc và trong kho lưu trữ. Thực thi lệnh <command>svn commit</command> trên tập tin sẽ thất bại với lỗi <quote>quá-hạn</quote>. Tập tin cần phải được cập nhật trước; lệnh <command>svn update</command> sẽ cố gắng để hợp nhất những thay đổi công khai với những thay đổi cục bộ. Nếu Subversion không thể hoàn thành việc hợp nhất tự động một cách hợp lý, người dùng có thể tự giải quyết xung đột.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.wc-funcdamentals">
<!--         <title>Fundamental working copy interactions</title> -->
        <title>Tương tác cơ bản trên bảo sao làm việc</title>

<!--
        <para>A typical Subversion repository often holds the files (or
          source code) for several projects; usually, each project is a
          subdirectory in the repository's filesystem tree.  In this
          arrangement, a user's working copy will usually correspond to
          a particular subtree of the repository.</para>
-->
        <para>Một kho lưu trữ Subversion điển hình thường chứa những tập tin (hoặc mã nguồn) của nhiều dự án; thông thường, mỗi dự án là một thư mục con trong cây hệ thống tập tin. Theo cách sắp xếp này, bản sao làm việc của người dùng sẽ thông thường tương ứng với một cây con cụ thể của kho lưu trữ.</para>

<!--
        <para>For example, suppose you have a repository that contains
          two software projects, <literal>paint</literal> and
          <literal>calc</literal>.  Each project lives in its own
          top-level subdirectory, as shown in <xref
          linkend="svn.basic.in-action.wc.dia-1"/>.</para>
-->
        <para>Ví dụ, giả sử bạn có một kho lưu trữ mà chứa hai dự án phần mềm, <literal>paint</literal> và <literal>calc</literal>. Mỗi dự án được bố trí trong cấp cao nhất của thư mục con riêng của dự án như được trình bày trong hình <xref linkend="svn.basic.in-action.wc.dia-1"/>.</para>

<!--
        <figure id="svn.basic.in-action.wc.dia-1">
          <title>The repository's filesystem</title>
          <graphic fileref="images/ch02dia6.png"/>
        </figure>
-->
        <figure id="svn.basic.in-action.wc.dia-1">
          <title>Hệ thống tập tin của kho lưu trữ</title>
          <graphic fileref="images/ch02dia6.png"/>
        </figure>

<!--
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>checkout</tertiary>
          </indexterm>
          <indexterm>
            <primary>checking out</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>creating</secondary>
            <see>checking out</see>
          </indexterm>To get a working copy, you must <firstterm>check
          out</firstterm> some subtree of the repository.  (The term
          <emphasis>check out</emphasis> may sound like it has something to do
          with locking or reserving resources, but it doesn't; it simply
          creates a working copy of the project for you.)  For example,
          if you check out <filename>/calc</filename>, you will get a
          working copy like this:</para>
-->
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>lệnh con</secondary>
            <tertiary>kiểm xuất</tertiary>
          </indexterm>
          <indexterm>
            <primary>quá trình kiểm xuất</primary>
          </indexterm>
          <indexterm>
            <primary>bản sao làm việc</primary>
            <secondary>khởi tạo</secondary>
            <see>quá trình kiểm xuất</see>
          </indexterm>Để tạo một bản sao làm việc, bạn cần phải <firstterm>kiểm xuất</firstterm> một số cây con của kho lưu trữ. (Khái niệm <emphasis>kiểm xuất</emphasis> nghe có vẻ như nó có liên quan tới khóa hoặc đặt trước nguồn lực, tuy nhiên nó không phải như vậy; nó đơn giản chỉ tạo cho bạn một bản sao làm việc của dự án.) Ví dụ, nếu bạn kiểm xuất <filename>/calc</filename>, bạn sẽ có một bản sao làm việc như thế này:</para>

        <informalexample>
          <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.
$ ls -A calc
Makefile  button.c integer.c .svn/
$
</screen>
        </informalexample>

<!--
        <para>The list of letter <literal>A</literal>s in the left
          margin indicates that Subversion is adding a number of items
          to your working copy.  You now have a personal copy of the
          repository's <filename>/calc</filename> directory, with one
          additional entry&mdash;<filename>.svn</filename>&mdash;which
          holds the extra information needed by Subversion, as mentioned
          earlier.</para>
-->
        <para>Danh sách những ký tự <literal>A</literal> ở bên lề trái chỉ ra rằng Subversion đang thêm một số mục vào trong bản sao làm việc của bạn. Lúc này bạn có một bản sao riêng của thư mục <filename>/calc</filename> thuộc kho lưu trữ, với một mục bổ sung &mdash;<filename>.svn</filename>&mdash;mà chứa những thông tin bổ sung cần thiết cho Subversion như được đề cập trước đây.</para>

<!--
        <para>
          <indexterm>
            <primary>committing</primary>
          </indexterm>
          <indexterm>
            <primary>checking in</primary>
            <see>committing</see>
          </indexterm>Suppose you make changes
          to <filename>button.c</filename>.  Since
          the <filename>.svn</filename> directory remembers the file's
          original modification date and contents, Subversion can tell
          that you've changed the file.  However, Subversion does not
          make your changes public until you explicitly tell it to.
          The act of publishing your changes is more commonly known as
          <firstterm>committing</firstterm> (or <firstterm>checking
          in</firstterm>) changes to the repository.</para>
-->
        <para>
          <indexterm>
            <primary>quá trình chuyển giao</primary>
          </indexterm>
          <indexterm>
            <primary>kiểm nhập</primary>
            <see>quá trình chuyển giao</see>
          </indexterm>Giả sử bạn thay đổi trên tập tin <filename>button.c</filename>. Bởi vì thư mục <filename>.svn</filename> ghi nhớ nội dung và ngày tháng chỉnh sửa gốc của tập tin, Subversion có thể cho bạn biết rằng bạn vừa mới thay đổi tập tin. Tuy nhiên, Subversion không làm cho thay đổi của bạn công khai cho tới khi bạn yêu cầu nó làm việc đó một cách rõ ràng. Động tác phát hành thay đổi của bạn thường được biết đến nhiều hơn như là <firstterm>chuyển giao</firstterm> (hoặc <firstterm>kiểm nhập</firstterm>) những thay đổi vào kho lưu trữ.</para>

<!--
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>commit</tertiary>
          </indexterm>
          <indexterm>
            <primary>committing</primary>
          </indexterm>To publish your changes, you can use
          Subversion's <command>svn commit</command> command:</para>
-->
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>lệnh con</secondary>
            <tertiary>chuyển giao</tertiary>
          </indexterm>
          <indexterm>
            <primary>quá trình chuyển giao</primary>
          </indexterm>Để phát hành thay đổi của bạn, bạn có thể dùng lệnh <command>svn commit</command> của Subversion:</para>

        <informalexample>
          <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
$
</screen>
        </informalexample>

<!--
        <para>Now your changes to <filename>button.c</filename> have
          been committed to the repository, with a note describing your
          change (namely, that you fixed a typo).  If another user
          checks out a working copy of <filename>/calc</filename>, she
          will see your changes in the latest version of the
          file.</para>
-->
        <para>Lúc này những thay đổi của bạn trên tập tin <filename>button.c</filename> đã được chuyển giao vào kho lưu trữ, với một ghi chú mô tả thay đổi của bạn (chẳng hạn, bạn sửa một lỗi đánh máy). Nếu một người khác kiểm xuất một bản sao làm việc của <filename>/calc</filename>, cô ấy sẽ thấy nhưng thay đổi của bạn trong phiên bản mới nhất của tập tin.</para>

<!--
        <para>Suppose you have a collaborator, Sally, who checked out a
          working copy of <filename>/calc</filename> at the same time
          you did.  When you commit your change to
          <filename>button.c</filename>, Sally's working copy is left
          unchanged; Subversion modifies working copies only at the
          user's request.</para>
-->
        <para>Giả sử bạn có một người cộng tác, Sally, người mà kiểm xuất một bản sao làm việc của <filename>button.c</filename> ngay cùng thời điểm mà bạn cũng kiểm xuất. Khi bạn chuyển giao những thay đổi của bạn lên <filename>button.c</filename>, bản sao làm việc của Sally không thay đổi; Subversion chỉ sửa đổi bản sao làm việc ở thời điểm người dùng yêu cầu.</para>

<!--
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>update</tertiary>
          </indexterm>
          <indexterm>
            <primary>updating</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>updating</secondary>
            <see>updating</see>
          </indexterm>To bring her project up to date, Sally can ask
          Subversion to <firstterm>update</firstterm> her working
          copy, by using the <command>svn update</command> command.
          This will incorporate your changes into her working copy, as
          well as any others that have been committed since she
          checked it out.</para>
-->
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>lệnh con</secondary>
            <tertiary>cập nhật</tertiary>
          </indexterm>
          <indexterm>
            <primary>đang cập nhật</primary>
          </indexterm>
          <indexterm>
            <primary>bản sao làm việc</primary>
            <secondary>cập nhật</secondary>
            <see>cập nhật</see>
          </indexterm>Để làm cho dự án của cô ấy hiện hành, Sally có thể yêu cầu Subversion <firstterm>cập nhật</firstterm> bản sao làm việc của cô ấy với lệnh <firstterm>svn update</firstterm>. Lệnh này sẽ kết hợp những thay đổi của bạn vào bản sao làm việc của cô ấy, cũng như thay đổi của những người khác mà được chuyển giao trước khi cô ấy kiểm xuất.</para>

        <informalexample>
          <screen>
$ pwd
/home/sally/calc
$ ls -A
Makefile button.c integer.c .svn/
$ svn update
Updating '.':
U    button.c
Updated to revision 57.
$
</screen>
        </informalexample>

<!--
        <para>The output from the <command>svn update</command> command
          indicates that Subversion updated the contents of
          <filename>button.c</filename>.  Note that Sally didn't need to
          specify which files to update; Subversion uses the information
          in the <filename>.svn</filename> directory as well as further
          information in the repository, to decide which files need to
          be brought up to date.</para>
-->
        <para>Đầu ra của lệnh <command>svn update</command> chỉ ra rằng Subversion đã cập nhật nội dung của tập tin <filename>button.c</filename>. Lưu ý rằng Sally không cần thiết phải chỉ định rõ sẽ cập nhật tập tin nào; Subversion sử dụng thông tin trong thư mục <filename>.svn</filename> cũng như những thông tin khác trong kho lưu trữ để quyết định tập tin nào sẽ được cập nhật.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs">
<!--         <title>Mixed-revision working copies</title> -->
        <title>Bản sao làm việc phiên-bản-hỗn-hợp</title>

        <para>
          <indexterm>
            <primary>bản sao làm việc</primary>
            <secondary>phiên-bản-hỗn-hợp</secondary>
          </indexterm>Như một nguyên tắc cơ bản, Subversion cố gắng để càng linh hoạt càng tốt. Một tính linh hoạt đặc biệt đó là khả năng cho phép một bản sao làm việc chứa tập tin và thư mục với hỗn hợp của nhiều số phiên bản làm việc khác nhau. Bản sao làm việc Subversion không nhất thiết phải luôn luôn tương ứng với mỗi phiên bản riêng biệt trong kho lưu trữ; chúng có thể chứa tập tin từ nhiều phiên bản khác nhau. Ví dụ, giả sử bạn kiểm xuất một bản sao làm việc từ kho lưu trữ với phiên bản mới nhất là 4:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:4
</literallayout>
        </informalexample>

<!--
        <para>At the moment, this working directory corresponds exactly
          to revision 4 in the repository.  However, suppose you make a
          change to <filename>button.c</filename>, and commit that
          change.  Assuming no other commits have taken place, your
          commit will create revision 5 of the repository, and your
          working copy will now look like this:</para>
-->
        <para>Tại thời điểm này, thư mục làm việc này tương ứng chính xác với phiên bản 4 trong kho lưu trữ. Tuy nhiên, giả sử bạn thay đổi tập tin <filename>button.c</filename> và chuyển giao thay đổi này. Giả định rằng không có chuyển giao khác diễn ra, chuyển giao của bạn sẽ tạo phiên bản 5 của kho lưu trữ, và bản sao làm việc của bạn sẽ như sau:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:5
</literallayout>
        </informalexample>

<!--
        <para>Suppose that, at this point, Sally commits a change to
          <filename>integer.c</filename>, creating revision 6.  If you
          use <command>svn update</command> to bring your working copy
          up to date, it will look like this:</para>
-->
        <para>Giả sử rằng, vào lúc này, Sally chuyển giao một thay đổi trong tập tin <filename>integer.c</filename>, tạo ra phiên bản 6. Nếu bạn ra lệnh <command>svn update</command> để cập nhật bản sao làm việc của bạn, nó sẽ như thế này:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:6
   integer.c:6
   button.c:6
</literallayout>
        </informalexample>

<!--
        <para>Sally's change to <filename>integer.c</filename> will
          appear in your working copy, and your change will still be
          present in <filename>button.c</filename>.  In this example,
          the text of <filename>Makefile</filename> is identical in
          revisions 4, 5, and 6, but Subversion will mark your working
          copy of <filename>Makefile</filename> with revision 6 to
          indicate that it is still current.  So, after you do a clean
          update at the top of your working copy, it will generally
          correspond to exactly one revision in the repository.</para>
-->
        <para>Thay đổi của Sally trên tập tin <filename>integer.c</filename> sẽ xuất hiện trong bản sao làm việc của bạn, và thay đổi của bạn sẽ vẫn hiện diện trong <filename>button.c</filename>. Trong ví dụ này, văn bản của tập tin <filename>Makefile</filename> là tương đồng trong các phiên bản 4, 5 và 6 nhưng Subversion sẽ đánh dấu bản sao làm việc của <filename>Makefile</filename> với phiên bản 6 để chỉ ra rằng nó vẫn hiện hành. Như vậy, sau khi bạn thực hiện việc cập nhật toàn diện ở chóp của bản sao làm việc của bạn, nó sẽ thường tương ứng với chính xác một phiên bản trong kho.</para>
  
        <sect4 id="svn.basic.in-action.mixedrevs.update-commit">
<!--           <title>Updates and commits are separate</title> -->
          <title>Cập nhật và chuyển giao là tách biệt</title>

<!--
          <para>One of the fundamental rules of Subversion is that
            a <quote>push</quote> action does not cause
            a <quote>pull</quote> nor vice versa.  Just
            because you're ready to submit new changes to the repository
            doesn't mean you're ready to receive changes that others
            have checked in.  And if you have new changes still in progress,
            <command>svn update</command> should gracefully merge
            repository changes into your own, rather than forcing you to
            publish them.</para>
-->
          <para>Một trong những quy tắc cơ bản của Subversion đó là một thao tác <quote>đẩy</quote> không gây ra một thao tác <quote>kéo</quote> hoặc ngược lại. Chỉ vì bạn sẵn sàng gửi thay đổi mới tới kho lưu trữ không có nghĩa rằng bạn sẵn sàng để tiếp nhận những thay đổi mà những người khác đã chuyển giao. Và nếu bạn có thay đổi mới vẫn đang trong quá trình thay đổi, lệnh <command>svn update</command> sẽ hợp nhất một cách nhẹ nhàng những thay đổi trên kho lưu trữ vào trong bản sao làm việc của bạn thay vì ép bạn phải phát hành chúng.</para>

<!--
          <para>The main side effect of this rule is that it means a
            working copy has to do extra bookkeeping to track mixed
            revisions as well as be tolerant of the mixture.  It's made
            more complicated by the fact that directories themselves are
            versioned.</para>
-->
          <para>Tác dụng phụ chủ yếu của quy tắc này đó là bản sao làm việc phải thực hiện thêm việc ghi sổ sách để theo dõi phiên bản hỗn hợp. Vấn đề trở nên phức tạp hơn vì thực tế những thư mục này đã được đánh phiên bản.</para>
    <!-- ### TODO: consider to forget "as well as be tolerant of the mixture" -->

<!--
          <para>For example, suppose you have a working copy entirely
            at revision 10, while others have been committing their
            changes so that the youngest revision in the repository is
            now revision 14.  You edit the file
            <filename>foo.html</filename> and then perform
            an <command>svn commit</command>, which creates revision
            15 in the repository.  After the commit succeeds, many new
            users would expect the working copy to be entirely at
            revision 15, but that's not the case!  Any number of
            changes might have happened in the repository between
            revisions 10 and 15.  The client knows nothing of those
            changes in the repository, since you haven't yet
            run <command>svn update</command>, and <command>svn
            commit</command> doesn't pull down new changes.  If, on
            the other hand, <command>svn commit</command> were to
            automatically download the newest changes, it would be
            possible to set the entire working copy to revision
            15&mdash;but then we'd be breaking the fundamental rule
            of <quote>push</quote> and <quote>pull</quote> remaining
            separate actions.  Therefore, the only safe thing the
            Subversion client can do is mark the one
            file&mdash;<filename>foo.html</filename>&mdash;as being at
            revision 15.  The rest of the working copy remains at
            revision 10.  Only by running <command>svn
            update</command> can the latest changes be downloaded and
            the whole working copy be marked as revision 15.</para>
-->
          <para>Ví dụ, giả sử rằng bạn có một bản sao làm việc mà toàn bộ ở phiên bản 10, trong khi đó những người khác đã chuyển giao những thay đổi của họ và do đó phiên bản mới nhất trong kho lưu trữ lúc này là 14. Bạn hiệu chỉnh tập tin <filename>foo.html</filename> và thực hiện lệnh <command>svn commit</command> mà sẽ tạo phiên bản 15 trong kho lưu trữ. Sau khi chuyển giao thành công, nhiều người sử dụng mới sẽ mong muốn bản sao làm việc sẽ toàn bộ có phiên bản 15, nhưng nó không phải như vậy! Một số thay đổi bất kỳ có thể xuất hiện trong kho lưu trữ giữa phiên bản 10 và 15. Ứng dụng khách không biết gì về những thay đổi này trong kho vì bạn chưa thực thi lệnh <command>svn update</command>, còn lệnh <command>svn commit</command> không kéo về những thay đổi mới. Mặc khác, nếu lệnh <command>svn commit</command> là để tải về tự động những thay đổi mới nhất, nó sẽ có khả năng thiết lập toàn bộ bản sao làm việc sang phiên bản 15&mdash;nhưng như vậy chúng ta sẽ phá vỡ quy tắc cơ bản của việc <quote>đẩy</quote> và <quote>kéo</quote> tồn tại như hai thao tác độc lập. Như vậy, cách an toàn duy nhất mà ứng dụng khách Subversion có thể làm là đánh dấu tập tin&mdash;<filename>foo.html</filename>&mdash;như là đang ở phiên bản 15. Phần còn lại của bản sao làm việc được duy trì với phiên bản 10. Chỉ bằng cách thực thi lệnh <command>svn update</command> thì những thay đổi mới nhất có thể được tải về và toàn bộ bản sao làm việc được đánh dấu với phiên bản 15.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.normal">
<!--           <title>Mixed revisions are normal</title> -->
          <title>Phiên bản hỗn hợp là bình thường</title>

<!--
          <para>The fact is, <emphasis>every time</emphasis> you run
            <command>svn commit</command> your working copy ends up
            with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions than
            everything else.  After several commits (with no updates
            in between), your working copy will contain a whole mixture
            of revisions.  Even if you're the only person using the
            repository, you will still see this phenomenon.  To examine
            your mixture of working revisions, use the <command>svn
            status</command> command with the <option>-verbose</option>
            (<option>-v</option>) option (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information).</para>
-->
          <para>Thực tế, <emphasis>mỗi khi</emphasis> bạn thực thi lệnh <command>svn commit</command> thì bản sao làm việc của bạn sẽ bao gồm hỗn hợp các phiên bản. Những thay đổi bạn vừa mới chuyển giao được đánh dấu với phiên bản làm việc lớn hơn tất cả. Sau một vài chuyển giao (mà không cập nhật), bản sao làm việc của bạn sẽ chứa một hỗn hợp toàn bộ các phiên bản. Ngay cả khi chỉ có duy nhất bạn làm việc với kho lưu trữ, bạn vẫn sẽ gặp hiện tượng này. Để kiểm tra hỗn hợp các phiên bản này, dùng lệnh <command>svn status</command> với tùy chọn <option>--verbose</option> (<option>-v</option>) (xem chi tiết ở <xref linkend="svn.tour.cycle.examine.status"/>).</para>

<!--
          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to the
            working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, he expects
            to see the entire history of the object.  But if the
            object's working revision is quite old (often because
            <command>svn update</command> hasn't been run in a long
            time), the history of the <emphasis>older</emphasis>
            version of the object is shown.</para>
-->
          <para>Thông thường, người dùng mới hoàn toàn không biết rằng bản sao làm việc của họ chứa nhiều phiên bản trộn lẫn. Điều này có thể gây nhầm lẫn bởi vì nhiều lệnh của ứng dụng khách rất nhạy cảm với phiên bản làm việc của những mục mà những lệnh này đang kiểm tra. Ví dụ, lệnh <command>svn log</command> được sử dụng để hiển thị lịch sử thay đổi trên một tập tin hoặc thư mục (xem <xref linkend="svn.tour.history.log"/>). Khi người sử dụng phát lệnh này trên một đối tượng phiên bản làm việc, anh ấy mong đợi được nhìn thấy toàn bộ lịch sử của đối tượng. Nhưng phiên bản làm việc của đối tượng cũ quá (thông thường bởi vì lệnh <command>svn update</command> không được thực thi trong một thời gian dài), lúc này lịch sử của những phiên bản <emphasis>cũ hơn</emphasis> của đối tượng được hiển thị.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.useful">
<!--           <title>Mixed revisions are useful</title> -->
          <title>Phiên bản hỗn hợp là có ích</title>

          <para>
            <indexterm>
              <primary>lùi ngày</primary>
            </indexterm>Nếu dự án của bạn đủ phức tạp, bạn sẽ khám phá ra rằng đôi khi sẽ tốt hơn khi buộc lùi ngày (cập nhật sang một phiên bản cũ hơn phiên bản bạn đang có) một phần của bản sao làm việc của bạn sang một phiên bản cũ hơn; bạn sẽ học cách thực hiện trong <xref linkend="svn.tour"/>. Có thể bạn muốn một phiên bản trước đó của một module được chứa trong một thư mục con, hoặc có thể bạn muốn hình dung khi nào một lỗi lần đầu xuất hiện trong một tập tin cụ thể. Đây là một dạng <quote>cổ máy thời gian</quote> của một hệ thống kiểm soát phiên bản&mdash;một tính năng mà cho phép bạn di chuyển một phần bất kỳ của bản sao làm việc của bạn tới hoặc lùi trong lịch sử làm việc.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.limits">
<!--           <title>Mixed revisions have limitations</title> -->
          <title>Phiên bản hỗn hợp có mặt giới hạn</title>

<!--
          <para>However you make use of mixed revisions in your working
            copy, there are limitations to this flexibility.</para>
-->
          <para>Dù bạn làm việc với phiên bản hỗn hợp cách nào thì vẫn có giới hạn với tính linh hoạt này.</para>

<!--
          <para>First, you cannot commit the deletion of a file or
            directory that isn't fully up to date.  If a newer version
            of the item exists in the repository, your attempt to delete
            will be rejected to prevent you from accidentally
            destroying changes you've not yet seen.</para>
-->
          <para>Thứ nhất, bạn không thể chuyển giao việc xóa bỏ một tập tin hoặc thư mục mà không được cập nhật đầy đủ. Nếu một phiên bản mới hơn của đối tượng tồn tại trên kho lưu trữ, cố gắng xóa của bạn sẽ bị từ chối để ngăn bạn tình cờ hủy hoại những thay đổi mà bạn không nhìn thấy.</para>

<!--
          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up to date.  You'll learn about
            attaching <quote>properties</quote> to items in <xref
            linkend="svn.advanced"/>.  A directory's working revision
            defines a specific set of entries and properties, and thus
            committing a property change to an out-of-date directory may
            destroy properties you've not yet seen.</para>
-->
          <para>Thứ hai, bạn không thể chuyển giao một thay đổi của siêu dữ liệu trừ khi nó được cập nhật đầy đủ. Bạn sẽ học cách gắn <quote>thuộc tính</quote> vào đối tượng tại <xref linkend="svn.advanced"/>. Một phiên bản làm việc của thư mục định nghĩa một bộ cụ thể những mục và thuộc tính và vì vậy việc chuyển giao một thay đổi thuộc tính vào một thư mục quá-hạn có thể phá hủy những thuộc tính mà bạn không nhìn thấy.</para>

<!--
          <para>Finally, beginning in Subversion 1.7, you cannot by
            default use a mixed-revision working copy as the target of
            a merge operation.  (This new requirement was introduced
            to prevent common problems which stem from doing so.)</para>
-->
          <para>Cuối cùng, bắt đầu từ Subversion 1.7, bạn mặc định không thể dùng một bản sao làm việc hỗn hợp như là đích trong việc hợp nhất. (Yêu cầu mới này được giới thiệu để ngăn những vấn đề chung mà xuất phát từ cách làm như vậy.)</para>

        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
<!--     <title>Summary</title> -->
    <title>Tóm Tắt</title>
    
<!--
    <para>We covered a number of fundamental Subversion concepts in
      this chapter:</para>
-->
    <para>Chúng tôi đề cập đến một số những khái niệm cơ bản của Subversion trong chương này:</para>

    <itemizedlist>
<!--
      <listitem>
        <para>We introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>
-->
      <listitem>
        <para>Chúng tôi giới thiệu khái niệm về kho lưu trữ trung tâm, bản sao làm việc khách và chuỗi những cây phiên bản kho lưu trữ.</para>
      </listitem>

<!--
      <listitem>
        <para>We saw some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
      </listitem>
-->
      <listitem>
        <para>Chúng tôi trình bày một vài ví dụ đơn giản về việc làm cách nào hai cộng tác viên có thể sử dụng Subversion để phát hành và tiếp nhận những thay đổi từ người kia, sử dụng mô hình <quote>sao chép-sửa đổi-hợp nhất</quote>.</para>
      </listitem>

<!--
      <listitem>
        <para>We talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>
-->
      <listitem>
        <para>Chúng tôi đề cập một ít đến cách mà Subversion theo dõi và quản lý thông tin trong một bản sao làm việc.</para>
      </listitem>

    </itemizedlist>

<!--
    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to move into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>
-->
    <para>Ở thời điểm này, bạn đã có được một cái nhìn tổng thể về cách Subversion làm việc. Được trang bị kiến thức này, bạn giờ đây có thể sẵn sàng chuyển sang chương kế tiếp, đó là một chuyến hành trình chi tiết của những lệnh và tính năng của Subversion.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
