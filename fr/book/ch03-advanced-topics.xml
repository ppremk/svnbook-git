<!-- -*- sgml -*- -->

<chapter id="svn.advanced">
<!--
  <title>Advanced Topics</title>
-->
  <title>Sujets avancés</title>

<!--
  <para>If you've been reading this book chapter by chapter, from
    start to finish, you should by now have acquired enough
    knowledge to use the Subversion client to perform the most
    common version control operations.  You understand how to
    check out a working copy from a Subversion repository.  You are
    comfortable with submitting and receiving changes using the
    <command>svn commit</command> and <command>svn update</command>
    operations.  You've probably even developed a reflex that causes
    you to run the <command>svn status</command> command almost
    unconsciously.  For all intents and purposes, you are ready to
    use Subversion in a typical environment.</para>
-->
  <para>Si vous lisez ce livre chapitre par chapitre, du début à la fin,
    vous avez acquis maintenant suffisamment de connaissance du
    fonctionnement de Subversion pour effectuer les opérations les plus
    courantes de gestion de versions. Vous savez comment extraire une
    copie de travail du dépôt Subversion. Vous n'avez aucune difficulté
    à propager vos modifications et à recevoir des mises à jour en
    utilisant les commandes <command>svn commit</command> et
    <command>svn update</command>. Vous avez probablement acquis le
    réflexe, presque inconscient, de lancer la commande
    <command>svn status</command>. Bref, vous êtes apte à utiliser
    Subversion dans un environnement normal pour tout type de
    projet.</para>

<!--
  <para>But the Subversion feature set doesn't stop at <quote>common
    version control operations.</quote>  It has other bits of
    functionality besides just communicating file and
    directory changes to and from a central repository.</para>
-->
  <para>Mais les fonctionnalités de Subversion ne s'arrêtent pas aux
    <quote>opérations courantes de gestion de versions</quote>. Il
    possède d'autres atouts, en plus de permettre simplement le partage
    de fichiers et de dossiers depuis un dépôt central.</para>

<!--
  <para>This chapter highlights some of Subversion's features that,
    while important, may not be part of the typical user's daily routine.
    It assumes that you are familiar with Subversion's basic file and
    directory versioning capabilities.  If you aren't, you'll want to
    first read <xref linkend="svn.basic" /> and <xref
    linkend="svn.tour" />.  Once you've mastered those basics and
    consumed this chapter, you'll be a Subversion power user!</para>
-->
  <para>Ce chapitre dévoile certaines fonctionnalités de Subversion qui,
    bien qu'importantes, ne sont pas d'une utilisation quotidienne pour
    un utilisateur normal. Nous supposons que vous êtes familier avec
    les possibilités de base de gestion de versions sur les fichiers et
    dossiers. Sinon, reportez-vous au <xref linkend="svn.basic" />
    et au <xref linkend="svn.tour" />. Une fois que vous maîtriserez ces
    bases et que vous aurez assimilé ce chapitre, vous serez un
    super-utilisateur de Subversion&nbsp;!</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.revs.specifiers">
<!--
    <title>Revision Specifiers</title>
-->
    <title>Identifiants de révisions</title>

<!--
    <para>As we described in <xref linkend="svn.basic.in-action.revs"
      />, revision numbers in Subversion are pretty
      straightforward&mdash;integers that keep getting larger as you
      commit more changes to your versioned data.  Still, it doesn't
      take long before you can no longer remember exactly what
      happened in each and every revision.  Fortunately, the typical
      Subversion workflow doesn't often demand that you supply
      arbitrary revisions to the Subversion operations you perform.
      For operations that <emphasis>do</emphasis> require a revision
      specifier, you generally supply a revision number that you saw
      in a commit email, in the output of some other Subversion
      operation, or in some other context that would give meaning to
      that particular number.</para>
-->
    <para>Comme vous avez pu le constater dans
      <xref linkend="svn.basic.in-action.revs"/>, les numéros de
      révision dans Subversion sont d'une grande simplicité, formant une
      suite d'entiers incrémentés au fur et à mesure des changements
      propagés dans le dépôt. Néanmoins, il ne faudra pas longtemps
      avant que vous ne puissiez plus vous rappeler exactement quel
      changement correspond à quelle révision. Heureusement, le
      fonctionnement normal de Subversion ne requiert pas souvent que
      vous fournissiez explicitement un numéro de révision pour une
      opération. Pour les opérations qui nécessitent
      <emphasis>vraiment</emphasis> un numéro de révision, c'est
      généralement un numéro de révision que vous avez vu soit dans un
      mail de propagation, soit dans la sortie d'une autre opération
      Subversion, soit dans un autre contexte où ce numéro possédait
      une signification particulière.</para>

    <note>
<!--
      <para>Referring to revision numbers with
        an <quote><literal>r</literal></quote> prefix
        (<literal>r314</literal>, for example) is an established
        practice in Subversion communities, and is both supported and
        encouraged by many Subversion-related tools.  In most places
        where you would specify a bare revision number on the command
        line, you may also use
        the <literal>r</literal><replaceable>NNN</replaceable>
        syntax.</para>
-->
      <para>Faire référence aux numéros de révision avec le préfixe
        <quote><literal>r</literal></quote> (par exemple
        <literal>r314</literal>) est d'un usage courant dans la
        communauté Subversion et est accepté voire encouragé par de
        nombreux outils en relation avec Subversion. Dans la plupart des
        cas où vous spécifiez un numéro de révision dans la ligne de
        commande, vous pouvez tout aussi bien utliser la syntaxe
        <literal>r</literal><replaceable>NNN</replaceable>.</para>
    </note>

<!--
    <para>
      <indexterm>
        <primary>revisions</primary>
        <secondary>keywords</secondary>
      </indexterm>But occasionally, you need to pinpoint a moment in
      time for which you don't already have a revision number
      memorized or handy.  So besides the integer revision numbers,
      <command>svn</command> allows as input some additional forms of
      revision specifiers: <firstterm>revision keywords</firstterm>
      and revision dates.</para>
-->
    <para>
      <indexterm>
        <primary>révisions</primary>
        <secondary>mots-clés</secondary>
      </indexterm>À l'occasion, vous aurez besoin d'indiquer un moment
      précis dans le temps pour lequel vous n'avez pas encore le numéro
      de révision sous la main ou en mémoire. C'est pourquoi, en sus des
      numéros de révision, la commande <command>svn</command> autorise
      d'autres formes d'appellations pour les révisions&nbsp;: les
      <firstterm>mots-clés de révision</firstterm> et les dates de
      révision.</para>

<!--
    <note>
      <para>The various forms of Subversion revision specifiers can be
        mixed and matched when used to specify revision ranges.  For
        example, you can use <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        where <replaceable>REV1</replaceable> is a revision keyword
        and <replaceable>REV2</replaceable> is a revision number, or
        where <replaceable>REV1</replaceable> is a date and
        <replaceable>REV2</replaceable> is a revision keyword, and so
        on.  The individual revision specifiers are independently
        evaluated, so you can put whatever you want on the opposite
        sides of that colon.</para>
    </note>
-->
    <note>
      <para>Les différentes formes d'appellations pour les révisions
        peuvent être mélangées et comparées pour définir des intervalles
        de révisions. Par exemple, vous pouvez spécifier <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        où <replaceable>REV1</replaceable> est un mot-clé de révision et
        <replaceable>REV2</replaceable> est un numéro de révision, ou
        bien où <replaceable>REV1</replaceable> est une date et
        <replaceable>REV2</replaceable> est un numéro de révision. Comme
        chaque appellation de révision est évaluée indépendamment, vous
        pouvez placer n'importe quel type d'appellation de chaque côté
        du symbole deux-points.</para>
    </note>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.keywords">
<!--
      <title>Revision Keywords</title>
-->
      <title>Mots-clés de révision</title>

      <indexterm>
<!--
        <primary>revisions</primary>
        <secondary>keywords</secondary>
-->
        <primary>révisions</primary>
        <secondary>mots-clés</secondary>
      </indexterm>

<!--
      <para>The Subversion client understands a number of revision
        keywords.  These keywords can be used instead of integer
        arguments to the <option>- -revision</option>
        (<option>-r</option>) option, and are resolved into specific
        revision numbers by Subversion:</para>
-->
      <para>Le client Subversion accepte une grande variété de mots-clés
        de révision. En tant qu'argument de l'option
        <option>--revision</option> (<option>-r</option>) ces mots-clés
        peuvent être utilisés en lieu et place des numéros et sont
        remplacés par les numéros correspondants par
        Subversion&nbsp;:</para>

      <variablelist>

        <varlistentry>
          <term><literal>HEAD</literal></term>
          <listitem>
            <indexterm>
              <primary>HEAD</primary>
            </indexterm>
            <indexterm>
<!--
              <primary>revisions</primary>
              <secondary>keywords</secondary>
-->
              <primary>révisions</primary>
              <secondary>mots-clés</secondary>
              <tertiary>HEAD</tertiary>
            </indexterm>
<!--
            <para>The latest (or <quote>youngest</quote>) revision in
              the repository.</para>
-->
            <para>La dernière (c'est-à-dire la plus récente) révision
              présente dans le dépôt.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>BASE</literal></term>
          <listitem>
            <indexterm>
              <primary>BASE</primary>
            </indexterm>
            <indexterm>
<!--
              <primary>revisions</primary>
              <secondary>keywords</secondary>
-->
              <primary>révisions</primary>
              <secondary>mots-clés</secondary>
              <tertiary>BASE</tertiary>
            </indexterm>
<!--
            <para>The revision number of an item in a working copy.
              If the item has been locally modified, this refers to
              the way the item appears without those local
              modifications.</para>
-->
            <para>Le numéro de révision d'un élément de la copie de
              travail. Si l'élément a été modifié localement, la
              <quote>version BASE</quote> fait référence à l'élément tel
              qu'il était sans ces modifications locales.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>COMMITTED</literal></term>
          <listitem>
            <indexterm>
              <primary>COMMITTED</primary>
            </indexterm>
            <indexterm>
<!--
              <primary>revisions</primary>
              <secondary>keywords</secondary>
-->
              <primary>révisions</primary>
              <secondary>mots-clés</secondary>
              <tertiary>COMMITTED</tertiary>
            </indexterm>
<!--
            <para>The most recent revision prior to, or equal to,
              <literal>BASE</literal>, in which an item changed.</para>
-->
            <para>La révision la plus récente avant (ou égale à)
              <literal>BASE</literal>, dans laquelle un élément a
              changé.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>PREV</literal></term>
          <listitem>
            <indexterm>
              <primary>PREV</primary>
            </indexterm>
            <indexterm>
<!--
              <primary>revisions</primary>
              <secondary>keywords</secondary>
-->
              <primary>révisions</primary>
              <secondary>mots-clés</secondary>
              <tertiary>PREV</tertiary>
            </indexterm>
<!--
            <para>The revision immediately <emphasis>before</emphasis>
              the last revision in which an item changed.
              Technically, this boils down to
              <literal>COMMITTED</literal>-1.</para>
-->
            <para>La révision <emphasis>précédant</emphasis>
              immédiatement la dernière révision dans laquelle un
              élément a changé. Techniquement, cela revient à
              <literal>COMMITTED</literal>&minus;1.</para>
          </listitem>
        </varlistentry>

      </variablelist>

<!--
      <para>As can be derived from their descriptions, the
        <literal>PREV</literal>, <literal>BASE</literal>, and
        <literal>COMMITTED</literal> revision keywords are used only
        when referring to a working copy path&mdash;they don't apply
        to repository URLs.  <literal>HEAD</literal>, on the other
        hand, can be used in conjunction with both of these path
        types.</para>
-->
      <para>Comme vous pouvez le deviner d'après leur description, les
        mots-clés de révision <literal>PREV</literal>,
        <literal>BASE</literal> et <literal>COMMITTED</literal> ne sont
        utilisés que pour faire référence à un chemin dans la copie de
        travail&nbsp;; ils ne s'appliquent pas à des URL du dépôt. En
        revanche, <literal>HEAD</literal> peut être utilisé avec les
        deux types de chemin (local ou URL du dépôt).</para>

<!--
      <para>Here are some examples of revision keywords in
        action:</para>
-->
      <para>Vous trouvez ci-dessous des exemples de l'utilisation de
        ces mots-clés&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working copy (with all of its local changes) to the
# latest version of that tree in the repository

$ svn diff -r BASE:HEAD foo.c
# compares the unmodified version of foo.c with the latest version of
# foo.c in the repository

$ svn log -r BASE:HEAD
# shows all commit logs for the current versioned directory since you
# last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c, decreasing foo.c's working revision

$ svn diff -r BASE:14 foo.c
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14-->
$ svn diff -r PREV:COMMITTED machin.c
# affiche le dernier changement propagé concernant machin.c

$ svn log -r HEAD
# affiche le commentaire associé à la dernière propagation dans le dépôt.

$ svn diff -r HEAD
# compare votre copie de travail (avec tous ses changements locaux)
# à la dernière version de l'arborescence correspondante du dépôt.

$ svn diff -r BASE:HEAD machin.c
# compare la version non modifiée localement de machin.c avec la dernière
# version de machin.c dans le dépôt.

$ svn log -r BASE:HEAD
# affiche, pour le dossier suivi en versions courant, les commentaires
# de propagation depuis la dernière mise à jour (svn update).

$ svn update -r PREV machin.c
# revient une version en arrière pour le fichier machin.c. Ceci diminue
# de un la révision de la version de travail du fichier machin.c.

$ svn diff -r BASE:14 machin.c
# compare la version non modifiée localement de machin.c avec
# la version de ce fichier à la révision 14.


</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.dates">
<!--
      <title>Revision Dates</title>
-->
      <title>Dates de révision</title>

      <indexterm>
<!--
        <primary>revisions</primary>
        <secondary>as dates</secondary>
-->
        <primary>révisions</primary>
        <secondary>dates de révisions</secondary>
      </indexterm>

<!--
      <para>Revision numbers reveal nothing about the world outside
        the version control system, but sometimes you need to
        correlate a moment in real time with a moment in version
        history.  To facilitate this, the <option>- -revision</option>
        (<option>-r</option>) option can also accept as input date
        specifiers wrapped in curly braces (<literal>{</literal> and
        <literal>}</literal>).  Subversion accepts the standard
        ISO-8601 date and time formats, plus a few others.  Here are
        some examples.</para>
-->
      <para>Les numéros de révision n'ont aucune signification en dehors
        du système de gestion de versions. Cependant, parfois, vous avez
        besoin d'associer une date réelle à un moment précis de
        l'historique des versions. À cette fin, l'option
        <option>--revision</option> (<option>-r</option>) accepte comme
        argument une date placée entre accolades (<literal>{</literal>
        et <literal>}</literal>). Subversion accepte les dates et les
        heures aux formats définis dans le standard ISO-8601 ainsi que
        quelques autres formats. Voici quelques exemples&nbsp;:</para>

      <informalexample>
        <screen>
$ svn update -r {2006-02-17}
$ svn update -r {15:30}
$ svn update -r {15:30:00.200000}
$ svn update -r {"2006-02-17 15:30"}
$ svn update -r {"2006-02-17 15:30 +0230"}
$ svn update -r {2006-02-17T15:30}
$ svn update -r {2006-02-17T15:30Z}
$ svn update -r {2006-02-17T15:30-04:00}
$ svn update -r {20060217T1530}
$ svn update -r {20060217T1530Z}
$ svn update -r {20060217T1530-0500}
&hellip;
</screen>
      </informalexample>

      <note>
<!--
        <para>Keep in mind that most shells will require you to, at a
          minimum, quote or otherwise escape any spaces that are
          included as part of revision date specifiers.  Certain
          shells may also take issue with the unescaped use of curly
          braces, too.  Consult your shell's documentation for the
          requirements specific to your environment.</para>
-->
        <para>Gardez à l'esprit que la plupart des interpréteurs de
          commandes (shells) requièrent de mettre les dates qui
          contiennent des espaces entre guillemets ou
          <quote>d'échapper</quote> les espaces. Certains interpréteurs
          peuvent aussi poser problème avec les accolades si elles ne
          sont pas échappées. Consulter la documentation de votre
          interpréteur pour connaître les spécificités de votre
          environnement.</para>
      </note>

<!--
      <para>When you specify a date, Subversion resolves that date to
        the most recent revision of the repository as of that date,
        and then continues to operate against that resolved revision
        number:</para>
-->
      <para>Quand vous spécifiez une date, Subversion convertit cette
        date vers le numéro de révision le plus récent du dépôt à la
        date spécifiée. Puis, il continue son travail avec ce numéro de
        révision&nbsp;:</para>

      <informalexample>
        <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------ <!--
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
-->
r12 | ira | 2006-11-27 12:31:51 -0600 (lun. 27 nov. 2006) | 6 lignes
&hellip;
</screen>
      </informalexample>

      <sidebar>
<!--
        <title>Is Subversion a Day Early?</title>
-->
        <title>Subversion retarde-t-il d'une journée&nbsp;?</title>

<!--
        <para>If you specify a single date as a revision without
          specifying a time of day (for example
          <literal>2006-11-27</literal>), you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <emphasis>most recent revision of the
          repository</emphasis> as of the date you give.  If you give
          a date without a timestamp, such as
          <literal>2006-11-27</literal>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the 27th.</para>
-->
        <para>Si vous spécifiez une date de révision sans préciser
          l'heure (par exemple <literal>2006-11-27</literal>), vous
          pourriez penser que Subversion vous donne la dernière
          révision qui a eu lieu le 27 novembre. En fait, vous aurez une
          révision datant du 26, voire même avant. Souvenez-vous que
          Subversion renvoie <emphasis>la révision la plus récente du
          dépôt</emphasis> à la date spécifiée. Si vous spécifiez une
          date sans préciser l'heure, comme <literal>2006-11-27</literal>,
          Subversion utilise alors 00h00 comme heure et la recherche de
          la plus récente révision ne renvoit donc pas de résultat
          correspondant au 27 novembre.</para>

<!--
        <para>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<literal>{"2006-11-27
          23:59"}</literal>), or just specify the next day
          (<literal>{2006-11-28}</literal>).</para>
-->
        <para>Si vous voulez inclure le 27 dans votre recherche, vous
          pouvez soit spécifier une heure (<literal>{"2006-11-27
          23:59"}</literal>), soit simplement spécifier le jour suivant
          (<literal>{2006-11-28}</literal>).</para>
      </sidebar>

<!--
      <para>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</para>
-->
      <para>Vous pouvez également utiliser des intervalles de dates.
        Subversion trouve alors les révisions incluses entre ces deux
        dates&nbsp;:</para>

      <informalexample>
        <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
&hellip;
</screen>
      </informalexample>

      <warning>
<!--
        <para>Subversion's ability to correctly convert revision dates
          into real revision numbers depends on revision datestamps
          maintaining a sequential ordering&mdash;the younger the
          revision, the younger its datestamp.  But datestamps are
          stored in the unversioned, modifiable
          <literal>svn:date</literal> property of the revision (see
          <xref linkend="svn.advanced.props" />), so it is possible
          for revision datestamps to get out of sequence.  Now, most
          of Subversion's operations are unaffected by this
          situation&mdash;after all, the revision number itself is the
          primary identifier of each revision.  But if the datestamp
          ordering isn't maintained, you will likely find that trying
          to use dates to specify revision ranges in your repository
          doesn't always return the data you might have expected.
          Combining the histories of multiple repositories into a
          single one (as described in
          <xref linkend="svn.reposadmin.maint.migrate" />) is the most
          common cause of this scenario.</para>
-->

        <para>L'aptitude de Subversion à convertir correctement les
          horodatages de révisions en numéros de révision repose sur le
          fait que les horodatages de révisions sont ordonnées de manière
          croissante (plus le numéro est élevé, plus l'horodatage est
          récent). Mais l'horodatage d'une révision étant stocké comme une
          propriété modifiable et non suivie en versions de la révision
          (reportez-vous à <xref linkend="svn.advanced.props" />), les
          horodatages peuvent être modifiés et ne plus suivre la
          chronologie réelle. Aujourd'hui, cela n'affecte pas la plupart
          des opérations de Subversion (c'est le numéro de révision qui
          est l'identifiant primaire d'une révision). Mais si
          l'ordonnacement des horodatages n'est pas maintenu, il y a de
          grandes chances que l'utilisation des dates pour spécifier des
          intervalles de révisions dans votre dépôt ne fournisse pas les
          résultats attendus. Combiner les historiques de plusieurs
          dépôts pour n'en former qu'un (tel que décrit dans <xref
          linkend="svn.reposadmin.maint.migrate" />) est la cause
          principale de ce type de situation.</para>
      </warning>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
<!--
    <title>Peg and Operative Revisions</title>
-->
    <title>Révisions pivots et révisions opérationnelles</title>

<!--
    <para>We copy, move, rename, and completely replace files and
      directories on our computers all the time.  And your version
      control system shouldn't get in the way of your doing these
      things with your version-controlled files and directories,
      either.  Subversion's file management support is quite
      liberating, affording almost as much flexibility for versioned
      files as you'd expect when manipulating your unversioned ones.
      But that flexibility means that across the lifetime of your
      repository, a given versioned object might have many paths, and
      a given path might represent several entirely different
      versioned objects.  This introduces a certain level of
      complexity to your interactions with those paths and
      objects.</para>
-->
    <para>Continuellement, nous copions, déplaçons, renommons et
      remplaçons des fichiers et des dossiers sur nos ordinateurs.
      Et votre système de gestion de versions ne doit pas être un
      obstacle à ces opérations sur les fichiers et dossiers suivis
      en versions. La gestion des fichiers par Subversion se fait
      pratiquement oublier, étant presque aussi flexible pour les
      fichiers suivis en versions que pour les autres. Mais cette
      flexibilité signifie qu'au cours de la vie de votre dépôt un objet
      suivi en versions a un certain nombre de chemins et qu'un
      chemin donné peut représenter plusieurs objets suivis en
      versions tout à fait différents. Cela ajoute un niveau de
      complexité supplémentaire dans les actions sur les chemins et les
      objets.</para>

<!--
    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address.</quote>
      For example, if you ask for the revision history log of a
      particular file that was renamed last week, Subversion happily
      provides all those logs&mdash;the revision in which the rename
      itself happened, plus the logs of relevant revisions both before
      and after that rename.  So, most of the time, you don't even
      have to think about such things.  But occasionally, Subversion
      needs your help to clear up ambiguities.</para>
-->
    <para>Subversion est plutôt adroit pour détecter les
      <quote>changements d'adresses</quote> dans l'historique du suivi
      de versions d'un objet. Par exemple, si vous demandez l'historique
      d'un fichier qui a été renommé la semaine dernière, Subversion
      fournit ce journal&nbsp;:la révision dans laquelle s'est produit
      le changement de nom et les journaux pertinents avant et après ce
      renommage. Ainsi, la plupart du temps, vous n'avez pas à vous
      préoccuper de ces opérations. Mais il arrive que Subversion ait
      besoin de votre aide pour lever des ambiguïtés.</para>

<!--
    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      The thing you deleted and the thing you later added aren't the
      same thing.  They merely happen to have had the same
      path&mdash;<filename>/trunk/object</filename>, for example.
      What, then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to <emphasis>all</emphasis> the objects that have
      ever lived at that path?  Subversion needs a hint about what you
      really want.</para>
-->
    <para>L'exemple correspondant le plus simple est quand un fichier ou
      un dossier est supprimé du suivi de versions, puis qu'un
      nouveau dossier ou fichier est créé avec le même nom et ajouté
      au suivi de versions. L'objet qui a été effacé et celui qui a été
      ajouté plus tard ne sont pas les mêmes. Ils se trouve qu'ils ont
      juste le même chemin (<filename>/trunk/objet</filename> par
      exemple). Que signifie alors de demander à Subversion l'historique
      de <filename>/trunk/objet</filename>&nbsp;? La question
      concerne-t-elle l'objet actuellement à cet emplacement ou l'objet
      précédent qui a été supprimé&nbsp;? Ou encore les opérations sur
      <emphasis>tous</emphasis> les objets qui ont résidé à cet
      emplacement&nbsp;? Subversion a besoin de savoir ce que vous
      demandez réellement.</para>

<!--
    <para>And thanks to moves, versioned object history can get far
      more twisted than even that.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.<footnote><para><quote>You're not
      supposed to name it.  Once you name it, you start getting
      attached to it.</quote>&mdash;Mike Wazowski</para></footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
-->
    <para>Et, en raison des déplacements, l'historique des objets suivis
      en versions peut être beaucoup plus tordu que cela. Par exemple,
      vous pouvez avoir un dossier appelé
      <filename>concept</filename>, contenant une ébauche de projet
      logiciel sur lequel vous vous êtes essayé. Il se peut que ce
      projet mûrisse et que l'idée soit pertinente au point que, chose
      inimaginable, vous décidiez de donner un nom au projet
      <footnote>
        <para><quote>Sulli, il ne faut pas l'appeler&nbsp;! Tu commences
        par l'appeler et tu finis par t'attacher</quote>, Bob Razowski
        (le cyclope de Monstres et Cie).</para>
      </footnote>.
      Imaginons que vous nommiez ce logiciel
      <filename>Frabnaggilywort</filename>. Il semble alors logique de
      renommer le dossier <filename>concept</filename> en
      <filename>frabnaggilywort</filename> pour refléter le nom du
      projet. L'eau coule sous les ponts et Frabnaggilywort sort en
      version 1.0, est téléchargé et utilisé quotidiennement par des
      tonnes de gens qui veulent se faciliter la vie.</para>

<!--
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>
-->
    <para>Quelle belle histoire&nbsp;! Mais elle ne s'arrête pas là.
      Comme vous avez une âme d'entrepreneur, vous avez déjà une autre
      idée derrière la tête&nbsp;: vous créez donc un nouveau dossier
      <filename>concept</filename> et la boucle est bouclée. En fait,
      ce cycle recommence plusieurs fois au fil du temps, à chaque fois
      à partir de ce vieux dossier <filename>concept</filename>
      qui, quelquefois, est renommé, quand l'idée plaît et, d'autres
      fois, est effacé quand l'idée ne convient pas. En plus, pour être
      réellement tordu, vous donnez parfois à
      <filename>concept</filename> un autre nom temporaire, puis
      renommez ce même dossier <filename>concept</filename> pour une
      raison quelconque.</para>

<!--
    <para>In scenarios like these, attempting to instruct
      Subversion to work with these reused paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      20 minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist&mdash;and our Subversion&mdash;need a
      little more detail to do the right thing.</para>
-->
    <para>Avec de tels scénarios, demander à Subversion d'apprendre à
      travailler avec ces renommages multiples est un peu comme dire à
      un automobiliste de la banlieue de prendre la direction de Paris
      et de prendre à gauche sur <quote>la rue du Château
      </quote>&nbsp;: il croisera la rue du Château à Asnières,
      La Garenne-Colombes, Nanterre, Neuilly, Rueil-Malmaison, &hellip;
      et, non, ce n'est pas la même rue à chaque fois. De la même
      manière, Subversion a besoin d'un peu plus de précisions pour
      travailler correctement.</para>

<!--
    <para>
      <indexterm>
        <primary>revisions</primary>
        <secondary>peg revisions</secondary>
      </indexterm>
      <indexterm>
        <primary>at syntax</primary>
      </indexterm>
      <indexterm>
        <primary>@</primary>
        <see>at syntax</see>
      </indexterm>Fortunately, Subversion allows you to tell it
      exactly which Main Street you meant.  The mechanism used is
      called a <firstterm>peg revision</firstterm>, and you provide
      these to Subversion for the sole purpose of identifying unique
      lines of history.  Because at most one versioned object may
      occupy a path at any given time&mdash;or, more precisely, in any
      one revision&mdash;the combination of a path and a peg revision
      is all that is needed to unambiguously identify a specific line
      of history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>
-->
    <para>
      <indexterm>
        <primary>révisions</primary>
        <secondary>révisions pivots</secondary>
      </indexterm>
      <indexterm>
        <primary>peg revisions</primary>
        <see>révisions pivots</see>
      </indexterm>
      <indexterm>
        <primary>syntaxe at</primary>
      </indexterm>
      <indexterm>
        <primary>@</primary>
        <see>syntaxe at</see>
      </indexterm>Heureusement, Subversion vous permet de lui indiquer
      de quelle rue du Château vous parlez exactement. Le mécanisme
      utilisé s'appelle les <firstterm>révisions pivots</firstterm>
      et vous les fournissez à Subversion uniquement pour identifier de
      manière unique une ligne de l'historique. Comme il y a au plus
      un objet suivi en versions à un endroit et à un moment donnés (ou
      plus précisément à une révision donnée), la combinaison d'un
      chemin et d'une révision pivot est tout ce dont vous avez
      besoin pour désigner une ligne spécifique de l'historique. Les
      révisions pivots sont indiquées au client texte interactif Subversion
      en utilisant la notation <firstterm>at</firstterm> (on l'appelle
      ainsi parce que la syntaxe de la commande utilise le signe
      <quote>arobase</quote>&nbsp;:<literal>@</literal>) suivi de la
      révision pivot demandée, en fin de chemin.</para>

<!--
    <para>
      <indexterm>
        <primary>revisions</primary>
        <secondary>operative revisions</secondary>
      </indexterm>
      <indexterm>
        <primary>revisions</primary>
        <secondary>operative revision range</secondary>
      </indexterm>But what of the <option>- -revision</option>
      (<option>-r</option>) of which we've spoken so much in this
      book?  That revision (or set of revisions) is called the
      <firstterm>operative revision</firstterm> (or
      <firstterm>operative revision range</firstterm>).  Once a
      particular line of history has been identified using a path and
      peg revision, Subversion performs the requested operation using
      the operative revision(s).  To map this to our Chicagoland
      streets analogy, if we are told to go to 606 N. Main Street in
      Wheaton,<footnote><para>606 N. Main Street, Wheaton, Illinois,
      is the home of the Wheaton <emphasis>History</emphasis> Center.
      It seemed appropriate&hellip;</para></footnote> we can think
      of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path that can be traveled (north or
      south on Main Street), and they keep us from traveling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>
-->
    <para>
      <indexterm>
        <primary>révisions</primary>
        <secondary>révisions opérationnelles</secondary>
      </indexterm>
      <indexterm>
        <primary>révisions</primary>
        <secondary>intervalle de révisions opérationnelles</secondary>
      </indexterm>Mais alors qu'en est-il de l'option
      <option>--revision</option> (<option>-r</option>) dont nous avons
      tant parlé dans ce livre&nbsp;? Cette révision (ou ensemble de
      révisions) est appelée la <firstterm>révision
      opérationnelle</firstterm> (ou <firstterm>intervalle de révisions
      opérationnelles</firstterm>). Une fois qu'une ligne particulière
      de l'historique a été identifiée en utilisant un chemin et une
      révision pivot, Subversion effectue la requête en utilisant la
      révision opérationnelle (ou l'intervallle de révisions
      opérationnelles). Pour reprendre notre analogie avec les rues
      françaises, si on vous dit d'aller au 15 de la rue du Château à
      Rueil-Malmaison <footnote>
        <para>Au 15 de la rue du Château à Rueil-Malmaison se trouve
          un musée d'<emphasis>histoire</emphasis> (consacré à Joséphine,
          épouse de Napoléon). Cela nous a semblé approprié&hellip;</para>
      </footnote>,
      vous pouvez penser que <quote>la rue du Château</quote>
      est le chemin dans le système de fichiers et
      <quote>Rueil-Malmaison</quote> la révision pivot. Ces deux
      informations identifient de manière unique une route donnée et
      vous évitent de parcourir une autre rue du Château à
      la recherche de votre destination finale. Maintenant, vous pouvez
      rechercher le <quote>15</quote> comme numéro de révision
      opérationnelle puisque nous savons <emphasis>exactement</emphasis>
      où aller.</para>

    <sidebar id="svn.advanced.pegrevs.algorithm">
<!--
      <title>The Peg Revision Algorithm</title>
-->
      <title>Algorithme des révisions pivots</title>

<!--
      <para>The Subversion command-line client performs the peg revision
        algorithm any time it needs to resolve possible ambiguities in
        the paths and revisions provided to it.  Here's an example of
        such an invocation:</para>
-->
      <para>Le client texte interactif Subversion utilise l'algorithme
        des révisions pivots chaque fois qu'il doit résoudre une
        ambiguïté dans les chemins et numéros de versions fournis en
        ligne de commande. Voici un exemple d'une telle ligne de
        commande&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>-->
$ svn <replaceable>commande</replaceable> -r <replaceable>RÉVISION-OPÉRATIONNELLE</replaceable> élément@<replaceable>RÉVISION-PIVOT</replaceable>

</screen>
      </informalexample>

<!--
      <para>If <replaceable>OPERATIVE-REV</replaceable> is older than
        <replaceable>PEG-REV</replaceable>, the algorithm is as
        follows:</para>
-->
      <para>Si <replaceable>RÉVISION-OPERATIONNELLE</replaceable> est
        plus vieille que <replaceable>RÉVISION-PIVOT</replaceable>,
        alors l'algorithme est le suivant&nbsp;:</para>

      <orderedlist>
        <listitem>
<!--
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>PEG-REV</replaceable>.  There
            can be only one such object.</para>
-->
          <para>Trouver <replaceable>élément</replaceable> dans la
            révision identifiée par
            <replaceable>RÉVISION-PIVOT</replaceable>. Il ne peut y
            avoir qu'un seul objet.</para>
        </listitem>
        <listitem>
<!--
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in the revision
            <replaceable>OPERATIVE-REV</replaceable>.</para>
-->
          <para>Parcourir l'historique de l'objet à l'envers (y compris
            en tenant compte d'éventuels renommages) jusqu'à son ancêtre
            dans la révision
            <replaceable>RÉVISION-OPERATIONNELLE</replaceable>.</para>
        </listitem>
        <listitem>
<!--
          <para>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be or might have been at that time.</para>
-->
          <para>Effectuer la requête sur cet ancêtre, où qu'il soit et
            quel que soit son nom (actuel et à ce moment là).</para>
        </listitem>
      </orderedlist>

<!--
      <para>But what if <replaceable>OPERATIVE-REV</replaceable> is
        <emphasis>younger</emphasis> than
        <replaceable>PEG-REV</replaceable>?  Well, that adds some
        complexity to the theoretical problem of locating the path in
        <replaceable>OPERATIVE-REV</replaceable>, because the path's
        history could have forked multiple times (thanks to copy
        operations) between <replaceable>PEG-REV</replaceable> and
        <replaceable>OPERATIVE-REV</replaceable>.  And that's not
        all&mdash;Subversion doesn't store enough information to
        performantly trace an object's history forward, anyway.  So
        the algorithm is a little different:</para>
-->
      <para>Mais que se passe-t-il si
        <replaceable>RÉVISION-OPERATIONNELLE</replaceable> est
        <emphasis>plus récente</emphasis> que
        <replaceable>RÉVISION-PIVOT</replaceable>&nbsp;? Et bien,
        cela ajoute un peu de complexité à la recherche du chemin dans
        <replaceable>RÉVISION-OPERATIONNELLE</replaceable>, parce que
        l'historique du chemin peut avoir bifurqué à plusieurs reprises
        (en raison d'opérations de copie) entre
        <replaceable>RÉVISION-PIVOT</replaceable> et
        <replaceable>RÉVISION-OPERATIONNELLE</replaceable>. Et ce n'est
        pas tout car, de toute façon, Subversion ne stocke pas
        suffisamment d'informations pour retracer de façon performante
        l'historique d'un élément dans le sens chronologique. Donc, dans
        ce cas, l'algorithme est un peu différent&nbsp;:</para>

      <orderedlist>
        <listitem>
<!--
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>OPERATIVE-REV</replaceable>.  There
            can be only one such object.</para>
-->
          <para>Trouver <replaceable>élément</replaceable> dans la
            révision identifiée par
            <replaceable>RÉVISION-OPERATIONNELLE</replaceable>.
            Il ne peut y avoir qu'un seul objet.</para>
        </listitem>
        <listitem>
<!--
          <para>Trace the object's history backward (through any
            possible renames) to its ancestor in the revision
            <replaceable>PEG-REV</replaceable>.</para>
-->
          <para>Parcourir l'historique de l'objet à l'envers (y compris
            en tenant compte d'éventuels renommages) jusqu'à son ancêtre
            dans la révision
            <replaceable>RÉVISION-PIVOT</replaceable>.</para>
        </listitem>
        <listitem>
<!--
          <para>Verify that the object's location (path-wise) in
            <replaceable>PEG-REV</replaceable> is the same as it is in
            <replaceable>OPERATIVE-REV</replaceable>.  If that's the
            case, at least the two locations are known to be
            directly related, so perform the requested action on the
            location in <replaceable>OPERATIVE-REV</replaceable>.
            Otherwise, relatedness was not established, so error out
            with a loud complaint that no viable location was found.
            (Someday, we expect that Subversion will be able to handle
            this usage scenario with more flexibility and
            grace.)</para>
-->
          <para>Vérifier que la position de l'objet (son chemin) dans
            <replaceable>RÉVISION-PIVOT</replaceable> est la même
            que dans <replaceable>RÉVISION-OPERATIONNELLE</replaceable>.
            Si c'est le cas, c'est-à-dire que l'on sait que les deux
            positions sont directement liées, effectuer la requête sur
            la position dans
            <replaceable>RÉVISION-OPERATIONNELLE</replaceable>.
            Sinon, c'est-à-dire si la relation entre les deux n'est pas
            établie, renvoyer une erreur expliquant qu'aucune position
            viable n'a été trouvée. On peut espérer qu'un jour
            Subversion sera plus flexible et saura mieux gérer ce type
            de cas.</para>
        </listitem>
      </orderedlist>

<!--
      <para>Note that even when you don't explicitly supply a peg
        revision or operative revision, they are still present.  For
        your convenience, the default peg revision is
        <literal>BASE</literal> for working copy items and
        <literal>HEAD</literal> for repository URLs.  And when no
        operative revision is provided, it defaults to being the same
        revision as the peg revision.</para>
-->
      <para>Notez que même quand vous ne spécifiez pas explicitement de
        révision pivot ni de révision opérationnelle, elles
        sont néanmoins présentes. Par défaut, la valeur de la révision
        pivot est <literal>BASE</literal> pour les éléments de la
        copie de travail et <literal>HEAD</literal> pour les URL du
        dépôt. Et quand aucune révision opérationnelle n'est fournie,
        la valeur par défaut est celle de la révision pivot.</para>

    </sidebar>

<!--
    <para>Say that long ago we created our repository, and in revision 1
      we added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and thousands of revisions flew by,
      just like they would in any good romance story.</para>
-->
    <para>Supposons que nous ayons créé notre dépôt il y a longtemps et
      que dans la révision 1 nous ayons ajouté notre premier
      dossier <filename>concept</filename> ainsi qu'un fichier
      <filename>IDÉE</filename>, situé dans ce dossier, contenant la
      description du concept. Nous avons ensuite ajouté et modifié de
      véritables lignes de code. À la révision 20, nous avons renommé ce
      dossier en <filename>frabnaggilywort</filename>. Lors de la
      révision 27, nous développons un nouveau concept et un nouveau
      dossier <filename>concept</filename> est créé pour l'héberger,
      avec un nouveau fichier <filename>IDÉE</filename> pour le décrire.
      Cinq ans et vingt mille révisions passent, comme dans tout bon
      roman d'amour.</para>

<!--
    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know whether we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      whether we are asking for the contents of whatever file lived at
      <filename>concept/IDEA</filename> in revision 1.  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask those questions.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>
-->
    <para>À présent, plusieurs années plus tard, nous nous demandons à
      quoi ressemblait le fichier <filename>IDÉE</filename> en révision
      1. Mais Subversion a besoin de savoir si nous demandons à quoi
      ressemble le fichier <emphasis>actuel</emphasis> tel qu'il était
      lors de la révision 1 ou si nous demandons le contenu du fichier
      positionné dans l'arborescence à <filename>concept/IDÉE</filename>
      au moment de la révision 1. Ces questions ont certainement des
      réponses différentes et grâce aux révisions pivots, nous
      pouvons poser ces deux questions. Pour obtenir le contenu du
      fichier <filename>IDÉE</filename> actuel tel qu'il était dans
      cette vieille révision, tapez&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn cat -r 1 concept/IDEA
svn: E195012: Unable to find repository location for 'concept/IDEA' in revision 1
-->
$ svn cat -r 1 concept/IDÉE
svn: E195012: Impossible de trouver la localisation dans le dépôt de 'concept/IDÉE' pour la révision 1
</screen>
    </informalexample>

<!--
    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The previous command is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>
-->
    <para>Bien sûr, dans cet exemple, le fichier
      <filename>IDÉE</filename> actuel n'existait pas lors de la
      révision 1, c'est pourquoi Subversion renvoie une erreur. La
      commande ci-dessus est un raccourci pour la notation plus longue
      qui explicite la révision pivot. La notation complète est
      donc&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn cat -r 1 concept/IDEA@BASE
svn: E195012: Unable to find repository location for 'concept/IDEA' in revision 1
-->
$ svn cat -r 1 concept/IDÉE@BASE
svn: E195012: Impossible de trouver la localisation dans le dépôt de 'concept/IDÉE' pour la révision 1
</screen>
    </informalexample>

<!--
    <para>And when executed, it has the expected results.</para>
-->
    <para>On obtient bien le résultat attendu.</para>

<!--
    <para>The perceptive reader is probably wondering at this point whether
      the peg revision syntax causes problems for working copy paths
      or URLs that actually have at signs in them.  After
      all, how does <command>svn</command> know whether
      <literal>news@11</literal> is the name of a directory in my
      tree or just a syntax for <quote>revision 11 of
      <filename>news</filename></quote>?  Thankfully, while
      <command>svn</command> will always assume the latter, there is a
      trivial workaround.  You need only append an at sign to the
      end of the path, such as <literal>news@11@</literal>.
      <command>svn</command> cares only about the last at sign in
      the argument, and it is not considered illegal to omit a literal
      peg revision specifier after that at sign.  This workaround
      even applies to paths that end in an at sign&mdash;you would
      use <literal>filename@@</literal> to talk about a file named
      <filename>filename@</filename>.</para>
-->
    <para>Le lecteur perspicace est certainement en train de se demander
      si la syntaxe des révisions pivots ne pose pas de problèmes
      pour les chemins ou les URL qui comportent déjà le signe arobase.
      Après tout, comment <command>svn</command> peut-il savoir si
      <literal>nouveau@11</literal> est le nom d'un dossier dans mon
      arborescence ou juste la syntaxe pour <quote>révision 11 de
      <filename>nouveau</filename></quote>&nbsp;? Dieu merci, alors que
      <command>svn</command> opte par défaut pour cette dernière
      hypothèse, il existe une solution de contournement triviale&nbsp;:
      il suffit juste d'ajouter un signe arobase à la fin du
      chemin, comme ceci&nbsp;: <literal>nouveau@11@</literal>.
      <command>svn</command> ne s'intéresse qu'au dernier arobase de
      l'argument et il n'est pas considéré comme illégal d'omettre le
      spécificateur de révision pivot après cet arobase. Cette
      solution de contournement s'applique même aux chemins qui se
      terminent par arobase (utilisez
      <literal>nom-du-fichier@@</literal> pour désigner le fichier
      <filename>nom-du-fichier@</filename>.</para>

<!--
    <para>Let's ask the other question, then&mdash;in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>
-->
    <para>Posons maintenant l'autre question&nbsp;: dans la révision 1,
      quel était le contenu du fichier qui occupait l'adresse
      <filename>concept/IDÉE</filename> à ce moment là&nbsp;? Nous
      allons utiliser explicitement une révision pivot pour nous
      aider&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.-->
$ svn cat concept/IDÉE@1
L'idée de ce projet est de fournir un logiciel qui peut frabber un
naggily wort. Frabber les naggilys worts est particulièrement difficile
et ne pas le faire correctement aurait des conséquences inimaginables.
Nous devons donc utiliser des mécanismes de vérification des
entrées et des données du dernier cri.
</screen>
    </informalexample>

<!--
    <para>Notice that we didn't provide an operative revision this
      time.  That's because when no operative revision is specified,
      Subversion assumes a default operative revision that's the same
      as the peg revision.</para>
-->
    <para>Remarquez que cette fois nous n'avons pas fourni de révision
      opérationnelle. C'est parce que, quand aucune révision
      opérationnelle n'est spécifiée, Subversion considère que le
      numéro de révision opérationnelle est égal au numéro de révision
      pivot.</para>

<!--
    <para>As you can see, the output from our operation appears to be
      correct.  The text even mentions frabbing naggily worts, so this
      is almost certainly the file that describes the software now
      called Frabnaggilywort.  In fact, we can verify this using the
      combination of an explicit peg revision and explicit operative
      revision.  We know that in <literal>HEAD</literal>, the
      Frabnaggilywort project is located in the
      <filename>frabnaggilywort</filename> directory.  So we specify
      that we want to see how the line of history identified in
      <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>
-->
    <para>Comme vous pouvez le constater, la résultat de la commande
      semble être correct. Le texte parle même de "frabber les naggilys
      worts", ce qui laisse supposer que c'est certainement le fichier
      décrivant le logiciel maintenant connu sous le nom de
      Frabnaggilywort. En fait, on peut le vérifier en combinant une
      révision pivot explicite et une révision opérationnelle explicite.
      Nous savons que dans <literal>HEAD</literal>, le projet
      Frabnaggilywort se situe dans le dossier
      <filename>frabnaggilywort</filename>. Nous spécifions donc que
      nous voulons voir à quoi ressemblait le fichier
      <filename>frabnaggilywort/IDÉE</filename> identifié dans
      <literal>HEAD</literal> au moment de la révision 1.</para>

    <informalexample>
      <screen><!--
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.-->
$ svn cat -r 1 frabnaggilywort/IDÉE@HEAD
L'idée de ce projet est de fournir un logiciel qui peut frabber un
naggily wort. Frabber les naggilys worts est particulièrement difficile
et ne pas le faire correctement aurait des conséquences inimaginables.
Nous devons donc utiliser des mécanismes de vérification des
entrées et des données du dernier cri.
</screen>
    </informalexample>

<!--
    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had been deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>
-->
    <para>Vous pouvez aussi spécifier des révisions pivots et des
      révisions opérationnelles moins triviales. Par exemple, disons
      que <filename>frabnaggilywort</filename> a été effacé de
      <literal>HEAD</literal>, mais nous savons qu'il existait en
      révision 20 et nous voulons voir les différences entre la
      révision 4 et la révision 10 pour son fichier
      <filename>IDÉE</filename>. Nous pouvons utiliser la révision pivot
      20 en conjonction avec l'URL qu'avait le fichier
      <filename>frabnaggilywort/IDÉE</filename> dans la révision 20
      et utiliser 4 et 10 pour spécifier l'intervalle de révisions
      opérationnelles.</para>

    <informalexample>
      <screen> <!--
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
- - frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.-->
$ svn diff -r 4:10 http://svn.red-bean.com/projets/frabnaggilywort/IDÉE@20
Index: frabnaggilywort/IDÉE
===================================================================
--- frabnaggilywort/IDÉE	(révision 4)
+++ frabnaggilywort/IDÉE	(révision 10)
@@ -1,5 +1,5 @@
-L'idée de ce projet est de fournir un logiciel qui peut frabber un
-naggily wort. Frabber les naggilys worts est particulièrement difficile
-et ne pas le faire correctement aurait des conséquences inimaginables.
-Nous devons donc utiliser des mécanismes de vérification des
-entrées et des données du dernier cri.
+L'idée de ce projet est de fournir un logiciel client-serveur qui peut
+frabber un naggily wort de manière distante. Frabber les naggilys worts
+est particulièrement difficile et ne pas le faire correctement aurait
+des conséquences inimaginables. Nous devons donc utiliser des mécanismes
+de vérification des entrées et des données du dernier cri.
</screen>
    </informalexample>

<!--
    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>
-->
    <para>Heureusement, la plupart d'entre vous n'auront pas à faire
      face à des situations aussi complexes. Mais si jamais c'est le
      cas, rappelez-vous que les révisions pivots sont les
      informations complémentaires dont a besoin Subversion pour lever
      toute ambiguïté.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
<!--
    <title>Properties</title>
-->
    <title>Propriétés</title>
    <indexterm>
<!--
      <primary>properties</primary>
-->
      <primary>propriétés</primary>
    </indexterm>

<!--
    <para>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.</para>
-->
    <para>Nous avons vu en détail comment Subversion stocke et récupère
      les différentes versions des fichiers et dossiers dans le
      dépôt. Des chapitres entiers ont décrit cette fonctionnalité
      fondamentale de l'outil. Et si la gestion de versions se limitait
      à ça, Subversion couvrirait déjà complètement les besoins
      attendus pour un système de gestion de versions.</para>

<!--
    <para>But it doesn't stop there.</para>
-->
    <para>Mais ce n'est pas tout.</para>

<!--
    <para>
      <indexterm>
        <primary>properties</primary>
      </indexterm>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <firstterm>properties</firstterm>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must contain only
      ASCII characters.  And the best part about these properties is
      that they, too, are versioned, just like the textual contents of
      your files.  You can modify, commit, and revert property changes
      as easily as you can file content changes.  And the sending and
      receiving of property changes occurs as part of your typical
      commit and update operations&mdash;you don't have to change your
      basic processes to accommodate them.</para>
-->
    <para>
      <indexterm>
        <primary>propriétés</primary>
      </indexterm>En plus de gérer les versions de vos dossiers et de
      vos fichiers, Subversion fournit une interface pour ajouter,
      modifier et supprimer des méta-données suivies en versions pour
      chacun de vos dossiers et de vos fichiers. On appelle ces
      méta-données des <firstterm>propriétés</firstterm>. Elles peuvent
      être pensées comme des tableaux à deux colonnes, qui associent des
      noms de propriétés à des valeurs arbitraires, pour chaque élément
      de votre copie de travail. En termes simples, vous pouvez assigner
      n'importe quel nom et n'importe quelle valeur à vos propriétés, à
      la seule condition que le nom ne contiennent que des caractères
      ASCII. Et l'atout principal de ces propriétés réside dans le fait
      que ces propriétés sont également suivies en versions, tout comme
      le contenu textuel de vos fichiers. Vous pouvez modifier, propager
      et revenir en arrière sur les propriétés aussi facilement que sur
      le contenu des fichiers. L'envoi et la réception des changements
      concernant les propriétés intervient lors de vos propagations et
      mises à jour&nbsp;: vous n'avez pas à changer vos habitudes pour
      les utiliser.</para>

<!--
    <note>
      <para>Subversion has reserved the set of properties whose names
        begin with <literal>svn:</literal> as its own.  While there
        are only a handful of such properties in use today, you should
        avoid creating custom properties for your own needs whose names
        begin with this prefix.  Otherwise, you run the risk that a
        future release of Subversion will grow support for a feature
        or behavior driven by a property of the same name but with
        perhaps an entirely different interpretation.</para>
    </note>
-->
    <note>
      <para>Subversion a réservé pour son propre usage les propriétés
        dont le nom commence par <literal>svn:</literal>. Bien qu'il n'y
        en ait seulement que quelques unes d'utilisées actuellement,
        vous ne devez pas créer vos propres propriétés avec un nom
        commençant par ce préfixe. Sinon, vous courez le risque qu'une
        future version de Subversion définisse une propriété ayant le
        même nom mais pour un usage tout autre.</para>
    </note>

<!--
    <para>Properties show up elsewhere in Subversion, too.  Just as
      files and directories may have arbitrary property names and
      values attached to them, each revision as a whole may have
      arbitrary properties attached to it.  The same constraints
      apply&mdash;human-readable names and anything-you-want binary
      values.  The main difference is that revision properties are not
      versioned.  In other words, if you change the value of, or
      delete, a revision property, there's no way, within the scope of
      Subversion's functionality, to recover the previous value.</para>
-->
    <para>Les propriétés sont aussi présentes ailleurs dans Subversion.
      De la même manière que pour les fichiers et dossiers, chaque
      révision en tant que telle peut avoir des propriétés arbitraires
      associées. Les mêmes contraintes s'appliquent&nbsp;: nom lisible
      par un humain et valeur arbitraire, éventuellement binaire. La
      différence principale est que les propriétés des révisions ne sont
      pas suivies en versions. Autrement dit, si vous changez la valeur
      ou si vous supprimez une propriété d'une révision, il n'y a pas
      moyen, en utilisant Subversion, de revenir à la valeur
      précédente.</para>

<!--
    <para>Subversion has no particular policy regarding the use of
      properties.  It asks only that you do not use property names that
      begin with the prefix <literal>svn:</literal> as that's the
      namespace that it sets aside for its own use.  And Subversion
      does, in fact, use properties&mdash;both the versioned and
      unversioned variety.  Certain versioned properties have special
      meaning or effects when found on files and directories, or they
      house a particular bit of information about the revisions on
      which they are found.  Certain revision properties are
      automatically attached to revisions by Subversion's commit
      process, and they carry information about the revision.  Most of
      these properties are mentioned elsewhere in this or other
      chapters as part of the more general topics to which they are
      related.  For an exhaustive list of Subversion's predefined
      properties, see <xref linkend="svn.advanced.props.ref" />.</para>
-->
    <para>Subversion ne fournit pas de recommandation particulière quant
      à l'utilisation des propriétés. Il demande seulement de ne pas
      utiliser de nom de propriété qui commence par le préfixe
      <literal>svn:</literal>. C'est l'espace de noms qu'il garde pour
      son propre usage. Et Subversion utilise bien lui-même les
      propriétés, suivies en versions ou pas. Certaines propriétés
      suivies en versions ont une signification particulière ou des
      effets particuliers quand elles font référence à un fichier ou à
      un dossier, ou stockent des informations relatives à la
      révision à laquelle elles sont rattachées. Certaines propriétés de
      révision sont automatiquement rattachées à une révision par la
      procédure de propagation et stockent des informations relatives à
      cette révision. La plupart de ces propriétés sont mentionnées
      ailleurs dans ce chapitre ou dans d'autres chapitres comme faisant
      partie de sujets plus généraux. Pour une liste exhaustive des
      propriétés pré-définies de Subversion, référez-vous à
      <xref linkend="svn.advanced.props.ref" />.</para>

<!--
    <note>
      <para>While Subversion automatically attaches properties
        (<literal>svn:date</literal>, <literal>svn:author</literal>,
        <literal>svn:log</literal>, and so on) to revisions, it does
        <emphasis>not</emphasis> presume thereafter the existence of
        those properties, and neither should you or the tools you use to
        interact with your repository.  Revision properties can be
        deleted programmatically or via the client (if allowed by the
        repository hooks) without damaging Subversion's ability to
        function.  So, when writing scripts which operate on your
        Subversion repository data, do not make the mistake of
        assuming that any particular revision property exists on a
        revision.</para>
    </note>
-->
    <note>
      <para>Bien que Subversion crée automatiquement des propriétés à
        chaque révision (<literal>svn:date</literal>, <literal>svn:author</literal>,
        <literal>svn:log</literal>, etc.), il <emphasis>ne</emphasis>
        présage <emphasis>pas</emphasis> de leur existence par la suite
        et vous (ou les outils que vous utilisez) ne devriez pas non
        plus présager de leur existence dans vos interactions avec le
        dépôt. Les propriétés de révisions peuvent être effacées par
        programmation ou <foreignphrase>via</foreignphrase> le client
        (si les procédures automatiques l'autorisent) sans remettre en
        cause le bon fonctionnement de Subversion. En conséquence, lors
        de l'écriture de scripts qui opèrent sur les données du dépôt,
        veillez à ne pas considérer l'existence d'une propriété de
        révision comme acquis.</para>
    </note>

<!--
    <para>In this section, we will examine the utility&mdash;both to
      users of Subversion and to Subversion itself&mdash;of property
      support.  You'll learn about the property-related
      <command>svn</command> subcommands and how property
      modifications affect your normal Subversion workflow.</para>
-->
    <para>Dans cette section, nous examinons l'utilité des propriétés,
      à la fois pour l'utilisateur et pour Subversion lui-même. Vous
      apprendrez les sous-commandes <command>svn</command> relatives
      aux propriétés et comment la modification des propriétés change
      votre manière habituelle d'utiliser Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
<!--
      <title>Why Properties?</title>
-->
      <title>Utilisation des propriétés</title>

<!--
      <para>Just as Subversion uses properties to store extra
        information about the files, directories, and revisions that
        it contains, you might also find properties to be of similar
        use.  You might find it useful to have a place
        close to your versioned data to hang custom metadata about
        that data.</para>
-->
      <para>À l'instar de Subversion, qui utilise les propriétés
        pour stocker des méta-données sur les fichiers, les dossiers
        et les révisions qu'il gère, vous pouvez faire une utilisation
        similaire des propriétés. Vous pouvez trouver utile d'avoir un
        endroit, près de vos données suivies en versions, pour stocker
        des méta-données relatives à vos données.</para>

<!--
      <para>Say you wish to design a web site that houses many digital
        photos and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.</para>
-->
      <para>Imaginons que vous vouliez créer un site Web qui héberge
        beaucoup de photos et qui les affiche avec une légende et une
        date. D'accord, mais votre collection de photos change
        constamment, donc vous voulez automatiser le plus possible la
        gestion du site. Ces photos peuvent être relativement
        volumineuses et vous voulez pouvoir fournir des miniatures à vos
        visiteurs, comme c'est généralement le cas sur ce genre de
        site.</para>

<!--
      <para>Now, you can get this functionality using traditional
        files.  That is, you can have your
        <filename>image123.jpg</filename> and an
        <filename>image123-thumbnail.jpg</filename> side by side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, such as
        <filename>thumbnails/image123.jpg</filename>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  But the problem here
        is that your collection of files multiplies with each new
        photo added to the site.</para>
-->
      <para>Certes, vous pouvez le faire en utilisant des fichiers
        traditionnels. C'est-à-dire que vous avez votre
        <filename>image123.jpg</filename> et une
        <filename>image123-thumbnail.jpg</filename> côte à côte dans un
        dossier. Ou, si vous voulez garder les mêmes noms de fichier,
        vous placez vos miniatures dans un dossier différent, comme
        <filename>thumbnails/image123.jpg</filename>. Vous pouvez
        également stocker vos légendes et dates de la même façon,
        séparées encore une fois du fichier image original. Mais le
        problème est que votre collection de fichiers s'agrandit de
        plusieurs fichiers à chaque nouvelle photo ajoutée au
        site.</para>

<!--
      <para>Now consider the same web site deployed in a way that
        makes use of Subversion's file properties.  Imagine having a
        single image file, <filename>image123.jpg</filename>, with
        properties set on that file that are named
        <literal>caption</literal>, <literal>datestamp</literal>, and
        even <literal>thumbnail</literal>.  Now your working copy
        directory looks much more manageable&mdash;in fact, it looks
        to the casual browser like there are nothing but image files
        in it.  But your automation scripts know better.  They know
        that they can use <command>svn</command> (or better yet, they
        can use the Subversion language bindings&mdash;see <xref
        linkend="svn.developer.usingapi" />) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</para>
-->
      <para>Maintenant, considérons le même site Web conçu en utilisant
        les propriétés des fichiers fournies par Subversion. Imaginez un
        simple fichier image, <filename>image123.jpg</filename>, et un
        ensemble de propriétés relatives à ce fichier nommées
        <literal>légende</literal>, <literal>date</literal> et même
        <literal>miniature</literal>. À présent, le dossier de votre
        copie de travail se gère beaucoup plus facilement&nbsp;; en fait,
        vu du navigateur, il semble ne contenir que des images. Mais vos
        scripts d'automatisation vont plus loin&nbsp;: ils savent qu'ils
        peuvent utiliser les commandes <command>svn</command> (ou mieux,
        ils peuvent utiliser les connecteurs spécifiques au langage
        utilisé, voir <xref linkend="svn.developer.usingapi" />) pour
        extraire les informations dont votre site a besoin sans avoir à
        lire un fichier d'index ou à jouer avec des chemins de
        fichiers.</para>

      <note>
<!--
        <para>While Subversion places few restrictions on the names
          and values you use for properties, it has not been designed
          to optimally carry large property values or large sets of
          properties on a given file or directory.  Subversion
          commonly holds all the property names and values associated
          with a single item in memory at the same time, which can
          cause detrimental performance or failed operations when
          extremely large property sets are used.</para>
-->
        <para>Bien que Subversion n'impose que peu de restrictions sur
          les noms et les valeurs des propriétés, il n'a pas été conçu
          pour gérer de façon optimale des valeurs de propriétés de
          grande taille ou un grand nombre de propriétés sur un fichier
          ou un dossier donné. Subversion garde souvent en mémoire en
          même temps tous les noms et valeurs de propriétés associés à
          un élément, ce qui peut engendrer des problèmes de performance
          lors de l'utilisation de très gros ensembles de
          propriétés.</para>
      </note>


<!--
      <para>Custom revision properties are also frequently used.  One
        common such use is a property whose value contains an issue
        tracker ID with which the revision is associated, perhaps
        because the change made in that revision fixes a bug filed in
        the tracker issue with that ID.  Other uses include hanging
        more friendly names on the revision&mdash;it might be hard to
        remember that revision 1935 was a fully tested revision.  But
        if there's, say, a <literal>test-results</literal> property on
        that revision with the value <literal>all passing</literal>,
        that's meaningful information to have.  And Subversion allows
        you to easily do this via the <option>- -with-revprop</option>
        option of the <command>svn commit</command> command:</para>
-->
      <para>On utilise également fréquemment des propriétés de révisions
        personnalisées. Une utilisation classique est d'avoir une
        propriété qui contient un identifiant en provenance d'un autre
        outil de gestion et de l'associer à une révision. Par exemple,
        l'outil de gestion est utilisé pour suivre les bogues et la
        révision corrige le bogue associé à l'identifiant. Il s'agit
        parfois aussi d'utiliser des noms plus conviviaux pour les
        révisions&nbsp;: il peut être difficile de se remémorer que la
        révision 1935 correspond à une révision qui a subi la totalité
        des tests, alors qu'une propriété
        <literal>resultat-des-tests</literal> avec la valeur
        <literal>tout ok</literal> est autrement plus utile.</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Fix up the last remaining known regression bug." \
             - -with-revprop "test-results=all passing"
Sending        lib/crit_bits.c
Transmitting file data .
Committed revision 912.
-->
$ svn commit -m "Corrige la dernière régression connue." \
             --with-revprop "resultat-des-tests=tout ok"
Envoi         lib/crit_bits.c
Transmission des données .
Révision 912 propagée.
$
</screen>
      </informalexample>

      <sidebar>
<!--
        <title>Searchability (or, Why <emphasis>Not</emphasis>
          Properties)</title>
-->
        <title>Retrouver ses petits (ou savoir <emphasis>ne pas
          utiliser</emphasis> les propriétés)</title>

<!--
        <para>For all their utility, Subversion properties&mdash;or,
          more accurately, the available interfaces to them&mdash;have
          a major shortcoming: while it is a simple matter to
          <emphasis>set</emphasis> a custom property,
          <emphasis>finding</emphasis> that property later is a whole
          different ball of wax.</para>
-->
        <para>Bien que très utiles, les propriétés Subversion, ou plus
          exactement les interfaces disponibles pour y accéder, ont une
          lacune majeure&nbsp;: alors qu'il est très simple de
          <emphasis>définir</emphasis> une propriété personnalisée, la
          <emphasis>retrouver</emphasis> plus tard est une toute autre
          affaire.</para>

<!--
        <para>Trying to locate a custom revision property generally
          involves performing a linear walk across all the revisions
          of the repository, asking of each revision, <quote>Do you
          have the property I'm looking for?</quote>  Use
          the <option>- -with-all-revprops</option> option with
          the <command>svn log</command> command's XML output mode to
          facilitate this search.  Notice the presence of the custom
          revision property <literal>testresults</literal> in the
          following output:</para>
-->
        <para>Trouver une propriété de révision personnalisée implique
          généralement d'effectuer un parcours linéaire de toutes les
          révisions du dépôt, en demandant à chacune&nbsp;:
          <quote>Avez-vous la propriété que je cherche&nbsp;?</quote>.
          L'utilisation de l'option <option>--with-all-revprops</option>
          sur la commande <command>svn log</command> avec la sortie en
          mode XML facilite la recherche. Notez la présence de la
          propriété de révision personnalisée
          <literal>resultat-des-tests</literal> dans la copie d'écran
          suivante&nbsp;:</para>

        <informalexample>
          <screen>
$ svn log --with-all-revprops --xml lib/crit_bits.c
&lt;?xml version="1.0"?&gt;
&lt;log&gt;
&lt;logentry
   revision="912"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2011-07-29T14:47:41.169894Z&lt;/date&gt;<!--
&lt;msg&gt;Fix up the last remaining known regression bug.&lt;/msg&gt;-->
&lt;msg&gt;Corrige la dernière régression connue.&lt;/msg&gt;
&lt;revprops&gt;
&lt;property<!--
   name="testresults"&gt;all passing&lt;/property&gt;-->
   name="resultat-des-tests"&gt;tout ok&lt;/property&gt;
&lt;/revprops&gt;
&lt;/logentry&gt;
&hellip;
$
</screen>
        </informalexample>

<!--
        <para>Trying to find a custom versioned property is painful,
          too, and often involves a recursive <command>svn
          propget</command> across an entire working copy.  In your
          situation, that might not be as bad as a linear walk across
          all revisions.  But it certainly leaves much to be desired
          in terms of both performance and likelihood of success,
          especially if the scope of your search would require a
          working copy from the root of your repository.</para>
-->
        <para>Trouver une propriété personnalisée suivie en versions est
          également difficile et implique souvent un appel récursif à
          <command>svn propget</command> sur toute une copie de travail.
          Dans votre situation, c'est peut-être moins pire que le
          parcours linéaire de toutes les révisions. Mais cela laisse
          certainement beaucoup à désirer en termes de performance et de
          probabilité de réussite, surtout si, pour votre recherche, il
          faut une copie de travail de la racine de votre dépôt.</para>

<!--
        <para>For this reason, you might choose&mdash;especially in
          the revision property use case&mdash;to simply add your
          metadata to the revision's log message using some
          policy-driven (and perhaps programmatically enforced)
          formatting that is designed to be quickly parsed from the
          output of <command>svn log</command>.  It is quite common to
          see the following in Subversion log messages:</para>
-->
        <para>C'est pourquoi vous pouvez choisir, en particulier pour
          ce qui concerne les propriétés de révisions, de simplement
          ajouter les méta-données au commentaire de propagation. Par
          exemple, utilisez une politique de formatage (idéalement
          appliquée automatiquement par un script) conçue pour être
          rapidement analysée à partir de la sortie de
          <command>svn log</command>. Ainsi, il est assez fréquent de
          voir dans Subversion des commentaires de propagation qui
          ressemblent à&nbsp;:</para>

        <informalexample>
          <programlisting><!--
Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process-->
Problème(s): IZ2376, IZ1919
Corrigé par:  sally

Corrige un méchant plantage dans la fonction machin bidule
&hellip;
</programlisting>
        </informalexample>

<!--
        <para>But here again lies some misfortune.  Subversion doesn't
          yet provide a log message templating mechanism, which would
          go a long way toward helping users be consistent with the
          formatting of their log-embedded revision metadata.</para>
-->
        <para>Mais hélas, cela ne résout pas tout. Subversion ne fournit
        pas encore de mécanisme pour gérer des modèles de commentaires
        associés aux propagations, ce qui aiderait pourtant beaucoup les
        utilisateurs à respecter le format des méta-données qu'ils
        placent dans les commentaires de révision.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
<!--
      <title>Manipulating Properties</title>
-->
      <title>Manipuler les propriétés</title>

<!--
      <para>The <command>svn</command> program affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command line of the <command>svn propset</command>
        subcommand:</para>
-->
      <para>La commande <command>svn</command> offre différentes
        possibilités pour ajouter ou modifier des propriétés sur les
        fichiers et les dossiers. Pour les propriétés avec des
        valeurs courtes, lisibles par un humain, la solution la plus
        simple est sûrement de spécifier le nom de la propriété et sa
        valeur en ligne de commande avec la
        sous-commande <command>svn propset</command>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'-->
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/bouton.c
Propriété 'copyright' définie sur 'calc/bouton.c'
$
</screen>
      </informalexample>

<!--
      <para>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multiline textual, or even binary, property value, you
        probably do not want to supply that value on the command line.
        So the <command>svn propset</command> subcommand takes a
        <option>- -file</option> (<option>-F</option>) option for
        specifying the name of a file that contains the new property
        value.</para>
-->
      <para>Mais nous avons vanté la souplesse de Subversion pour
        spécifier les valeurs des propriétés. Ainsi, si vous envisagez
        d'avoir des valeurs de plusieurs lignes de texte, ou même une
        valeur binaire, la passer en ligne de commande ne vous convient
        pas. La sous-commande <command>svn propset</command> accepte donc
        l'option <option>--file</option> (<option>-F</option>) pour
        spécifier le nom d'un fichier qui contient la nouvelle valeur de
        la propriété.</para>

      <informalexample>
        <screen><!--
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
-->
$ svn propset licence -F /chemin/vers/LICENCE calc/bouton.c
Propriété 'licence' définie sur 'calc/bouton.c'
$
</screen>
      </informalexample>

<!--
      <para>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<literal>:</literal>), or an underscore
        (<literal>_</literal>); after that, you can also use digits,
        hyphens (<literal>-</literal>), and periods
        (<literal>.</literal>).<footnote><para>If you're familiar with
        XML, this is pretty much the ASCII subset of the syntax for
        XML <quote>Name</quote>.</para></footnote></para>
-->
      <para>Il y a quelques restrictions sur les noms de propriétés. Un
        nom de propriété doit commencer par une lettre, le caractère
        deux points (<literal>:</literal>), ou le caractère souligné
        (<literal>_</literal>)&nbsp;; ensuite, vous pouvez aussi
        utiliser des chiffres, des tirets (<literal>-</literal>) et des
        points (<literal>.</literal>)
          <footnote>
            <para>Pour ceux qui connaissent le XML, c'est à peu près le
              sous-ensemble ASCII pour la syntaxe du champ "Name" en
              XML.</para>
          </footnote>.
      </para>

<!--
      <para>In addition to the <command>propset</command> command, the
        <command>svn</command> program supplies the
        <command>propedit</command> command.  This command uses the
        configured editor program (see <xref
        linkend="svn.advanced.confarea.opts.config" />) to add or
        modify properties.  When you run the command,
        <command>svn</command> invokes your editor program on a
        temporary file that contains the current value of the property
        (or that is empty, if you are adding a new property).  Then,
        you just modify that value in your editor program until it
        represents the new value you wish to store for the property,
        save the temporary file, and then exit the editor program.  If
        Subversion detects that you've actually changed the existing
        value of the property, it will accept that as the new property
        value.  If you exit your editor without making any changes, no
        property modification will occur:</para>
-->
      <para>En plus de la commande <command>propset</command>,
        <command>svn</command> dispose de la commande
        <command>propedit</command>. Cette commande utilise l'éditeur de
        texte pré-configuré (reportez-vous à <xref
        linkend="svn.advanced.confarea.opts.config" />) pour ajouter ou
        modifier des propriétés. Quand vous exécutez la commande,
        <command>svn</command> lance votre éditeur de texte avec un
        fichier temporaire qui contient la valeur actuelle de la
        propriété (ou un contenu vierge si vous ajoutez une nouvelle
        propriété). Vous pouvez alors modifier la valeur dans l'éditeur
        de texte pour y placer votre nouvelle valeur, sauvegarder le
        fichier temporaire et quitter l'éditeur. Si Subversion détecte
        que la valeur a effectivement changé, il la prend en compte. Si
        vous quittez l'éditeur sans faire de changement, la propriété
        n'est pas modifiée&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
-->
$ svn propedit copyright calc/bouton.c  ### sortez de l'éditeur sans faire de modification
Pas de modification de la propriété 'copyright' sur 'calc/bouton.c'
$
</screen>
      </informalexample>

<!--
      <para>We should note that, as with other <command>svn</command>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done the following:</para>
-->
      <para>Vous pouvez noter que, à l'instar des autres commandes
        <command>svn</command>, celles relatives aux propriétés
        fonctionnent aussi sur des chemins multiples. Vous pouvez ainsi
        modifier les propriétés d'un ensemble de fichiers en une seule
        commande. Par exemple, nous aurions pu taper&nbsp;:</para>

      <informalexample>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/* <!--
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
-->
Propriété 'copyright' définie sur 'calc/Makefile'
Propriété 'copyright' définie sur 'calc/bouton.c'
Propriété 'copyright' définie sur 'calc/entier.c'
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <command>svn</command> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <command>svn proplist</command>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <command>svn
        propget</command>.  This command will, given a property name
        and a path (or set of paths), print the value of the property
        to the standard output stream.</para>
-->
      <para>Toutes ces manipulations de propriétés ne seraient pas
        vraiment utiles si vous ne pouviez pas récupérer facilement la
        valeur d'une propriété. Subversion propose donc deux
        sous-commandes pour afficher les noms et les valeurs des
        propriétés associées aux fichiers et dossiers. La commande
        <command>svn proplist</command> fournit la liste des noms de
        propriétés qui existent dans un chemin. Une fois que vous
        connaissez les noms des propriétés d'un élément, vous pouvez
        obtenir les valeurs correspondantes avec la commande
        <command>svn propget</command>. Cette commande affiche sur la
        sortie standard la valeur de la propriété dont le nom et le
        chemin (ou l'ensemble des chemins) ont été passés en
        paramètres.</para>

      <informalexample>
        <screen><!--
$ svn proplist calc/button.c
Properties on 'calc/button.c':
-->
$ svn proplist calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright
  licence<!--
$ svn propget copyright calc/button.c-->
$ svn propget copyright calc/bouton.c
(c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

<!--
      <para>There's even a variation of the
        <command>proplist</command> command that will list both the
        name and the value for all of the properties.  Simply supply the
        <option>- -verbose</option> (<option>-v</option>) option.</para>
-->

      <para>Il y a même une variante de la commande
        <command>proplist</command> qui liste à la fois le nom et la
        valeur de toutes les propriétés. Ajoutez simplement l'option
        <option>--verbose</option> (<option>-v</option>) à la
        commande&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
-->
$ svn proplist -v calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright
    (c) 2006 Red-Bean Software
  license
    ================================================================
    Copyright (c) 2006 Red-Bean Software.  All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions, and the recipe for Fitz's famous
    red-beans-and-rice.
    &hellip;
</screen>
      </informalexample>

<!--
      <para>The last property-related subcommand is
        <command>propdel</command>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <command>svn propedit</command> or
        <command>svn propset</command>.  For example, this command will
        <emphasis>not</emphasis> yield the desired effect:</para>
-->
      <para>La dernière sous-commande relative aux propriétés est
        <command>propdel</command>. Puisque Subversion vous autorise à
        stocker des propriétés avec une valeur vide, vous ne pouvez pas
        supprimer une propriété en utilisant <command>svn propedit</command>
        ou <command>svn propset</command>. Par exemple, la commande
        suivante <emphasis>ne produit pas</emphasis> le résultat
        escompté&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn propset license "" calc/button.c
property 'license' set on 'calc/button.c'
-->
$ svn propset licence calc/bouton.c
Propriété 'licence' définie sur 'calc/bouton.c' <!--
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':-->
$ svn proplist -v calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright
    (c) 2006 Red-Bean Software
  license

$
</screen>
      </informalexample>

<!--
      <para>You need to use the <command>propdel</command> subcommand
        to delete properties altogether.  The syntax is similar to the
        other property commands:</para>
-->
      <para>Vous devez utiliser la sous-commande
        <command>propdel</command> pour supprimer complètement une
        propriété. La syntaxe est similaire aux autres commandes sur les
        propriétés&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
-->
$ svn propdel license calc/bouton.c
Propriété 'licence' supprimée de 'calc/bouton.c'.<!--
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
-->
$ svn proplist -v calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright
    (c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

<!--
      <para>Remember those unversioned revision properties?  You can
        modify those, too, using the same <command>svn</command>
        subcommands that we just described.  Simply add the
        <option>- -revprop</option> command-line parameter and specify
        the revision whose property you wish to modify.  Since
        revisions are global, you don't need to specify a target path
        to these property-related commands so long as you are
        positioned in a working copy of the repository whose revision
        property you wish to modify.  Otherwise, you can simply
        provide the URL of any path in the repository of interest
        (including the repository's root URL).  For example, you might
        want to replace the commit log message of an existing
        revision.<footnote><para>Fixing spelling errors, grammatical
        gotchas, and <quote>just-plain-wrongness</quote> in commit log
        messages is perhaps the most common use case for
        the <option>- -revprop</option> option.</para></footnote> If
        your current working directory is part of a working copy of
        your repository, you can simply run the
        <command>svn propset</command> command with no target path:</para>
-->
      <para>Vous souvenez-vous des propriétés de révision non suivies en
        versions&nbsp;? Vous pouvez les modifier elles-aussi en
        utilisant les mêmes sous-commandes <command>svn</command> que
        nous venons de décrire. Il suffit juste d'ajouter l'option
        <option>--revprop</option> au client texte interactif et de spécifier
        la révision à laquelle s'applique la modification. Puisque les
        numéros de révisions s'appliquent à l'ensemble de l'arborescence,
        vous n'avez pas besoin d'indiquer un chemin pour ces commandes,
        du moment que vous êtes dans une copie de travail du dépôt
        contenant la révision dont vous voulez modifier la propriété.
        Autrement, vous pouvez simplement fournir n'importe quelle URL
        du dépôt en question (y compris l'URL racine). Par exemple,
        imaginons que vous vouliez remplacer le commentaire associé à la
        propagation d'une révision précédente
        <footnote>
          <para>Corriger les fautes d'orthographe, les erreurs de
            grammaire et les informations simplement erronées au sein
            des commentaires de propagation est peut-être l'usage le plus
            courant de l'option <option>--revprop</option>.</para>
        </footnote>.
        Si le dossier actuel fait partie de votre copie de travail du
        dépôt, vous pouvez simplement lancer la commande
        <command>svn propset</command> sans spécifier de
        chemin&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn propset svn:log "* button.c: Fix a compiler warning." -r11 - -revprop
property 'svn:log' set on repository revision '11'
-->
$ svn propset svn:log "* bouton.c: corrige un avertissement du compilateur." -r11 --revprop
Nouvelle valeur définie pour la propriété 'svn:log' à la révision du dépôt '11'
$
</screen>
      </informalexample>

<!--
      <para>But even if you haven't checked out a working copy from
        that repository, you can still effect the property change by
        providing the repository's root URL:</para>
-->
      <para>Et même si vous n'avez pas extrait de copie de travail du
        dépôt, vous pouvez toujours modifier la propriété en indiquant
        l'URL racine du dépôt&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn propset svn:log "* button.c: Fix a compiler warning." -r11 - -revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
-->
$ svn propset svn:log "* bouton.c: corrige un avertissement du compilateur." -r11 --revprop \
              http://svn.exemple.com/depot/projet
Nouvelle valeur définie pour la propriété 'svn:log' à la révision du dépôt '11'
$
</screen>
      </informalexample>

<!--
      <para>Note that the ability to modify these unversioned
        properties must be explicitly added by the repository
        administrator (see <xref linkend="svn.reposadmin.maint.setlog" />).
        That's because the properties aren't versioned, so you run the risk of
        losing information if you aren't careful with your edits.
        The repository administrator can set up methods to protect
        against this loss, and by default, modification of
        unversioned properties is disabled.</para>
-->
      <para>Notez que le droit de modifier cette propriété non suivie en
        versions doit être explicitement ajouté par l'administrateur du
        dépôt (voir <xref linkend="svn.reposadmin.maint.setlog" />).
        En effet, la propriété n'étant pas suivie en versions, vous
        risquez une perte d'informations si vous la modifiez à tort et
        à travers. L'administrateur du dépôt peut mettre en place des
        protections contre ce type d'incident et, par défaut, la
        modification de propriétés non suivies en versions est
        désactivée.</para>

      <tip>
<!--
        <para>Users should, where possible, use <command>svn
          propedit</command> instead of <command>svn
          propset</command>.  While the end result of the commands is
          identical, the former will allow them to see the current
          value of the property that they are about to change, which helps
          them to verify that they are, in fact, making the change
          they think they are making.  This is especially true when
          modifying unversioned revision properties.  Also, it is
          significantly easier to modify multiline property values in
          a text editor than at the command line.</para>
      </tip>
-->
        <para>Dans la mesure du possible, il est recommandé d'utiliser
          <command>svn propedit</command> au lieu de <command>svn
          propset</command>. Bien que le résultat soit identique, la
          première permet de visualiser la valeur actuelle de la
          propriété que l'on veut modifier, ce qui aide à vérifier que
          l'on fait bien ce que l'on pense faire. C'est particulièrement
          vrai dans le cas des propriétés non suivies en versions. Il
          est aussi beaucoup plus facile de modifier un texte de
          plusieurs lignes dans un éditeur de texte qu'en ligne de
          commande.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.workflow">
<!--
      <title>Properties and the Subversion Workflow</title>
-->
      <title>Les propriétés et le cycle de travail Subversion</title>

<!--
      <para>Now that you are familiar with all of the
        property-related <command>svn</command> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging&mdash;cleanly or with conflicts&mdash;someone
        else's modifications into your own.</para>
-->
      <para>Maintenant que vous êtes familier avec toutes les
        sous-commandes <command>svn</command> relatives aux propriétés,
        voyons comment la modification des propriétés change le cycle
        habituel d'utilisation de Subversion. Comme mentionné
        précédemment, les propriétés des fichiers et dossiers sont
        suivies en versions, à l'instar du contenu des fichiers. En
        conséquence, Subversion offre les mêmes possibilités pour
        fusionner (proprement ou quand apparaissent des conflits) vos
        modifications avec celles des autres collaborateurs.</para>

<!--
      <para>As with file contents, your property changes are local
        modifications, made permanent only when you commit them to the
        repository with <command>svn commit</command>.  Your property
        changes can be easily unmade, too&mdash;the <command>svn
        revert</command> command will restore your files and
        directories to their unedited states&mdash;contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <command>svn status</command> and <command>svn diff</command>
        commands.</para>
-->
      <para>De même que pour le contenu des fichiers, les modifications
        de propriétés sont locales. Elles ne deviennent permanentes que
        quand vous les propagez dans le dépôt
        <foreignphrase>via</foreignphrase>
        <command>svn commit</command>. Vos modifications sur les
        propriétés peuvent aussi être annulées facilement&nbsp;: la
        commande <command>svn revert</command> restaure vos fichiers
        et dossiers dans leur état d'avant les modifications, y
        compris pour les propriétés. Vous pouvez également obtenir des
        informations intéressantes sur l'état des propriétés de vos
        fichiers et dossiers en utilisant les commandes
        <command>svn status</command> et
        <command>svn diff</command>.</para>

      <informalexample>
        <screen><!--
$ svn status calc/button.c
 M      calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
-->
$ svn status calc/bouton.c
 M     calc/bouton.c
$ svn diff calc/bouton.c
Modification de propriétés sur calc/bouton.c
___________________________________________________________________
Added: copyright
## -0,0 +1 ##
+(c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

<!--
      <para>Notice how the <command>status</command> subcommand
        displays <literal>M</literal> in the second column instead of
        the first.  That is because we have modified the properties on
        <filename>calc/button.c</filename>, but not its textual
        contents.  Had we changed both, we would have seen
        <literal>M</literal> in the first column, too.  (We cover
        <command>svn status</command> in <xref
        linkend="svn.tour.cycle.examine.status" />).</para>
-->
      <para>Remarquez que la sous-commande <command>status</command>
        place le <literal>M</literal> dans la deuxième colonne plutôt
        que dans la première. C'est parce que nous avons modifié les
        propriétés de <filename>calc/bouton.c</filename>, mais pas son
        contenu. Si nous avions changé les deux, nous aurions vu le
        <literal>M</literal> dans la première colonne également
        (reportez-vous à <xref
        linkend="svn.tour.cycle.examine.status" />).</para>

      <sidebar>
<!--
        <title>Property Conflicts</title>
-->
        <title>Conflits sur les propriétés</title>

<!--
        <para>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned object that clash with your own,
          Subversion will report that the object is in a conflicted
          state.</para>
-->
        <para>De la même manière que pour le contenu des fichiers, les
          modifications locales effectuées sur les propriétés peuvent
          entrer en conflit avec les changements effectués par d'autres
          collaborateurs. Si vous faites une mise à jour de votre copie
          de travail et que vous recevez un changement incompatible avec
          vos propres modifications d'une propriété d'un objet suivi en
          versions, Subversion vous indique que l'objet est dans un
          état de conflit.</para>

        <informalexample>
          <screen>
$ svn update calc<!--
Updating 'calc': -->
Mise à jour de 'calc' :
M  calc/Makefile.in <!--
Conflict for property 'linecount' discovered on 'calc/button.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (s) show all options: p
 C calc/button.c
Updated to revision 143.
Summary of conflicts:
  Property conflicts: 1
-->
Actualisé à la révision 143.
Conflit sur la propriété 'nombre_lignes' découvert sur 'calc/bouton.c'.
local add, incoming add upon update
Select: (p) postpone, (mf) my version, (tf) their version,
        (dc) display conflict, (e) edit property, (q) quit resolution,
        (h) help: p
Résumé des conflits :
  Property conflicts: 1
$
</screen>
        </informalexample>

<!--
        <para>Subversion will also create, in the same directory as
          the conflicted object, a file with a
          <filename>.prej</filename> extension that contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <literal>C</literal> in the second column of <command>svn
          status</command> output for that object, and attempts to
          commit your local modifications will fail.</para>
-->
        <para>Subversion va aussi créer, dans le même dossier que
          l'objet en conflit, un fichier avec l'extension
          <filename>.prej</filename> qui contient les détails du
          conflit. Vous devrez examiner le contenu de ce fichier pour
          décider comment résoudre le conflit. Tant que le conflit n'est
          pas résolu, vous voyez un <literal>C</literal> dans la
          deuxième colonne de la sortie de <command>svn status</command>
          pour cet objet et les tentatives de propager vos modifications
          locales échouent.</para>

        <informalexample>
          <screen>
$ svn status calc<!--
 C      calc/button.c
?       calc/button.c.prej
$ cat calc/button.c.prej
Trying to change property 'linecount' from '1267' to '1301',
but property has been locally changed from '1267' to '1256'.
-->
 C      calc/bouton.c
?       calc/bouton.c.prej
$ cat calc/bouton.c.prej
Tentative de modification de la propriété 'nombre_lignes' de '1267' à '1301'
mais la propriété a été modifiée localement de '1267' à '1256'.
$
</screen>
        </informalexample>

<!--
        <para>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <command>svn resolve - -accept=working</command>
          command to alert Subversion that you have manually resolved the
          problem.</para>
-->
        <para>Pour résoudre les conflits sur les propriétés,
          assurez-vous simplement que les propriétés en question
          contiennent bien les valeurs qu'elle doivent contenir, puis
          utilisez la commande <command>svn resolved</command> pour
          indiquer à Subversion que vous avez résolu le problème
          manuellement.</para>

      </sidebar>

<!--
      <para>You might also have noticed the nonstandard way that
        Subversion currently displays property differences.  You can
        still use <command>svn diff</command> and redirect its output
        to create a usable patch file.  The <command>patch</command>
        program will ignore property patches&mdash;as a rule, it
        ignores any noise it can't understand.  This does,
        unfortunately, mean that to fully apply a patch generated by
        <command>svn diff</command> using <command>patch</command>,
        any property modifications will need to be applied by
        hand.</para>
-->
      <para>Vous avez peut-être remarqué que Subversion affiche les
        différences au niveau des propriétés d'une manière non standard.
        Certes, vous pouvez toujours rediriger la sortie de
        <command>svn diff</command> pour créer un fichier correctif
        utilisable&nbsp;: le programme <command>patch</command> ignore
        ce qui concerne les propriétés (comme il ignore tout ce qu'il ne
        comprend pas). Malheureusement, cela signifie aussi que pour
        appliquer intégralement un correctif généré par
        <command>svn diff</command>, les modifications concernant les
        propriétés doivent être faites à la main.</para>

<!--
      <para>Subversion 1.7 improves this situation in two ways.
        First, its nonstandard display of property differences is at
        least machine-readable&mdash;an improvement over the display
        of properties in versions prior to 1.7.  But Subversion 1.7
        also introduces the <command>svn patch</command> subcommand,
        designed specifically to handle the additional information
        which <command>svn diff</command>'s output can carry, applying
        those changes to the Subversion working copy.  Of specific
        relevance to our topic, property differences present in patch
        files generated by <command>svn diff</command> in Subversion
        1.7 or better can be automatically applied to a working copy
        by the <command>svn patch</command> command.  For more
        about <command>svn patch</command>, see
        <xref linkend="svn.ref.svn.c.patch" /> in
        <xref linkend="svn.ref.svn"/>.</para>
-->
      <para>Subversion 1.7 améliore la situation sur deux points.
        D'abord, son affichage non standard des différences de
        propriétés est au moins traitable par machine &mdash; c'est une
        amélioration par rapport à l'affichage des propriétés des
        versions antérieures à la 1.7. Ensuite, Subversion 1.7 introduit
        la sous-commande <command>svn patch</command>, conçue
        spécifiquement pour prendre en charge les informations
        supplémentaires que génère la sortie de <command>svn
        diff</command> afin d'appliquer les changements à la copie de
        travail. Ainsi, pour ce qui nous concerne directement dans ce
        chapitre, les différences de propriétés indiquées dans les
        fichiers diff produits par <command>svn diff</command> de
        Subversion 1.7 ou ultérieur peuvent être appliqués
        automatiquement à une copie de travail par la commande
        <command>svn patch</command>. Pour plus d'informations
        concernant <command>svn patch</command>, référez-vous à
        <xref linkend="svn.ref.svn.c.patch" /> dans
        <xref linkend="svn.ref.svn"/>.</para>

      <note>
<!--
        <para>There's one exception to how property changes are
          reported by <command>svn diff</command>: changes to
          Subversion's special <literal>svn:mergeinfo</literal>
          property&mdash;used to track information about merges which
          have been performed in your repository&mdash;are described
          in a more human-readable fashion.  This is quite helpful to
          the humans who have to read those descriptions.  But it also
          serves to cause patching programs (including <command>svn
          patch</command>) to skip those change descriptions as noise.
          This might sound like a bug, but it really isn't because
          this property is intended to be managed solely by
          the <command>svn merge</command> subcommand.  For more about
          merge tracking, see <xref linkend="svn.branchmerge"
          />.</para>
-->
        <para>Il existe une exception à l'indication des modifications
          de propriétés que rapporte la commande <command>svn
          diff</command>&nbsp;: les modifications à la propriété
          spéciale de Subversion <literal>svn:mergeinfo</literal>
          (cette propriété est utilisée pour garder trace des fusions
          qui ont été effectuées dans le dépôt) sont affichées d'une
          manière plus lisible pour les humains. C'est une facilité
          accordée à ceux qui doivent lire ces descriptions. Mais cela
          sert également à ce que les programmes qui appliquent les
          <foreignphrase>patchs</foreignphrase> (y compris
          <command>svn patch</command>) sautent ces descriptions en les
          traitant comme du bruit non significatif. Cela pourrait
          ressembler à un bogue, mais pas du tout car cette propriété a
          pour finalité d'être gérée uniquement par la sous-commmande
          <command>svn merge</command>. Pour plus d'information sur le
          suivi des fusions, regardez <xref
          linkend="svn.branchmerge"/>.</para>
      </note>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.inheritable">
<!--
      <title>Inherited Properties</title>
-->
      <title>Propriétés héritées</title>

<!--
      <para>Subversion 1.8 introduces the concept of inherited properties.
        There is really nothing special about a property that makes it
        inheritable.  In fact, all versioned properties are inheritable!
        The main difference between versioned properties before 1.8 and
        after is that the latter provides a mechanism to find the
        properties set on a target path's <emphasis>parents</emphasis>,
        even if those parents are not found within the working copy.
        </para>
-->
      <para>Subversion 1.8 introduit le concept de propriétés héritées.
        Il n'y a rien de particulier concernant une propriété qui fait
        qu'on peut en hériter. En fait, on peut hériter de toutes les
        propriétés suivies en versions&nbsp;! La principale différence
        entre les propriétés suivies en version avant Subversion 1.8 et
        après est que ces dernières proposent un mécanisme pour trouver
        les propriétés définies sur des chemins cibles
        <emphasis>parents</emphasis> même si ces parents ne se trouvent
        plus dans la copie de travail.</para>

<!--
      <para>Generic property inheritance manifests itself in a few
        commands.  First, the <command>svn proplist</command> and <command>
        svn propget</command> subcommands can retrieve all the properties
        on a URL's or a working copy path's parents by using the <option>
        - -show-inherited-props</option> option.  You might think of this
        as the opposite of a <option>- -recursive</option> subcommand
        operation&mdash;instead of recursing "down" into a target's
        subdirectories, subcommands with the <option>- -show-inherited-props
        </option> option look "up" into the target's parent directories.
        The <command>svnlook propget</command> and <command>svnlook
        proplist </command> subcommands also use the <option>
        - -show-inherited-props</option> option in a similar fashion.</para>
-->
      <para>L'héritage de propriété se concrètise par l'intermédiaire de
        quelques commandes. D'abord, les sous-commandes
        <command>svn proplist</command> et <command>svn propget</command>
        peuvent retrouver toutes les propriétés de parents de chemins
        d'une URL ou d'une copie de travail en utilisant l'option
        <option>--show-inherited-props</option>. Vous pouvez vous
        représenter cette option comme étant l'opposé de l'option
        <option>--recursive</option>&nbsp;: au lieu de parcourir
        récursivement <quote>vers le bas</quote> les sous-dossiers
        de la cible, les sous-commandes avec l'option
        <option>--show-inherited-props </option> parcourrent <quote>vers
        le haut</quote> les dossiers parents de la cible. Les
        sous-commandes <command>svnlook propget</command> et
        <command>svnlook proplist </command> peuvent aussi utiliser
        l'option <option>--show-inherited-props</option> de la même
        manière.</para>

<!--
      <para>Let's look at an example of how this works. The following
        recursive propget on the root of our working copy finds that the
        <literal>svn:auto-props</literal> property is set on both the target
        of the subcommand and one of its subdirectories <filename>site
        </filename>:</para>
-->

      <para>Regardons un exemple pour mieux en comprendre le
        fonctinnement. La commande propget récursive ci-dessous
        appliquée à la racine de la copie de travail trouve la propriété
        <literal>svn:auto-props</literal> définie à la fois sur la
        cible et sur l'un de ses sous-dossiers
        <filename>site</filename>&nbsp;:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose -R .<!--
Properties on '.':-->
Propriétés sur '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
<!--
Properties on 'site':
-->
Propriétés sur 'site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

<!--
      <para>If we were to instead make the target of the subcommand the
        subdirectory <filename>site</filename>, then using the <option>
        - -show-inherited-props</option> option, we find that the <literal>
        svn:auto-props</literal> property is set on the target <emphasis>
        and</emphasis> its parent.  The parent's properties are called out
        as "inherited":</para>
-->
      <para>Si nous spécifions comme cible de la sous-commande le
        sous-dossier <filename>site</filename> et que nous utilisons
        l'option <option>--show-inherited-props</option>, nous trouvons
        que la propriété <literal>svn:auto-props</literal> est définie
        sur la cible <emphasis>et</emphasis> son parent. Les propriétés
        des parents sont affichées en tant que
        <quote>héritées</quote>&nbsp;:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose --show-inherited-props site<!--
Inherited properties on 'site',
from '.': -->
Propriétés héritées sur 'site'
de '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
<!--
Properties on 'site':
-->
Propriétés sur 'site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

<!--
      <para>In the prior examples the root of the working copy
        corresponds to the root of the repository, but properties can
        also be inherited from outside the working copy when this is
        not the case.  Let's checkout the <filename>site</filename>
        directory from the prior example, making it the root of our
        working copy:</para>
-->
      <para>Dans les exemples précédents, la racine de la copie de
        travail correspond à la racine du dépôt, mais les propriétés
        peuvent aussi être héritées de l'extérieur de la copie de
        travail quand les racines ne coïncident pas. Réalisons une
        extraction du dossier <filename>site</filename> de l'exemple
        précédent et faisons-en la racine de notre copie de
        travail&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn co http://svn.example.com/repos site-wc
A    site-wc/publish
A    site-wc/publish/ch2.html
A    site-wc/publish/news.html
A    site-wc/publish/ch3.html
A    site-wc/publish/faq.html
A    site-wc/publish/index.html
A    site-wc/publish/ch1.html
 U   site-wc
Checked out revision 19.-->
$ svn co http://svn.exemple.com/depot site-ct
A    site-ct/publication
A    site-ct/publication/ch2.html
A    site-ct/publication/actualités.html
A    site-ct/publication/ch3.html
A    site-ct/publication/faq.html
A    site-ct/publication/index.html
A    site-ct/publication/ch1.html
 U   site-ct
Révision 19 extraite.
$ cd site-ct
</screen>
        </informalexample>

<!--
      <para>Now when we check for inherited properties on a working copy
        path we can see that one property is inherited from a working
        copy parent and one from a repository parent representing a
        location "above" the root of the working copy:</para>
-->
      <para>Maintenant, quand nous cherchons les propriétés héritées
        sur un chemin d'une copie de travail, nous pouvons constater
        qu'une propriété est héritée d'un parent de la copie de travail
        et une est héritée d'un parent du dépôt, c'est-à-dire à un
        emplacement <quote>au-dessus</quote> de la racine de la copie de
        travail&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn pg svn:auto-props - -verbose - -show-inherited-props publish
Inherited properties on 'publish',
from 'http://svn.example.com/repos':-->
$ svn pg svn:auto-props --verbose --show-inherited-props publication
Propriétés héritées sur 'publication',
de 'http://svn.exemple.com/depot':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native<!--

Inherited properties on 'publish',
from '.':-->
Propriétés héritées sur 'publication',
de '.':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

        <warning>
<!--
          <para>You can only inherit properties from repository paths
            which you have read authorization to&mdash;see
            <xref linkend="svn.serverconfig.svnserve.auth" /> and
            <xref linkend="svn.serverconfig.httpd.authz" />.  If you
            don't have read authorization to a parent path then it will
            appear as if the parent has no properties set on it.
          </para>
-->
          <para>Vous ne pouvez hériter de propriétés des chemins dans
            des dépôts pour lesquels vous avez un droit en lecture
            &mdash; regardez <xref
            linkend="svn.serverconfig.svnserve.auth" /> et
            <xref linkend="svn.serverconfig.httpd.authz" />. Si vous
            n'avez pas de droit de lecture à un chemin parent alors tout
            se passe comme si le parent n'avait pas de propriété
            définie.</para>
        </warning>

<!--
      <para>As mentioned above, the <command>svnlook proplist</command>
        and <command>svnlook propget</command> commands also support the
        <option>- -show-inherited-props</option> option, but instead of
        reporting the inherited props by working copy path or URL, they
        are listed by repository paths:</para>
-->
      <para>Comme indiqué précédemment, les commandes
        <command>svnlook proplist</command> et <command>svnlook
        propget</command> acceptent l'option
        <option>--show-inherited-props</option>, mais au lieu de
        travailler sur des copies de travail ou des URL, elles
        travaillent sur des chemins de dépôts&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook pg repos svn:auto-props /site/publish - -show-inherited-props -v
Inherited properties on '/site/publish',
from '/':-->
$ svnlook pg repos svn:auto-props /site/publication --show-inherited-props -v
Propriétés héritées sur '/site/publish'
de '/':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
<!--
Inherited properties on '/site/publish',
from '/site':
-->
Propriétés héritées sur '/site/publish'
de '/site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

<!--
      <para>Properties inherited from above the root of the working copy
        are cached in the working copy's administrative database when the
        working copy is initially checked out and then refreshed whenever
        the working copy is updated.  This means that you don't need
        access to your repository to view inherited properties.  This
        allows Subversion subcommands that have traditionally not
        required access to the repository (e.g. <command>svn add</command>
        ) to remain "disconnected" while still accessing properties
        inherited from paths not found in the working copy.  However it
        also means that inherited properties from above the root of the
        working copy may have changed since your most recent update,
        causing your local cache to become out of date.  So if you require
        the absolute latest value of some inherited property, it's always
        safest to update your working copy first or query the repository
        directly.</para>
-->
      <para>Les propriétés héritées en amont de la racine d'une copie de
        travail sont mises en cache dans la zone administrative de la
        copie de travail au momemnt de l'extraction et des mises à jour
        de la copie de travail. Cela signifie que vous n'avez pas besoin
        d'accéder au dépôt pour visualiser les propriétés héritées. Cela
        permet aux sous-commandes Subversion qui n'accèdent
        tradionnellement pas au dépôt (par exemple <command>svn
        add</command>) de restées <quote>déconnectées</quote> tout en
        ayant accès aux propriétés héritées de chemins qui ne sont pas
        dans la copie de travail. Cependant, cela signifie aussi que les
        propriétés héritées en amont de la racine de la copie de travail
        peuvent avoir été modifiées depuis la dernière mise à jour, ce
        qui rend votre cache local obsolète. Donc, si vous avez
        absolument besoin des dernières valeurs de propriétés héritées,
        il est toujours préférable de d'abord mettre à jour votre copie
        de travail ou de requêter directement le dépôt.</para>

<!--
      <para>At this point you might be thinking, "nice trick, but what
        good is it?"  By itself property inheritance isn't very useful.
        Before 1.8, all of Subversion's own reserved <literal>svn:*
        </literal> properties (and likely all of your own custom user
        properties) applied only to the path on which they were set or
        at most, the path's immediate children<footnote><para>The one
        noteable exception to this being the <literal>svn:mergeinfo
        </literal> property, which is inheritable&mdash;see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo" />
        </para></footnote>  Rather, inheritable properties are a tool
        that Subversion uses to do other more interesting things, like
        setting automatic properties with the <literal>svn:auto-props
        </literal> property or repository-wide ignores with the <literal>
        svn:global-ignores</literal> property&mdash;see
        <xref linkend="svn.advanced.props.auto" /> and
        <xref linkend="svn.advanced.props.special.ignore" /> for more
        information about these special properties and how to use them.
        </para>
-->
      <para>Arrivé à ce point, vous devez vous dire&nbsp;: <quote>pas
        mal, mais à quoi cela sert-il vraiment&nbsp;?</quote>. En tant
        que tel, l'héritage de propriété n'est pas très utile. Avant la
        version 1.8, toutes les propriétés <literal>svn:*</literal>
        que Subversion se réserve (et possiblement toutes les propriétés
        spécifiques définies par les utilisateurs) s'appliquaient
        seulement sur le chemin sur lequel elles étaient définies ou, au
        plus, sur les enfants directs des chemins<footnote><para>
		L'exception notable à cet état de fait est la propriété
        <literal>svn:mergeinfo</literal> qui est héritable, voir
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo" />
        </para></footnote>.  Les propriétés héritées sont un moyen
        utilisé par Subversion pour accomplir d'autres choses
        intéressantes, comme définir des propriétés
        automatiques avec <literal>svn:auto-props</literal> ou des
        bannissements sur tout le dépôt avec la propriété
        <literal>svn:global-ignores</literal>. Reportez-vous à <xref
        linkend="svn.advanced.props.auto" /> et <xref
        linkend="svn.advanced.props.special.ignore" /> pour plus
        d'informations sur ces propriétés spéciales et les manières de
        les utiliser.</para>

        <tip>
<!--
          <para>Currently inheritable properties are primarily useful only
            as regards the <literal>svn:auto-props</literal> and <literal>
            svn:global-ignores</literal> properties but that doesn't mean
            those two properties are the end of the story.  Look for more
            features to be built with inherited properties in future
            releases of Subversion&mdash;a log message templating mechanism
            comes to mind.  In the meantime feel free to use the feature
            however you'd like.  Any piece of versioned metadata you want
            to apply to your whole repository (or large subsections
            thereof) can easily be stored in a property on the root of
            your repository (or the appropriate subtree).  We suspect that
            some users and administrators will come up with clever ways to
            use inheritable properties which we never considered.</para>
-->
          <para>Aujourd'hui les propriétés héritables sont surtout
            utiles pour le fonctionnement de
            <literal>svn:auto-props</literal> et
            <literal>svn:global-ignores</literal>, mais cela ne signifie
            pas pour autant la fin de l'histoire. Les futures versions
            de Subversion intégreront d'autres fonctionnalités basées
            sur l'héritage de propriétés (un mécanisme pour définir des
            modèles de commentaires de propagation est le premier exemple
            qui nous vient à l'esprit). D'ici là, vous pouvez mettre en
            œuvre cette fonctionnalité comme bon vous semble. N'importe
            quelle métadonnées suivie en versions que vous voulez
            appliquer sur l'ensemble du dépôt (ou sur une grande partie
            de celui-ci) peut être stockée facilement dans une propriété
            à la racine du dépôt (ou sur le sous-arbre approprié). Nous
            sommes convaincu que des utilisateurs ou des administrateurs
            trouveront des utilisations à l'héritage de propriétés que
            nous n'avons jamais envisagées.</para>
        </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
<!--
      <title>Automatic Property Setting</title>
-->
      <title>Configuration automatique des propriétés</title>

<!--
      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters&mdash;textual diff and merge
        support, keyword substitution, newline translation, and so on.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that
        step can be easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        few simple but useful features.</para>
-->
      <para>Les propriétés constituent une fonctionnalité très puissante
        de Subversion et sont un élément central de nombreuses
        fonctionnalités de Subversion présentées ailleurs dans ce
        chapitre ainsi que dans les autres chapitres&nbsp;: comparaisons
        et fusions textuelles, substitution de mots-clés, transformation
        des retours à la ligne,&nbsp;etc. Mais pour profiter pleinement
        des propriétés, il faut les placer sur les dossiers et
        fichiers adéquats. Malheureusement, cette étape peut passer à la
        trappe dans le train-train quotidien, d'autant plus qu'oublier
        de configurer une propriété n'engendre généralement pas une
        erreur qui saute aux yeux (du moins comparativement à oublier
        d'ajouter un fichier dans la gestion de versions). Pour vous
        aider à placer vos propriétés au bon endroit, Subversion propose
        deux fonctionnalités simples mais néanmoins utiles.</para>

<!--
      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion tries to assist by setting some common
        file properties automatically.  First, on operating systems
        whose filesystems support an execute permission bit,
        Subversion will automatically set the
        <literal>svn:executable</literal> property on newly added or
        imported files whose execute bit is enabled.  (See <xref
        linkend="svn.advanced.props.special.executable" /> later in
        this chapter for more about this property.)</para>
-->
      <para>Au moment d'introduire un fichier en suivi de versions à
        l'aide de la commande <command>svn add</command> ou
        <command>svn import</command>, Subversion essaie de vous aider
        en configurant automatiquement certaines propriétés communes des
        fichiers. D'abord, sur les systèmes d'exploitation dont le
        système de fichiers utilise un bit <quote>exécutable</quote>,
        Subversion ajoute automatiquement la propriété
        <literal>svn:executable</literal> aux nouveaux fichiers, ajoutés
        ou importés, qui ont ce bit activé (voir <xref
        linkend="svn.advanced.props.special.executable" /> plus loin
        dans ce chapitre pour plus de détails sur cette
        propriété).</para>

<!--
      <para>Second, Subversion tries to determine the file's MIME
        type.  If you've configured a
        <literal>mime-types-files</literal> runtime configuration
        parameter, Subversion will try to find a MIME type mapping in
        that file for your file's extension.  If it finds such a
        mapping, it will set your file's
        <literal>svn:mime-type</literal> property to the MIME type it
        found.  If no mapping file is configured, or no mapping for
        your file's extension could be found, Subversion will fall
        back to heuristic algorithms to determine the file's MIME
        type.  Depending on how it is built, Subversion 1.7 can make
        use of file scanning libraries<footnote><para>Currently,
        libmagic is the support library used to accomplish
        this.</para></footnote> to detect a file's type based on its
        content.  Failing all else, Subversion will employ its own
        very basic heuristic to determine whether the file contains
        nontextual content.  If so, it automatically sets the
        <literal>svn:mime-type</literal> property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise&mdash;perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal>&mdash;you can
        always remove or edit that property.  (For more on
        Subversion's use of MIME types, see <xref
        linkend="svn.advanced.props.special.mime-type" /> later in
        this chapter.)</para>
-->
      <para>Ensuite, Subversion essaie de déterminer le type MIME du
        fichier. Si vous avez configuré le paramètre
        <literal>mime-types-files</literal>, Subversion essaie de
        trouver un type MIME correspondant à l'extension du nom de
        fichier. Si un tel type MIME existe, il définit
        automatiquement la propriété <literal>svn:mime-type</literal>
        avec la valeur du type trouvé. S'il ne trouve pas de type MIME
        correspondant ou s'il n'existe pas de fichier définissant les
        correspondances, Subversion applique des heuristiques pour
        déterminer le type MIME. En fonction de la façon dont il a été
        compilé, Subversion 1.7 peut utiliser des bibliothèques qui
        scrutent le contenu du fichier<footnote><para>Actuellement, la
        bibliohèque utilisée est <literal>libmagic</literal>.</para>
        </footnote> pour déterminer son type. En dernier recours,
        Subversion utilise sa propre heuristique très basique pour
        déterminer si le fichier contient des éléments non textuels.
        Si c'est le cas, Subversion attribue automatiquement la valeur
        propriété <literal>application/octet-stream</literal> (type MIME
        générique indiquant <quote>une suite d'octets</quote>) à la
        propriété <literal>svn:mime-type</literal>. Bien sûr, si
        Subversion se trompe ou si vous voulez indiquer un type plus
        précis (par exemple <literal>image/png</literal> ou
        <literal>application/x-shockwave-flash</literal>), vous pouvez
        toujours supprimer ou modifier cette propriété (pour d'avantage
        d'informations sur la gestion des types MIME par Subversion,
        reportez vous à <xref
        linkend="svn.advanced.props.special.mime-type" /> plus loin dans
        ce chapitre).</para>

<!--
      <note>
        <para>UTF-16 is commonly used to encode files whose semantic
          content is textual in nature, but the encoding itself makes
          heavy use of bytes which are outside the typical ASCII
          character byte range.  As such, Subversion will tend to
          classify such files as binary files, much to the chagrin of
          users who desire line-based differencing and merging,
          keyword substitution, and other behaviors for those
          files.</para>
      </note>

-->
      <note>
        <para>L'encodage UTF-16 est communément utilisé pour des
          fichiers dont le contenu sémantique est textuel par nature,
          mais cet encodage utilise beaucoup les octets en dehors de
          l'intervalle typique ASCII. Ainsi, Subversion aura tendance à
          classer de tels fichiers dans la catégorie binaire, au grand
          regret des utilisateurs qui souhaitent pouvoir effectuer des
          comparaisons et des fusions, de la substitution de mots-clés
          ou d'autres manipulations sur ces fichiers.</para>
      </note>

<!--
      <para>Subversion also provides, via its runtime configuration
        system (see <xref linkend="svn.advanced.confarea" />), a more
        flexible automatic property setting feature that allows you
        to create mappings of filename patterns to property names and
        values.  Once again, these mappings affect adds and imports,
        and can not only override the default MIME type decision made
        by Subversion during those operations, but can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that anytime you add
        JPEG files&mdash;ones whose names match the pattern
        <literal>*.jpg</literal>&mdash;Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  For more details on automatic
        property support in the runtime configuration see <xref
        linkend="svn.advanced.confarea.opts.config"/>.</para>
-->
      <para>Subversion fournit également, <foreignphrase>via</foreignphrase>
        sa zone de configuration
        (voir <xref linkend="svn.advanced.confarea" />), une fonction de
        renseignement automatique des propriétés, plus flexible, qui
        vous permet de créer des associations entre, d'une part, des
        motifs de noms de fichiers et, d'autre part, des noms de
        propriétés&nbsp;/&nbsp;valeurs de propriétés. Là encore, ces
        associations modifient le comportement des commandes
        <command>add</command> et <command>import</command>, pouvant non
        seulement passer outre la décision prise par défaut
        d'attribution d'une propriété de type MIME mais pouvant aussi
        définir d'autres propriétés, qu'elles soient utilisées par
        Subversion ou personnalisées. Par exemple, vous pouvez créer une
        association qui, à chaque ajout d'un fichier JPEG (c'est-à-dire
        dont le nom est du type <literal>*.jpg</literal>), fixe la
        propriété <literal>svn:mime-type</literal> de ce fichier à la
        valeur <literal>image/jpeg</literal>. Ou alors affecte à tout
        fichierde type <literal>*.cpp</literal> la propriété
        <literal>svn:eol-style</literal> avec la valeur
        <literal>native</literal> et la propriété
        <literal>svn:keywords</literal> avec la valeur
        <literal>Id</literal>. Reportez-vous à <xref
        linkend="svn.advanced.confarea.opts.config"/> pour plus
        d'informations sur la configuration de cette fonction.</para>

<!--
      <para>While automatic property support via the runtime
        configuration system is certainly handy, Subversion
        administrators might prefer a set of property definitions
        which all connecting clients automatically consider when
        operating on working copies checked out from a given server.
        Subversion 1.8 and newer clients support such functionality
        through the <literal>svn:auto-props</literal> inheritable
        property.</para>
-->
      <para>Bien que la configuration automatique de propriétés par
        la zone de configuration soit certainement très facile
        d'utilisation, les administrateurs de Subversion préféreront
        peut-être définir automatiquement, sur un serveur donné, un
        ensemble de propriétés pour tous les clients qui se connectent
        pour des extractions. Les clients Subversion 1.8 et plus récents
        possèdent cette fonctionnalité
        <foreignphrase>via</foreignphrase> la propriété héritable
        <literal>svn:auto-props</literal>.</para>

<!--
      <para>The <literal>svn:auto-props</literal> property works like
        the runtime configuration to automatically set properties on
        files when they are added or imported.  The value of the
        <literal>svn:auto-props</literal> property is expected to be
        the same as the <literal>auto-props</literal> runtime
        configuration option (i.e. Any number of key-value pairs in
        the format FILE_PATTERN = PROPNAME=VALUE[;PROPNAME=VALUE ...])
        Like the <literal>auto-props</literal> runtime option, the
        <literal>svn:auto-props</literal> property can be disregarded
        when using the <option>- -no-auto-props</option> option, but unlike
        the config option, the <literal>svn:auto-props</literal> property
        is <emphasis>not</emphasis> disabled when the
        <literal>enable-auto-props</literal> configuration option is set
        to <literal>no</literal>.
        </para>
-->
      <para>La propriété <literal>svn:auto-props</literal> fonctionne
        comme la zone de configuration pour automatiquement définir des
        propriétés sur les fichiers lorsqu'ils sont ajoutés ou importés.
        La valeur de la propriété <literal>svn:auto-props</literal> doit
        être la même que celle de <literal>auto-props</literal> dans la
        zone de configuration (c'est-à-dire un nombre quelconque de
        paires clé-valeur au format
        MOTIF_FICHIER = NOM_PROPRIETE=VALEUR[;NOM_PROPRIETE=VALEUR ...]).
        Comme pour l'option de configuration
        <literal>auto-props</literal>, la propriété
        <literal>svn:auto-props</literal> peut être ignorée en
        spécifiant l'option <option>--no-auto-props</option>, mais
        contrairement à l'option de la zone de configuration, la
        propriété <literal>svn:auto-props</literal> n'est
        <emphasis>pas</emphasis> désactivée par l'option de la zone de
        configuration <literal>enable-auto-props</literal> définie à
        <literal>no</literal>.</para>

<!--
      <para>For example, say you have checked out a working copy of your
        <filename>trunk</filename> branch and need to add a new file
        (let's assume that automatic properties in your runtime
        configuration are disabled):</para>
-->
      <para>Par exemple, considérons que vous avez extrait une copie de
        travail du tronc (<filename>trunk</filename>) et que avez besoin
        d'ajouter un nouveau fichier (nous supposons que les propriétés
        automatiques sont désactivées dans votre zone de
        configuration)&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn st
?       calc/data.c

$ svn add calc/data.c
A         calc/data.c

$ svn proplist -v calc/data.c
Properties on 'calc/data.c':-->
$ svn st
?       calc/données.c

$ svn add calc/données.c
A         calc/données.c

$ svn proplist -v calc/données.c
Propriétés sur 'calc/données.c':
  svn:eol-style
    native
</screen>
    </informalexample>

<!--
      <para>Notice that after you place the unversioned file
        <filename>data.c</filename> under version control the
        <literal>svn:eol-style</literal> property was automatically set
        on it.  Since we assumed that the <literal>auto-props</literal>
        runtime configuration option is disabled, we know
        that the <literal>svn:auto-props</literal> property must be set
        on some parent path of <filename>data.c</filename>.  Using the
        <command>svn propget</command> subcommand with the
        <option>- -show-inherited-props</option> option we see that this
        is indeed the case:</para>
-->
      <para>Vous notez qu'après avoir placé le fichier
        <filename>données.c</filename> sous suivi de versions, la
        propriété <literal>svn:eol-style</literal> a automatiquement été
        définie sur lui. Puisque nous avons supposé que l'option de la
        zone de configuration <literal>auto-props</literal> est
        désactivée, nous savons que la propriété
        <literal>svn:auto-props</literal> doit être définie sur un
        chemin parent de <filename>données.c</filename>. En utilisant la
        commande <command>svn propget</command> avec l'option
        <option>--show-inherited-props</option>, nous pouvons vérifier
        que c'est effectivement le cas&nbsp;:</para>

    <informalexample>
      <screen>
$ svn propget svn:auto-props --show-inherited-props -v calc<!--
Inherited properties on 'calc',
from 'http://svn.example.com/repos':-->
Propriétés héritées sur 'calc'
de 'http://svn.exemple.com/depot':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
</screen>
    </informalexample>

<!--
      <para>Unlike the <literal>svn:global-ignores</literal> property and
        its analogous runtime configuration
        <literal>global-ignores</literal>, which are combined, the
        <literal>svn:auto-props</literal> property
        <emphasis>overrides</emphasis> the <literal>auto-props</literal>
        runtime configuration if it defines an auto-prop for the
        <emphasis>same</emphasis> pattern as the runtime configuration.
        Automatic properties inherited<footnote><para>Remember that users
        can only inherit properties from paths for which they have read
        access.  So if an administrator sets
        <literal>svn:auto-props</literal> on some high-level parent
        path (e.g. the repository root), they need to be sure all users
        have read access to that path or the desired automatic property
        setting won't kick in.</para></footnote> from one path can also
        override the <emphasis>identical</emphasis> pattern inherited from
        a different path.  The hierarchy of these overrides works as
        follows:</para>
-->
      <para>Au contraire de la propriété
        <literal>svn:global-ignores</literal> et de la directive
        homologue de la zone de configuration
        <literal>global-ignores</literal>, qui se combinent, la
        propriété <literal>svn:auto-props</literal>
        <emphasis>prévaut</emphasis> sur l'option de la zone de
        configuration <literal>auto-props</literal> si elle définit une
        propriété automatique pour le <emphasis>même</emphasis> motif
        que la zone de configuration. Les propriétés automatiques
        héritées<footnote><para>Rappelez-vous que les utilisateurs ne
        peuvent hériter de propriétés pour lesquelles ils ont un droit
        en lecture. Donc si un administrateur définit la propriété
        <literal>svn:auto-props</literal> sur un chemin parent très
        ascendant (par exemple à la racine du dépôt), il doit s'assurer
        que tous les utilisateurs possèdent le droit de lecture sur ce
        chemin ou la configuration automatique de propriété voulue ne
        fonctionnera pas.</para></footnote> d'un chemin peuvent aussi
        prévaloir sur un motif <emphasis>identique</emphasis> hérité
        d'un chemin différent. L'ordre de priorité est défini comme
        suit&nbsp;:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>An auto-prop, for a given pattern, defined in
            <literal>svn:auto-props</literal> overrides the same auto-prop
            for the identical pattern in the <literal>auto-props</literal>
            runtime configuration.</para>
-->
          <para>Une propriété automatique, pour un motif donné, définie
            par <literal>svn:auto-props</literal> prévaut sur la même
            propriété automatique pour un motif identique définie par
            <literal>auto-props</literal> dansla zone de
            configuration.</para>
        </listitem>
        <listitem>
<!--
          <para>If an auto-prop, for a given pattern, is inherited from
            more than one parents' <literal>svn:auto-props</literal>
            property, the nearer path-wise parent overrides the more
            distant parents.</para>
-->
          <para>Si une propriété automatique, pour un motif donné, est
            héritée depuis plus d'un chemin parent par la propriété
            <literal>svn:auto-props</literal>, le chemin parent le plus
            près prévaut sur les chemins parents plus éloignés.</para>
        </listitem>
        <listitem>
<!--
          <para>An auto-prop, for a given pattern, defined in a
            <literal>svn:auto-props</literal> property explicitly set on
            a path overrides the same auto-prop(s) for the identical
            pattern inherited from any parents.</para>
-->
          <para>Une propriété automatique, pour un motif donné, définie
            par la propriété <literal>svn:auto-props</literal>
            explicitement appliquée à un chemin prévaut sur la même (ou
            les mêmes) propriétés automatiques pour un motif identique
            héritées de parents.</para>
        </listitem>
      </itemizedlist>

<!--
      <para>Let's look at an example.  Suppose you have this runtime
        configuration:</para>
-->
      <para>Prenons un exemple. Supposons que nous avons ce contenu dans
        le fichier de configuration:</para>

    <informalexample>
      <screen>
[miscellany]
enable-auto-props = yes
[auto-props]
*.py  = svn:eol-style=CR
*.c   = svn:eol-style=CR
*.h   = svn:eol-style=CR
*.cpp = svn:eol-style=CR
</screen>
    </informalexample>

<!--
      <para>And you want to add three files in the <filename>calc</filename>
        directory of your working copy:</para>
-->
      <para>Vous voulez ajouter trois fichiers dans le dossier
        <filename>calc</filename> de votre copie de travail:</para>

    <informalexample>
      <screen>
$ svn st<!--
?       calc/data-binding.cpp
?       calc/data.c
?       calc/editor.py-->
?       calc/données-binding.cpp
?       calc/données.c
?       calc/éditeur.py
</screen>
    </informalexample>

<!--
      <para>Let's check what <literal>svn:auto-props</literal> apply to
        <filename>calc</filename>:</para>
-->
      <para>Vérifions que <literal>svn:auto-props</literal> s'applique
        sur <filename>calc</filename>&nbsp;:</para>

    <informalexample>
      <screen>
$ svn propget svn:auto-props -v --show-inherited-props calc<!--
Inherited properties on 'calc',
from 'http://svn.example.com/repos':-->
Propriétés héritées sur 'calc'
de 'http://svn.exemple.com/depot':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
<!--
Inherited properties on 'calc',
from '.':
-->
Propriétés héritées sur 'calc'
de '.':
  svn:auto-props
    *.py = svn:eol-style=native<!--
    *.c = svn:keywords=Author Date Id Rev URL-->
    *.c = svn:keywords=Auteur Date Id Rev URL
</screen>
    </informalexample>

<!--
      <para>When we add these three files what auto-props do we expect?
        We add the trio to version control and then check:</para>
-->
      <para>Quand nous ajoutons ces trois fichiers, qu'attendons nous
        pour <literal>auto-props</literal>&nbsp;? Nous ajoutons le trio
        au suivi de versions et nous vérifions&nbsp;:</para>

    <informalexample>
      <screen>
$ svn add calc --force<!--
A         calc/data-binding.cpp
A         calc/data.c
A         calc/editor.py-->
A         calc/données-binding.cpp
A         calc/données.c
A         calc/éditeur.py
</screen>
    </informalexample>

<!--
      <para>The file <filename>data-binding.cpp</filename> has only one
        matching pattern, <literal>*.cpp = svn:eol-style=CR</literal>
        in the runtime configuration, so obviously the
        <literal>svn:eol-style</literal> property is set to
        <literal>CR</literal>:</para>
-->
      <para>Le nom de fichier <filename>données-binding.cpp</filename>
        ne correspond qu'à un seul motif, <literal>*.cpp =
        svn:eol-style=CR</literal> dans la zone de configuration,
        donc la propriété <literal>svn:eol-style</literal> est
        évidemment définie à <literal>CR</literal>&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn proplist -v calc/data-binding.cpp
Properties on 'calc/data-binding.cpp':-->
$ svn proplist -v calc/données-binding.cpp
Propriétés sur 'calc/données-binding.cpp':
  svn:eol-style
    CR
</screen>
    </informalexample>

<!--
      <para>The file <filename>editor.py</filename> matches a single
        pattern in runtime config and both of the
        <literal>svn:auto-props</literal> properties, but by the hierarchy
        described above, the property explicitly set on
        <filename>calc</filename>,
        <literal>*.py = svn:eol-style=native</literal>, takes precedence.
        So the <literal>svn:eol-style</literal> property is set to
        <literal>native:</literal>:</para>
-->
      <para>Le nom de fichier <filename>éditeur.py</filename> correspond
        à un seul motif dans la zone de configuration et à deux pour la
        propriété <literal>svn:auto-props</literal> mais, en raison de
        l'ordre de priorité défini auparavant, la propriété définie
        explicitement sur <filename>calc</filename>, <literal>*.py =
        svn:eol-style=native</literal>, est prioritaire. Donc la
        propriété <literal>svn:eol-style</literal> est définie à
        <literal>native:</literal>&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn proplist -v calc/editor.py
Properties on 'calc/editor.py':-->
$ svn proplist -v calc/éditeur.py
Propriétés sur 'calc/éditeur.py':
  svn:eol-style
    native
</screen>
    </informalexample>

<!--
      <para>The file <filename>data.c</filename> also matches patterns
        in the runtime config and both of the inherited
        <literal>svn:auto-props</literal> properties.  The
        <literal>svn:keywords</literal> auto-prop is only defined once,
        on <filename>calc</filename>, so <filename>data.c</filename>
        automatically gets that property.  The
        <literal>svn:auto-props</literal> on <filename>calc</filename>
        don't define a <literal>svn:eol-style</literal> value however, so
        the nearest inherited parent,
        <literal>http://svn.example.com/repos</literal>,
        provides that value:</para>
-->
      <para>Le nom de fichier <filename>données.c</filename> correspond
        à des motifs dans la zone de configuration et dans les
        propriétés héritées <literal>svn:auto-props</literal>. La
        propriété automatique <literal>svn:keywords</literal> n'est
        définie qu'une seule fois, sur <filename>calc</filename>, donc
        <filename>données.c</filename> possède automatiquement cette
        propriété. <literal>svn:auto-props</literal> sur
        <filename>calc</filename> ne définit pas de valeur pour
        <literal>svn:eol-style</literal>, donc le parent le plus proche
        <literal>http://svn.exemple.com/depot</literal>, définit la
        valeur&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn proplist -v calc/data.c
Properties on 'calc/data.c':-->
$ svn proplist -v calc/données.c
Propriétés sur 'calc/données.c':
  svn:eol-style
    native
  svn:keywords<!--
    Author Date Id Rev URL-->
    Auteur Date Id Rev URL
</screen>
    </informalexample>

      <warning>
<!--
        <para>Overriding auto-props only applies for
          <emphasis>identical</emphasis> patterns.  If a file to be added
          or imported matches more than one pattern, then there is no
          guarantee which pattern's auto-props will be applied.  For
          example, say you want to add the file
          <filename>foo.cpp</filename> in the directory
          <filename>bar</filename>.  Further, suppose the
          <literal>svn:auto-props</literal> property is set on
          <filename>bar</filename> with the value:</para>
-->
        <para>L'application des priorités est uniquement valable pour
          des motifs <emphasis>identiques</emphasis>. Si un nom de
          fichier à ajouter ou importer correspond à plus d'un motif,
          alors il n'y a aucune garantie concernant le motif des
          propriétés automatiques qui est appliqué. Par exemple, disons
          que vous voulez ajouter le fichier
          <filename>truc.cpp</filename> dans le dossier
          <filename>machin</filename>. Supposons encore que la propriété
          <literal>svn:auto-props</literal> est définie sur
          <filename>machin</filename> avec la valeur&nbsp;:</para>

    <informalexample>
      <screen>
*.c*  = svn:eol-style=native<!--
*.cpp = svn:eol-style=native;svn:keywords=Author Date Id Rev URL-->
*.cpp = svn:eol-style=native;svn:keywords=Auteur Date Id Rev URL
</screen>
    </informalexample>

<!--
        <para>Since <filename>foo.cpp</filename> matches both patterns,
          there is no way to know if the <literal>svn:keywords</literal>
          property will be set on <filename>foo.cpp</filename> when it
          is added.</para>
-->
        <para>Comme <filename>truc.cpp</filename> correspond aux deux
          motifs,il n'est pas possible de savoir si la propriété
          <literal>svn:keywords</literal> sera définie sur
          <filename>truc.cpp</filename> quand on l'ajoutera.</para>
      </warning>

<!--
      <para>A final note on <literal>svn:auto-props</literal>.  This
        property (along with the similar
        <literal>svn:global-ignores</literal>, see
        <xref linkend="svn.advanced.props.special.ignore"/>)
        only provides a <emphasis>recommendation</emphasis> to clients
        that understand the meaning of the property.  Older clients will
        ignore these properties, the <option>- -no-auto-props</option>
        option will disregard them, a user might manually change or remove
        automatic properties after they have been set&mdash;there are
        numerous ways in which the recommended properties contained in
        <literal>svn:auto-props</literal> can be by-passed.  Given
        this, administrators will still need to use hook scripts to
        validate that the properties added to and modified on files
        and directories match the administrator's preferred policies,
        rejecting commits which are non-compliant in this fashion.
        (See <xref linkend="svn.reposadmin.hooks"/> for more about
        hook scripts.)</para>
-->
      <para>Un dernier point sur <literal>svn:auto-props</literal>.
        Cette propriété (tout comme
        <literal>svn:global-ignores</literal>, voir <xref
        linkend="svn.advanced.props.special.ignore"/>) ne constitue
        qu'une <emphasis>indication</emphasis> aux clients qui
        comprennent la signification de cette propriété. Les clients
        plus anciens ignorent ces propriétés, l'option
        <option>--no-auto-props</option> les laisse de côté, un
        utilisateur peut très bien modifier ou supprimer les propriétés
        automatiquement après qu'elles aient été définies&nbsp;; il
        existe pléthore de moyens de passer outre les indications
        fournies par le contenu de <literal>svn:auto-props</literal>.
        Sachant cela, les administrateurs doivent toujours utiliser des
        procédures automatiques (<foreignphrase>hook
        scripts</foreignphrase> en anglais) pour valider la politique
        des propriétés qu'ils souhaitent mettre en place&nbsp;; ils
        peuvent ainsi rejeter les propagations qui ne respectent pas
        les règles. Reportez-vous à <xref linkend="svn.reposadmin.hooks"/>
        pour plus de détails sur les procédures automatiques du
        dépôt.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.ref">

  <!--
      <title>Subversion's Reserved Properties</title>
  -->
      <title>Propriétés réservées à l'usage de Subversion</title>

  <!--
      <para>In this section, we'll briefly summarize all the
        properties which Subversion reserves for its own use.  We'll
        look at both types of properties&mdash;those which are
        associated with individual versioned files and directories,
        and those which are associated with revisions.</para>
  -->
      <para>Dans cette section, nous allons brièvement aborder toutes
        les propriétés que Subversion réserve à son propre usage. Nous
        regardons les deux types de propriétés, celles associées à un
        fichier ou un dossier particulier suivi en versions et celles
        associées aux révisions</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.props.ref.versioned">
  <!--
        <title>Versioned properties</title>
  -->
        <title>Propriétés suivies en versions</title>

  <!--
        <para>These are the versioned (or node) properties that
          Subversion reserves for its own use:</para>
  -->
        <para>Les propriétés suivies en versions que Subversion réserve
          à son propre usage sont les suivantes&nbsp;:</para>

        <variablelist>

          <varlistentry>
            <term><literal>svn:auto-props</literal></term>
            <listitem>
<!--
              <para>If present on a directory, the value is a set of
                automatic property definitions which apply to all files
                under the directory, See
                <xref linkend="svn.advanced.props.auto" />.</para>
-->
              <para>Si elle est définie sur un dossier, la valeur est
                un ensemble de définitions de propriétés qui
                s'appliquent à tous les fichiers sous le dossier.
                Voir <xref linkend="svn.advanced.props.auto" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:executable</literal></term>
            <listitem>
  <!--
              <para>If present on a file, the client will make the file
                executable in Unix-hosted working copies.  See
                <xref linkend="svn.advanced.props.special.executable"
                />.</para>
  -->
              <para>Si elle est définie sur un fichier, le client
                rendra le fichier exécutable sur les copies de travail
                d'un système de type Unix. Voir <xref
                linkend="svn.advanced.props.special.executable"/>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:mime-type</literal></term>
            <listitem>

  <!--
              <para>If present on a file, the value indicates the file's
                MIME type.  This allows the client to decide whether
                line-based contextual merging is safe to perform during
                updates, and can also affect how the file behaves when
                fetched via a web browser.  See
                <xref linkend="svn.advanced.props.special.mime-type"
                />.</para>
  -->
              <para>Si elle est définie sur un fichier, la valeur
                indique le type MIME du fichier. Cela permet au client
                de décider si des fusions à partir des lignes sont
                pertinentes lors des mises à jour et cela peut aussi
                affecter le comportement des fichiers lorsqu'on les
                parcourt avec un navigateur web. Voir <xref
                linkend="svn.advanced.props.special.mime-type"/>.
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:ignore</literal></term>
            <listitem>

  <!--
              <para>If present on a directory, the value is a list of
                <emphasis>unversioned</emphasis> file patterns to be
                ignored by <command>svn status</command> and other
                subcommands.  See
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
  -->
              <para>Si elle est définie sur un dossier, la valeur est
                une liste de motifs de noms de fichiers <emphasis>non
                suivis en versions</emphasis> que les sous-commandes
                <command>svn status</command> et autres ignoreront.
                Voir <xref
                linkend="svn.advanced.props.special.ignore"/>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:global-ignores</literal></term>
            <listitem>
<!--
              <para>If present on a directory, the value is a list of
                <emphasis>unversioned</emphasis> file patterns to be
                ignored by <command>svn status</command> and other
                subcommands.  Unlike <literal>svn:ignore</literal> these
                patterns apply to <emphasis>all</emphasis> unversioned
                subtrees under the directory, not just the directory's
                immediate file children.  See
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
-->
              <para>Si elle définie sur un dossier, la valeur est une
                liste de motifs de noms de fichiers <emphasis>non suivis
                en versions</emphasis> que les sous-commandes
                <command>svn status</command> et autres ignoreront. Au
                contraire de <literal>svn:ignore</literal>, les motifs
                s'appliquent à <emphasis>toute</emphasis> la
                sous-arborescence du dossier et pas seulement aux
                noms de fichiers qui sont fils directs du dossier.
                Voir <xref
                linkend="svn.advanced.props.special.ignore"/>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:keywords</literal></term>
            <listitem>

  <!--
              <para>If present on a file, the value tells the client how
                to expand particular keywords within the file.  See
                <xref linkend="svn.advanced.props.special.keywords"
                />.</para>
  -->
              <para>Si elle est définie sur un fichier, la valeur
                indique au client comment remplacer des mots-clés
                particuliers à l'intérieur du fichier. Voir
                <xref linkend="svn.advanced.props.special.keywords"/>.
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:eol-style</literal></term>
            <listitem>

  <!--
              <para>If present on a file, the value tells the client how
                to manipulate the file's line-endings in the working
                copy and in exported trees.  See
                <xref linkend="svn.advanced.props.special.eol-style" />
                and <xref linkend="svn.ref.svn.c.export" />.</para>
  -->
              <para>Si elle est définie sur fichier, la valeur indique
                au client comment les fins de ligne doivent être
                comprises dans la copie de travail et dans les exports
                d'arborescences. Voir <xref
                linkend="svn.advanced.props.special.eol-style"/> et
                <xref linkend="svn.ref.svn.c.export" />.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:externals</literal></term>
            <listitem>

  <!--
              <para>If present on a directory, the value is a multiline
                list of other paths and URLs the client should check
                out.  See <xref linkend="svn.advanced.externals"
                />.</para>
  -->
              <para>Si elle est définie sur un dossier, la valeur est
                une liste sur plusieurs lignes de chemins et d'URL que
                le client doit extraire. Voir <xref
                linkend="svn.advanced.externals"/>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:special</literal></term>
            <listitem>

  <!--
              <para>If present on a file, indicates that the file is not
                an ordinary file, but a symbolic link or other special
                object.<footnote><para>As of this writing, symbolic
                links are indeed the only <quote>special</quote>
                objects.  But there might be more in future releases of
                Subversion.</para></footnote></para>
  -->
              <para>Si elle est définie sur un ficiher, elle indique que
                ce fichier n'est pas ordinaire, mais est plutôt un lien
                symbolique ou autre objet spécial.<footnote><para>Au
                moment de la rédaction de ce livre, les liens
                symboliques sont en fait les seuls objets
                <quote>spéciaux</quote> traités. Mais rien n'interdit
                qu'il y en ait d'autres dans des versions futures de
                Subversion.</para></footnote></para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:needs-lock</literal></term>
            <listitem>

  <!--
              <para>If present on a file, tells the client to make the
                file read-only in the working copy, as a reminder that
                the file should be locked before editing begins.  See
                <xref linkend="svn.advanced.locking.lock-communication"
                />.</para>
  -->
              <para>Si elle est définie sur un fichier, elle indique au
                client de placer le fichier en lecture seule dans la
                copie de travail, pour rappeler que ce fichier doit être
                verrouillé avant toute édition. Voir <xref
                linkend="svn.advanced.locking.lock-communication"/>.
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:mergeinfo</literal></term>
            <listitem>

  <!--
              <para>Used by Subversion to track merge data.  See
                <xref linkend="svn.branchmerge.basicmerging.mergeinfo"
                /> for details, but you should never edit this property
                unless you <emphasis>really</emphasis> know what you're
                doing.</para>
  -->
              <para>Utilisée par Subversion pour suivre les métadonnées
                liées aux fusions. Voir <xref
                linkend="svn.branchmerge.basicmerging.mergeinfo"/> pour
                les détails&nbsp; vous ne devriez jamais éditer cette
                propriété à moins de <emphasis>réellement</emphasis>
                savoir ce que vous faites.</para>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.props.ref.unversioned">
  <!--
        <title>Unversioned properties</title>
  -->
        <title>Propriétés non suivies en versions</title>

  <!--
        <para>The following are the unversioned (or revision) properties
          that Subversion reserves for its own use.  Most of these
          appear on every revision in the repository, carrying important
          information about the origin and nature of the changes made in
          that revision.</para>
  -->
        <para>Les propriétés suivantes, toujours réservées par
          Subversion pour son propre usage, ne sont pas suivies en
          versions et s'appliquent aux révisions. La plupart d'entre
          elles apparaissent sur chaque révision dans le dépôt, stockant des
          informations importantes sur l'origine et la nature des
          modifications faites par cette révision.</para>

        <variablelist>

          <varlistentry>
            <term><literal>svn:author</literal></term>
            <listitem>

  <!--
              <para>If present, contains the authenticated username of
                the person who created the revision.  (If not present,
                the revision was committed anonymously.)</para>
  -->
              <para>Si elle est définie, elle contient le nom
                de l'utilisateur authentifié qui a créé la révision. Si
                elle n'est pas définie, la révision a été propagée de
                manière anonyme.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:autoversioned</literal></term>
            <listitem>

  <!--
              <para>If present, the revision was created via the
                autoversioning feature.  See
                <xref linkend="svn.webdav.autoversioning"/>.</para>
  -->
              <para>Si elle est définie, la révision a été créée par un
                mécanisme d'autoversionnage automatique. Voir <xref
                linkend="svn.webdav.autoversioning"/>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:date</literal></term>
            <listitem>

  <!--
              <para>Contains the UTC time the revision was created, in
                ISO 8601 format.  The value comes from the
                <emphasis>server</emphasis> machine's clock, not the
                client's.</para>
  -->
              <para>Contient l'horodatage UTC correspondant à la
                création de la révision, au format ISO 8601. La valeur
                provient de l'horloge du <emphasis>serveur</emphasis>,
                pas du client.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:log</literal></term>
            <listitem>

  <!--
              <para>Contains the log message describing the
                revision.</para>
  -->
              <para>Contient le commentaire de propagation relatif à la
                révision.</para>
            </listitem>
          </varlistentry>

        </variablelist>

<!--
        <para>Certain auxiliary tools in the Subversion
          toolchain&mdash;namely, <command>svnrdump</command>
          and <command>svnsync</command>&mdash;also use unversioned
          properties for their own accounting purposes.  These
          properties are found only on revision 0 of repositories on
          which these tools are operating.  For more about
          <command>svnrdump</command> and <command>svnsync</command> and
          the functionality they offer, see
          <xref linkend="svn.reposadmin" />.  The following are the
          properties created and managed by these tools.</para>
-->
        <para>Certains outils connexes de la collection Subversion
          (<command>svnrdump</command> et <command>svnsync</command>)
          utilisent également les propriétés non suivies en version pour
          stocker des informations les concernant. Ces propriétés sont
          présentes uniquement sur la révision 0 des dépôts sur lesquels
          ces outils opèrent. Pour plus d'information sur
          <command>svnrdump</command> et <command>svnsync</command>,
          reportez-vous à <xref linkend="svn.reposadmin" />. Les propriétés
          créées et gérées par ces outils sont les
          suivantes&nbsp;:</para>

        <variablelist>

          <varlistentry>
            <term><literal>svn:rdump-lock</literal></term>
            <listitem>

  <!--
              <para>Used to temporarily enforce mutually exclusive
                access to the repository by <command>svnrdump
                load</command>.  This property is generally only
                observed when such an operation is active&mdash;or when
                an <command>svnrdump</command> command failed to cleanly
                disconnect from the repository.  (This property is only
                relevant when it appears on revision 0.)</para>
  -->
              <para>Utilisée pour mettre en œuvre un accès exclusif
                temporaire au dépôt par la commande
                <command>svnrdump load</command>. Cette propriété est
                généralement présente seulement quand une opération de
                ce type est en cours (ou quand une commande
                <command>svnrdump</command> a échoué à se déconnecter
                proprement du dépôt). Cette propriété n'a de sens que si
                elle est définie sur la révision 0.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:sync-currently-copying</literal></term>
            <listitem>

  <!--
              <para>Contains the revision number from the source
                repository which is currently being mirrored to this one
                by the <command>svnsync</command> tool.  (This property
                is only relevant when it appears on revision 0.)</para>
  -->
              <para>Contient le numéro de révision du dépôt source qui
                est en train d'être recopié sur le dépôt cible par la
                commande <command>svnsync</command>. Cette propriété n'a
                de sens que si elle est définie sur la révision
                0.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:sync-from-uuid</literal></term>
            <listitem>

  <!--
              <para>Contains the UUID of the repository of which this
                repository has been initialized as a mirror by
                the <command>svnsync</command> tool.  (This property is
                only relevant when it appears on revision 0.)</para>
  -->
              <para>Contient l'UUID du dépôt dont le dépôt cible est un
                mirroir, créé par l'outil <command>svnsync</command>.
                Cette propriété n'a de sens que si elle est définie sur
                la révision 0.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:sync-from-url</literal></term>
            <listitem>

  <!--
              <para>Contains the URL of the repository directory of
                which this repository has been initialized as a mirror
                by the <command>svnsync</command> tool.  (This property
                is only relevant when it appears on revision 0.)</para>
  -->
              <para>Contient l'URL du dépôt dont le dépôt cible est un
                mirroir, créé par l'outil <command>svnsync</command>.
                Cette propriété n'a de sens que si elle est définie sur
                la révision 0.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:sync-last-merged-rev</literal></term>
            <listitem>

  <!--
              <para>Contains the revision of the source repository which
                was most recently and successfully mirrored to this one.
                (This property is only relevant when it appears on
                revision 0.)</para>
  -->
              <para>Contient le numéro de révision du dépôt source qui
                a été dupliqué avec succès le plus récemment sur le
                dépôt cible. Cette propriété n'a de sens que si elle est
                définie sur la révision 0.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:sync-lock</literal></term>
            <listitem>

  <!--
              <para>Used to temporarily enforce mutually exclusive
                access to the repository by <command>svnsync</command>
                mirroring operations.  This property is generally only
                observed when such an operation is active&mdash;or when
                an <command>svnsync</command> command failed to cleanly
                disconnect from the repository.  (This property is
                only relevant when it appears on revision 0.)</para>
  -->
              <para>Utilisée pour mettre en œuvre un accès exclusif
                temporaire au dépôt par la commande de duplication
                <command>svnsync</command>. Cette propriété est
                généralement présente seulement quand une opération de
                ce type est en cours (ou quand une commande
                <command>svnsync</command> a échoué à se déconnecter
                proprement du dépôt).
                Cette propriété n'a de sens que si elle est définie sur
                la révision 0.</para>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.file-portability">
<!--
    <title>File Portability</title>
-->
    <title>Portabilité des fichiers</title>

<!--
    <para>Fortunately for Subversion users who routinely find
      themselves on different computers with different operating
      systems, Subversion's command-line program behaves almost
      identically on all those systems.  If you know how to wield
      <command>svn</command> on one platform, you know how to wield it
      everywhere.</para>
-->
    <para>Heureusement pour les utilisateurs de Subversion qui
      travaillent sur différents ordinateurs et systèmes d'exploitation,
      le comportement du client texte interactif est pratiquement
      identique sur tous les systèmes. Si vous vous débrouillez avec
      <command>svn</command> sur un système, vous devriez vous en sortir
      sur n'importe quel système.</para>

<!--
    <para>However, the same is not always true of other general classes
      of software or of the actual files you keep in Subversion.  For
      example, on a Windows machine, the definition of a <quote>text
      file</quote> would be similar to that used on a Linux box, but
      with a key difference&mdash;the character sequences used to mark
      the ends of the lines of those files.  There are other
      differences, too.  Unix platforms have (and Subversion supports)
      symbolic links; Windows does not.  Unix platforms use filesystem
      permission to determine executability; Windows uses filename
      extensions.</para>
-->
    <para>Cependant, ce n'est pas toujours le cas pour d'autres types de
      logiciels ou pour les fichiers que vous gérez dans Subversion. Par
      exemple, sur un système Windows, la définition d'un
      <quote>fichier texte</quote> est similaire à la définition de
      Linux, mais avec une différence notable pour ce qui concerne les
      retours à la ligne. Il y a aussi d'autres différences. Les
      plateformes Unix (et Subversion) supportent la notion de lien
      symbolique&nbsp;; Windows non. Les plateformes Unix utilisent les
      permissions du fichier pour déterminer si un fichier est
      exécutable&nbsp;; Windows utilise l'extension du fichier.</para>

<!--
    <para>Because Subversion is in no position to unite the whole
      world in common definitions and implementations of all of these
      things, the best it can do is to try to help make your life
      simpler when you need to work with your versioned files and
      directories on multiple computers and operating systems.  This
      section describes some of the ways Subversion does this.</para>
-->
    <para>Subversion n'a pas la possibilité d'unifier toutes ces
      définitions et ces implémentations. Tout ce qu'il peut faire,
      c'est aider au maximum l'utilisateur qui travaille sur plusieurs
      systèmes et plusieurs ordinateurs. Cette section décrit comment
      Subversion s'y prend.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.mime-type">
<!--
      <title>File Content Type</title>
-->
      <title>Type de contenu des fichiers</title>

<!--
      <para>Subversion joins the ranks of the many applications that
        recognize and make use of Multipurpose Internet Mail
        Extensions (MIME) content types.  Besides being a
        general-purpose storage location for a file's content type,
        the value of the <literal>svn:mime-type</literal> file
        property determines some behavioral characteristics of
        Subversion itself.</para>
-->
      <para>Subversion fait partie des nombreuses applications qui
        reconnaissent et utilisent les types MIME (Multipurpose Internet
        Mail Extensions). Ainsi, la valeur de la propriété
        <literal>svn:mime-type</literal> permet, en plus de stocker le
        type de contenu d'un fichier, de changer le comportement de
        Subversion lui-même.</para>

      <sidebar>
<!--
        <title>Identifying File Types</title>
-->
        <title>Identification des types de fichiers</title>

<!--
        <para>Various programs on most modern operating systems make
          assumptions about the type and format of the contents of a
          file by the file's name, specifically its file extension.
          For example, files whose names end in
          <filename>.txt</filename> are generally assumed to be
          human-readable; that is, able to be understood by simple perusal
          rather than requiring complex processing to decipher.  Files
          whose names end in <filename>.png</filename>, on the other
          hand, are assumed to be of the Portable Network Graphics
          type&mdash;not human-readable at all, and sensible only when
          interpreted by software that understands the PNG format and
          can render the information in that format as a raster
          image.</para>
-->
        <para>Beaucoup de programmes sur les systèmes d'exploitation
          modernes font des suppositions sur le type et le format du
          contenu d'un fichier à partir de son nom, notamment son
          extension. Par exemple, les fichiers qui se terminent par
          <filename>.txt</filename> sont généralement considérés comme
          lisibles par un être humain, aptes à être compris pratiquement
          tels quels, sans nécessiter un processus de décodage compliqué.
          Les fichiers dont le nom se termine par
          <filename>.png</filename>, en revanche, sont considérés comme
          des fichiers du type "Portable Network Graphics" (PNG),
          illisibles pour un être humain, et utilisables uniquement au
          travers d'un logiciel capable de comprendre le format PNG et
          de l'afficher en tant qu'image matricielle.</para>

<!--
        <para>Unfortunately, some of those extensions have changed
          their meanings over time.  When personal computers first appeared,
          a file named <filename>README.DOC</filename> would have
          almost certainly been a plain-text file, just like today's
          <filename>.txt</filename> files.  But by the mid-1990s, you
          could almost bet that a file of that name would not be a
          plain-text file at all, but instead a Microsoft Word
          document in a proprietary, non-human-readable format.  But
          this change didn't occur overnight&mdash;there was certainly
          a period of confusion for computer users over what exactly
          they had in hand when they saw a <filename>.DOC</filename>
          file.<footnote><para>You think that was rough?  During that
          same era, WordPerfect also used <filename>.DOC</filename>
          for their proprietary file format's preferred
          extension!</para></footnote></para>
-->
        <para>Malheureusement, certaines de ces extensions ont changé de
          sens au fil du temps. Au début des ordinateurs personnels, un
          fichier <filename>LISEZMOI.DOC</filename> aurait
          certainement été un simple fichier texte, comme aujourd'hui
          les fichiers <filename>.txt</filename>. Mais, rendu au milieu
          des années 1990, vous pouviez parier que ce fichier ne serait
          plus un simple fichier texte, mais un document "Microsoft
          Word", format propriétaire et illisible pour un être humain.
          Ce changement n'a pas eu lieu du jour au lendemain et il y a
          eu une période de confusion pour les utilisateurs qui,
          lorsqu'ils tombaient sur un fichier <filename>.doc</filename>,
          ne savaient pas trop de quel type était ce fichier
          <footnote>
            <para>Ca vous semble dur&nbsp;? Et bien, à la même période,
              WordPerfect utilisait aussi <filename>.DOC</filename>
              comme extension préférée de son format de fichier
              propriétaire&nbsp;!</para>
          </footnote>.
        </para>

<!--
        <para>The popularity of computer networking cast still more
          doubt on the mapping between a file's name and its content.
          With information being served across networks and generated
          dynamically by server-side scripts, there was often no real
          file per se, and therefore no filename.  Web
          servers, for example, needed some other way to tell browsers
          what they were downloading so that the browser could do something
          intelligent with that information, whether that was to
          display the data using a program registered to handle that
          datatype or to prompt the user for where on the client
          machine to store the downloaded data.</para>
-->
        <para>L'essor des réseaux informatiques n'a fait qu'ajouter à la
          confusion sur la relation entre le nom d'un fichier et son
          contenu. Avec l'information circulant à travers les réseaux,
          souvent générée dynamiquement par des programmes sur les
          serveurs, il n'y avait plus de fichier en tant que tel et donc
          plus de nom de fichier. Les serveurs Web, par exemple, avaient
          besoin d'un autre moyen pour indiquer au navigateur quel type
          de contenu il télécharge afin qu'il puisse appliquer un
          traitement cohérent à cette information&nbsp;: soit afficher
          les données à l'aide d'un programme qui sait traiter ce type
          de contenu, soit demander à l'utilisateur où stocker les
          données téléchargées.</para>

<!--
        <para>Eventually, a standard emerged for, among other things,
          describing the contents of a data stream.  In 1996, RFC 2045
          was published.  It was the first of five RFCs describing
          MIME.  It describes the concept of media types and subtypes
          and recommends a syntax for the representation of those
          types.  Today, MIME media types&mdash;or <quote>MIME
          types</quote>&mdash;are used almost universally across
          email applications, web servers, and other software as the
          de facto mechanism for clearing up the file content
          confusion.</para>
-->
        <para>Finalement, un standard est apparu pour, entre autres,
          décrire le contenu d'un flux de données. En 1996 était publiée
          la RFC2045, la première des cinq RFC à décrire le format MIME.
          Elle décrit le concept de types de média et de sous-types et
          recommande une syntaxe pour représenter ces types. Aujourd'hui,
          les types de média MIME (ou simplement types MIME) sont
          utilisés de manière pratiquement universelle par les clients
          de messagerie, les serveurs Web et autres logiciels, pour
          déterminer de manière sûre le type de contenu d'un
          fichier.</para>

      </sidebar>

<!--
      <para>For example, one of the benefits that Subversion typically
        provides is contextual, line-based merging of changes received
        from the server during an update into your working file.  But
        for files containing nontextual data, there is often no
        concept of a <quote>line.</quote>  So, for versioned files
        whose <literal>svn:mime-type</literal> property is set to a
        nontextual MIME type (generally, something that doesn't begin
        with <literal>text/</literal>, though there are exceptions),
        Subversion does not attempt to perform contextual merges
        during updates.  Instead, any time you have locally modified a
        binary working copy file that is also being updated, your file
        is left untouched and Subversion creates two new files.  One
        file has a <filename>.oldrev</filename> extension and contains
        the BASE revision of the file.  The other file has a
        <filename>.newrev</filename> extension and contains the
        contents of the updated revision of the file.  This behavior
        is really for the protection of the user against failed
        attempts at performing contextual merges on files that simply
        cannot be contextually merged.</para>
-->
      <para>Par exemple, un avantage fourni par cette reconnaissance de
        type par Subversion est la possibilité de fusion contextuelle,
        ligne par ligne, des changements reçus lors d'une mise à jour.
        En revanche, pour les fichiers contenant autre chose que du
        texte, il n'y a souvent pas de concept de <quote>ligne</quote>.
        En conséquence, pour les fichiers suivis en versions dont la
        propriété <literal>svn:mime-type</literal> contient une valeur
        de type MIME non textuel (généralement un intitulé qui ne
        commence pas par <literal>text/</literal>, bien qu'il y ait des
        exceptions), Subversion ne tente pas de fusion contextuelle
        pendant la mise à jour. À la place, chaque fois que vous avez
        modifié localement un fichier binaire qui a été mis à jour sur
        le dépôt, Subversion ne touche pas à votre fichier mais crée
        deux nouveaux fichiers. Un fichier avec l'extension
        <filename>.oldrev</filename> qui contient la version du fichier
        à la révision BASE. Un autre fichier avec l'extension
        <filename>.newrev</filename> qui contient la version à jour du
        fichier. Ce comportement est dicté par la volonté d'éviter que
        l'utilisateur ne tente d'effectuer une fusion qui échouerait
        parce que les fichiers ne peuvent tout simplement pas être
        fusionnés.</para>

<!--
      <para>Additionally, since the acts of displaying line-based
        differences and line-based change attribution are, rather
        obviously, dependent on there being a meaningful definition
        of <quote>line</quote> for a given file, files with nontextual
        MIME types will by default trigger errors when used as the
        targets of <command>svn diff</command> and <command>svn
        annotate</command> operations.  This can be especially
        frustrating for users with XML files whose
        <literal>svn:mime-type</literal> property is set to something
        such as <literal>application/xml</literal> which is not
        unambiguously human-readable and as such is treated as
        nontextual by Subversion.  Fortunately, those subcommands
        offer a <option>- -force</option> option for forcing
        Subversion to attempt the operations in spite of the apparent
        non-human-readability of the files.</para>
-->
      <para>De plus, puisque le fait d'afficher les différences et les
        modifications ligne par ligne est, c'est évident, dépendant de
        la signification que l'on accorde à une <quote>ligne</quote> du
        fichier considéré, les fichiers dont le type MIME n'est pas
        compatible avec du texte déclenchent par défaut des erreurs
        lorsqu'ils sont la cible de sous-commandes telles que
        <command>svn diff</command> et <command>svn annotate</command>.
        Cela peut s'avérer particulièrement frustrant pour les
        utilisateurs de fichiers XML dont la propriété
        <literal>svn:mime-type</literal> est définie avec une valeur
        comme <literal>application/xml</literal> qui n'est pas
        interprétée par Subversion comme lisible par un humain car
        relativement ambigüe. Heureusement, ces sous-commandes proposent
        l'option <option>--force</option> pour obliger Subversion à
        essayer d'opérer sur ces fichiers malgré leur apparente
        illisibilité pour un humain.</para>
      <warning>
<!--
        <para>The <literal>svn:mime-type</literal> property, when set
          to a value that does not indicate textual file contents, can
          cause some unexpected behaviors with respect to other
          properties.  For example, since the idea of line endings
          (and therefore, line-ending conversion) makes no sense when
          applied to nontextual files, Subversion will prevent you
          from setting the <literal>svn:eol-style</literal> property
          on such files.  This is obvious when attempted on a single
          file target&mdash;<command>svn propset</command> will error
          out.  But it might not be as clear if you perform a
          recursive property set, where Subversion will silently skip
          over files that it deems unsuitable for a given
          property.</para>
      </warning>
-->
        <para>La propriété <literal>svn:mime-type</literal>, lorsqu'elle
          est définie avec une valeur qui n'indique pas de contenu
          textuel, peut entrainer des comportements inattendus avec les
          autres propriétés. Par exemple, comme la notion de fin de
          ligne (et donc de conversion de caractère de fin de ligne) n'a
          pas de sens pour un fichier binaire, Subversion vous
          empêche de définir la propriété
          <literal>svn:eol-style</literal> sur ces fichiers. Cela saute
          aux yeux lorsque vous travaillez sur un seul fichier et que
          <command>svn propset</command> génère une erreur. C'est
          beaucoup moins évident si vous effectuez une opération
          récursive, où Subversion omet silencieusement les fichiers
          qu'il considère inappropriés pour une propriété donnée.</para>
      </warning>

<!--
      <para>Subversion provides a number of mechanisms by which to
        automatically set the <literal>svn:mime-type</literal>
        property on a versioned file.  See
        <xref linkend="svn.advanced.props.auto" /> for details.</para>
-->
      <para>Subversion fournit plusieurs mécanismes pour définir
        automatiquement la propriété <literal>svn:mime-type</literal>
        sur un fichier suivi en versions. Consultez <xref
        linkend="svn.advanced.props.auto"/> pour en obtenir les
        détails.</para>

<!--
      <para>Also, if the <literal>svn:mime-type</literal> property is
        set, then the Subversion Apache module will use its value to
        populate the <literal>Content-type:</literal> HTTP header when
        responding to GET requests.  This gives your web browser a
        crucial clue about how to display a file when you use it to
        peruse your Subversion repository's contents.</para>
-->
      <para>Par ailleurs, si la propriété
        <literal>svn:mime-type</literal> est définie, alors le greffon
        Apache pour Subversion utilise cette valeur pour renseigner le
        champ <literal>Content-type:</literal> de l'en-tête HTTP en
        réponse à une requête GET. Cela fournit au navigateur Web une
        indication très importante pour pouvoir afficher correctement le
        fichier, quand vous l'utilisez pour parcourir le contenu du
        dépôt Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.executable">
<!--
      <title>File Executability</title>
-->
      <title>Fichiers exécutables ou non</title>

<!--
      <para>On many operating systems, the ability to execute a file
        as a command is governed by the presence of an execute
        permission bit.  This bit usually defaults to being disabled,
        and must be explicitly enabled by the user for each file that
        needs it.  But it would be a monumental hassle to have to
        remember exactly which files in a freshly checked-out working
        copy were supposed to have their executable bits toggled on,
        and then to have to do that toggling.  So, Subversion provides
        the <literal>svn:executable</literal> property as a way to
        specify that the executable bit for the file on which that
        property is set should be enabled, and Subversion honors that
        request when populating working copies with such files.</para>
-->
      <para>Sur beaucoup de systèmes d'exploitation, la capacité de
        rendre un fichier exécutable dépend d'un bit dit
        <quote>exécutable</quote>. Habituellement, ce bit est désactivé
        par défaut et doit être explicitement activé par l'utilisateur
        pour chaque fichier concerné. Ce serait une perte de temps
        énorme d'avoir à se rappeler exactement quel fichier, parmi ceux
        que l'on vient d'extraire du dépôt, doit avoir le bit exécutable
        positionné et ensuite de devoir le faire manuellement. C'est
        pourquoi Subversion fournit la propriété
        <literal>svn:executable</literal> pour spécifier que le bit
        exécutable doit être activé pour le fichier concerné. Subversion
        s'occupe lui-même de cette tâche quand il rapatrie de tels
        fichiers dans la copie de travail locale.</para>

<!--
      <para>This property has no effect on filesystems that have no
        concept of an executable permission bit, such as FAT32 and
        NTFS.<footnote><para>The Windows filesystems use file
        extensions (such
        as <filename>.EXE</filename>, <filename>.BAT</filename>, and
        <filename>.COM</filename>) to denote executable
        files.</para></footnote>  Also, although it has no defined
        values, Subversion will force its value
        to <literal>*</literal> when setting this property.  Finally,
        this property is valid only on files, not on
        directories.</para>
-->
      <para>Cette propriété n'a aucun effet sur les systèmes de fichiers
        qui ne possèdent pas le concept du bit exécutable, tels que
        FAT32 et NTFS
        <footnote>
          <para>Les systèmes de fichiers Windows utilisent les extensions
            des fichiers (telles que
            <filename>.EXE</filename>, <filename>.BAT</filename> et
            <filename>.COM</filename>) pour indiquer que les fichiers
            sont exécutables.</para>
        </footnote>.
        Par ailleurs, bien qu'elle n'ait pas de valeurs définies,
        Subversion lui attribue la valeur <literal>*</literal>
        lorsqu'il active cette propriété. Enfin, cette propriété n'est
        valide que sur des fichiers, pas sur des dossiers.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.eol-style">
<!--
      <title>End-of-Line Character Sequences</title>
-->
      <title>Caractères de fin de ligne</title>

<!--
      <para>Unless otherwise noted using a versioned file's
        <literal>svn:mime-type</literal> property, Subversion
        assumes the file contains human-readable data.  Generally
        speaking, Subversion uses this knowledge only to determine
        whether contextual difference reports for that file are
        possible.  Otherwise, to Subversion, bytes are bytes.</para>
-->
      <para>Pour tout fichier suivi en versions, Subversion considère
        que le contenu est lisible par un humain sauf si la propriété
        <literal>svn:mime-type</literal> indique le contraire. En
        règle générale, Subversion utilise cette information pour
        déterminer s'il est possible d'effectuer une comparaison
        contextuelle pour ce fichier. Sinon, pour Subversion, les octets
        sont des octets.</para>

<!--
      <para>
        <indexterm>
          <primary>line endings</primary>
        </indexterm>
        <indexterm>
          <primary>end-of-line (EOL) markers</primary>
          <see>line endings</see>
        </indexterm>This means that by default, Subversion doesn't pay
        any attention to the type of <firstterm>end-of-line (EOL)
        markers</firstterm> used in your files.  Unfortunately,
        different operating systems have different conventions about
        which character sequences represent the end of a line of text
        in a file.  For example, the usual line-ending token used by
        software on the Windows platform is a pair of ASCII control
        characters&mdash;a carriage return (<literal>CR</literal>)
        followed by a line feed (<literal>LF</literal>).  Unix
        software, however, just uses the <literal>LF</literal>
        character to denote the end of a line.</para>
-->
      <para>
        <indexterm>
          <primary>fins de lignes</primary>
        </indexterm>
        <indexterm>
          <primary>end-of-line (EOL)</primary>
          <see>fins de lignes</see>
        </indexterm>Cela veut dire que par défaut, Subversion ne
        s'intéresse pas au type de caractère utilisé pour marquer les
        <firstterm>fins de lignes</firstterm>
        (<foreignphrase>EOL</foreignphrase> en anglais, pour
        <foreignphrase>End Of Line</foreignphrase>). Malheureusement,
        des conventions différentes sont utilisées suivant les systèmes
        d'exploitation pour indiquer une fin de ligne de texte dans un
        fichier. Par exemple, les logiciels sous Windows utilisent
        généralement une paire de caractères de contrôle ASCII&nbsp;: un
        retour chariot (<literal>CR</literal>, <foreignphrase>carriage
        return</foreignphrase>) suivi par un saut de ligne
        (<literal>LF</literal>, <foreignphrase>line feed</foreignphrase>).
        Les logiciels Unix, cependant, utilisent uniquement le caractère
        <literal>LF</literal> pour indiquer les fins de lignes.</para>

<!--
      <para>Not all of the various tools on these operating systems
        understand files that contain line endings in a format that
        differs from the <firstterm>native line-ending
        style</firstterm> of the operating system on which they are
        running.  So, typically, Unix programs treat the
        <literal>CR</literal> character present in Windows files as a
        regular character (usually rendered as <literal>^M</literal>),
        and Windows programs combine all of the lines of a Unix file
        into one giant line because no <literal>CR</literal>
        characters are found to denote the ends of the lines.</para>
-->
      <para>Tous les programmes ne savent pas gérer les fichiers
        utilisant un marqueur de fin de ligne <quote>exogène</quote> au
        système d'exploitation sur lequel ils tournent. Ainsi, il n'est
        pas rare de voir les programmes Unix traiter le marqueur
        <literal>CR</literal> des fichiers Windows comme un caractère
        normal (en affichant à l'écran un <literal>^M</literal>) et les
        programmes Windows combiner en une seule ligne immense un fichier
        Unix parce qu'ils n'y ont pas trouvé la combinaison retour
        chariot-passage à la ligne (<literal>CR-LF</literal>). </para>

<!--
      <para>This sensitivity to foreign EOL markers can be
        frustrating for folks who share a file across different
        operating systems.  For example, consider a source code
        file, and developers who edit this file on both Windows and
        Unix systems.  If all the developers always use tools that
        preserve the line-ending style of the file, no problems
        occur.</para>
-->
      <para>Cette incapacité de traiter correctement les marqueurs de
        fin de ligne d'autres plates-formes peut être assez frustrante
        pour ceux qui partagent des fichiers entre différents systèmes
        d'exploitation. Prenons l'exemple d'un fichier de code source
        qui est édité par des développeurs à la fois sous Windows et
        sous Unix. Si tous les développeurs utilisent des outils qui se
        plient à la convention utilisée par le fichier, pas de
        problème.</para>

<!--
      <para>But in practice, many common tools either fail to
        properly read a file with foreign EOL markers, or
        convert the file's line endings to the native style when the
        file is saved.  If the former is true for a developer, he
        has to use an external conversion utility (such as
        <command>dos2unix</command> or its companion,
        <command>unix2dos</command>) to prepare the file for
        editing.  The latter case requires no extra preparation.
        But both cases result in a file that differs from the
        original quite literally on every line!  Prior to committing
        his changes, the user has two choices.  Either he can use a
        conversion utility to restore the modified file to the same
        line-ending style that it was in before his edits were made,
        or he can simply commit the file&mdash;new EOL markers and
        all.</para>
-->
      <para>Mais, en pratique, de nombreux outils largement utilisés
        soit ne parviennent pas à lire correctement un fichier utilisant
        une convention différente pour les fins de ligne, soit ils
        convertissent les fins de lignes au format local lors de la
        sauvegarde. Dans le premier cas, le développeur doit utiliser
        des outils externes (tels que <command>dos2unix</command> et son
        compagnon <command>unix2dos</command>) pour préparer le fichier
        avant l'édition. Dans le deuxième cas, pas besoin de
        préparation. Mais dans les deux cas, le fichier résultant
        diffère de l'original littéralement pour toutes les
        lignes&nbsp;! Avant de propager ses changements, l'utilisateur a
        deux choix. Soit il utilise un utilitaire de conversion pour
        revenir à la même convention qu'avant l'édition. Soit il propage
        le fichier avec la nouvelle convention de fin de ligne.</para>

<!--
      <para>The result of scenarios like these include wasted time
        and unnecessary modifications to committed files.  Wasted
        time is painful enough.  But when commits change every line
        in a file, this complicates the job of determining which of
        those lines were changed in a nontrivial way.  Where was
        that bug really fixed?  On what line was a syntax error
        introduced?</para>
-->
      <para>Au final, les deux hypothèses conduisent à une perte de
        temps et des modifications inutiles sur les fichiers propagés.
        La perte de temps est déjà pénible. Mais si en plus la
        propagation change chaque ligne du fichier, trouver quelle
        ligne a effectivement changé devient non trivial. À quel endroit
        ce bogue a-t-il réellement été corrigé&nbsp;? Dans quelle ligne
        y avait-il cette erreur de syntaxe&nbsp;? </para>

<!--
      <para>The solution to this problem is the
        <literal>svn:eol-style</literal> property.  When this
        property is set to a valid value, Subversion uses it to
        determine what special processing to perform on the file so
        that the file's line-ending style isn't flip-flopping with
        every commit that comes from a different operating
        system.  The valid values are:</para>
-->
      <para>La solution à ce problème est la propriété
        <literal>svn:eol-style</literal> (eol pour <foreignphrase>End Of
        Line</foreignphrase>). Quand cette propriété possède une valeur
        valide, Subversion l'utilise pour déterminer quel traitement il
        doit appliquer pour que le fichier ne change pas de convention à
        chaque propagation provenant d'un système d'exploitation
        différent. Les valeurs valides sont&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><literal>native</literal></term>
          <listitem>
<!--
            <para>This causes the file to contain the EOL markers
              that are native to the operating system on which
              Subversion was run.  In other words, if a user on a
              Windows machine checks out a working copy that
              contains a file with an
              <literal>svn:eol-style</literal> property set to
              <literal>native</literal>, that file will contain
              <literal>CRLF</literal> EOL markers.  A Unix user
              checking out a working copy that contains the same
              file will see <literal>LF</literal> EOL markers in his
              copy of the file.</para>
-->
            <para>Ceci force le fichier à adopter la convention
              utilisée par le système d'exploitation sur lequel
              s'exécute Subversion. En d'autres termes, si un
              utilisateur d'une machine Windows récupère une copie de
              travail d'un fichier dont la propriété
              <literal>svn:eol-style</literal> vaut
              <literal>native</literal>, ce fichier contiendra le
              marqueur <literal>CRLF</literal> pour indiquer les fins de
              ligne. Un utilisateur Unix qui récupère une copie de
              travail qui contient le même fichier verra simplement
              <literal>LF</literal> pour indiquer les fins de ligne sur
              sa copie.</para>

<!--
            <para>Note that Subversion will actually store the file
              in the repository using normalized
              <literal>LF</literal> EOL markers regardless of the
              operating system.  This is basically transparent to
              the user, though.</para>
-->
            <para>Notez que Subversion stocke en fait le fichier dans
              le dépôt en utilisant le marqueur standard
              <literal>LF</literal> indépendamment du système
              d'exploitation. Cela reste toutefois tout à fait
              transparent pour l'utilisateur.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CRLF</literal></term>
          <listitem>
<!--
            <para>This causes the file to contain
              <literal>CRLF</literal> sequences for EOL markers,
              regardless of the operating system in use.</para>
-->
            <para>Le fichier contiendra le marqueur
              <literal>CRLF</literal> pour indiquer les fins de ligne,
              quel que soit le système d'exploitation..</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>LF</literal></term>
          <listitem>
<!--
            <para>This causes the file to contain
              <literal>LF</literal> characters for EOL markers,
              regardless of the operating system in use.</para>
-->
            <para>Le fichier contiendra le marqueur
              <literal>LF</literal> pour indiquer les fins de ligne,
              quel que soit le système d'exploitation.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CR</literal></term>
          <listitem>
<!--
            <para>This causes the file to contain
              <literal>CR</literal> characters for EOL markers,
              regardless of the operating system in use.  This
              line-ending style is not very common.</para>
-->
            <para>Le fichier contiendra le marqueur
              <literal>CR</literal> pour indiquer les fins de ligne,
              quel que soit le système d'exploitation. Ce marqueur de
              fin de ligne n'est pas très courant.</para>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.ignore">
<!--
    <title>Ignoring Unversioned Items</title>
-->
    <title>Occultation des éléments non suivis en versions</title>

<!--
    <para>In any given working copy, there is a good chance that
      alongside all those versioned files and directories are other
      files and directories that are neither versioned nor intended
      to be.  Text editors litter directories with backup files.
      Software compilers generate intermediate&mdash;or even
      final&mdash;files that you typically wouldn't bother to
      version.  And users themselves drop various other files and
      directories wherever they see fit, often in version control
      working copies.</para>
-->
    <para>Dans n'importe quelle copie de travail, il y a de grandes
      chances que les fichiers et dossiers suivis en versions
      côtoient d'autres fichiers et dossiers non suivis en versions
      ou qui n'ont pas lieu de l'être. Les éditeurs de texte remplissent
      les dossiers avec des fichiers de sauvegarde. Les compilateurs
      créent des fichiers intermédiaires (ou même des fichiers finaux)
      que vous ne voudrez pas suivre en versions. Et les utilisateurs
      eux-mêmes déposent des fichiers et des dossiers où bon leur
      semble, souvent dans des copies de travail locales.</para>

<!--
    <para>It's ludicrous to expect Subversion working copies to be
      somehow impervious to this kind of clutter and impurity.  In
      fact, Subversion counts it as a <emphasis>feature</emphasis>
      that its working copies are just typical directories, just like
      unversioned trees.  But these not-to-be-versioned files and
      directories can cause some annoyance for Subversion users.  For
      example, because the <command>svn add</command> and <command>svn
      import</command> commands act recursively by default and don't
      know which files in a given tree you do and don't wish to
      version, it's easy to accidentally add stuff to version control
      that you didn't mean to.  And because <command>svn
      status</command> reports, by default, every item of interest in
      a working copy&mdash;including unversioned files and
      directories&mdash;its output can get quite noisy where many of
      these things exist.</para>
-->
    <para>Il est ridicule de penser que les copies de travail Subversion
      échappent à ce type de méli-mélo. En fait, Subversion prend en
      compte (c'est une <emphasis>fonctionnalité</emphasis>) dès le début
      que les copies de travail sont des dossiers comme les autres,
      comme ceux qui ne sont pas suivis en versions. Mais ces fichiers
      et dossiers qui-n-ont-pas-vocation-à-être-suivis-en-versions
      peuvent perturber les utilisateurs de Subversion. Par exemple,
      comme les commandes <command>svn add</command> et <command>svn
      import</command> sont récursives par défaut et ne savent pas
      quels fichiers de l'arborescence vous voulez suivre ou non en
      versions, il est relativement facile d'ajouter au suivi de
      versions des éléments que vous ne vouliez pas suivre. Et comme la
      commande <command>svn status</command> liste, par défaut, tous
      les éléments intéressants de la copie de travail, y compris les
      fichiers et dossiers non suivis en versions, son affichage
      devient rapidement confus avec de tels imbroglios.</para>

<!--
    <para>
      <indexterm>
        <primary>file patterns</primary>
      </indexterm>
      <indexterm>
        <primary>globs</primary>
        <see>file patterns</see>
      </indexterm>
      <indexterm>
        <primary>shell wildcard patterns</primary>
        <see>file patterns</see>
      </indexterm>So Subversion provides several ways for telling it
      which files you would prefer that it simply disregard.  One of
      the ways involves the use of Subversion's runtime configuration
      system (see <xref linkend="svn.advanced.confarea" />), and
      therefore applies to all the Subversion operations that make use
      of that runtime configuration&mdash;generally those performed on
      a particular computer or by a particular user of a computer.
      Two other methods make use of Subversion's directory property
      support and are more tightly bound to the versioned tree itself,
      and therefore affects everyone who has a working copy of that
      tree.  All of these mechanisms use <firstterm>file
      patterns</firstterm> (strings of literal and special wildcard
      characters used to match against filenames) to decide which
      files to ignore.</para>
-->
    <para>
      <indexterm>
        <primary>motifs de noms de fichiers</primary>
      </indexterm>
      <indexterm>
        <primary>globs</primary>
        <see>motifs de noms de fichiers</see>
      </indexterm>
      <indexterm>
        <primary>motifs de filtrage du shell</primary>
        <see>motifs de noms de fichiers</see>
      </indexterm>C'est pourquoi Subversion fournit plusieurs méthodes
      pour pouvoir lui indiquer quels fichiers vous souhaitez ignorer.
      La première implique l'utilisation de la zone de configuration
      (voir <xref linkend="svn.advanced.confarea" />) et, par
      conséquent, s'applique à toutes les opérations Subversion qui
      utilisent cette zone de configuration, généralement toutes celles
      de l'ordinateur ou d'un utilisateur particulier de l'ordinateur.
      Deux autres méthodes utilisent les propriétés Subversion des
      dossiers et sont plus liées à l'arborescence suivie en versions
      elle-même. Par conséquent, elles affectent tous ceux qui possèdent
      une copie de travail de cette arborescence. Tous ces mécanismes
      utilisent des <firstterm>motifs de noms de fichiers</firstterm>
      (des chaines de caractères simples ou des jokers) pour trouver des
      correspondances avec les noms de fichiers qu'il faut
      ignorer.</para>

<!--
    <para>The Subversion runtime configuration system provides an
      option, <literal>global-ignores</literal>, whose value is a
      whitespace-delimited collection of file patterns.  The
      Subversion client checks these patterns against the names of the
      files that are candidates for addition to version control, as
      well as to unversioned files that the <command>svn
      status</command> command notices.  If any file's name matches
      one of the patterns, Subversion will basically act as if the
      file didn't exist at all.  This is really useful for the kinds
      of files that you almost never want to version, such as editor
      backup files such as Emacs' <literal>*~</literal> and
      <literal>.*~</literal> files.</para>
-->
    <para>La zone de configuration de Subversion propose une directive,
      <literal>global-ignores</literal>, dont la valeur est un ensemble
      de motifs de noms de fichiers séparés par des espaces. Le client
      Subversion compare ces motifs aux noms des fichiers que l'on tente
      d'ajouter au suivi de versions, ainsi qu'aux noms des fichiers non
      suivis en versions détectés par la commande <command>svn
      status</command>. Si un nom de fichier correspond au motif,
      Subversion ignore totalement ce fichier. C'est particulièrement
      utile pour les fichiers que vous ne voulez jamais suivre en
      versions, comme les fichiers de sauvegarde créés par les éditeurs
      de texte (par exemple, les fichiers <literal>*~</literal> et
      <literal>.*~</literal> créés par Emacs).</para>

    <sidebar>
<!--
      <title>File Patterns in Subversion</title>
-->
      <title>Les motifs de noms de fichiers dans Subversion</title>

<!--
      <para>File patterns (also called <firstterm>globs</firstterm> or
        <firstterm>shell wildcard patterns</firstterm>) are strings of
        characters that are intended to be matched against filenames,
        typically for the purpose of quickly selecting some subset of
        similar files from a larger grouping without having to
        explicitly name each file.  The patterns contain two types of
        characters:  regular characters, which are compared explicitly
        against potential matches, and special wildcard characters,
        which are interpreted differently for matching
        purposes.</para>
-->
      <para>Les motifs de noms de fichiers (également appelés
        <firstterm>globs</firstterm> ou motifs de filtrage du shell)
        sont des chaînes de caractères destinées à être comparées
        à des noms de fichiers, en général dans le but de sélectionner
        rapidement un sous-ensemble de fichiers similaires au sein d'un
        ensemble plus large, sans avoir à nommer explicitement chaque
        fichier. Les motifs contiennent deux types de caractères&nbsp;:
        les caractères standard, qui sont comparés explicitement aux
        noms de fichiers, et les caractères spéciaux (aussi nommés
        quantificateurs), qui sont interprétés différemment. </para>

<!--
      <para>There are different types of file pattern syntaxes, but
        Subversion uses the one most commonly found in Unix systems
        implemented as the <function>fnmatch</function> system
        function.  It supports the following wildcards, described here
        simply for your convenience:</para>
-->
      <para>Il existe différents types de syntaxe de motifs, mais
        Subversion utilise celle qui est la plus répandue sur les
        systèmes Unix, implémentée dans la fonction
        <function>fnmatch</function>. Elle reconnaît les caractères
        spéciaux suivants, décrits ici à titre
        d'information&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><literal>?</literal></term>
          <listitem>
<!--
            <para>Matches any single character</para>
-->
            <para>Correspond à n'importe quel caractère unique.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>*</literal></term>
          <listitem>
<!--
            <para>Matches any string of characters, including the
              empty string</para>
-->
            <para>Correspond à n'importe quelle chaîne de caractères, y
              compris la chaîne vide.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>[</literal></term>
          <listitem>
<!--
            <para>Begins a character class definition terminated by
              <literal>]</literal>, used for matching a subset of
              characters</para>
-->
            <para>Marque le début de la définition d'une classe de
              caractères, se terminant par <literal>]</literal>,
              utilisée pour décrire un sous-ensemble de
              caractères.</para>
          </listitem>
        </varlistentry>
      </variablelist>

<!--
      <para>You can see this same pattern matching behavior at a Unix
        shell prompt.  The following are some examples of patterns
        being used for various things:</para>
-->
      <para>Vous pouvez observer ce même filtrage de motifs à l'invite
        de commandes d'un shell Unix. Voici des exemples de
        motifs utilisés pour différentes choses&nbsp;:</para>

      <informalexample>
        <screen> <!--
$ ls   ### the book sources
-->
$ ls   ### les sources du livre
appa-quickstart.xml             ch06-server-configuration.xml
appb-svn-for-cvs-users.xml      ch07-customizing-svn.xml
appc-webdav.xml                 ch08-embedding-svn.xml
book.xml                        ch09-reference.xml
ch00-preface.xml                ch10-world-peace-thru-svn.xml
ch01-fundamental-concepts.xml   copyright.xml
ch02-basic-usage.xml            foreword.xml
ch03-advanced-topics.xml        images/
ch04-branching-and-merging.xml  index.xml
ch05-repository-admin.xml       styles.css <!--
$ ls ch*   ### the book chapters
-->
$ ls ch*   ### les chapitres du livre
ch00-preface.xml                ch06-server-configuration.xml
ch01-fundamental-concepts.xml   ch07-customizing-svn.xml
ch02-basic-usage.xml            ch08-embedding-svn.xml
ch03-advanced-topics.xml        ch09-reference.xml
ch04-branching-and-merging.xml  ch10-world-peace-thru-svn.xml
ch05-repository-admin.xml <!--
$ ls ch?0-*   ### the book chapters whose numbers end in zero
-->
$ ls ch?0-*   ### les chapitres du livre dont le numéro se termine par 0
ch00-preface.xml  ch10-world-peace-thru-svn.xml <!--
$ ls ch0[3578]-*   ### the book chapters that Mike is responsible for
-->
$ ls ch0[3578]-*   ### les chapitres du livre dont Mike est responsable
ch03-advanced-topics.xml   ch07-customizing-svn.xml
ch05-repository-admin.xml  ch08-embedding-svn.xml
$
</screen>
      </informalexample>

<!--
      <para>File pattern matching is a bit more complex than what
        we've described here, but this basic usage level tends to suit
        the majority of Subversion users.</para>
-->
      <para>Le filtrage par motif de fichiers est un peu plus complexe
        que ce que nous avons décrit ici, mais ce niveau d'utilisation
        semble suffire à la majorité des utilisateurs de
        Subversion.</para>

    </sidebar>

<!--
    <para>When found on a versioned directory, the
      <literal>svn:ignore</literal> property is expected to contain a
      list of newline-delimited file patterns that Subversion should
      use to determine ignorable objects in that
      <emphasis>same</emphasis> directory.
      These patterns do not override those found in the
      <literal>global-ignores</literal> runtime configuration option,
      but are instead appended to that list.  And it's worth noting
      again that, unlike the <literal>global-ignores</literal> option,
      the patterns found in the <literal>svn:ignore</literal>
      property apply only to the directory on which that property is
      set, and not to any of its subdirectories.  The
      <literal>svn:ignore</literal> property is a good way to tell
      Subversion to ignore files that are likely to be present in
      every user's working copy of that directory, such as compiler
      output or&mdash;to use an example more appropriate to this
      book&mdash;the HTML, PDF, or PostScript files generated as the
      result of a conversion of some source DocBook XML files to a
      more legible output format.</para>
-->
    <para>Pour un dossier suivi en versions, la propriété
      <literal>svn:ignore</literal> est supposée contenir une liste de
      motifs de noms de fichiers (un motif par ligne) que Subversion
      utilise pour déterminer quels objets ignorer dans le dossier
      concerné. Ces motifs ne remplacent pas les motifs inscrits dans
      la directive <literal>global-ignores</literal> de la zone de
      configuration, mais s'ajoutent à cette liste. Veuillez également
      noter que, contrairement à la directive
      <literal>global-ignores</literal>, les motifs de la propriété
      <literal>svn:ignore</literal>
      s'appliquent uniquement au dossier pour lequel la propriété est
      définie et pas à ses sous-dossiers. La propriété
      <literal>svn:ignore</literal> est utile pour indiquer à Subversion
      d'ignorer les fichiers susceptibles d'être présents dans la copie
      de travail de ce dossier chez chaque utilisateur comme les fichiers
      produits par les compilateurs ou, pour citer un exemple plus approprié
      à ce livre, les fichiers HTML, PDF ou PostScript générés par la
      conversion des fichiers sources DocBook XML vers un format de fichier
      plus lisible.</para>

<!--
    <para>Subversion 1.8 provides a more powerful version of the
      <literal>svn:ignore</literal> property, the
      <literal>svn:global-ignores</literal> property.  Like the
      <literal>svn:ignore</literal> property,
      <literal>svn:global-ignores</literal> can only be set
      on a directory and contains file patterns Subversion uses to
      determine ignorable objects.<footnote><para>The ignore patterns
      in the <literal>svn:global-ignores</literal> property may be
      delimited with any whitespace (similar to the
      <literal>global-ignores</literal> runtime configuration option),
      not just newlines (as with the <literal>svn:ignore</literal>
      property).</para></footnote> These ignore patterns are also
      appended to any patterns defined in the
      <literal>global-ignores</literal> runtime configuration option
      together with any <literal>svn:ignore</literal> defined patterns.
      Unlike <literal>svn:ignore</literal> however, the
      <literal>svn:global-ignores</literal> property is inheritable
      <footnote><para>Of course only a 1.8 or newer Subversion client
      will recognize the inheritability and special meaning of the
      <literal>svn:global-ignores</literal> property!</para></footnote>
      and applies to <emphasis>all</emphasis> paths under the directory on
      which the property is set, not just the immediate children of the
      directory.</para>
-->
    <para>Subversion 1.8 fournit une version plus puissante de la
      propriété <literal>svn:ignore</literal>&nbsp;: la propriété
      <literal>svn:global-ignores</literal>. Comme la propriété
      <literal>svn:ignore</literal>,
      <literal>svn:global-ignores</literal> ne peut être définie que
      pour un dossier et elle contient les motifs de noms de fichiers
      que Subversions doit ignorer<footnote><para>Les motifs de la
      propriété <literal>svn:global-ignores</literal> doivent être
      séparés par des blancs (comme pour la directive
      <literal>global-ignores</literal> de la zone de configuration),
      pas uniquement des fins de lignes (au contraire de la propriété
      <literal>svn:ignore</literal>).</para></footnote>. Ces motifs à
      ignorer sont aussi ajoutés aux motifs définis dans la zone de
      configuration par la directive <literal>global-ignores</literal>
      et à ceux définis par la propriété <literal>svn:ignore</literal>.
      Contrairemen à  <literal>svn:ignore</literal>, la propriété
      <literal>svn:global-ignores</literal> s'hérite<footnote>
		  <para> Naturellement, seuls les clients Subversion 1.8 ou plus
		  récents reconnaîtront l'héritage et la signification de la
		  propriété <literal>svn:global-ignores</literal>&nbsp;!</para>
	  </footnote> et elle s'applique à <emphasis>tous</emphasis> les
	  chemins placés sous le dossier sur lequel la propriété est
	  définie, pas seulement les fils directs de ce dossier.</para>

<!--
    <note>
      <para>Subversion's support for ignorable file patterns extends
        only to the one-time process of adding unversioned
        files and directories to version control.  Once an object is
        under Subversion's control, the ignore pattern mechanisms no
        longer apply to it.  In other words, don't expect Subversion
        to avoid committing changes you've made to a versioned file
        simply because that file's name matches an ignore
        pattern&mdash;Subversion <emphasis>always</emphasis> notices
        all of its versioned objects.</para>
    </note>
-->
    <note>
      <para>Le support des motifs de fichiers à ignorer dans Subversion
        s'applique uniquement à la procédure d'ajout de fichiers et
        dossiers non suivis en versions vers la gestion de versions.
        Une fois que l'objet est suivi en versions par Subversion, les
        mécanismes permettant d'ignorer certains fichiers selon des
        motifs prédéfinis ne s'appliquent plus. Autrement dit, ne pensez
        pas que Subversion ne propagera pas les changements que vous
        avez faits à un fichier suivi en versions simplement parce que
        son nom correspond à un motif à ignorer&nbsp;: Subversion prend
        <emphasis>toujours</emphasis> en compte l'ensemble des objets
        qu'il gère.</para>
    </note>

    <sidebar>
<!--
      <title>Ignore Patterns for CVS Users</title>
-->
      <title>Motifs de fichier à ignorer pour les utilisateurs de
        CVS</title>

<!--
      <para>The Subversion <literal>svn:ignore</literal> property is
        very similar in syntax and function to the CVS
        <filename>.cvsignore</filename> file.  In fact, if you are
        migrating a CVS working copy to Subversion, you can directly
        migrate the ignore patterns by using the
        <filename>.cvsignore</filename> file as input to the
        <command>svn propset</command> command:</para>
-->
      <para>La syntaxe et le fonctionnement de la propriété
        <literal>svn:ignore</literal> de Subversion sont très similaires
        à ceux du fichier <filename>.cvsignore</filename> de CVS. Si
        vous migrez une copie de travail CVS vers Subversion, vous
        pouvez migrer directement les motifs à ignorer en utilisant le
        fichier <filename>.cvsignore</filename> comme entrée à la
        commande <command>svn propset</command>&nbsp;:</para>

      <informalexample>
        <screen>
$ svn propset svn:ignore -F .cvsignore .  <!--
property 'svn:ignore' set on '.'
-->
Propriété 'svn:ignore' définie sur '.'
$
</screen>
      </informalexample>

<!--
      <para>There are, however, some differences in the ways that CVS
        and Subversion handle ignore patterns.  The two systems use
        the ignore patterns at some different times, and there are
        slight discrepancies in what the ignore patterns apply to.
        Also, Subversion does not recognize the use of the
        <literal>!</literal> pattern as a reset back to having no
        ignore patterns at all.</para>
-->
      <para>Il y a quand même quelques différences entre CVS et
        Subversion concernant les motifs à ignorer. Les deux systèmes
        n'utilisent pas les motifs au même moment et il y a quelques
        légères divergences sur ce sur quoi ils s'appliquent.
        D'ailleurs, Subversion ne reconnaît pas le motif
        <literal>!</literal> pour revenir à une situation où aucun motif
        n'est ignoré.</para>

    </sidebar>

<!--
    <para>The ignore patterns in the <literal>global-ignores</literal>
      runtime configuration option tend to be more a
      matter of personal taste<footnote><para>Despite being a matter
      of personal taste, if you don't explicitly set the
      <literal>global-ignores</literal> runtime
      configuration option&mdash;either to your preferred set of
      patterns or to an empty string&mdash;Subversion uses a default
      value.  See the <literal>global-ignores</literal> entry in
      <xref linkend="svn.advanced.confarea.opts.config"/></para>
      </footnote> and ties more closely to a user's particular tool
      chain than to the details of any particular working copy's needs.
      So, the rest of this section will focus
      on the <literal>svn:ignore</literal> and
      <literal>svn:global-ignores</literal> properties and their
      uses.</para>
-->
    <para>La liste globale des motifs à ignorer définie dans la
      directive <literal>global-ignores</literal> de la zone de
      configuration reste une affaire de goût<footnote>
		<para>Bien que ce soit une affaire de goût, si vous ne
		définissez pas explicitement de valeur pour la directive
		<literal>global-ignores</literal> dans la zone de configuration,
		soit avec votre ensemble préféré de motifs, soit avec une
		chaine vide, alors Subversion utilise une valeur par défaut.
		Regardez l'entrée <literal>global-ignores</literal> dans
        <xref linkend="svn.advanced.confarea.opts.config"/>.
		</para></footnote>, car elle doit davantage s'intégrer à la
	  collection d'outils de l'utilisateur que répondre aux besoins
	  d'une copie de travail particulière. C'est pourquoi le reste de
	  cette section s'attache à décrire l'utilisation des propriétés
      <literal>svn:ignore</literal> et
      <literal>svn:global-ignores</literal>.</para>

<!--
    <para>Say you have the following output from <command>svn
      status</command>:</para>
-->
    <para>Prenons par exemple le résultat suivant de la commande
      <command>svn status</command>&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn status calc
 M      calc/button.c
?       calc/calculator
?       calc/data.c-->
 M     calc/bouton.c
?      calc/calculatrice
?      calc/donnees.c
?       calc/debug_log
?       calc/debug_log.1
?       calc/debug_log.2.gz
?       calc/debug_log.3.gz
</screen>
    </informalexample>

<!--
    <para>In this example, you have made some property modifications
      to <filename>button.c</filename>, but in your working copy, you
      also have some unversioned files: the latest
      <filename>calculator</filename> program that you've compiled
      from your source code, a source file named
      <filename>data.c</filename>, and a set of debugging output
      logfiles.  Now, you know that your build system always results
      in the <filename>calculator</filename> program being
      generated.<footnote><para>Isn't that the whole point of a build
      system?</para></footnote>  And you know that your test suite
      always leaves those debugging logfiles lying around.  These
      facts are true for all working copies of this project, not just
      your own.  And you know that you aren't interested in seeing
      those things every time you run
      <command>svn status</command>, and you are pretty sure that
      nobody else is interested in them either.  So you use
      <userinput>svn propedit svn:ignore calc</userinput> to add some
      ignore patterns to the <filename>calc</filename>
      directory.</para>
-->
    <para>Dans cet exemple, des modifications ont été faites sur les
      propriétés de <filename>bouton.c</filename> et il y a aussi des
      fichiers non suivis en versions&nbsp;: le programme
      <filename>calculatrice</filename> (résultat de votre dernière
      compilation du code source), un fichier source
      <filename>donnees.c</filename> et un ensemble de fichiers de
      traces pour le débogage. Vous êtes conscient du fait que compiler
      votre code engendre à chaque fois la création du programme
      <filename>calculatrice</filename>
      <footnote>
        <para>N'est-ce pas précisément la finalité d'un système de
          compilation&nbsp;?</para>
      </footnote>.
      Vous savez également que vous avez toujours des fichiers de
      traces qui traînent. On peut faire ce constat pour toutes les
      copies de travail locales de ce projet, pas seulement la vôtre. Et
      vous savez que cela ne vous intéresse pas et que cela n'intéresse
      très probablement aucun autre développeur, de voir ces fichiers
      apparaître à chaque commande <command>svn status</command>. Vous
      allez donc utiliser <userinput>svn propedit svn:ignore calc</userinput>
      pour ajouter des motifs à ignorer pour le dossier
      <filename>calc</filename>.</para>

    <informalexample>
      <screen>
$ svn propget svn:ignore calc <!--
calculator-->
calculatrice
debug_log*
$
</screen>
    </informalexample>

<!--
    <para>After you've added this property, you will now have a local
      property modification on the <filename>calc</filename>
      directory.  But notice what else is different about your
      <command>svn status</command> output:</para>
-->
    <para>Après avoir ajouté cette propriété, vous avez une propriété
      modifiée localement dans votre dossier
      <filename>calc</filename>. Mais notez les autres différences sur
      le résultat de la commande
      <command>svn status</command>&nbsp;:</para>

    <informalexample>
      <screen>
$ svn status
 M      calc<!--
 M      calc/button.c
?       calc/data.c-->
 M     calc/bouton.c
?      calc/donnees.c
</screen>
    </informalexample>

<!--
    <para>Now, all that cruft is missing from the output!  Your
      <filename>calculator</filename> compiled program and all those
      logfiles are still in your working copy; Subversion just isn't
      constantly reminding you that they are present and unversioned.
      And now with all the uninteresting noise removed from the
      display, you are left with more intriguing items&mdash;such as
      that source code file <filename>data.c</filename> that you
      probably forgot to add to version control.</para>
-->
    <para>Maintenant, tout le superflu a disparu&nbsp;! Bien sûr, votre
      programme compilé et les fichiers de trace sont toujours présents
      dans votre copie locale. Subversion ne vous présente pas ces
      fichiers présents mais non suivis en versions, c'est tout. Et
      maintenant que ces parasites sont supprimés de l'affichage, il ne
      vous reste plus que les éléments intéressants, tels que le fichier
      source <filename>donnees.c</filename> que vous avez
      probablement oublié d'ajouter au suivi de versions.</para>

<!--
    <para>Of course, this less-verbose report of your working copy
      status isn't the only one available.  If you actually want to
      see the ignored files as part of the status report, you can pass
      the <option>- -no-ignore</option> option to Subversion:</para>
-->
    <para>Bien évidemment, ce compte-rendu plus succinct de l'état de
      votre copie de travail locale n'est pas le seul possible. Si vous
      voulez voir les fichiers ignorés dans le compte-rendu, vous pouvez
      ajouter l'option <option>--no-ignore</option> à la commande
      Subversion&nbsp;:</para>

    <informalexample>
      <screen>
$ svn status --no-ignore
 M      calc<!--
 M      calc/button.c
I       calc/calculator
?       calc/data.c-->
 M     calc/bouton.c
I      calc/calculatrice
?      calc/donnees.c
I       calc/debug_log
I       calc/debug_log.1
I       calc/debug_log.2.gz
I       calc/debug_log.3.gz
</screen>
    </informalexample>

<!--
    <para>All of your previously hidden unversioned paths are once
      again shown, but now with the <literal>'I' Ignored</literal>
      status.  But wait, what about <filename>wip.1.diff</filename>?
      The <literal>svn:ignore</literal> property on
      <filename>calc</filename> doesn't include any pattern that
      matches that filename, so why is it ignored?<footnote><para>
      Let's assume that you don't have a matching pattern anywhere
      in your <literal>global-ignores</literal> runtime configuration.
      </para></footnote>  The answer lies in the third method by which
      Subversion can disregard unversioned paths, the inheritable
      <literal>svn:global-ignores</literal> property.  Using the
      <command>svn propget</command> subcommand with the
      <option>- -show-inherited-props</option> option, you see that
      the <literal>svn:global-ignores</literal> property is set on the
      root of your working copy, and sure enough, it defines a
      matching ignore pattern:</para>
-->
    <para>Tous les fichiers non suivis en versions auparavant occultés
      apparaissent de nouveau, mais avec un état <literal>I</literal>
      pour Ignoré. Mais attendez, qu'en est-il du fichier
      <filename>wip.1.diff</filename>&nbsp;? La propriété
      <literal>svn:ignore</literal> définie sur
      <filename>calc</filename> ne comporte aucun motif qui corresponde
      à ce nom de fichier, alors pourquoi est-il occulté<footnote>
		  <para>Supposons que vous n'avez pas non plus de motif qui
		  corresponde dans la directive <literal>global-ignores</literal>
		  de la zone de configuration.</para>
	  </footnote>&nbsp;? La réponse réside dans la troisième méthode
	  qu'utilise Subversion pour ignorer les chemins non suivis en
	  versions, la propriété héritée
	  <literal>svn:global-ignores</literal>. Utilisez la sous-commande
	  <command>svn propget</command> avec l'option
	  <option>--show-inherited-props</option> ,vous verrez alors que la
	  propriété <literal>svn:global-ignores</literal> est définie à la
	  racine de votre copie de travail et, pour sûr, qu'elle définit
	  un motif qui correspond au nom de fichier cherché&nbsp;:</para>

    <informalexample>
      <screen>
$ svn pg svn:global-ignores calc -v --show-inherited-props<!--
Inherited properties on 'calc',
from '.':-->
Propriétés héritées sur 'calc'
de '.':
  svn:global-ignores
    *.diff
    *.patch
</screen>
    </informalexample>

<!--
    <para>As mentioned earlier, the list of file patterns to ignore is
      also used by <command>svn add</command> and <command>svn
      import</command>.  Both of these operations involve asking
      Subversion to begin managing some set of files and directories.
      Rather than force the user to pick and choose which files in a
      tree she wishes to start versioning, Subversion uses the ignore
      patterns&mdash;the global, per-directory, and inherited
      lists&mdash;to determine which files should not be swept into
      the version control system as part of a larger recursive
      addition or import operation.  And here again, you can use the
      <option>- -no-ignore</option> option to tell Subversion to disregard
      its ignores list and operate on all the files and directories
      present.</para>
-->
    <para>Comme mentionné auparavant, la liste des motifs de fichiers à
      ignorer est aussi utilisée par <command>svn add</command> et
      <command>svn import</command>. Ces deux opérations demandent à
      Subversion de gérer un ensemble de fichiers et de dossiers.
      Plutôt que de forcer l'utilisateur à choisir dans l'arborescence
      quels fichiers il souhaite suivre en versions, Subversion utilise
      les motifs de fichiers à ignorer, à la fois la liste globale et
      ceux définis par dossier, pour déterminer quels fichiers suivre
      (ou ne pas suivre) en versions dans sa procédure récursive d'ajout
      ou d'import. Là encore, vous pouvez utiliser l'option
      <option>--no-ignore</option> pour indiquer à Subversion d'ignorer
      ces listes et de d'agir effectivement sur tous les fichiers et
      dossiers présents.</para>

    <tip>
<!--
      <para>Even if <literal>svn:ignore</literal> or
        <literal>svn:global-ignores</literal> is set, you may run
        into problems if you use shell wildcards in a command.  Shell
        wildcards are expanded into an explicit list of targets before
        Subversion operates on them, so running <userinput>svn
        <replaceable>SUBCOMMAND</replaceable> *</userinput> is just like
        running <userinput>svn <replaceable>SUBCOMMAND</replaceable>
        file1 file2 file3 &hellip;</userinput>.  In the case of the
        <command>svn add</command> command, this has an effect similar
        to passing the <option>- -no-ignore</option> option.  So
        instead of using a wildcard, use <userinput>svn add - -force
        .</userinput> to do a bulk scheduling of unversioned things for
        addition.  The explicit target will ensure that the current
        directory isn't overlooked because of being already under
        version control, and the <option>- -force</option> option will
        cause Subversion to crawl through that directory, adding
        unversioned files while still honoring the
        <literal>svn:ignore</literal> and
        <literal>svn:global-ignores</literal> properties and the
        <literal>global-ignores</literal> runtime configuration
        variable.  Be sure to also provide the <option>- -depth
        files</option> option to the <command>svn add</command>
        command if you don't want a fully recursive crawl for things
        to add.</para>
-->
      <para>Même si <literal>svn:ignore</literal> ou
        <literal>svn:global-ignores</literal> sont définies, vous
        risquez de rencontrer des problèmes si vous utilisez des
        caractères spéciaux du shell dans une commande. Les caractères
        spéciaux sont remplacés par une liste explicite de cibles avant
        que Subversion n'agisse sur eux et donc lancer <userinput>svn
        <replaceable>SOUS-COMMANDE</replaceable> *</userinput> revient
        à lancer <userinput>svn <replaceable>SOUS-COMMANDE</replaceable>
        fichier1 fichier2 fichier3 &hellip;</userinput>. Dans le cas de
        la commande <command>svn add</command>, ceci a un effet
        similaire à l'option <option>--no-ignore</option>. Par conséquent,
        au lieu d'utiliser un caractère spécial, utilisez plutôt
        <userinput>svn add --force .</userinput> pour marquer d'un seul
        coup les éléments non suivis en versions pour ajout. La cible
        explicite permet de s'assurer que le dossier en cours ne sera
        pas négligé car déjà suivi en versions et l'option
        <option>--force</option> force Subversion à parcourir ce
        dossier, ajoutant les fichiers non suivis en versions, tout en
        respectant les propriétés <literal>svn:ignore</literal> et
        <literal>sv:global-ignores</literal> ainsi que la
        directive <literal>global-ignores</literal> de la zone de
        configuration. Pensez aussi à rajouter l'option <option>--depth
        files</option> à la commande <command>svn add</command>
        si vous ne voulez pas que la recherche de fichiers à ajouter au
        suivi de versions ne parcoure le dossier de façon
        récursive.</para>

      </tip>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.keywords">
<!--
    <title>Keyword Substitution</title>
-->
    <title>Substitution de mots-clés</title>

<!--
    <para>
      <indexterm>
        <primary>keywords</primary>
      </indexterm>Subversion has the ability to substitute
      <firstterm>keywords</firstterm>&mdash;pieces of useful,
      dynamic information about a versioned file&mdash;into the
      contents of the file itself.  Keywords generally provide
      information about the last modification made to the file.
      Because this information changes each time the
      file changes, and more importantly, just
      <emphasis>after</emphasis> the file changes, it is a hassle
      for any process except the version control system to keep
      the data completely up to date.  Left to human authors, the
      information would inevitably grow stale.</para>
-->
    <para>
      <indexterm>
        <primary>mots-clés</primary>
      </indexterm>Subversion a la capacité de substituer des
      <firstterm>mots-clés</firstterm> dans les fichiers suivis en
      versions par des informations dynamiques et utiles. Les mots-clés
      fournissent généralement des indications sur les dernières
      modifications faites au fichier. Comme ces informations changent à
      chaque fois que le fichier change et, plus spécifiquement, juste
      <emphasis>après</emphasis> que le fichier change, c'est compliqué
      pour tout processus, excepté pour le système de gestion de
      versions, de garder les données à jour. Sans outil automatique,
      adieu la pertinence de ces informations&nbsp;!</para>

<!--
    <para>For example, say you have a document in which you would
      like to display the last date on which it was modified.  You
      could burden every author of that document to, just before
      committing their changes, also tweak the part of the
      document that describes when it was last changed.  But
      sooner or later, someone would forget to do that.  Instead,
      simply ask Subversion to perform keyword substitution on the
      <literal>LastChangedDate</literal> keyword.  You control
      where the keyword is inserted into your document by placing
      a <firstterm>keyword anchor</firstterm> at the desired
      location in the file.  This anchor is just a string of text
      formatted as
      <literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>.</para>
-->
    <para>Par exemple, prenons un document dont vous voulez
      afficher la date de dernière modification. Vous pouvez charger
      chaque contributeur du document de renseigner le champ
      correspondant juste avant de propager ses changements. Mais un
      jour ou l'autre, quelqu'un oubliera de le faire. Demandez plutôt
      à Subversion de substituer le mot-clé
      <literal>LastChangedDate</literal>. Vous contrôlez où est inséré
      le mot-clé dans votre document en plaçant un signet à l'endroit
      voulu dans le fichier. Ce signet est juste une chaîne de
      caractères formatée comme ceci&nbsp;:
      <literal>$</literal><replaceable>NomDuMotClé</replaceable><literal>$</literal>.</para>

<!--
    <para>Adding keyword anchor text alone to your file does nothing
      special.  Subversion will never attempt to perform textual
      substitutions on your file contents unless explicitly asked to
      do so.  After all, you might be writing a
      document<footnote><para>&hellip; or maybe even a section of a
      book &hellip;</para></footnote> about how to use keywords, and
      you don't want Subversion to substitute your beautiful examples
      of unsubstituted keyword anchors!</para>
-->
    <para>Ajouter un signet dans votre fichier ne fait rien de
      particulier. Subversion n"essayera jamais de le substituer tant
      que vous ne lui demandez pas explicitement de le faire. Après tout,
      vous êtes peut-être en train de rédiger un document<footnote>
		  <para>&hellip;ou peut-être même un paragraphe d'un
		  livre&hellip;</para>
	  </footnote> sur l'utilisation des mots-clés et vous ne voulez pas
	  que Subversion substitue à vos beaux exemples de signets non
	  substitués leur valeur réelle&nbsp;!.</para>

<!--
    <para>To tell Subversion whether to substitute keywords
      on a particular file, we again turn to the property-related
      subcommands.  The <literal>svn:keywords</literal> property,
      when set on a versioned file, controls which keywords will
      be substituted on that file.  The value is a space-delimited
      list of keyword names or aliases.</para>
-->
    <para>Pour indiquer à Subversion que vous voulez substituer les
      mots-clés d'un fichier particulier, nous nous tournons une fois
      de plus vers les sous-commandes relatives aux propriétés. La
      propriété <literal>svn:keywords</literal>, quand elle est définie
      sur un fichier suivi en versions, contrôle quels mots-clés doivent
      être substitués dans ce fichier. Elle doit contenir une liste de
      mots-clés ou d'alias séparés par des espaces.</para>

<!--
    <para>For example, say you have a versioned file named
      <filename>weather.txt</filename> that looks like
      this:</para>
-->
    <para>Par exemple, admettons que vous ayez un fichier suivi en
      versions nommé <filename>météo.txt</filename> qui ressemble à
      ceci&nbsp;:</para>

    <informalexample>
      <programlisting>
<!--
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
-->
Voici les dernières prévisions de nos spécialistes :
$LastChangedDate$
$Rev$
Les cumulus sont de plus en plus nombreux au fur et à mesure que l'été approche.
</programlisting>
    </informalexample>

<!--
    <para>With no <literal>svn:keywords</literal> property set on
      that file, Subversion will do nothing special.  Now, let's
      enable substitution of the
      <literal>LastChangedDate</literal> keyword.</para>
-->
    <para>Sans la propriété <literal>svn:keywords</literal> définie sur
      ce fichier, Subversion ne fait rien de spécial. À présent, si
      nous activons les substitutions pour le mot-clé
      <literal>LastChangedDate</literal>&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
-->
$ svn propset svn:keywords "Date Author" météo.txt
Propriété 'svn:keywords' définie sur 'météo.txt'
$
</screen>
    </informalexample>

<!--
    <para>Now you have made a local property modification on the
      <filename>weather.txt</filename> file.  You will see no
      changes to the file's contents (unless you made some of your
      own prior to setting the property).  Notice that the file
      contained a keyword anchor for the <literal>Rev</literal>
      keyword, yet we did not include that keyword in the property
      value we set.  Subversion will happily ignore requests to
      substitute keywords that are not present in the file and
      will not substitute keywords that are not present in the
      <literal>svn:keywords</literal> property value.</para>
-->
    <para>Vous venez d'effectuer une modification locale des propriétés
      du fichier <filename>météo.txt</filename>. Vous ne verrez aucun
      changement dans le contenu du fichier (à moins d'avoir fait des
      modifications avant d'activer la propriété). Notez que le fichier
      contenait un signet pour le mot-clé <literal>Rev</literal> et que
      nous n'avons pas inclus ce mot-clé dans la valeur de la propriété.
      Subversion ignore simplement les requêtes de substitutions de
      mots-clés qui ne sont pas présents dans le fichier et ne
      substitue pas de mot-clé qui ne soit pas présent dans la valeur
      de la propriété <literal>svn:keywords</literal>.</para>

<!--
    <para>Immediately after you commit this property change,
      Subversion will update your working file with the new
      substitute text.  Instead of seeing your keyword anchor
      <literal>$LastChangedDate$</literal>, you'll see its
      substituted result.  That result also contains the name of
      the keyword and continues to be delimited by the dollar sign
      (<literal>$</literal>) characters.  And as we predicted, the
      <literal>Rev</literal> keyword was not substituted because
      we didn't ask for it to be.</para>
-->
    <para>Immédiatement après avoir propagé cette modification de
      propriété, Subversion met à jour votre copie de travail avec le
      nouveau texte substitué. Au lieu de voir votre signet
      <literal>$LastChangedDate$</literal>, vous voyez le résultat de la
      substitution. Ce résultat contient aussi le nom du mot-clé et est
      toujours entouré par des caractères dollar (<literal>$</literal>).
      Comme prévu, le mot-clé <literal>Rev</literal> n'a pas été
      substitué parce que nous n'avons pas demandé qu'il le soit.</para>

<!--
    <para>Note also that we set the <literal>svn:keywords</literal>
      property to <literal>Date Author</literal>, yet the keyword
      anchor used the alias <literal>$LastChangedDate$</literal>
      and still expanded correctly:</para>
-->
    <para>Notez également que la substitution s'est bien passée alors
      que nous avons indiqué <literal>Date Author</literal> comme valeur
      de propriété <literal>svn:keywords</literal> et que le signet
      utilisait l'alias
      <literal>$LastChangedDate$</literal>&nbsp;:</para>

    <informalexample>
      <programlisting>
<!--
Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
-->
Voici les dernières prévisions de nos spécialistes :
$LastChangedDate: 2006-07-22 21:42:37 -0700 (sam. 22 juil. 2006) $
$Rev$
Les cumulus sont de plus en plus nombreux au fur et à mesure que l'été approche.
</programlisting>
    </informalexample>

<!--
    <para>If someone else now commits a change to
      <filename>weather.txt</filename>, your copy of that file
      will continue to display the same substituted keyword value
      as before&mdash;until you update your working copy.  At that
      time, the keywords in your <filename>weather.txt</filename>
      file will be resubstituted with information that
      reflects the most recent known commit to that file.</para>
-->
    <para>Si quelqu'un d'autre propage une modification de
      <filename>météo.txt</filename>, votre copie de ce fichier
      continue à afficher la même valeur substituée de mot-clé,
      jusqu'à ce que vous mettiez à jour votre copie de travail. Aux
      mots-clés de <filename>météo.txt</filename> sont alors à nouveau
      substituées les informations qui se rapportent à la plus récente
      propagation du fichier.</para>

<!--
    <para>All keywords are case-sensitive where they appear as
      anchors in files: you must use the correct capitalization
      for the keyword to be expanded.  You should consider the
      value of the <literal>svn:keywords</literal> property to be
      case-sensitive, too&mdash;for the sake of backward
      compatibility, certain keyword names will be recognized
      regardless of case, but this behavior is deprecated.</para>
-->
    <para>Tous les mots-clés sont sensibles à la casse des caractères
      quand ils apparaissent en tant que signets&nbsp;: vous devez
      placer les majuscules aux bons endroits pour que le mot-clé soit
      effectivement remplacé. Vous devez aussi considérer que la
      valeur de la propriété <literal>svn:keywords</literal> est
      sensible à la casse (<foreignphrase>case-sensitive</foreignphrase>
      en anglais)&nbsp;: certains mots-clés sont reconnus
      indépendamment de la casse, mais ce comportement est
      obsolète.</para>

<!--
    <para>Subversion defines the list of keywords available for
      substitution.  That list contains the following keywords,
      some of which have aliases that you can also use:</para>
-->
    <para>Subversion définit la liste des mots-clés disponibles pour les
      substitutions. Cette liste contient les cinq mots-clés suivants
      (certains d'entre eux ont des alias que vous pouvez aussi
      utiliser)&nbsp;:</para>

    <variablelist>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>Date</secondary>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>LastChangedDate</secondary>
        <!-- <see>keywords, Date</see> -->
        <see>mots-clés, Date</see>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>Revision</secondary>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>LastChangedRevision</secondary>
        <!-- <see>keywords, Revision</see> -->
        <see>mots-clés, Revision</see>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>Rev</secondary>
        <!-- <see>keywords, Revision</see> -->
        <see>mots-clés, Revision</see>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>Author</secondary>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>LastChangedBy</secondary>
        <!-- <see>keywords, Author</see> -->
        <see>mots-clés, Author</see>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>HeadURL</secondary>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>URL</secondary>
        <!-- <see>keywords, HeadURL</see> -->
        <see>mots-clés, HeadURL</see>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>Id</secondary>
      </indexterm>
      <indexterm>
        <!-- <primary>keywords</primary> -->
        <primary>mots-clés</primary>
        <secondary>Header</secondary>
      </indexterm>

      <varlistentry>
        <term><literal>Date</literal></term>
        <listitem>
<!--
          <para>This keyword describes the last time the file was
            known to have been changed in the repository, and is of
            the form <literal>$Date: 2006-07-22 21:42:37 -0700 (Sat,
            22 Jul 2006) $</literal>.  It may also be specified as
            <literal>LastChangedDate</literal>.  Unlike the
            <literal>Id</literal> keyword, which uses UTC, the
            <literal>Date</literal> keyword displays dates using the
            local time zone.</para>
-->
          <para>Ce mot-clé indique la date du dernier changement connu
            dans le dépôt. Il est de la forme
            <literal>$Date: 2006-07-22 21:42:37 -0700 (sam.
            22 juil. 2006) $</literal>. Il peut également être spécifié
            en tant que <literal>LastChangedDate</literal>.
            Contrairement au mot-clé <literal>Id</literal>, qui utilise
            l'heure UTC, le mot-clé <literal>Date</literal> affiche la
            date et l'heure locales.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Revision</literal></term>
        <listitem>
<!--
          <para>This keyword describes the last known revision in
            which this file changed in the repository, and looks
            something like <literal>$Revision: 144 $</literal>.
            It may also be specified as
            <literal>LastChangedRevision</literal> or
            <literal>Rev</literal>.</para>
-->
          <para>Ce mot-clé indique la dernière révision connue pour
            laquelle le fichier a changé dans le dépôt. Il fournit une
            réponse du type <literal>$Revision: 144 $</literal>.
            Il peut aussi être spécifié en tant que
            <literal>LastChangedRevision</literal> ou
            <literal>Rev</literal>..</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Author</literal></term>
        <listitem>
<!--
          <para>This keyword describes the last known user to
            change this file in the repository, and looks
            something like <literal>$Author: harry $</literal>.
            It may also be specified as
            <literal>LastChangedBy</literal>.</para>
-->
          <para>Ce mot-clé indique le nom du dernier utilisateur qui a
            modifié le fichier dans le dépôt et retourne une valeur du
            type <literal>$Author: harry $</literal>. Il peut aussi être
            spécifié en tant que
            <literal>LastChangedBy</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>HeadURL</literal></term>
        <listitem>
<!--
          <para>This keyword describes the full URL to the latest
            version of the file in the repository, and looks
            something like <literal>$HeadURL:
            http://svn.example.com/repos/trunk/calc.c $</literal>.
            It may be abbreviated as
            <literal>URL</literal>.</para>
-->
          <para>Ce mot-clé décrit l'URL complète de la dernière version
            du fichier dans le dépôt et ressemble à <literal>$HeadURL:
            http://svn.exemple.com/depot/trunk/calc.c $</literal>. Il
            peut être abrégé en <literal>URL</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Id</literal></term>
        <listitem>
<!--
          <para>This keyword is a compressed combination of the other
            keywords.  Its substitution looks something like
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, and is interpreted to mean that the file
            <filename>calc.c</filename> was last changed in revision
            148 on the evening of July 28, 2006 by the user
            <literal>sally</literal>.  The date displayed by this
            keyword is in UTC, unlike that of the
            <literal>Date</literal> keyword (which uses the local time
            zone).</para>
-->
          <para>Ce mot-clé est une combinaison abrégée des autres
            mots-clés. Sa substitution donne quelque chose comme
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally $</literal>,
            que l'on interprète comme suit&nbsp;: <quote>Le fichier
            <filename>calc.c</filename> a été modifié en dernier par
            l'utilisateur <literal>sally</literal> lors de la révision
            148 le 28 juillet 2006 au soir.</quote> La date et l'heure
            affichées sont en heure UTC, contrairement au mot-clé
            <literal>Date</literal> qui utilise l'heure locale.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Header</literal></term>
        <listitem>
<!--
          <para>This keyword is similar to the <literal>Id</literal>
            keyword but contains the full URL of the latest revision
            of the item, identical to <literal>HeadURL</literal>.
            Its substitution looks something like <literal>$Header:
            http://svn.example.com/repos/trunk/calc.c
            148 2006-07-28 21:30:43Z sally $</literal>.</para>
-->
          <para>Ce mot-clé est similaire au mot-clé
            <literal>Id</literal>, mais contient l'URL complète de la
            dernière révision de l'élément, à l'identique de
            <literal>HeadURL</literal>. Sa substitution donne un
            résultat du type <literal>$Header:
            http://svn.exemple.com/depot/trunk/calc.c 148 2006-07-28
            21:30:43Z sally $</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

<!--
    <para>Several of the preceding descriptions use the phrase
      <quote>last known</quote> or similar wording.  Keep in mind that
      keyword expansion is a client-side operation, and your client
      <quote>knows</quote> only about changes that have occurred in
      the repository when you update your working copy to include
      those changes.  If you never update your working copy, your
      keywords will never expand to different values even if those
      versioned files are being changed regularly in the
      repository.</para>
-->
    <para>Une bonne partie des définitions qui précèdent utilisent la
      locution <quote>dernière &hellip; connue</quote> ou quelque chose
      d'équivalent. Rappelez-vous que la substitution des mots-clés est
      une opération effectuée côté client et que votre client ne connaît
      pas les changements qui ont eu lieu dans le dépôt depuis votre
      dernière mise à jour. Si vous ne mettez jamais à jour de votre
      copie de travail locale, vos mots-clés restent figés à la même
      valeur même si des changements ont lieu régulièrement dans le
      dépôt.</para>

    <sidebar>
<!--
      <title>Where's $GlobalRev$?</title>
-->
      <title>Où est passé $GlobalRev$&nbsp;?</title>

<!--
      <para>New users are often confused by how the
        <literal>$Rev$</literal> keyword works.  Since the repository
        has a single, globally increasing revision number, many people
        assume that it is this number that is reflected by the
        <literal>$Rev$</literal> keyword's value.  But
        <literal>$Rev$</literal> expands to show the last revision in
        which the file <emphasis>changed</emphasis>, not the last
        revision to which it was updated.  Understanding this clears
        the confusion, but frustration often remains&mdash;without the
        support of a Subversion keyword to do so, how can you
        automatically get the global revision number into your
        files?</para>
-->
      <para>Les nouveaux utilisateurs sont parfois surpris par le
        fonctionnement du mot-clé <literal>$Rev$</literal>. Puisque le
        dépôt a un numéro de révision à la fois unique, global et
        croissant, beaucoup de gens pensent que c'est par ce numéro
        qu'est remplacé le mot-clé <literal>$Rev$</literal>. Mais
        <literal>$Rev$</literal> indique la dernière révision dans
        laquelle le fichier a <emphasis>changé</emphasis>, pas la
        révision de la dernière mise à jour. Le malentendu est ainsi
        dissipé, mais peut-être pas la frustration de ne pas avoir
        automatiquement le numéro global de la dernière révision dans
        vos fichiers, n'est-ce pas&nbsp;?</para>

<!--
      <para>To do this, you need external processing.  Subversion
        ships with a tool called <command>svnversion</command>, which
        was designed for just this purpose.  It crawls your working
        copy and generates as output the revision(s) it finds.  You
        can use this program, plus some additional tooling, to embed
        that revision information into your files.  For more
        information on <command>svnversion</command>, see <xref
        linkend="svn.ref.svnversion"/>.</para>
-->
      <para>Pour l'obtenir, vous avez besoin d'un outil externe.
        Subversion est livré avec un outil appelé
        <command>svnversion</command>, qui a été conçu spécifiquement
        pour cela. <command>svnversion</command> parcourt votre copie de
        travail et affiche toutes les révisions qu'il trouve. Vous
        pouvez utiliser ce programme, avec d'autres outils de
        traitement, pour insérer l'information de révision désirée dans
        vos fichiers. Pour davantage d'information sur
        <command>svnversion</command>, voir
        <xref linkend="svn.ref.svnversion"/>.</para>

    </sidebar>

<!--
    <para>In addition to previous set of stock keyword definitions and
      aliases, Subversion 1.8 allows you the freedom to define and use
      custom keywords.  To define a custom keyword, add a token to the
      value of the <literal>svn:keywords</literal> property which is
      of the form
      <userinput><replaceable>MyKeyword</replaceable>=<replaceable>FORMAT</replaceable></userinput>,
      where <replaceable>MyKeyword</replaceable> is the keyword name
      (which you'll use in the keyword anchor)
      and <replaceable>FORMAT</replaceable> is a format string into
      which information will be substituted when your keyword is
      expanded inside your file.</para>
-->
    <para>En complément de ces mots-clés et alias prédéfinis,
      Subversion 1.8 vous permet de définir et d'utiliser les mots-clés
      personnalisés. Pour définir un mot-clé personnalisé, ajoutez une
      jeton à la propriété <literal>svn:keywords</literal> avec la
      syntaxe suivante&nbsp;:
      <userinput><replaceable>MyMot-Clé</replaceable>=<replaceable>FORMAT</replaceable></userinput>.
      <replaceable>MyMot-Clé</replaceable> est le nom du mot-clé (celui
      que vous utiliserez dans le signet) et
      <replaceable>FORMAT</replaceable> est une chaine formatée dans
      laquelle l'information sera insérée lorsque le mot-clé sera
      substitué dans votre fichier.</para>

<!--
    <para>The format string syntax used for custom keywords supports
      the following format codes:</para>
-->
    <para>La syntaxe de la chaine formatée utilisée pour les mots-clés
      personnalisés accepte les codes de substitution
      suivants&nbsp;:</para>

    <variablelist>
      <varlistentry>
        <term><literal>%a</literal></term>
        <listitem>
<!--
          <para>The author of the revision given
            by <literal>%r</literal>.</para>
-->
          <para>L'auteur de la révision
            <literal>%r</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%b</literal></term>
        <listitem>
<!--
          <para>The basename of the URL of the file.</para>
-->
          <para>Le nom de fichier de l'URL du fichier.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%d</literal></term>
        <listitem>
<!--
          <para>Short format of the date of the revision given by
            <literal>%r</literal>.</para>
-->
          <para>La date de la révision
            <literal>%r</literal> au format court.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%D</literal></term>
        <listitem>
<!--
          <para>Long format of the date of the revision given by
            <literal>%r</literal>.</para>
-->
          <para>La date de la révision
            <literal>%r</literal> au format long.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%P</literal></term>
        <listitem>
<!--
          <para>The file's path, relative to the repository
            root.</para>
-->
          <para>Le chemin du fichier, relativement à la racine du
            dépôt.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%r</literal></term>
        <listitem>
<!--
          <para>The last known revision in which this file changed in
          the repository.  (This is the same revision which would be
          substituted for the <literal>Revision</literal>
          keyword.)</para>
-->
          <para>La dernière révision connue pour laquelle ce fichier a
            été modifié dans le dépôt (c'est la même révision que pour
            le mot-clé <literal>Revision</literal>).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%R</literal></term>
        <listitem>
<!--
          <para>The URL to the root of the repository.</para>
-->
          <para>L'URL de la racine du dépôt.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%u</literal></term>
        <listitem>
<!--
          <para>The URL of the file.</para>
-->
          <para>L'URL du fichier.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%_</literal></term>
        <listitem>
<!--
          <para>A space character. (Keyword definitions cannot contain
            a literal space character.)</para>
-->
          <para>Un caractère <quote>espace</quote> (la définition d'un
            mot-clé ne peut pas contenir d'espace).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%%</literal></term>
        <listitem>
<!--
          <para>A literal percent sign ('<literal>%</literal>').</para>
-->
          <para>Le caractère pourcent ('<literal>%</literal>').</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%H</literal></term>
        <listitem>
<!--
          <para>Equivalent to <literal>%P%_%r%_%d%_%a</literal>.</para>
-->
          <para>Équivaut à <literal>%P%_%r%_%d%_%a</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%I</literal></term>
        <listitem>
<!--
          <para>Equivalent to <literal>%b%_%r%_%d%_%a</literal>.</para>
-->
          <para>Équivaut à <literal>%b%_%r%_%d%_%a</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

<!--
    <para>As you can see, many of the individual format codes serve as
      placeholders for the same information available through the
      stock keywords.  But of course, the custom keyword format allows
      you to more flexibly string together multiple bits of
      information.  For example, you might wish to have a single
      keyword in your files which reports the repository relative path
      of the file and last-changed revision, formatted in a pleasant,
      human-readable way.  To do so, you'd first define your custom
      keyword:</para>
-->
    <para>Comme vous pouvez le constater, beaucoup de codes de format
      reprennent les informations disponibles dans les mots-clés
      prédéfinis. Mais bien ûr, les mots-clés personnalisés vous offrent
      plus de souplesse dans l'organisation de l'information. Par
      exemple, vous pouvez avoir envie d'avoir un mot-clé dans vos
      fichiers qui donne le chemin relatif dans le dépôt du fichier et
      la dernière révision qui le modifie, formattée à votre convenance
      pour une meilleure lisibilité. Pour ce faire, vous devez d'abord
      définir votre mot-clé personnalisé&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn pset svn:keywords "PathRev=%P,%_r%r" calc/button.c
property 'svn:keywords' set on 'button.c'-->
$ svn pset svn:keywords "CheminRev=%P,%_r%r" calc/bouton.c
Propriété 'svn:keywords' définie sur 'bouton.c'
$
</screen>
    </informalexample>

<!--
    <para>Next, you'd edit the file's contents to add the keyword
      anchor for your custom keyword, which in this case
      is <literal>$PathRev$</literal>.  After committing these
      changes, an examination of your file's contents will show that
      your custom keyword was substituted as you would
      expect&mdash;where previously the file
      contained <literal>$PathRev$</literal>, it now reads
      <literal>$PathRev: trunk/calc/button.c, r23 $</literal>.</para>
-->
    <para>Ensuite, vous devez éditer votre fichier pour ajouter le
      signet pour votre mot-clé, ce qui nous donne dans ce cas
      <literal>$CheminRev$</literal>. Après avoir propagé ces
      modifications, si vous regardez le contenu du fichier, vous
      constaterez que le mot-clé a été substitué conformément au
      résultat attendu&nbsp;: où le fichier contenait
      <literal>$CheminRev$</literal>, il contient maintenant
      <literal>$cheminRev: trunk/calc/bouton.c, r23 $</literal>.</para>

    <note>
<!--
      <para>Subversion will automatically truncate any keyword
        expansions which exceed 255 bytes in length.  Also custom
        keywords defined with names that exceed 255 bytes will be
        ignored altogether.</para>
-->
      <para>Subversion tronque automatiquement toute expansion de
        mot-clé qui dépasse 255 caractères de long. Les définitions de
        mots-clés dont le nom dépasse 255 caractères sont aussi
        ignorées.</para>
    </note>

<!--
    <para>You can also instruct Subversion to maintain a fixed length
      (in terms of the number of bytes consumed) for the substituted
      keyword.  By using a double colon (<literal>::</literal>) after
      the keyword name, followed by a number of space characters, you
      define that fixed width.  When Subversion goes to substitute
      your keyword for the keyword and its value, it will essentially
      replace only those space characters, leaving the overall width
      of the keyword field unchanged.  If the substituted value is
      shorter than the defined field width, there will be extra
      padding characters (spaces) at the end of the substituted field;
      if it is too long, it is truncated with a special hash
      (<literal>#</literal>) character just before the final dollar
      sign terminator.</para>
-->
    <para>Vous pouvez aussi demander à Subversion de conserver une
      longueur constante (en nombre d'octets consommés) pour la
      substitution d'un mot-clé. En utilisant la séquence double
      deux-points (<literal>::</literal>), suivi par le nombre
      de caractères désiré, vous définissez la largeur voulue. Quand
      Subversion substituera le mot-clé pour le mot-clé et sa valeur, il
      ne remplacera que les caractères espaces, laissant le reste du
      champ de mot-clé inchangé. Si la valeur de substitution est plus
      courte que la largeur définie, il y aura des caractères de
      remplissage à la fin du champ substitué&nbsp;; si elle est trop
      longue, elle sera tronquée avec un caractère spécial
      <quote>dièse</quote> (<literal>#</literal>) juste avant le caractère
      dollar qui sert de délimiteur de fin.</para>

<!--
    <para>For example, say you have a document in which you have
      some section of tabular data reflecting the document's
      Subversion keywords.  Using the original Subversion keyword
      substitution syntax, your file might look something
      like:</para>
-->
    <para>Par exemple, supposons que vous ayez un document dans lequel
      vous avez un paragraphe avec des données tabulées qui
      représentent les mots-clés Subversion du document. Si vous
      utilisez la syntaxe originale Subversion pour la substitution des
      mots-clés, votre fichier ressemblera à&nbsp;:</para>

    <informalexample>
      <programlisting>
<!--
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
-->
$Rev$:     Révision de la dernière propagation
$Author$:  Auteur de la dernière propagation
$Date$:    Date de la dernière propagation
</programlisting>
    </informalexample>

<!--
    <para>Now, that looks nice and tabular at the start of things.
      But when you then commit that file (with keyword substitution
      enabled, of course), you see:</para>
-->
    <para>Tel quel, cela semble joli et bien aligné. Mais quand vous allez
      propager ce fichier (avec la substitution des mots-clés activée, bien
      évidemment), vous verrez&nbsp;:</para>

    <informalexample>
      <programlisting>
<!--
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
-->
$Rev: 12 $:     révision de la dernière propagation
$Author: harry $:  auteur de la dernière propagation
$Date: 2006-03-15 02:33:03 -0500 (mer. 15 Mar 2006) $:    date de la dernière propagation
</programlisting>
    </informalexample>

<!--
    <para>The result is not so beautiful.  And you might be
      tempted to then adjust the file after the substitution so
      that it again looks tabular.  But that holds only as long as
      the keyword values are the same width.  If the last
      committed revision rolls into a new place value (say, from
      99 to 100), or if another person with a longer username
      commits the file, stuff gets all crooked again.  However, if
      you are using Subversion 1.2 or later, you can use the new
      fixed-length keyword syntax and define some field widths that
      seem sane, so your file might look like this:</para>
-->
    <para>Le résultat n'est pas très heureux. Vous êtes alors tenté d'ajuster
      le fichier après la substitution pour le remettre en forme. Mais cela ne
      fonctionne que tant que les substitutions de mots-clés gardent la
      même longueur. Si le numéro de la dernière révision propagée passe de 99
      à 100 par exemple, ou si une autre personne avec un nom d'utilisateur
      plus long propage le fichier, tout le travail est à refaire. Cependant,
      si vous travaillez avec Subversion 1.2 ou plus récent, vous pouvez
      utiliser la nouvelle syntaxe des mots-clés à longueur fixe et spécifier
      la largeur adéquate de certains champs&nbsp;; le fichier ressemble alors
      à ceci&nbsp;:</para>

    <informalexample>
      <programlisting>
<!--
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
-->
$Rev::               $:  révision de la dernière propagation
$Author::            $:  auteur de la dernière propagation
$Date::              $:  date de la dernière propagation
</programlisting>
    </informalexample>

<!--
    <para>You commit this change to your file.  This time,
      Subversion notices the new fixed-length keyword syntax and
      maintains the width of the fields as defined by the padding
      you placed between the double colon and the trailing dollar
      sign.  After substitution, the width of the fields is
      completely unchanged&mdash;the short values for
      <literal>Rev</literal> and <literal>Author</literal> are
      padded with spaces, and the long <literal>Date</literal>
      field is truncated by a hash character:</para>
-->
    <para>Propagez les modifications du fichier. Cette fois, Subversion prend
      en compte la nouvelle syntaxe des mots-clés à longueur fixe et conserve
      la largeur des champs telle que définie en complétant en tant que de
      besoin entre le double deux-points et le dollar de fin. Après
      substitution, la largeur des champs n'a pas changé&nbsp;: les valeurs
      courtes comme <literal>Rev</literal> et <literal>Author</literal> sont
      complétées avec des espaces et le champ <literal>Date</literal>, trop
      long, est tronqué par un caractère dièse&nbsp;:</para>

    <informalexample>
      <programlisting>
<!--
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
-->
$Rev:: 13            $:  révision de la dernière propagation
$Author:: harry      $:  auteur de la dernière propagation
$Date:: 2006-03-15 0#$:  date de la dernière propagation
</programlisting>
    </informalexample>

<!--
    <para>The use of fixed-length keywords is especially handy when
      performing substitutions into complex file formats that
      themselves use fixed-length fields for data, or for which the
      stored size of a given data field is overbearingly difficult to
      modify from outside the format's native application.  Of course,
      where binary file formats are concerned, you must always take great
      care that any keyword substitution you introduce&mdash;fixed-length
      or otherwise&mdash;does not violate the integrity of that format.
      While it might sound easy enough, this can be an astonishingly
      difficult task for most of the popular binary file formats in use
      today, and <emphasis>not</emphasis> something to be undertaken by
      the faint of heart!</para>
-->
    <para>L'utilisation de champs de mots-clés à longueur fixe est
      particulièrement utile lorsque vous faites des substitutions dans
      des fichiers dont le format est complexe et fait lui-même usage
      de champs à longueurs fixes ou lorsque la place disponible pour le
      stockage du champ de donnée est vraiment trop difficile à changer
      en dehors de l'application native elle-même. Bien sûr, dans le cas de
      fichiers binaires, vous devez toujours faire très attention à ce
      que les substitutions de mots-clés (à longueur fixe ou non) ne
      cassent pas l'intégrité du fichier. Bien que cela semble facile,
      cela peut être étonnament difficile pour la plupart des formats
      de fichiers binaires utilisés de nos jours et vous
      <emphasis>ne</emphasis> devez <emphasis>pas</emphasis>
      sous-estimer l'ampleur de cette tâche&nbsp;!</para>

<!--
    <warning>
      <para>Be aware that because the width of a keyword field is
        measured in bytes, the potential for corruption of
        multibyte values exists.  For example, a username that
        contains some multibyte UTF-8 characters might suffer
        truncation in the middle of the string of bytes that make
        up one of those characters.  The result will be a mere
        truncation when viewed at the byte level, but will likely
        appear as a string with an incorrect or garbled final
        character when viewed as UTF-8 text.  It is conceivable
        that certain applications, when asked to load the file,
        would notice the broken UTF-8 text and deem the entire
        file corrupt, refusing to operate on the file
        altogether.  So, when limiting keywords to a fixed size,
        choose a size that allows for this type of byte-wise
        expansion.</para>
    </warning>
-->
    <warning>
      <para>Soyez conscient que, comme la taille d'un mot-clé est
        mesurée en octets, les valeurs utilisant des données codées sur
        plusieurs octets peuvent être corrompues. Par exemple, un nom
        d'utilisateur qui contient des caractères au format UTF-8 codés
        sur plusieurs octets risque d'être tronqué en plein milieu d'un
        de ces caractères multi-octets. Cette troncature est valide au
        niveau du traitement des octets mais résulte en une chaîne
        UTF-8 incorrecte en raison du caractère final tronqué. Il est
        ainsi possible que certaines applications, au moment de charger
        le fichier, remarquent que le texte UTF-8 est invalide,
        considèrent tout le fichier comme corrompu et refusent de
        travailler dessus. En conséquence, lorsque vous utilisez les
        mots-clés à longueur fixe, veillez à choisir une taille adaptée
        à des valeurs pouvant contenir des caractères éventuellement
        codés sur plusieurs octets.</para>
    </warning>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.sparsedirs">
<!--
    <title>Sparse Directories</title>
-->
    <title>Répertoires clairsemés</title>

<!--
    <para>
      <indexterm>
        <primary>sparse directories</primary>
      </indexterm>
      <indexterm>
        <primary>checkouts</primary>
        <secondary>shallow</secondary>
        <see>sparse directories</see>
      </indexterm>By default, most Subversion operations on
      directories act in a recursive manner.  For
      example, <command>svn checkout</command> creates a working copy
      with every file and directory in the specified area of the
      repository, descending recursively through the repository tree
      until the entire structure is copied to your local disk.
      Subversion 1.5 introduces a feature called <firstterm>sparse
      directories</firstterm> (or <firstterm>shallow
      checkouts</firstterm>) that allows you to easily check out a
      working copy&mdash;or a portion of a working copy&mdash;more
      shallowly than full recursion, with the freedom to bring in
      previously ignored files and subdirectories at a later
      time.</para>
-->
    <para>
      <indexterm>
        <primary>répertoires clairsemés</primary>
      </indexterm>
      <indexterm>
        <primary>extraction</primary>
        <secondary>superficielle</secondary>
        <see>répertoires clairsemés</see>
      </indexterm>Par défaut, la plupart des opérations Subversion sur des
      dossiers agissent de manière récursive. Par exemple,
      <command>svn checkout</command> crée une copie de travail avec
      tous les fichiers et dossiers de la zone spécifiée du dépôt, en
      descendant récursivement dans l'arborescence du dépôt pour en
      copier la structure complète sur votre disque local. Subversion 1.5
      introduit une nouvelle fonctionnalité appelée
      <firstterm>répertoires clairsemés</firstterm> (ou
      <firstterm>extractions superficielles</firstterm>) qui permet
      d'obtenir facilement une copie de travail (ou une simple portion
      d'une copie de travail) moins profonde que
      <foreignphrase>via</foreignphrase> la récursion complète, avec la
      possibilité de n'extraire que plus tard les dossiers et les fichiers
      ignorés auparavant.</para>

<!--
    <para>For example, say we have a repository with a tree of files
      and directories with names of the members of a human family with
      pets.  (It's an odd example, to be sure, but bear with us.)  A
      regular <command>svn checkout</command> operation will give us a
      working copy of the whole tree:</para>
-->
    <para>Par exemple, imaginons un dépôt dont l'arborescence des
      fichiers et dossiers est constituée des noms des membres d'une
      famille et de leurs animaux de compagnie (c'est assurément un
      exemple bizarre, mais soit). Un <command>svn checkout</command>
      standard nous donne une copie de travail de l'ensemble de
      l'arborescence&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn checkout file:///var/svn/repos mom
A    mom/son
A    mom/son/grandson
A    mom/daughter
A    mom/daughter/granddaughter1
A    mom/daughter/granddaughter1/bunny1.txt
A    mom/daughter/granddaughter1/bunny2.txt
A    mom/daughter/granddaughter2
A    mom/daughter/fishie.txt
A    mom/kitty1.txt
A    mom/doggie1.txt
Checked out revision 1.
-->
$ svn checkout file:///var/svn/depot maman
A    maman/fils
A    maman/fils/petit-fils
A    maman/fille
A    maman/fille/petite-fille1
A    maman/fille/petite-fille1/lapinou1.txt
A    maman/fille/petite-fille1/lapinou2.txt
A    maman/fille/petite-fille2
A    maman/fille/poissonou.txt
A    maman/minou1.txt
A    maman/toutou1.txt
Révision 1 extraite.
$
</screen>
    </informalexample>

<!--
    <para>Now, let's check out the same tree again, but this time
      we'll ask Subversion to give us only the topmost directory
      with none of its children at all:</para>
-->
    <para>Maintenant, extrayons la même arborescence, mais cette fois en
      demandant à Subversion de nous donner uniquement le dossier
      racine sans les enfants&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn checkout file:///var/svn/repos mom-empty - -depth empty
Checked out revision 1
-->
$ svn checkout file:///var/svn/depot maman-vide --depth empty
Révision 1 extraite.
$
</screen>
    </informalexample>

<!--
    <para>Notice that we added to our original <command>svn
      checkout</command> command line a new <option>- -depth</option>
      option.  This option is present on many of Subversion's
      subcommands and is similar to the
      <option>- -non-recursive</option> (<option>-N</option>) and
      <option>- -recursive</option> (<option>-R</option>) options.  In
      fact, it combines, improves upon, supercedes, and ultimately
      obsoletes these two older options.  For starters, it expands the
      supported degrees of depth specification available to users,
      adding some previously unsupported (or inconsistently supported)
      depths.  Here are the depth values that you can request for a
      given Subversion operation:</para>
-->
    <para>Remarquez que nous avons ajouté l'option <option>--depth</option>
      à la commande <command>svn checkout</command> originale. Cette
      option existe pour de nombreuses sous-commandes Subversion et est
      similaire aux options <option>--non-recursive</option>
      (<option>-N</option>) et <option>--recursive</option>
      (<option>-R</option>). En fait, elle combine, améliore, remplace
      et, à terme, rend obsolète ces deux options plus anciennes. Déjà,
      elle permet à l'utilisateur de spécifier le niveau de profondeur de la
      récursion de façon plus précise, en ajoutant des niveaux auparavant non
      supportés (ou supportés de manière peu satisfaisante). Voici les
      valeurs de niveau de profondeur de récursion que vous pouvez ajouter à
      vos requêtes Subversion&nbsp;:</para>

    <variablelist>

      <indexterm>
        <primary>profondeur de récursion</primary>
        <secondary>empty</secondary>
      </indexterm>
      <indexterm>
        <primary>profondeur de récursion</primary>
        <secondary>files</secondary>
      </indexterm>
      <indexterm>
        <primary>profondeur de récursion</primary>
        <secondary>immediates</secondary>
      </indexterm>
      <indexterm>
        <primary>profondeur de récursion</primary>
        <secondary>infinity</secondary>
      </indexterm>
      <indexterm>
        <primary>depth</primary>
        <see>profondeur de récursion</see>
      </indexterm>

      <varlistentry>
        <term><literal>--depth empty</literal></term>
        <listitem>
<!--
          <para>Include only the immediate target of the operation,
            not any of its file or directory children.</para>
-->
          <para>Inclut uniquement la cible immédiate de l'opération,
            sans aucun fichier ou dossier fils.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth files</literal></term>
        <listitem>
<!--
          <para>Include the immediate target of the operation and any
            of its immediate file children.</para>
-->
          <para>Inclut la cible immédiate de l'opération et tous les
            fichiers fils immédiats.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth immediates</literal></term>
        <listitem>
<!--
          <para>Include the immediate target of the operation and any
            of its immediate file or directory children.  The directory
            children will themselves be empty.</para>
-->
          <para>Inclut la cible immédiate de l'opération et tous ses
            sous-dossiers et fils immédiats. Les dossiers fils
            seront eux-mêmes vides.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth infinity</literal></term>
        <listitem>
<!--
          <para>Include the immediate target, its file and directory
            children, its children's children, and so on to full
            recursion.</para>
-->
          <para>Inclut la cible immédiate, les fichiers et dossiers
            fils, les fils des fils et ainsi de suite de façon à
            réaliser une récursion complète.</para>
        </listitem>
      </varlistentry>

    </variablelist>

<!--
    <para>
      <indexterm>
        <primary>depth</primary>
        <secondary>ambient</secondary>
      </indexterm>Of course, merely combining two existing options into one
      hardly constitutes a new feature worthy of a whole section in
      our book.  Fortunately, there is more to this story.  This idea
      of depth extends not just to the operations you perform with
      your Subversion client, but also as a description of a working
      copy citizen's <firstterm>ambient depth</firstterm>, which is
      the depth persistently recorded by the working copy for that
      item.  Its key strength is this very persistence&mdash;the fact
      that it is <quote>sticky</quote>.  The working copy remembers
      the depth you've selected for each item in it until you later
      change that depth selection; by default, Subversion commands
      operate on the working copy citizens present, regardless of
      their selected depth settings.</para>
-->
    <para>
      <indexterm>
        <primary>profondeur de récursion</primary>
        <secondary>niveau associé</secondary>
      </indexterm>Bien sûr, la simple combinaison de deux options existantes en
      une seule ne constitue pas une nouvelle fonctionnalité méritant
      une section complète de ce livre. Heureusement, il y a plus à en
      dire. Ce concept de profondeur de récursion ne s'applique pas uniquement
      aux opérations réalisées avec le client Subversion mais il s'étend
      aussi à la description de la copie de travail elle-même, en tant
      que <firstterm>niveau associé</firstterm> de manière permanente
      par la copie de travail à chaque élément. La force de ce concept
      est cette permanence. La copie de travail se rappelle le niveau de
      profondeur que vous avez choisi pour chaque élément qui la compose,
      jusqu'à ce que vous en changiez. Par défaut, les commandes
      Subversion agissent sur les éléments présents dans la copie de
      travail, indépendamment de leur niveau de récursion propre.</para>

    <tip>
<!--
      <para>You can check the recorded ambient depth of a working copy
        using the <command>svn info</command> command.  If the ambient
        depth is anything other than infinite recursion, <command>svn
        info</command> will display a line describing that depth
        value:</para>
-->
      <para>Vous pouvez vérifier le niveau de profondeur d'une copie de
        travail en utilisant la commande <command>svn info</command>.
        Si le niveau de récursion n'est pas infini, <command>svn
        info</command> affiche une ligne indiquant le niveau de
        profondeur&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn info mom-immediates | grep "^Depth:"
Depth: immediates
-->
$ svn info maman-immediats | grep '^Profondeur :'
Profondeur : immédiates
$
</screen>
      </informalexample>
    </tip>

<!--
    <para>Our previous examples demonstrated checkouts of infinite
      depth (the default for <command>svn checkout</command>) and
      empty depth.  Let's look now at examples of the other depth
      values:</para>
-->
    <para>Ces premiers exemples comportaient des extractions avec un
      niveau infini de profondeur (la valeur par défaut de
      <command>svn checkout</command>) ou avec un niveau nul. Voyons
      maintenant des exemples avec d'autres valeurs de niveau de
      profondeur&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn checkout file:///var/svn/repos mom-files - -depth files
A    mom-files/kitty1.txt
A    mom-files/doggie1.txt
Checked out revision 1.
-->
$ svn checkout file:///var/svn/depot maman-fichiers --depth files
A    maman-fichiers/minou1.txt
A    maman-fichiers/toutou1.txt
Révision 1 extraite.<!--
$ svn checkout file:///var/svn/repos mom-immediates - -depth immediates
A    mom-immediates/son
A    mom-immediates/daughter
A    mom-immediates/kitty1.txt
A    mom-immediates/doggie1.txt
Checked out revision 1.
-->
$ svn checkout file:///var/svn/depot maman-immediats --depth immediates
A    maman-immediats/fils
A    maman-immediats/fille
A    maman-immediats/minou1.txt
A    maman-immediats/toutou1.txt
Révision 1 extraite.
$
</screen>
    </informalexample>

<!--
    <para>As described, each of these depths is something more than
      only the target, but something less than full recursion.</para>
-->
    <para>Comme indiqué, chacun de ces deux niveaux se situe quelque
      part entre la cible toute simple et la récursion complète.</para>

<!--
    <para>We've used <command>svn checkout</command> as an example
      here, but you'll find the <option>- -depth</option> option
      present on many other Subversion commands, too.  In those other
      commands, depth specification is a way to limit the scope of an
      operation to some depth, much like the way the older
      <option>- -non-recursive</option> (<option>-N</option>) and
      <option>- -recursive</option> (<option>-R</option>) options
      behave.  This means that when operating on a working copy of
      some depth, while requesting an operation of a shallower depth,
      the operation is limited to that shallower depth.  In fact, we
      can make an even more general statement: given a working copy of
      any arbitrary&mdash;even mixed&mdash;ambient depth, and a
      Subversion command with some requested operational depth, the
      command will maintain the ambient depth of the working copy
      members while still limiting the scope of the operation to the
      requested (or default) operational depth.</para>
-->
    <para>Nous avons utilisé la commande <command>svn checkout</command>
      pour nos exemples, mais l'option <option>--depth</option> est
      également accessible depuis beaucoup d'autres commandes Subversion.
      Pour ces autres commandes, spécifier un niveau de profondeur de la
      récursion est une manière de limiter le rayon d'action d'une opération à
      un niveau, à l'instar des vieilles options
      <option>--non-recursive</option> (<option>-N</option>) et
      <option>--recursive</option> (<option>-R</option>). Cela veut dire
      que lorsque vous travaillez sur une copie de travail d'un certain
      niveau et que vous faites une opération sur un niveau plus faible,
      l'opération est limitée à ce niveau faible. En fait, on peut
      généraliser ce raisonnement&nbsp;: pour une copie de travail d'un
      niveau de profondeur de récursion arbitraire (éventuellement hétérogène)
      et pour une commande Subversion comportant un niveau de profondeur, la
      commande conserve le niveau de récursion associé aux éléments de
      la copie de travail tout en limitant le rayon d'action de
      l'opération au niveau demandé (ou celui par défaut).</para>

<!--
    <para>In addition to the <option>- -depth</option> option, the
      <command>svn update</command> and <command>svn switch</command>
      subcommands also accept a second depth-related option:
      <option>- -set-depth</option>.  It is with this option that you
      can change the sticky depth of a working copy item.  Watch what
      happens as we take our empty-depth checkout and gradually
      telescope it deeper using <userinput>svn update
      - -set-depth <replaceable>NEW-DEPTH</replaceable> <replaceable>TARGET</replaceable></userinput>:</para>
-->
    <para>En plus de l'option <option>--depth</option>, les sous-commandes
      <command>svn update</command> et <command>svn switch</command> acceptent
      une deuxième option relative au niveau de profondeur de la
      récursion&nbsp;: <option>--set-depth</option>. C'est cette option qui
      vous permet de changer le niveau de profondeur de la récursion associé à
      un élément d'une copie de travail. Regardez ce qui se passe après avoir
      extrait notre niveau zéro puis graduellement augmenté le niveau de
      profondeur de la récursion en utilisant la commande <userinput>svn update
      --set-depth <replaceable>NOUVELLE-PROFONDEUR</replaceable>
      <replaceable>CIBLE</replaceable></userinput>:</para>

    <informalexample>
      <screen><!--
$ svn update - -set-depth files mom-empty
Updating 'mom-empty':
A    mom-empty/kittie1.txt
A    mom-empty/doggie1.txt
Updated to revision 1.
-->
$ svn update --set-depth files maman-vide
A    maman-vide/minou1.txt
A    maman-vide/toutou1.txt
Actualisé à la révision 1. <!--
$ svn update - -set-depth immediates mom-empty
Updating 'mom-empty':
A    mom-empty/son
A    mom-empty/daughter
Updated to revision 1.-->
$ svn update --set-depth immediates maman-vide
A    maman-vide/fils
A    maman-vide/fille
Actualisé à la révision 1.<!--
$ svn update - -set-depth infinity mom-empty
Updating 'mom-empty':
A    mom-empty/son/grandson
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
A    mom-empty/daughter/granddaughter2
A    mom-empty/daughter/fishie1.txt
Updated to revision 1.
-->
$ svn update --set-depth infinity maman-vide
A    maman-vide/fils/petit-fils
A    maman-vide/fille/petite-fille1
A    maman-vide/fille/petite-fille1/lapinou1.txt
A    maman-vide/fille/petite-fille1/lapinou2.txt
A    maman-vide/fille/petite-fille2
A    maman-vide/fille/poissonou1.txt
Actualisé à la révision 1.
$
</screen>
    </informalexample>

<!--
    <para>As we gradually increased our depth selection, the
      repository gave us more pieces of our tree.</para>
-->
    <para>Au fur et à mesure que nous avons augmenté le niveau de profondeur de
      la récursion, le dépôt a complété progressivement notre
      arborescence.</para>

<!--
    <para>In our example, we operated only on the root of our working
      copy, changing its ambient depth value.  But we can
      independently change the ambient depth value of
      <emphasis>any</emphasis> subdirectory inside the working copy,
      too.  Careful use of this ability allows us to flesh out only
      certain portions of the working copy tree, leaving other
      portions absent altogether (hence the <quote>sparse</quote> bit
      of the feature's name).  Here's an example of how we might build
      out a portion of one branch of our family's tree, enable full
      recursion on another branch, and keep still other pieces pruned
      (absent from disk).</para>
-->
    <para>Dans notre exemple, nous n'avons agi que sur la racine de
      notre copie de travail, en changeant la valeur du niveau associé de
      profondeur de la récursion. Mais nous pouvons aussi changer de façon
      indépendante le niveau associé de profondeur de la récursion à chaque
      sous-dossier de la copie de travail. Une utilisation minutieuse
      de cette option nous permet de récupérer uniquement certaines
      portions de la copie de travail, en laissant de côté toutes les
      autres portions (d'où le nom <quote>clairsemé</quote> de la
      fonctionnalité). Voici un exemple montrant comment construire une
      portion d'une branche de notre arbre généalogique, activer la
      récursion totale sur une autre branche et élaguer le reste (qui ne
      sera donc pas sur notre disque dur).</para>

    <informalexample>
      <screen><!--
$ rm -rf mom-empty
$ svn checkout file:///var/svn/repos mom-empty - -depth empty
Checked out revision 1.
-->
$ rm -rf maman-vide
$ svn checkout file:///var/svn/depot maman-vide --depth empty
Révision 1 extraite.<!--
$ svn update - -set-depth empty mom-empty/son
Updating 'mom-empty/son':
A    mom-empty/son
Updated to revision 1.-->
$ svn update --set-depth empty maman-vide/fils
A    maman-vide/fils
Actualisé à la révision 1.<!--
$ svn update - -set-depth empty mom-empty/daughter
Updating 'mom-empty/daughter':
A    mom-empty/daughter
Updated to revision 1.-->
$ svn update --set-depth empty maman-vide/fille
A    maman-vide/fille
Actualisé à la révision 1.<!--
$ svn update - -set-depth infinity mom-empty/daughter/granddaughter1
Updating 'mom-empty/daughter/granddaughter1':
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
Updated to revision 1.-->
$ svn update --set-depth infinity maman-vide/fille/petite-fille1
A    maman-vide/fille/petite-fille1
A    maman-vide/fille/petite-fille1/lapinou1.txt
A    maman-vide/fille/petite-fille1/lapinou2.txt
Actualisé à la révision 1.
$
</screen>
    </informalexample>

<!--
    <para>Fortunately, having a complex collection of ambient depths
      in a single working copy doesn't complicate the way you interact
      with that working copy.  You can still make, revert, display,
      and commit local modifications in your working copy without
      providing any new options (including <option>- -depth</option> and
      <option>- -set-depth</option>) to the relevant subcommands.  Even
      <command>svn update</command> works as it does elsewhere when no
      specific depth is provided&mdash;it updates the working copy
      targets that are present while honoring their sticky
      depths.</para>
-->
    <para>Heureusement, même avec différents niveaux de récursion
      définis au sein d'une même copie de travail, les actions sur la
      copie de travail ne s'en trouvent pas plus compliquées. Vous
      pouvez toujours effectuer des modifications et les propager,
      revenir en arrière ou afficher les modifications locales de
      votre copie de travail sans spécifier d'option particulière (y
      compris <option>--depth</option> et
      <option>--set-depth</option>) aux dites commandes. Même
      <command>svn update</command> fonctionne normalement quand on ne
      lui fournit pas de niveau de récursion spécifique&nbsp;: elle met
      à jour les cibles de la copie de travail qui sont présentes en
      tenant compte des niveaux de récursion qui leur sont
      associés.</para>

<!--
    <para>You might at this point be wondering, <quote>So what?  When
      would I use this?</quote>  One scenario where this feature
      finds utility is tied to a particular repository layout,
      specifically where you have many related or codependent
      projects or software modules living as siblings in a single
      repository location (<filename>trunk/project1</filename>,
      <filename>trunk/project2</filename>,
      <filename>trunk/project3</filename>, etc.).  In such
      scenarios, it might be the case that you personally care
      about only a handful of those projects&mdash;maybe some primary
      project and a few other modules on which it depends.  You can
      check out individual working copies of all of these things, but
      those working copies are disjoint and, as a result, it can be
      cumbersome to perform operations across several or all of them
      at the same time.  The alternative is to use the sparse
      directories feature, building out a single working copy that
      contains only the modules you care about.  You'd start with an
      empty-depth checkout of the common parent directory of the
      projects, and then update with infinite depth only the items you
      wish to have, like we demonstrated in the previous example.
      Think of it like an opt-in system for working copy
      citizens.</para>
-->
    <para>Vous devez vous demander&nbsp;: <quote>Bien. Mais quand
      aurais-je besoin d'utiliser ça&nbsp;?</quote> Un cas classique est
      lié à une architecture du dépôt particulière&nbsp;: lorsque de
      nombreux projets et modules logiciels liés cohabitent au même
      niveau dans un dépôt (<filename>trunk/projet1</filename>,
      <filename>trunk/projet2</filename>,
      <filename>trunk/projet3</filename>,&nbsp;etc.). Dans de tels scénarios,
      il est probable que seuls quelques projets vous intéressent
      personnellement, sans doute pas plus d'un projet principal et de
      quelques autres modules dont il dépend. Vous pouvez extraire une
      copie de travail pour chacune de ces arborescences, mais ces
      copies de travail sont séparées et, par conséquent, il peut être
      fastidieux d'effectuer des opérations sur plusieurs ou sur
      l'ensemble des copies de travail en même temps. L'autre solution
      est d'utiliser la fonctionnalité de répertoires clairsemés, en
      construisant une seule copie de travail qui ne contient que les
      modules qui vous intéressent. Vous partez d'une extraction du
      dossier parent commun aux différents projets avec un niveau
      zéro de profondeur de récursion (empty-depth), puis vous mettez à jour
      avec un niveau infini de récursion les éléments que vous voulez
      récupérer, comme nous l'avons fait dans l'exemple précédent. Voyez ça
      comme un système d'inclusion optionnelle des éléments qui peuplent la
      copie de travail.</para>

<!--
    <para>The original (Subversion 1.5) implementation of shallow
      checkouts was good, but didn't support de-telescoping of working
      copy items.  Subversion 1.6 remedies this problem.  For example,
      running <userinput>svn update - -set-depth empty</userinput> in
      an infinite-depth working copy will discard everything but the
      topmost directory.<footnote><para>Safely, of course.  As in
      other situations, Subversion will leave on disk any files you've
      modified or which aren't versioned.</para></footnote>  Subversion
      1.6 also introduces another supported value for
      the <option>- -set-depth</option>
      option: <literal>exclude</literal>.  Using <option>- -set-depth
      exclude</option> with <command>svn update</command> will cause
      the update target to be removed from the working copy
      entirely&mdash;a directory target won't even be left
      present-but-empty.  This is especially handy when there are more
      things that you'd like to keep in a working copy than things
      you'd like to <emphasis>not</emphasis> keep.</para>
-->
    <para>L'implémentation des extractions superficielles de Subversion
      1.5 était relativement bonne mais elle ne permettait pas de diminuer le
      niveau de profondeur de récursion d'un élément de la copie de travail.
      Subversion 1.6 pallie ce problème. Par exemple, si vous lancez
      <userinput>svn update --set-depth empty</userinput> sur une copie
      de travail de niveau de récursion infini, vous ne conserverez que le
      dossier sommital<footnote><para>En toute sécurité, bien sûr. Comme
      dans les autres situations, Subversion laissera sur le disque tous les
      fichiers que vous avez modifiés ou qui ne sont pas suivis en
      versions.</para></footnote>. Subversion 1.6 introduit également une autre
      valeur de profondeur de récursion pour l'option
      <option>--set-depth</option>&nbsp;: <literal>exclude</literal>. En
      indiquant <option>--set-depth exclude</option> à <command>svn
      update</command>, la cible de la mise à jour sera entièrement supprimée
      de la copie de travail, le dossier cible lui-même étant lui aussi
      supprimé. C'est utile lorsqu'il y a davantage d'éléments de la copie de
      travail que vous voulez garder par rapport à ce que vous voulez
      supprimer.</para>

<!--
    <para>Consider a directory with hundreds of subdirectories, one of
      which you would like to omit from your working copy.  Using
      an <quote>additive</quote> approach to sparse directories, you
      might check out the directory with an empty depth, then
      explicitly telescope (using <userinput>svn update - -set-depth
      infinity</userinput>) each and every subdirectory of the
      directory except the one you don't care about it.</para>
-->
    <para>Considérons un dossier avec des centaines de sous-dossiers,
      dont un que vous ne voulez pas voir dans votre copie de travail. En
      utilisant une approche <quote>additive</quote> des dossiers
      clairsemés, vous pourriez l'extraire avec un niveau de profondeur nul,
      puis explicitement augmenter (en utilisant  <userinput>svn update
      --set-depth infinity</userinput>) le niveau de profondeur pour tous les
      autres sous-dossiers.</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/repos/many-dirs - depth empty
&hellip;
$ svn update - -set-depth infinity many-dirs/wanted-dir-1
&hellip;
$ svn update - -set-depth infinity many-dirs/wanted-dir-2
&hellip;
$ svn update - -set-depth infinity many-dirs/wanted-dir-3
&hellip;
### and so on, and so on, ...
-->
$ svn checkout http://svn.exemple.com/depot/plein-de-repertoires --depth empty
&hellip;
$ svn update --set-depth infinity plein-de-repertoires/rep-voulu-1
&hellip;
$ svn update --set-depth infinity plein-de-repertoires/rep-voulu-2
&hellip;
$ svn update --set-depth infinity plein-de-repertoires/rep-voulu-3
&hellip;
### etc., etc.
</screen>
    </informalexample>

<!--
    <para>This could be quite tedious, especially since you don't even
      have stubs of these directories in your working copy to deal
      with.  Such a working copy would also have another
      characteristic that you might not expect or desire: if someone
      else creates any new subdirectories in this top-level directory,
      you won't receive those when you update your working
      copy.</para>
-->
    <para>C'est peut-être un peu fastidieux, d'autant que vous n'avez pas
      les <quote>souches</quote> de ces dossiers dans votre copie de travail
      pour les manipuler. Une telle copie de travail aurait de plus une
      caractéristique que vous ne soupçonnez pas ou ne voulez pas&nbsp;: si
      quelqu'un d'autre crée un sous-dossier dans le dossier racine, vous ne le
      recevrez pas lors de vos mises à jour.</para>

<!--
    <para>Beginning with Subversion 1.6, you can take a different
      approach.  First, check out the directory in full.  Then
      run <userinput>svn update - -set-depth exclude</userinput> on the
      one subdirectory you don't care about.</para>
-->
    <para>À partir de Subversion 1.6, vous pouvez adopter une approche
      différente. En premier lieu, faites une extraction du dossier en
      entier. Ensuite, lancez <userinput>svn update --set-depth
      exclude</userinput> sur le dossier que vous ne voulez pas voir.</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/repos/many-dirs
&hellip;
$ svn update - -set-depth exclude many-dirs/unwanted-dir
D         many-dirs/unwanted-dir-->
$ svn checkout http://svn.exemple.com/depot/plein-de-repertoires
&hellip;
$ svn update --set-depth exclude plein-de-repertoires/j-en-veux-pas
D         plein-de-repertoires/j-en-veux-pas
$
</screen>
    </informalexample>

<!--
    <para>This approach leaves your working copy with the same stuff
      as in the first approach, but any new subdirectories which
      appear in the top-level directory would also show up when you
      update your working copy.  The downside of this approach is that
      you have to actually check out that whole subdirectory that you
      don't even want just so you can tell Subversion that you don't
      want it.  This might not even be possible if that subdirectory
      is too large to fit on your disk (which might, after all, be the
      very reason you don't want it in your working copy).</para>
-->
    <para>Cette approche laisse votre copie de travail avec le même contenu
      que la première approche, mais si un sous-dossier est créé au niveau
      du dossier racine, il apparaîtra lors de la mise à jour de votre copie
      de travail. L'inconvénient de cette approche est que vous devez extraire
      tout le sous-dossier que vous ne voulez pas garder afin de pouvoir
      dire à Subversion que vous n'en voulez pas. Il n'est pas impossible que
      ce sous-dossier soit trop gros pour votre disque dur (ce qui pourrait
      expliquer, après tout, que vous n'en voulez pas dans votre copie de
      travail).</para>

<!--
    <note>
      <para>While the functionality for excluding an existing item
        from a working copy was hung off of the <command>svn
        update</command> command, you might have noticed that the
        output from <userinput>svn update - -set-depth
        exclude</userinput> differs from that of a normal update
        operation.  This output betrays the fact that, under the hood,
        exlusion is a completely client-side operation, very much
        unlike a typical update.</para>
    </note>
-->
    <note>
      <para>Alors qu'exclure un élément existant de la copie de travail
       ne fait pas partie de la commande <command>svn update</command>, vous
       avez sans doute remarqué que la sortie de <userinput> svn update
       --set-depth exclude</userinput> diffère de celle d'une mise à jour
       normale. Cette sortie trahit le fait que, sous le capot, l'exclusion est
       une opération réalisée entièrement du côté du client, à l'opposé d'une
       mise à jour classique.</para>
    </note>

<!--
    <para>In such a situation, you might consider a compromise
      approach.  First, check out the top-level directory
      with <option>- -depth immediates</option>.  Then, exclude the
      directory you don't want using <userinput>svn update - -set-depth
      exclude</userinput>.  Finally, telescope all the items that
      remain to infinite depth, which should be fairly easy to do
      because they are all addressable in your shell.</para>
-->
    <para>Dans une telle situation, vous pouvez adopter une approche
      intermédiaire. D'abord, faites une extraction du dossier racine avec
      l'option <option>--depth immediates</option>. Puis, faites une extraction
      du dossier que vous ne souhaitez pas conserver avec
      <userinput>svn update --set-depth exclude</userinput>. Enfin, récupérez
      tous les éléments qui restent à un niveau de profondeur infini, ce qui
      relativement facile puisque tous sont visibles par votre interpréteur de
      commandes.</para>

    <informalexample>
    <screen><!--
$ svn checkout http://svn.example.com/repos/many-dirs - -depth immediates
&hellip;
$ svn update - -set-depth exclude many-dirs/unwanted-dir
D         many-dirs/unwanted-dir
$ svn update - -set-depth infinity many-dirs/*
&hellip;-->
$ svn checkout http://svn.exemple.com/depot/plein-de-repertoires --depth immediates
&hellip;
$ svn update --set-depth exclude plein-de-repertoires/j-en-veux-pas
D         plein-de-repertoires/j-en-veux-pas
$ svn update --set-depth infinity plein-de-repertoires/*
&hellip;
$
</screen>
    </informalexample>

<!--
    <para>Once again, your working copy will have the same stuff as in
      the previous two scenarios.  But now, any time a new file or
      subdirectory is committed to the top-level directory, you'll
      receive it&mdash;at an empty depth&mdash;when you update your
      working copy.  You can now decide what to do with such newly
      appearing working copy items: expand them into infinite depth,
      or exclude them altogether.</para>
-->
    <para>Cette fois encore, votre copie de travail contiendra la même chose
      que dans les deux cas précédents. Mais maintenant, chaque fois qu'un
      nouveau fichier ou sous-dossier sera propagé au niveau du dossier
      racine, vous le recevrez (à un niveau de profondeur nul) au moment de
      votre mise à jour. Vous pouvez décider à ce stade ce que vous voulez
      faire avec ce nouvel élément&nbsp;: le récupérer avec un niveau de
      profondeur infini ou l'exclure.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
<!--
    <title>Locking</title>
-->
    <title>Verrouillage</title>

<!--
    <para>Subversion's copy-modify-merge version control model lives
      and dies on its data merging algorithms&mdash;specifically on
      how well those algorithms perform when trying to resolve
      conflicts caused by multiple users modifying the same file
      concurrently.  Subversion itself provides only one such
      algorithm: a three-way differencing algorithm that is smart
      enough to handle data at a granularity of a single line of text.
      Subversion also allows you to supplement its content merge
      processing with external differencing utilities (as described in
      <xref linkend="svn.advanced.externaldifftools.diff3" /> and
      <xref linkend="svn.advanced.externaldifftools.merge" />), some
      of which may do an even better job, perhaps providing
      granularity of a word or a single character of text.  But common
      among those algorithms is that they generally work only on text
      files.  The landscape starts to look pretty grim when you start
      talking about content merges of nontextual file formats.  And
      when you can't find a tool that can handle that type of merging,
      you begin to run into problems with the copy-modify-merge
      model.</para>
-->
    <para>Le modèle copier-modifier-fusionner de gestion de versions de
      Subversion repose sur ses algorithmes de fusion, notamment sur la
      manière dont ils gèrent les conflits quand de multiples
      collaborateurs modifient le même fichier simultanément. Subversion
      lui-même ne propose qu'un seul algorithme de ce type, un
      algorithme qui détecte les modifications par trois méthodes et qui
      est suffisamment intelligent pour gérer les données à la ligne
      près. Subversion vous permet également d'utiliser en plus des
      outils externes lors du processus de fusion (comme indiqué dans
      <xref linkend="svn.advanced.externaldifftools.diff3" /> et
      <xref linkend="svn.advanced.externaldifftools.merge" />), parfois
      encore meilleurs que ceux inclus dans Subversion, proposant par
      exemple une granularité plus fine allant jusqu'au mot, voire au
      caractère, au lieu de s'arrêter à la ligne. Mais, en règle
      générale, ces algorithmes ne fonctionnent que sur des fichiers
      texte. Le paysage est beaucoup plus sombre lorsque l'on recherche
      des outils de fusion pour des formats de fichiers non-texte. Et
      quand vous ne trouvez pas d'outil capable de fusionner de tels
      fichiers, les limites du modèle copier-modifier-fusionner se font
      vite sentir.</para>

<!--
    <para>Let's look at a real-life example of where this model runs
      aground.  Harry and Sally are both graphic designers working on
      the same project, a bit of marketing collateral for an
      automobile mechanic.  Central to the design of a particular
      poster is an image of a car in need of some bodywork, stored in
      a file using the PNG image format.  The poster's layout is
      almost finished, and both Harry and Sally are pleased with the
      particular photo they chose for their damaged car&mdash;a baby
      blue 1967 Ford Mustang with an unfortunate bit of crumpling on
      the left front fender.</para>
-->
   <para>Prenons un exemple de la vie réelle où ce type de problème
     apparaît. Harry et Sally sont deux graphistes travaillant sur le
     même projet (du marketing pour le patron d'un garage). Au cœur
     d'une affiche de ce projet se trouve l'image d'une voiture dont la
     carrosserie a besoin d'être réparée, stockée dans un fichier image
     au format PNG. L'agencement de l'affiche est pratiquement terminé,
     et Harry et Sally sont contents de la photo qu'ils ont choisie pour
     leur voiture endommagée&nbsp;: une Ford Mustang bleue de 1967, avec
     un gnon sur l'aile avant gauche.</para>

<!--
    <para>Now, as is common in graphic design work, there's a change
      in plans, which causes the car's color to be a concern.  So Sally
      updates her working copy to <literal>HEAD</literal>, fires up
      her photo-editing software, and sets about tweaking the image so
      that the car is now cherry red.  Meanwhile, Harry, feeling
      particularly inspired that day, decides that the image would
      have greater impact if the car also appears to have suffered
      greater impact.  He, too, updates to <literal>HEAD</literal>,
      and then draws some cracks on the vehicle's windshield.  He
      manages to finish his work before Sally finishes hers, and after
      admiring the fruits of his undeniable talent, he commits the
      modified image.  Shortly thereafter, Sally is finished with the
      car's new finish and tries to commit her changes.  But, as
      expected, Subversion fails the commit, informing Sally that
      her version of the image is now out of date.</para>
-->
    <para>C'est alors, comme c'est souvent le cas dans le domaine du
      graphisme, que des contraintes extérieures imposent de changer la
      couleur de la voiture. Sally met donc à jour sa copie de travail à
      la révision <literal>HEAD</literal>, lance son outil d'édition de
      photos et commence à modifier la photo de manière à obtenir une
      voiture rouge cerise. Pendant ce temps, Harry, particulièrement
      inspiré ce jour-là, décide que l'image serait plus percutante si
      la voiture était davantage endommagée. Lui aussi met à jour sa
      copie de travail à la révision <literal>HEAD</literal>, puis
      dessine des fissures sur le pare-brise. Il termine son travail
      avant que Sally ne termine le sien, admire son chef-d'œuvre et
      propage les changements. Peu après, Sally en termine avec la
      nouvelle couleur de la voiture et essaie de propager ses
      modifications. Mais, comme prévu, Subversion ne parvient pas à
      valider la propagation et informe Sally que sa version de l'image
      est dorénavant obsolète.</para>

<!--
    <para>Here's where the difficulty sets in.  If Harry and Sally
      were making changes to a text file, Sally would simply update
      her working copy, receiving Harry's changes in the process.  In
      the worst possible case, they would have modified the same
      region of the file, and Sally would have to work out by hand the
      proper resolution to the conflict.  But these aren't text
      files&mdash;they are binary images.  And while it's a simple
      matter to describe what one would expect the results of this
      content merge to be, there is precious little chance that any
      software exists that is smart enough to examine the common
      baseline image that each of these graphic artists worked
      against, the changes that Harry made, and the changes that Sally
      made, and then spit out an image of a busted-up red Mustang with
      a cracked windshield!</para>
-->
    <para>Voilà où résident les difficultés&nbsp;: si Harry et Sally
      avaient effectué leurs changements sur un fichier texte, Sally
      aurait simplement mis à jour sa copie de travail, recevant au
      passage les modifications de Harry. Dans le pire des cas, ils
      auraient modifié la même portion du fichier et Sally aurait eu à
      résoudre les conflits manuellement. Mais, ici, nous avons affaire
      à des images binaires, pas des fichiers texte. Et s'il est
      relativement facile de décrire ce que devrait être l'image finale,
      il y a très peu de chances qu'un logiciel soit suffisamment
      intelligent pour détecter les parties communes de l'image sur
      laquelle les artistes ont travaillé, les changements effectués par
      Harry et les changements effectués par Sally et pour en tirer une
      image d'une Mustang rouge avec un pare-brise fissuré&nbsp;!</para>

<!--
    <para>
      <indexterm>
        <primary>locks</primary>
      </indexterm>
      <indexterm>
        <primary>checkouts</primary>
        <secondary>reserved</secondary>
        <see>locking</see>
      </indexterm>Of course, things would have gone more smoothly if
      Harry and Sally had serialized their modifications to the
      image&mdash;if, say, Harry had waited to draw his windshield
      cracks on Sally's now-red car, or if Sally had tweaked the color
      of a car whose windshield was already cracked.  As is discussed
      in <xref linkend="svn.basic.vsn-models.copy-merge" />, most of
      these types of problems go away entirely where perfect
      communication between Harry and Sally
      exists.<footnote><para>Communication wouldn't have been such bad
      medicine for Harry and Sally's Hollywood namesakes, either, for
      that matter.</para></footnote> But as one's version control
      system is, in fact, one form of communication, it follows that
      having that software facilitate the serialization of
      nonparallelizable editing efforts is no bad thing.  This is
      where Subversion's implementation of the lock-modify-unlock
      model steps into the spotlight.  This is where we talk about
      Subversion's <firstterm>locking</firstterm> feature, which is
      similar to the <quote>reserved checkouts</quote> mechanisms of
      other version control systems.</para>
-->
    <para>
      <indexterm>
        <primary>verrous</primary>
      </indexterm>
      <indexterm>
        <primary>réserver</primary>
        <secondary>pour modifications</secondary>
        <see>verrouillages</see>
      </indexterm>Clairement, les choses se seraient mieux passées si Harry et
      Sally avaient sérialisé leurs modifications&nbsp;: par exemple, si
      Harry avait attendu et dessiné ses fissures sur la voiture
      nouvellement rouge de Sally, ou si Sally avait changé la couleur
      d'une voiture avec un pare-brise déjà fissuré. Comme indiqué dans
      <xref linkend="svn.basic.vsn-models.copy-merge" />, la plupart
      de ces problèmes disparaissent complètement quand une
      communication parfaite existe entre Harry et Sally
      <footnote>
        <para>À ce propos, un peu de communication n'aurait pas non plus
          été un mauvais remède pour leurs homonymes hollywoodiens.</para>
      </footnote>.
      Mais comme un système de gestion de versions est en fait un mode
      de communication, il s'ensuit que si ce type de logiciel facilite
      la sérialisation de tâches d'édition non parallélisables, c'est
      plutôt une bonne chose. C'est ici que l'implémentation du concept
      verrouiller-modifier-libérer dans Subversion prend tout son sens.
      Il est temps de parler de la fonctionnalité de
      <firstterm>verrouillage</firstterm> de Subversion, qui est
      similaire aux mécanismes permettant de <quote>réserver
      pour modifications</quote> des fichiers dans d'autres systèmes de
      gestion de versions.</para>

<!--
    <para>Subversion's locking feature exists ultimately to minimize
      wasted time and effort.  By allowing a user to programmatically
      claim the exclusive right to change a file in the repository,
      that user can be reasonably confident that any energy he invests
      on unmergeable changes won't be wasted&mdash;his commit of those
      changes will succeed.  Also, because Subversion communicates to
      other users that serialization is in effect for a particular
      versioned object, those users can reasonably expect that the
      object is about to be changed by someone else.  They, too, can
      then avoid wasting their time and energy on unmergeable changes
      that won't be committable due to eventual
      out-of-dateness.</para>
-->
    <para>En fin de compte, la fonctionnalité de verrouillage existe afin
      de minimiser les pertes de temps et les efforts. En autorisant un
      utilisateur à s'arroger logiciellement le droit exclusif de
      modifier un fichier dans le dépôt, cet utilisateur peut être
      suffisamment confiant dans le fait que son travail ne sera pas
      vain &mdash; la propagation de ses changements réussira. Aussi,
      en signifiant aux autres utilisateurs qu'une sérialisation a lieu
      pour un objet suivi en versions, ces utilisateurs peuvent
      raisonnablement s'attendre à ce que cet objet soit modifié par
      quelqu'un d'autre. Eux aussi peuvent alors éviter de perdre leur
      temps et leur énergie sur des modifications qui ne peuvent pas
      être fusionnées en raison d'un problème d'obsolescence du fichier
      correspondant.</para>

<!--
    <para>When referring to Subversion's locking feature, one is
      actually talking about a fairly diverse collection of behaviors,
      which include the ability to lock a versioned
      file<footnote><para>Subversion does not currently allow locks on
      directories.</para></footnote> (claiming the exclusive right to
      modify the file), to unlock that file (yielding that exclusive
      right to modify), to see reports about which files are locked
      and by whom, to annotate files for which locking before editing
      is strongly advised, and so on.  In this section, we'll cover
      all of these facets of the larger locking feature.</para>
-->
    <para>La fonctionnalité de verrouillage de Subversion comporte en
      fait plusieurs facettes, qui permettent entre autres de
      verrouiller un fichier suivi en versions<footnote>
        <para>Pour l'instant, Subversion ne permet pas de poser de
          verrou sur un dossier.</para>
      </footnote>
      (demander le droit exclusif de modification sur le fichier), de le
      déverrouiller (abandonner le droit exclusif de modification), de
      voir la liste des fichiers qui sont verrouillés et par qui,
      d'annoter des fichiers pour lesquels le verrouillage est fortement
      recommandé avant édition,&nbsp;etc. Dans cette section, nous abordons
      toutes les facettes de cette fonctionnalité de verrouillage.</para>

    <sidebar id="svn.advanced.locking.meanings">
<!--
      <title>The Many Meanings of <quote>Lock</quote></title>
-->
      <title>Les différents types de <quote>verrous</quote></title>

<!--
      <para>In this section, and almost everywhere in this book, the
        words <quote>lock</quote> and <quote>locking</quote> describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits.  Unfortunately, there are other sorts
        of <quote>lock</quote> with which Subversion, and therefore
        this book, sometimes needs to be concerned.</para>
-->
      <para>Dans cette section, comme pratiquement partout dans ce livre,
        les mots <quote>verrou</quote> et <quote>verrouillage</quote>
        décrivent un mécanisme d'exclusion mutuelle entre utilisateurs
        pour éviter des propagations incompatibles. Malheureusement, il
        existe d'autres sortes de <quote>verrous</quote> auxquels
        Subversion et donc ce livre sont confrontés.</para>

<!--
      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>administrative</secondary>
        </indexterm>Subversion uses <firstterm>administrative
        locks</firstterm> internally to prevent
        clashes between multiple Subversion clients operating on the
        same working copy.  This is the sort of lock indicated by an
        <computeroutput>L</computeroutput> in the third column of
        <command>svn status</command> output, and removed by the
        <command>svn cleanup</command> command, as described in <xref
        linkend="svn.tour.cleanup"/>.</para>
-->
      <para>
        <indexterm>
          <primary>verrous</primary>
          <secondary>administratifs</secondary>
        </indexterm>Subversion utilise en interne des <firstterm>verrous
        administratifs</firstterm> pour
        éviter des collisions entre de multiples instances du client
        Subversion travaillant sur la même copie de travail. Ce type de
        verrou est repérable grâce au <computeroutput>L</computeroutput>
        situé dans la troisième colonne de la sortie de <command>svn
        status</command> et peut être supprimé par la commande
        <command>svn cleanup</command>, comme indiqué à <xref
        linkend="svn.tour.cleanup"/>.</para>

<!--
      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>database</secondary>
        </indexterm>Administrators using the older Berkeley DB repository
        backend will need to be familiar with <firstterm>database
        locks</firstterm>, which exist to prevent clashes between multiple
        programs trying to access the database.  This is the sort of lock
        whose unwanted persistence after an error can cause a repository
        to be <quote>wedged,</quote> as described in
        <xref linkend="svn.berkeleydb.maintenance.recovery" />.</para>
-->
      <para>
        <indexterm>
          <primary>verrous</primary>
          <secondary>bases de données</secondary>
        </indexterm>Ensuite, pour les administrateurs qui utilisent l'ancien
        magasin de données Berkeley DB pour leurs dépôts, il y a les
        <firstterm>verrous des bases de données</firstterm>, utilisés en
        interne pour éviter les collisions entre de multiples
        programmes accédant à la base de données. C'est le type de
        verrou qui, s'il est encore présent à notre insu après une
        erreur, peut provoquer un <quote>plantage</quote> du dépôt, comme
        indiqué dans <xref linkend="svn.berkeleydb.maintenance.recovery"
        />.</para>
<!--
      <para>You can generally forget about these other kinds of locks
        until something goes wrong that requires you to care about
        them.  In this book, <quote>lock</quote> means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</para>
-->
      <para>En général, vous pouvez faire abstraction de ces autres
        types de verrous, du moins tant que tout va bien. Si les choses
        se gâtent, vous aurez peut-être à vous y intéresser. Dans ce
        livre, le terme <quote>verrou</quote> désigne la fonctionnalité
        Subversion, sauf si le contexte indique le contraire ou si c'est
        mentionné explicitement.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
<!--
      <title>Creating Locks</title>
-->
      <title>Création d'un verrou</title>

<!--
      <para>
        <indexterm>
          <primary>locks</primary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>lock token</secondary>
        </indexterm>
        <indexterm>
          <primary>locking</primary>
          <secondary>lock owner</secondary>
        </indexterm>In the Subversion repository, a
        <firstterm>lock</firstterm> is a piece of metadata that
        grants exclusive access to one user to change a file.  This
        user is said to be the <firstterm>lock owner</firstterm>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <firstterm>lock
        token</firstterm>.  The repository manages locks, ultimately
        handling their creation, enforcement, and removal.  If any
        commit transaction attempts to modify or delete a locked file
        (or delete one of the parent directories of the file), the
        repository will demand two pieces of information&mdash;that
        the client performing the commit be authenticated as the lock
        owner, and that the lock token has been provided as part of
        the commit process as a form of proof that the client knows which
        lock it is using.</para>
-->
      <para>
        <indexterm>
          <primary>verrous</primary>
        </indexterm>
        <indexterm>
          <primary>verrous</primary>
          <secondary>jeton de verrouillage</secondary>
        </indexterm>
        <indexterm>
          <primary>verrous</primary>
          <secondary>détenteur du verrou</secondary>
        </indexterm>Dans un dépôt Subversion, un <firstterm>verrou</firstterm>
        est une méta-donnée qui alloue à un utilisateur un accès
        exclusif en écriture sur un fichier. Cet utilisateur est
        appelé <firstterm>détenteur du verrou</firstterm>. Chaque verrou
        possède également un identifiant unique, en général une longue
        chaîne de caractères, appelé <firstterm>jeton de
        verrouillage</firstterm>. Le dépôt gère les verrous en assurant
        <foreignphrase>in fine</foreignphrase> leur création, leur application
        et leur suppression. Si une propagation tente de modifier ou effacer un
        fichier verrouillé (ou effacer un dossier parent dudit fichier), le
        dépôt demande deux informations&nbsp;: que le client effectuant
        la propagation s'authentifie en tant que détenteur du verrou et
        que le jeton de verrouillage soit fourni lors de la procédure de
        propagation afin de montrer que le client sait bien quel
        verrou il utilise.</para>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>lock</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>creation</secondary>
        </indexterm>To demonstrate lock creation, let's refer back to
        our example of multiple graphic designers working on the same
        binary image files.  Harry has decided to change a JPEG image.
        To prevent other people from committing changes to the file
        while he is modifying it (as well as alerting them that he is
        about to change it), he locks the file in the repository using
        the <command>svn lock</command> command.</para>
-->
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>lock</tertiary>
        </indexterm>
        <indexterm>
          <primary>verrous</primary>
          <secondary>création</secondary>
        </indexterm>Pour illustrer la création d'un verrou, reprenons notre
        exemple de graphistes travaillant sur les mêmes fichiers images
        binaires. Harry a décidé de changer cette image JPEG. Pour
        interdire aux autres collaborateurs d'effectuer des changements
        sur le fichier pendant qu'il le modifie (et pour les avertir
        qu'il va modifier ce fichier), il verrouille le fichier dans le
        dépôt en utilisant la commande
        <command>svn lock</command>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn lock banana.jpg -m "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.-->
$ svn lock banane.jpg -m "Édition du fichier pour la livraison de demain."
'banane.jpg' verrouillé par l'utilisateur 'harry'.
$
</screen>
      </informalexample>

<!--
      <para>The preceding example demonstrates a number of new things.
        First, notice that Harry passed the
        <option>- -message</option> (<option>-m</option>) option to
        <command>svn lock</command>.  Similar to <command>svn
        commit</command>, the <command>svn lock</command> command can
        take comments&mdash;via either <option>- -message</option>
        (<option>-m</option>) or <option>- -file</option>
        (<option>-F</option>)&mdash;to describe the reason for locking the
        file.  Unlike <command>svn commit</command>, however,
        <command>svn lock</command> will not demand a message by
        launching your preferred text editor.  Lock comments are
        optional, but still recommended to aid communication.</para>
-->
      <para>Il y a plusieurs points intéressants dans l'exemple
        ci-dessus&nbsp;: d'abord, notez que Harry utilise l'option
        <option>--message</option> (<option>-m</option>) de
        <command>svn lock</command>. Comme <command>svn
        commit</command>, la commande <command>svn lock</command>
        accepte des commentaires (soit <foreignphrase>via</foreignphrase>
        <option>--message</option> (<option>-m</option>), soit
        <foreignphrase>via</foreignphrase> <option>--file</option>
        (<option>-F</option>)) pour indiquer la raison du verrouillage du
        fichier. En revanche, contrairement à <command>svn
        commit</command>, <command>svn lock</command> n'exige pas
        automatiquement un message en lançant votre éditeur de texte
        préféré. Les commentaires de verrouillage sont optionnels, mais
        néanmoins recommandés pour faciliter la communication entre
        collaborateurs.</para>

<!--
      <para>Second, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out of date, the repository would have rejected the
        request, forcing Harry to <command>svn update</command> and
        reattempt the locking command.  The locking command would also
        have failed if the file had already been locked by someone
        else.</para>
-->
      <para>Ensuite, la tentative de verrouillage a réussi. Cela
        signifie que le fichier n'était pas préalablement verrouillé et
        que Harry disposait de la dernière version du fichier. Si la
        copie de travail de Harry avait été obsolète, le dépôt aurait
        refusé la demande, forçant Harry à effectuer une mise à jour
        (<command>svn update</command>) et à relancer ensuite la
        commande de verrouillage. La commande de verrouillage aurait
        également échoué si le fichier avait déjà été verrouillé par
        quelqu'un d'autre.</para>

<!--
      <para>As you can see, the <command>svn lock</command> command
        prints confirmation of the successful lock.  At this point,
        the fact that the file is locked becomes apparent in the
        output of the <command>svn status</command> and <command>svn
        info</command> reporting subcommands.</para>
-->
      <para>Comme vous pouvez le constater, la commande <command>svn
        lock</command> affiche la confirmation que le verrouillage a
        réussi. Dès lors, le verrouillage du fichier apparaît dans le
        résultat des commandes <command>svn status</command> et
        <command>svn info</command>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn status
     K  banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
Working Copy Root Path: /home/harry/project
URL: http://svn.example.com/repos/project/banana.jpg
Relative URL: ^/banana.jpg
Repository Root: http://svn.example.com/repos/project
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
-->
$ svn status
     K banane.jpg

$ svn info banane.jpg
Chemin : banane.jpg
Nom : banane.jpg
URL : http://svn.exemple.com/depot/projet/banane.jpg
Racine du dépôt : http://svn.exemple.com/depot
UUID du dépôt : edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Type de nœud : file
Tâche programmée : normale
Auteur de la dernière modification : frank
Révision de la dernière modification : 1950
Date de la dernière modification : 2006-03-15 12:43:04 -0600 (mer. 15 mars 2006)
Texte mis à jour : 2006-06-08 19:23:07 -0500 (jeu. 08 juin 2006)
Propriétés mis à jour : 2006-06-08 19:23:07 -0500 (jeu. 08 juin 2006)
Somme de contrôle: 3b110d3b10638f5d1f4fe0f436a5a2a5
Nom de verrou : opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Propriétaire du verrou : harry
Verrou créé : 2006-06-14 17:20:31 -0500 (mer. 14 juin 2006)
Commentaire du verrou (1 ligne):
Édition du fichier pour la livraison de demain.

$
</screen>
      </informalexample>

<!--
      <para>The fact that the <command>svn info</command> command,
        which does not contact the repository when run against working
        copy paths, can display the lock token reveals an important
        piece of information about those tokens:  they are cached in
        the working copy.  The presence of the lock token is critical.
        It gives the working copy authorization to make use of the
        lock later on.  Also, the <command>svn status</command>
        command shows a <literal>K</literal> next to the file (short
        for locKed), indicating that the lock token is present.</para>
-->
      <para>Le fait que la commande <command>svn info</command>, qui ne
        contacte pas le dépôt quand elle porte sur un chemin d'une copie
        de travail, affiche bien le jeton de verrouillage, révèle une
        caractéristique importante des jetons de verrouillage&nbsp;: ils
        sont intégrés dans la copie de travail. La présence du jeton de
        verrouillage est primordiale. Il authorise la copie de travail
        à utiliser le verrou ultérieurement. Par ailleurs, la
        commande <command>svn status</command> affiche un
        <literal>K</literal> (raccourci pour <foreignphrase>locKed</foreignphrase>
        &mdash; <quote>verrouillé</quote> en anglais) avant le nom du
        fichier, indiquant que le jeton de verrouillage est présent.</para>

      <sidebar>
<!--
        <title>Regarding Lock Tokens</title>
-->
        <title>À propos des jetons de verrouillage</title>

<!--
        <para>A lock token isn't an authentication token, so much as
          an <emphasis>authorization</emphasis> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <userinput>svn info
          <replaceable>URL</replaceable></userinput>.  A lock token is
          special only when it lives inside a working copy.  It's
          proof that the lock was created in that particular working
          copy, and not somewhere else by some other client.  Merely
          authenticating as the lock owner isn't enough to prevent
          accidents.</para>
-->
        <para>Un jeton de verrouillage n'est pas un jeton
          d'authentification mais plutôt un jeton
          d'<emphasis>autorisation</emphasis>. Le jeton n'est pas
          protégé comme un secret. En fait, le jeton de verrouillage
          peut être vu par n'importe quel utilisateur qui lance la
          commande <userinput>svn info <replaceable>URL</replaceable></userinput>.
          Un jeton de verrouillage n'a de propriété spéciale que quand
          il est placé dans une copie de travail. C'est la preuve que
          le verrou a été créé dans cette copie de travail et non
          ailleurs par quelqu'un d'autre. Seulement s'authentifier en
          tant que propriétaire du verrou n'est pas suffisant pour
          éviter les accidents.</para>

<!--
        <para>
          <indexterm>
            <primary>locks</primary>
            <secondary>breaking</secondary>
          </indexterm>For example, suppose you lock a file using a
          computer at your office, but leave work for the day before
          you finish your changes to that file.  It should not be
          possible to accidentally commit changes to that same file
          from your home computer later that evening simply because
          you've authenticated as the lock's owner.  In other words,
          the lock token prevents one piece of Subversion-related
          software from undermining the work of another.  (In our
          example, if you really need to change the file from an
          alternative working copy, you would need
          to <firstterm>break</firstterm> the lock and relock the
          file.)</para>
-->
        <para>
          <indexterm>
            <primary>verrous</primary>
            <secondary>cassage</secondary>
          </indexterm>Par exemple, supposons que vous verrouilliez un fichier
          avec votre ordinateur au bureau, puis que vous quittiez le
          travail avant d'avoir fini vos changements sur ce fichier. Il
          ne doit pas être possible de propager accidentellement des
          modifications de ce même fichier depuis votre ordinateur à la
          maison plus tard dans la soirée simplement parce que vous vous
          êtes authentifié en tant que détenteur du verrou. En d'autres
          termes, le verrou interdit à une instance d'un quelconque
          client Subversion de saboter le travail d'une autre instance
          (dans notre exemple, si vous avez réellement besoin de
          modifier le fichier depuis votre copie de travail à la maison,
          vous devrez <firstterm>casser</firstterm> le verrou puis
          re-verrouiller le fichier).</para>

      </sidebar>

<!--
      <para>Now that Harry has locked <filename>banana.jpg</filename>,
        Sally is unable to change or delete that file:</para>
-->
      <para>Maintenant que Harry a verrouillé <filename>banane.jpg</filename>,
        Sally ne peut ni modifier ni effacer ce fichier&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: E175002: Commit failed (details follow):
svn: E175002: Server sent unexpected return value (423 Locked) in response to
DELETE request for '/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc
35d/banana.jpg'
-->
$ svn delete banane.jpg
D         banane.jpg
$ svn commit -m "Suppression des fichiers inutiles."
Suppression    banane.jpg
svn: E175002: Échec de la propagation (commit), (détails):
svn: E175002: Suppression de '/depot/projet/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banane.jpg':
423 Verrouillé (http://svn.exemple.com)
$
</screen>
      </informalexample>

<!--
      <para>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner and also because his working
        copy holds the correct lock token:</para>
-->
      <para>Mais Harry, après avoir fait ses retouches sur sa belle
        banane jaune, peut propager ses changements sur le fichier.
        C'est parce qu'il s'authentifie en tant que détenteur du verrou
        et aussi parce que sa copie de travail possède le bon jeton de
        verrouillage&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status<!--
M    K  banana.jpg
$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
-->
M    K banane.jpg
$ svn commit -m "Rendu la banane plus jaune."
Envoi        banane.jpg
Transmission des données .
Révision 2201 propagée.
$ svn status
$
</screen>
      </informalexample>

<!--
      <para>Notice that after the commit is finished, <command>svn
        status</command> shows that the lock token is no longer
        present in the working copy.  This is the standard behavior of
        <command>svn commit</command>&mdash;it searches the working
        copy (or list of targets, if you provide such a list) for
        local modifications and sends all the lock tokens it
        encounters during this walk to the server as part of the
        commit transaction.  After the commit completes successfully,
        all of the repository locks that were mentioned are
        released&mdash;<emphasis>even on files that weren't
        committed</emphasis>.  This is meant to discourage users from
        being sloppy about locking or from holding locks for too long.
        If Harry haphazardly locks 30 files in a directory named
        <filename>images</filename> because he's unsure of which files
        he needs to change, yet changes only four of those files, when he
        runs <userinput>svn commit images</userinput>, the process will
        still release all 30 locks.</para>
-->
      <para>Notez qu'après que la propagation est terminée, <command>svn
        status</command> permet de voir que le jeton de verrouillage
        n'est plus présent dans la copie de travail. C'est le
        comportement normal de <command>svn commit</command>&nbsp;: elle
        recherche dans la copie de travail (ou dans une liste de cibles,
        si vous fournissez une telle liste) les modifications effectuées
        localement et elle envoie les jetons de verrouillage qu'elle
        trouve durant sa recherche au serveur, en tant que partie
        intégrante du processus de propagation. Après que la propagation
        a réussi, tous les verrous du dépôt qui ont été mentionnés sont
        libérés, <emphasis>même ceux pour lesquels les fichiers n'ont
        pas été propagés</emphasis>. Ce comportement a pour but de
        dissuader les utilisateurs d'être négligents avec leurs verrous
        ou de garder des verrous trop longtemps. Si Harry verrouille au
        hasard trente fichiers dans un répertoire nommé
        <filename>Images</filename> parce qu'il n'est pas sûr de savoir
        quels fichiers il doit modifier et qu'il ne modifie finalement
        que quatre fichiers, alors quand il lance la commande
        <userinput>svn commit Images</userinput>, la procédure libère
        les trente verrous.</para>

<!--
      <para>This behavior of automatically releasing locks can be
        overridden with the <option>- -no-unlock</option> option to
        <command>svn commit</command>.  This is best used for those
        times when you want to commit changes, but still plan to make
        more changes and thus need to retain existing locks.  You can
        also make this your default behavior by setting the
        <literal>no-unlock</literal> runtime configuration option (see
        <xref linkend="svn.advanced.confarea" />).</para>
-->
      <para>Ce mode de fonctionnement (libérer automatiquement les
        verrous) peut être modifié avec l'option
        <option>--no-unlock</option> de <command>svn commit</command>.
        C'est utile quand vous voulez propager des changements mais que
        vous prévoyez d'effectuer des changements supplémentaires et
        que donc vous avez toujours besoin des verrous. Vous pouvez
        également en faire le fonctionnement par défaut en réglant
        l'option <literal>no-unlock</literal> dans la zone de
        configuration (voir
        <xref linkend="svn.advanced.confarea" />).</para>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>unlock</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>releasing</secondary>
        </indexterm>Of course, locking a file doesn't oblige one to
        commit a change to it.  The lock can be released at any time
        with a simple <command>svn unlock</command> command:</para>
-->
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>unlock</tertiary>
        </indexterm>
        <indexterm>
          <primary>verrous</primary>
          <secondary>libération</secondary>
        </indexterm>Bien sûr, verrouiller un fichier n'oblige pas l'utilisateur
        à propager une modification sur ce modifier. Le verrou peut être libéré
        n'importe quand avec la commande <command>svn
        unlock</command>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn unlock banana.c
'banana.c' unlocked.
-->
$ svn unlock banane.c
'banane.c' déverrouillé.
</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
<!--
      <title>Discovering Locks</title>
-->
      <title>Identification d'un verrou</title>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>status</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>discovery</secondary>
        </indexterm>When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest way is to run
        <userinput>svn status -u</userinput>:</para>
-->
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>status</tertiary>
        </indexterm>
        <indexterm>
          <primary>verrous</primary>
          <secondary>identification</secondary>
        </indexterm>Quand une propagation échoue parce que quelqu'un d'autre a
        posé un verrou, il est facile de savoir pourquoi. La commande la
        plus simple est <userinput>svn status -u</userinput>:</para>

      <informalexample>
        <screen>
$ svn status -u<!--
M               23   bar.c
M    O          32   raisin.jpg
        *       72   foo.h
Status against revision:     105-->
M               23   truc.c
M    O          32   raisin.jpg
        *       72   machin.h
État par rapport à la révision      105

$
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>info</tertiary>
        </indexterm>In this example, Sally can see not only that her copy of
        <filename>foo.h</filename> is out of date, but also that one of the
        two modified files she plans to commit is locked in the
        repository.  The <literal>O</literal> symbol stands for
        <quote>Other,</quote> meaning that a lock exists on the file
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <filename>raisin.jpg</filename> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <command>svn info</command> has the
        answers:</para>
-->

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>info</tertiary>
        </indexterm>Dans cet exemple, Sally peut voir que non seulement sa
        copie de travail de <filename>machin.h</filename> n'est plus à jour,
        mais aussi qu'un des deux fichiers qu'elle prévoie de propager
        est verrouillé dans le dépôt. La lettre <literal>O</literal>
        (<foreignphrase>Others</foreignphrase> &mdash; autres en
        anglais) indique qu'un verrou est posé sur ce fichier et qu'il a été
        créé par quelqu'un d'autre. Si elle essayait de lancer <command>svn
        commit</command>, le verrou sur <filename>raisin.jpg</filename> l'en
        empêcherait. Sally est laissée dans l'expectative de savoir qui a posé
        le verrou, quand et pourquoi. Là encore, <command>svn info</command>
        trouve la réponse&nbsp;:</para>

      <informalexample>
        <screen>
$ svn info ^/raisin.jpg <!--
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Relative URL: ^/raisin.jpg
Repository Root: http://svn.example.com/repos/project
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Need to make a quick tweak to this image.
-->
Chemin : raisin.jpg
Nom : raisin.jpg
URL: http://svn.exemple.com/depot/projet/raisin.jpg
UUID du dépôt : edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Révision: 105
Type de nœud : file
Auteur de la dernière modification : sally
Révision de la dernière modification : 32
Texte mis à jour : 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Nom de verrou : opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Propriétaire du verrou : harry
Verrou créé : 2006-02-16 13:29:18 -0500 (jeu. 16 févr. 2006)
Commentaire du verrou (1 ligne):
Besoin de faire une retouche rapide sur cette image.
$
</screen>
      </informalexample>

<!--
      <para>Just as you can use <command>svn info</command> to examine
        objects in the working copy, you can also use it to examine
        objects in the repository.  If the main argument to
        <command>svn info</command> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <command>svn info</command> on a working copy
        path will show no lock information at all).  If the main
        argument to <command>svn info</command> is a URL, the
        information reflects the latest version of an object in the
        repository, and any mention of a lock describes the current
        lock on the object.</para>
-->
      <para>De la même manière que <command>svn info</command> peut être
        utilisée pour examiner les objets de la copie de travail, elle
        peut être utilisée pour examiner les objets du dépôt. Si
        l'argument principal de <command>svn info</command> est un
        chemin de la copie de travail, alors toutes les informations
        stockées localement sont affichées&nbsp;; toute mention d'un
        verrou signifie que la copie de travail détient un jeton de
        verrouillage (si le fichier est verrouillé par un autre
        utilisateur ou depuis une autre copie de travail, alors lancer
        <command>svn info</command> sur la copie de travail ne renvoie
        aucune information relative au verrou). Si l'argument principal
        de <command>svn info</command> est une URL, alors les
        informations affichées se rapportent à la dernière version de
        l'objet dans le dépôt et toute mention d'un verrou concerne le
        verrou en cours sur l'objet.</para>

<!--
      <para>So in this particular example, Sally can see that Harry
        locked the file on February 16 to <quote>make a quick
        tweak.</quote>  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</para>
-->
      <para>Ainsi, dans notre exemple, Sally peut voir que Harry a
        verrouillé le fichier le 16 février pour effectuer une
        <quote>retouche rapide</quote>. Comme nous sommes en juin, elle
        suspecte qu'il a probablement oublié le verrou. Elle pourrait
        téléphoner à Harry pour le lui signaler et lui demander de
        libérer le verrou. S'il n'est pas joignable, elle peut toujours
        essayer de forcer le verrou elle-même, ou demander à un
        administrateur de le faire.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
<!--
      <title>Breaking and Stealing Locks</title>
-->
      <title>Cassage et vol d'un verrou</title>

<!--
      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>breaking</secondary>
        </indexterm>A repository lock isn't sacred&mdash;in Subversion's
        default configuration state, locks can be released not only by
        the person who created them, but by anyone.  When somebody
        other than the original lock creator destroys a lock, we refer
        to this as <firstterm>breaking the lock</firstterm>.</para>
-->
      <para>
        <indexterm>
          <primary>verrous</primary>
          <secondary>cassage</secondary>
        </indexterm>Un verrou n'est pas quelque chose de sacré&nbsp;: dans la
        configuration par défaut de Subversion, les verrous peuvent être
        libérés non seulement par leur détenteur, mais aussi par
        n'importe qui d'autre. Quand quelqu'un d'autre que le détenteur
        d'un verrou le libère, nous appelons ça <firstterm>casser le
        verrou</firstterm>.</para>

<!--
      <para>From the administrator's chair, it's simple to break
        locks.  The <command>svnlook</command>
        and <command>svnadmin</command> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>
-->
      <para>Avec un statut d'administrateur, il est facile de casser un
        verrou. Les programmes <command>svnlook</command>
        et <command>svnadmin</command> peuvent afficher et casser les
        verrous directement dans le dépôt (pour plus d'informations sur
        ces outils, reportez-vous à
        <xref linkend="svn.reposadmin.maint.tk"/>).</para>

      <informalexample>
        <screen><!--
$ svnadmin lslocks /var/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires:
Comment (1 line):
Still improving the yellow color.
-->
$ svnadmin lslocks /var/svn/depot
Chemin : /projet2/images/banane.jpg
Chaîne UUID : opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Propriétaire : frank
Créé : 2006-06-15 13:29:18 -0500 (jeu. 15 juin 2006)
Expire :
Commentaire (1 ligne):
J'améliore encore la couleur jaune.
<!--

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires:
Comment (1 line):
Need to make a quick tweak to this image.
-->
Chemin : /projet/raisin.jpg
Chaîne UUID : opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Propriétaire : harry
Créé : 2006-02-16 13:29:18 -0500 (jeu. 16 fév. 2006)
Expire :
Commentaire (1 ligne):
Besoin de faire une retouche rapide sur cette image.
  <!--
$ svnadmin rmlocks /var/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
-->
$ svnadmin rmlocks /var/svn/depot /projet/raisin.jpg
'/projet/raisin.jpg' déverrouillé
$
</screen>
      </informalexample>

<!--
      <para>The more interesting option is to allow users to break
        each other's locks over the network.  To do this, Sally simply
        needs to pass the <option>- -force</option> to the
        <command>svn unlock</command> command:</para>
-->
      <para>L'option la plus intéressante est celle qui permet aux
        utilisateurs de casser les verrous détenus par d'autres
        personnes à travers le réseau. Pour ce faire, Sally doit
        simplement ajouter l'option <option>--force</option> à la
        commande <command>svn unlock</command>&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status -u<!--
M               23   bar.c
M    O          32   raisin.jpg
        *       72   foo.h
Status against revision:     105
-->
M               23   machin.c
M    O          32   raisin.jpg
        *       72   truc.h
État par rapport à la révision     105
$ svn unlock raisin.jpg<!--
svn: E195013: 'raisin.jpg' is not locked in this working copy -->
svn: E195013: 'raisin.jpg' n'est pas verrouillé dans cette copie de travail.
$ svn info raisin.jpg | grep ^URL <!--
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: warning: W160039: Unlock failed on 'raisin.jpg' (403 Forbidden)
$ svn unlock - -force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.-->
URL: http://svn.exemple.com/depot/projet/raisin.jpg
$ svn unlock http://svn.exemple.com/depot/projet/raisin.jpg
svn: warning: W160039: Unlock failed  on 'raisin.jpg' (403 Forbidden)
$ svn unlock --force http://svn.exemple.com/depot/projet/raisin.jpg
'raisin.jpg' déverrouillé.
$
</screen>
      </informalexample>

<!--
      <para>Now, Sally's initial attempt to unlock failed because she
        ran <command>svn unlock</command> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <command>svn unlock</command>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <option>- -force</option>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</para>
-->
      <para>Ainsi, la tentative initiale de Sally pour libérer le verrou
        a échoué parce qu'elle a lancé <command>svn unlock</command>
        directement sur le fichier de sa copie de travail, où aucun
        jeton de verrouillage n'était présent. Pour casser le verrou
        directement dans le dépôt, elle doit passer une URL à
        <command>svn unlock</command>. Son premier essai pour casser le
        verrou avec l'URL échoue car elle ne peut pas s'authentifier
        comme détentrice du verrou (et elle n'a pas non plus le jeton de
        verrouillage). Mais quand elle passe l'option
        <option>--force</option>, les pré-requis d'authentification et
        d'autorisation sont ignorés et le verrou est cassé.</para>

<!--
      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>stealing</secondary>
        </indexterm>Simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but relock the file for her own use.
        She can accomplish this by using <command>svn unlock</command>
        with <option>- -force</option> and then <command>svn lock</command>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to do is to <firstterm>steal</firstterm> the lock, which involves
        breaking and relocking the file all in one atomic step.  To
        do this, Sally passes the <option>- -force</option> option
        to <command>svn lock</command>:</para>
-->
      <para>
        <indexterm>
          <primary>verrous</primary>
          <secondary>vol</secondary>
        </indexterm>Casser le verrou peut ne pas être suffisant. Dans
        l'exemple, Sally ne veut pas seulement casser le verrou oublié
        par Harry, mais également re-verrouiller le fichier pour son
        propre usage. Elle peut le faire en lançant <command>svn
        unlock</command> avec l'option <option>--force</option> puis
        <command>svn lock</command> à la suite, mais il existe une petite
        chance que quelqu'un d'autre verrouille le fichier entre les deux
        commandes. La meilleure solution est donc de <firstterm>voler le
        verrou</firstterm>, ce qui implique de casser et re-verrouiller
        le fichier en une seule opération atomique. Pour ce faire, Sally
        passe l'option <option>--force</option> à la commande <command>svn
        lock</command>&nbsp;:</para>

      <informalexample>
        <screen>
$ svn lock raisin.jpg <!--
svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h
arry' in filesystem '/var/svn/repos/db'
-->
svn: avertissement : W160035: Path '/project/raisin.jpg' is already locked by
user 'harry' in filesystem '/var/svn/repos/db'
$ svn lock --force raisin.jpg
 <!--
'raisin.jpg' locked by user 'sally'.
-->
'raisin.jpg' verrouillé par l'utilisateur 'sally'.
$
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>defunct</secondary>
        </indexterm>In any case, whether the lock is broken or stolen,
        Harry may be in for a surprise.  Harry's working copy still
        contains the original lock token, but that lock no longer
        exists.  The lock token is said to
        be <firstterm>defunct</firstterm>.  The lock represented by
        the lock token has either been broken (no longer in the
        repository) or stolen (replaced with a different lock).
        Either way, Harry can see this by asking
        <command>svn status</command> to contact the
        repository:</para>
-->
      <para>
        <indexterm>
          <primary>verrous</primary>
          <secondary>défunt</secondary>
        </indexterm>Dans tous les cas, que le verrou soit cassé ou volé, Harry
        est bon pour une bonne surprise. La copie de travail de Harry
        contient toujours le jeton de verrouillage original, mais le
        verrou n'existe plus. Le jeton de verrouillage est dit
        <firstterm>défunt</firstterm>. Le verrou associé au jeton de
        verrouillage a été soit cassé (il n'existe plus dans le dépôt)
        soit volé (remplacé par un autre verrou). Quoi qu'il en soit,
        Harry peut voir ce qu'il en est en demandant à
        <command>svn status</command> de contacter le dépôt&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status
     K  raisin.jpg
$ svn status -u
     B          32   raisin.jpg <!--
Status against revision:     105
-->
À la révision 105.
$ svn update
Updating '.':
  B  raisin.jpg <!--
Updated to revision 105.
-->
À la révision 105.
$ svn status
$
</screen>
      </informalexample>

<!--
      <para>If the repository lock was broken, then <userinput>svn
        status - -show-updates</userinput> (<option>-u</option>)
        displays a <literal>B</literal> (Broken) symbol next to the
        file.  If a new lock exists in place of the old one, then a
        <literal>T</literal> (sTolen) symbol is shown.  Finally,
        <command>svn update</command> notices any defunct lock tokens
        and removes them from the working copy.</para>
-->
      <para>Si le verrou dans le dépôt a été cassé, alors
        <userinput>svn status --show-updates</userinput> affiche un
        <literal>B</literal> (pour <foreignphrase>Broken</foreignphrase> &mdash;
        <quote>cassé</quote> en anglais) à côté du fichier. Si un nouveau
        verrou existe en lieu et place de l'ancien, alors un
        <literal>T</literal> (pour <foreignphrase>sTolen</foreignphrase> &mdash;
        <quote>volé</quote> en anglais) est affiché. Finalement,
        <command>svn update</command> détecte les jetons de verrouillage
        défunts et les supprime de la copie de travail.</para>

      <sidebar>
<!--
        <title>Locking Policies</title>
-->
        <title>Politiques de verrouillage</title>

<!--
        <para>Different systems have different notions of how strict a
          lock should be.  Some folks argue that locks must be
          strictly enforced at all costs, releasable only by the
          original creator or administrator.  They argue that if
          anyone can break a lock, chaos runs rampant and the
          whole point of locking is defeated.  The other side argues
          that locks are first and foremost a communication tool.  If
          users are constantly breaking each other's locks, it
          represents a cultural failure within the team and the
          problem falls outside the scope of software enforcement.</para>
-->
        <para>Il existe différentes visions de la résistance que
          doit avoir un verrou. Certains considèrent que les verrous
          doivent être respectés à tout prix et donc libérables
          uniquement par leur détenteur ou par un administrateur. Ils
          affirment que si n'importe qui peut casser un verrou c'est la
          pagaille et tout le concept de verrouillage est mis par terre.
          D'autres pensent que les verrous sont d'abord et avant tout un
          outil de communication. Si les utilisateurs cassent les
          verrous des autres en permanence, c'est un problème culturel
          de l'équipe qui ne peut pas être résolu par un outil
          logiciel.</para>

<!--
        <para>Subversion defaults to the <quote>softer</quote>
          approach, but still allows administrators to create stricter
          enforcement policies through the use of hook scripts.  In
          particular, the pre-lock and
          pre-unlock hooks allow administrators
          to decide when lock creation and lock releases are allowed
          to happen.  Depending on whether a lock already exists,
          these two hooks can decide whether to allow a certain user
          to break or steal a lock.  The
          post-lock and post-unlock hooks are also available,
          and can be used to send email after locking actions.  To
          learn more about repository hooks, see
          <xref linkend="svn.reposadmin.hooks" />.</para>
-->
        <para>Subversion souscrit à la version <quote>douce</quote>
          mais autorise cependant les administrateurs à mettre en place
          une politique plus stricte via l'utilisation de procédures
          automatiques. En particulier, les procédures automatiques de
          pré-verrouillage (<literal>pre-lock</literal>) et de
          pré-déverrouillage (<literal>pre-unlock</literal>)
          permettent aux administrateurs de décider dans quelles
          situations la création ou la libération d'un verrou est
          autorisée. En fonction de l'existence préalable ou non d'un
          verrou, ces deux procédures automatiques décident s'il
          convient ou non d'autoriser tel utilisateur à casser ou voler
          tel verrou. Des procédures automatiques de post-verrouillage
          (<literal>post-lock</literal>) et de
          post-déverrouillage (<literal>post-unlock</literal>)
          sont également disponibles et peuvent être utilisées pour
          envoyer des emails suite aux actions de verrouillage. Pour en
          savoir plus sur les procédures automatiques, voir <xref
          linkend="svn.reposadmin.hooks" />.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
<!--
      <title>Lock Communication</title>
-->
      <title>Communication par l'intermédiaire des verrous</title>

<!--
      <para>We've seen how <command>svn lock</command>
        and <command>svn unlock</command> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</para>
-->
      <para>Nous avons vu comment <command>svn lock</command>
        et <command>svn unlock</command> peuvent être utilisés pour
        poser, libérer, casser ou voler des verrous. Cela résout le
        problème de la sérialisation des accès à un fichier. Mais qu'en
        est-il du problème plus vaste d'éviter les pertes de
        temps&nbsp;?</para>
<!--

      <para>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <userinput>svn status
        -u</userinput>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out of date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away his or her work, and a lot of
        time has been wasted.</para>
-->

      <para>Par exemple, supposons que Harry verrouille un fichier image
        et commence à l'éditer. Pendant ce temps, loin de là, Sally veut
        faire la même chose. Elle ne pense pas à faire un <userinput>svn
        status -u</userinput> et n'a donc pas la moindre idée que Harry a déjà
        verrouillé le fichier. Elle passe des heures à modifier le fichier et
        quand elle tente de propager ses changements, elle découvre soit que le
        fichier est verrouillé, soit que son propre fichier n'était pas à jour.
        Quoi qu'il en soit, ses modifications ne peuvent pas être fusionnées
        avec celles de Harry. L'un des deux doit passer ses modifications par
        pertes et profits, un temps conséquent a été gaspillé.</para>

<!--

      <para>Subversion's solution to this problem is to provide a
        mechanism to remind users that a file ought to be locked
        <emphasis>before</emphasis> the editing begins.  The mechanism
        is a special property:  <literal>svn:needs-lock</literal>.  If
        that property is attached to a file (regardless of its value,
        which is irrelevant), Subversion will try to use
        filesystem-level permissions to make the file read-only&mdash;unless,
        of course, the user has explicitly locked the file.
        When a lock token is present (as a result of using
        <command>svn lock</command>), the file becomes read/write.
        When the lock is released, the file becomes read-only
        again.</para>
-->

      <para>La solution proposée par Subversion à ce problème est de
        fournir un mécanisme pour rappeler aux utilisateurs qu'un fichier
        devrait être verrouillé <emphasis>avant</emphasis> de faire des
        modifications. Ce mécanisme est mis en œuvre par une propriété
        spéciale&nbsp;: <literal>svn:needs-lock</literal>. Si cette
        propriété est associée à un fichier (quelle que soit sa valeur,
        qui n'est pas prise en compte), alors Subversion essaie
        d'utiliser les permissions du système de fichiers pour le placer
        en lecture seule &mdash; à moins, bien sûr, que l'utilisateur
        ait explicitement verrouillé le fichier. Quand un jeton de
        verrouillage est présent (indiquant que
        <command>svn lock</command> a été lancée), le fichier est placé
        en lecture-écriture. Quand le verrou est libéré, le fichier
        passe de nouveau en lecture seule.</para>

<!--
      <para>The theory, then, is that if the image file has this
        property attached, Sally would immediately notice
        something is strange when she opens the file for editing:
        many applications alert users immediately when a read-only
        file is opened for editing, and nearly all would
        prevent her from saving changes to the file.  This
        reminds her to lock the file before editing, whereby she
        discovers the preexisting lock:</para>
-->
      <para>La théorie est donc que si le fichier image a cette
        propriété définie, alors Sally remarquera tout de suite quelque
        chose d'étrange à l'ouverture du fichier&nbsp;: beaucoup
        d'applications avertissent l'utilisateur immédiatement quand un
        fichier en lecture seule est ouvert pour édition et pratiquement
        toutes l'empêchent de sauvegarder ses modifications dans le
        fichier. Cela lui rappelle de verrouiller le fichier avant de
        l'éditer, découvrant ainsi le verrou pré-existant&nbsp;:</para>

      <informalexample>
        <screen>
$ /usr/local/bin/gimp raisin.jpg <!--
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r- -r- -r- -   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h
arry' in filesystem '/var/svn/repos/db'
-->
gimp: erreur: le fichier est en lecture seule !
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 juin  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: avertissement : W160035: Échec de la demande de verrou : '/projet/raisin.jpg'
is already locked by user 'harry' in filesystem '/var/svn/depot/db'
<!--
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
-->
$ svn info http://svn.exemple.com/depot/projet/raisin.jpg | grep errou
Nom de verrou : opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Propriétaire du verrou : harry
Verrou créé : 2006-06-08 07:29:18 -0500 (jeu. 08 juin 2006)
Commentaire de verrouillage (1 ligne):
J'effectue quelques retouches.  Je le verrouille pour deux heures.
$
</screen>
      </informalexample>

<!--
      <tip>
        <para>Users and administrators alike are encouraged to attach
          the <literal>svn:needs-lock</literal> property to any file
          that cannot be contextually merged.  This is the primary
          technique for encouraging good locking habits and preventing
          wasted effort.</para>
      </tip>
-->
      <tip>
        <para>Les utilisateurs et les administrateurs sont tous
          encouragés à positionner la propriété
          <literal>svn:needs-lock</literal> sur les fichiers qui
          ne peuvent pas être contextuellement fusionnés. C'est la
          technique de base pour favoriser les bonnes habitudes de
          verrouillage et éviter les pertes de temps.</para>
      </tip>

<!--
      <para>Note that this property is a communication tool that
        works independently from the locking system.  In other words,
        any file can be locked, whether or not this property is
        present.  And conversely, the presence of this property
        doesn't make the repository require a lock when
        committing.</para>
-->
      <para>Notez que cette propriété est un outil de communication qui
        fonctionne indépendamment de la politique de verrouillage.
        Autrement dit, n'importe quel fichier peut être verrouillé, que
        cette propriété existe ou pas. Et réciproquement, l'existence de
        cette propriété ne rend pas obligatoire le verrouillage pour
        pouvoir propager des modifications.</para>

<!--
      <para>Unfortunately, the system isn't flawless.  It's possible
        that even when a file has the property, the read-only reminder
        won't always work.  Sometimes applications misbehave and
        <quote>hijack</quote> the read-only file, silently allowing
        users to edit and save the file anyway.  There's not much that
        Subversion can do in this situation&mdash;at the end of the
        day, there's simply no substitution for good interpersonal
        communication.<footnote><para>Except, perhaps, a classic
        Vulcan mind-meld.</para></footnote></para>
-->
      <para>Malheureusement, le système n'est pas parfait. Il est possible que,
        même si le fichier possède la propriété, l'avertissement de lecture
        seule ne marche pas. Quelquefois, les applications ne suivent pas les
        normes et <quote>piratent</quote> le fichier en lecture seule,
        autorisant sans rien dire l'utilisateur à modifier et sauvegarder le
        fichier. Subversion ne peut pas faire grand chose dans ce genre de
        cas&nbsp;: au final, rien ne remplace une bonne communication entre les
        membres d'une équipe
        <footnote>
          <para>À part, peut-être, la fusion mentale vulcaine.</para>
        </footnote>.
      </para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
<!--
    <title>Externals Definitions</title>
-->
    <title>Définition de références externes</title>

<!--
    <para>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository or perhaps from different
      repositories altogether.  You could certainly set up such a
      scenario by hand&mdash;using <command>svn checkout</command> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</para>
-->
    <para>Parfois il peut être utile de construire une copie de travail issue
      de différentes extractions. Par exemple, vous pouvez avoir envie d'avoir
      différents sous-répertoires provenant de différents endroits du dépôt ou
      même carrément de différents dépôts. Vous pouvez arriver à un tel
      enchevêtrement manuellement, en utilisant <command>svn
      checkout</command>, pour créer le genre de structure voulu pour votre
      copie de travail. Mais si cette configuration est importante pour tous
      les utilisateurs de votre dépôt, chacun doit effectuer les mêmes
      opérations d'extraction que vous.</para>

<!--
    <para>
      <indexterm>
        <primary>externals definitions</primary>
      </indexterm>
      <indexterm>
        <primary>externals</primary>
        <see>externals definitions</see>
      </indexterm>
      <indexterm>
        <primary>properties</primary>
        <secondary>svn:externals</secondary>
      </indexterm>Fortunately, Subversion provides support for
      <firstterm>externals definitions</firstterm>.  An externals
      definition is a mapping of a local directory to the
      URL&mdash;and ideally a particular revision&mdash;of a versioned
      directory.  In Subversion, you declare externals definitions in
      groups using the <literal>svn:externals</literal> property.  You
      can create or modify this property using <command>svn
      propset</command> or <command>svn propedit</command> (see <xref
      linkend="svn.advanced.props.manip" />).  It can be set on any
      versioned directory, and its value describes both the external
      repository location and the client-side directory to which that
      location should be checked out.</para>
-->
    <para>
      <indexterm>
        <primary>définition de références externes</primary>
      </indexterm>
      <indexterm>
        <primary>références externes</primary>
        <see>définition de références externes</see>
      </indexterm>
      <indexterm>
        <primary>externals definitions</primary>
        <see>définition de références externes</see>
      </indexterm>
      <indexterm>
        <primary>propriétés</primary>
        <secondary>svn:externals</secondary>
      </indexterm>Heureusement, Subversion supporte la <firstterm>définition
      de références externes</firstterm>. Une définition de référence externe
      est une association entre un répertoire local et une URL (et idéalement
      un numéro de révision particulier) pour un répertoire suivi en versions.
      Dans Subversion, vous déclarez les définitions de références externes
      dans des groupes en utilisant la propriété
      <literal>svn:externals</literal>. Vous pouvez créer et modifier cette
      propriété en utilisant <command>svn propset</command> ou <command>svn
      propedit</command> (voir <xref linkend="svn.advanced.props.manip" />).
      Elle peut être définie sur tous les répertoires suivis en versions et
      sa valeur décrit à la fois l'URL du dépôt externe et le répertoire côté
      client dans lequel est extrait cette URL.</para>

<!--
    <para>The convenience of the <literal>svn:externals</literal>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define the nested working
      copy structure, no one else has to bother&mdash;Subversion will,
      after checking out the original working copy, automatically also
      check out the external working copies.</para>
-->
    <para>L'un des attraits de la propriété <literal>svn:externals</literal>
      est qu'une fois qu'elle est définie pour un répertoire suivi en versions,
      chaque utilisateur qui extrait une copie de travail de ce répertoire
      bénéficie des définitions de références externes. En d'autres termes, une
      fois qu'un utilisateur a fait l'effort de définir la structure de la
      copie de travail imbriquée, tout le monde en bénéficie
      automatiquement&nbsp;: Subversion, lors de l'extraction de la copie de
      travail originale, extraie également les copies de travail
      externes.</para>

    <warning>
<!--
      <para>The relative target subdirectories of externals
        definitions <emphasis>must not</emphasis> already exist on
        your or other users' systems&mdash;Subversion will create them
        when it checks out the external working copy.</para>
-->
      <para>Les sous-dossiers cibles des définitions de références externes
        <emphasis>ne doivent pas</emphasis> déjà exister sur votre système ou
        sur le systèmes des autres utilisateurs&nbsp;: Subversion les crée lors
        de l'extraction des copies de travail externes.</para>
    </warning>

<!--
    <para>You also get in the externals definition design all the
      regular benefits of Subversion properties.  The definitions are
      versioned.  If you need to change an externals definition, you
      can do so using the regular property modification subcommands.
      When you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <userinput>svn update</userinput>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>
-->
    <para>Vous bénéficiez avec les définitions de références externes de tous
      les avantages liés aux propriétés Subversion. Les définitions sont
      suivies en versions. Si vous avez besoin de changer une définition de
      référence externe, vous pouvez le faire à l'aide des sous-commandes
      classiques sur les propriétés. Quand vous propagez des modifications
      relatives à la propriété <literal>svn:externals</literal>, Subversion
      synchronise les éléments extraits par rapport à la définition de
      références externes modifiée dès que vous lancez <userinput>svn
      update</userinput>. Tous ceux qui mettent à jour leur copie de travail
      reçoivent vos modifications concernant les définitions de références
      externes.</para>

    <tip>
<!--
      <para>Because the <literal>svn:externals</literal> property has
        a multiline value, we strongly recommend that you use
        <command>svn propedit</command> instead of <command>svn
        propset</command>.</para>
-->
      <para>Comme la valeur de la propriété <literal>svn:externals</literal>
        est constituée de plusieurs lignes, nous vous recommandons fortement
        d'utiliser <command>svn propedit</command> plutôt que <command>svn
        propset</command>.</para>
    </tip>

<!--
    <para>Subversion releases prior to 1.5 honor an externals
      definition format that is a multiline table of subdirectories
      (relative to the versioned directory on which the property is
      set), optional revision flags, and fully qualified, absolute
      Subversion repository URLs.  An example of this might look as
      follows:</para>
-->
    <para>Les versions de Subversion antérieures à 1.5 utilisent un format de
      définitions externes qui est un tableau sur plusieurs lignes composées de
      sous-dossiers (relativement au dossier suivi en versions sur lequel est
      définie la propriété), d'indicateurs de révision optionnels et l'URL,
      absolue et complètement qualifiée, du dépôt Subversion. Par
      exemple&nbsp;:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc<!--
third-party/sounds             http://svn.example.com/repos/sounds
third-party/skins -r148        http://svn.example.com/skinproj
third-party/skins/toolkit -r21 http://svn.example.com/skin-maker-->
tierce-partie/sons                 http://svn.exemple.com/depot/sons
tierce-partie/themes -r148         http://svn.exemple.com/projet-themes
tierce-partie/themes/outils -r21   http://svn.exemple.com/outils-themes
</screen>
    </informalexample>

<!--
    <para>When someone checks out a working copy of the
      <filename>calc</filename> directory referred to in the previous
      example, Subversion also continues to check out the items found
      in its externals definition.</para>
-->
    <para>Quand quelqu'un extrait une copie de travail du dossier
      <filename>calc</filename> décrit dans l'exemple ci-dessus, Subversion
      extrait également les éléments trouvés dans les définitions de références
      externes.</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/repos/calc
A    calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 148.
Fetching external item into calc/third-party/sounds
A    calc/third-party/sounds/ding.ogg
A    calc/third-party/sounds/dong.ogg
A    calc/third-party/sounds/clang.ogg
&hellip;
A    calc/third-party/sounds/bang.ogg
A    calc/third-party/sounds/twang.ogg
Checked out revision 14.
Fetching external item into calc/third-party/skins
-->
$ svn checkout http://svn.exemple.com/depot/calc
A  calc
A  calc/Makefile
A  calc/entier.c
A  calc/bouton.c
Révision 148 extraite.

Récupération de la référence externe dans 'calc/tierce-partie/sons'
A  calc/tierce-partie/sons/ding.ogg
A  calc/tierce-partie/sons/dong.ogg
A  calc/tierce-partie/sons/clang.ogg
&hellip;
A  calc/tierce-partie/sons/bang.ogg
A  calc/tierce-partie/sons/twang.ogg
Révision 14 extraite.

Récupération de la référence externe dans 'calc/tierce-partie/themes'
&hellip;
</screen>
    </informalexample>

<!--
    <para>As of Subversion 1.5, though, a new format of the
      <literal>svn:externals</literal> property is supported.
      Externals definitions are still multiline, but the order and
      format of the various pieces of information have changed.  The
      new syntax more closely mimics the order of arguments you might
      pass to <command>svn checkout</command>: the optional revision
      flags come first, then the external Subversion repository URL,
      and finally the relative local subdirectory.  Notice, though,
      that this time we didn't say <quote>fully qualified, absolute
      Subversion repository URLs.</quote> That's because the new
      format supports relative URLs and URLs that carry peg revisions.
      The previous example of an externals definition might, in
      Subversion 1.5, look like the following:</para>
-->
    <para>À partir de la version 1.5 de Subversion, un nouveau format de la
      propriété <literal>svn:externals</literal> est supporté. Les références
      externes sont toujours multi-lignes mais l'ordre et le format des
      différentes informations ont changé. La nouvelle syntaxe ressemble plus à
      l'ordre des arguments que vous passez à la commande <command>svn
      checkout</command>&nbsp;: l'indicateur optionnel de révision est placé en
      premier, puis l'URL du dépôt Subversion externe et, enfin, le
      sous-dossier local relatif. Notez cependant que cette fois-ci nous
      n'avons pas indiqué <quote>URL absolue et complètement qualifiée</quote>
      pour le dépôt externe. En effet, le nouveau format accepte les URL
      relatives et les URL avec des révisions pivots. L'exemple précédent sur
      les références externes donne avec Subversion 1.5&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn propget svn:externals calc
      http://svn.example.com/repos/sounds third-party/sounds
-r148 http://svn.example.com/skinproj third-party/skins
-r21  http://svn.example.com/skin-maker third-party/skins/toolkit-->
$ svn propget svn:externals calc
      http://svn.exemple.com/depot/sons     tierce-partie/sons
-r148 http://svn.exemple.com/projet-themes  tierce-partie/themes
-r21  http://svn.exemple.com/outils-themes  tierce-partie/themes/outils
</screen>
    </informalexample>

<!--
    <para>Or, making use of the peg revision syntax (which we describe
      in detail in <xref linkend="svn.advanced.pegrevs" />), it might
      appear as:</para>
-->
    <para>En utilisant la syntaxe avec les révisions pivots
      (décrite en détail dans <xref linkend="svn.advanced.pegrevs" />),
      il peut aussi être écrit comme ceci&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn propget svn:externals calc
http://svn.example.com/repos/sounds third-party/sounds
http://svn.example.com/skinproj@148 third-party/skins
http://svn.example.com/skin-maker@21 third-party/skins/toolkit-->
$ svn propget svn:externals calc
http://svn.exemple.com/depot/sons         tierce-partie/sons
http://svn.exemple.com/projet-themes@148  tierce-partie/themes
http://svn.exemple.com/outils-themes@21   tierce-partie/themes/outils
</screen>
    </informalexample>

<!--
    <tip>
      <para>You should seriously consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides avoiding the surprise of getting changes to
        third-party repositories that you might not have any control
        over, using explicit revision numbers also means that as you
        backdate your working copy to a previous revision, your
        externals definitions will also revert to the way they looked
        in that previous revision, which in turn means that the
        external working copies will be updated to match the way
        <emphasis>they</emphasis> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</para>
    </tip>
-->
    <tip>
      <para>Il est particulièrement conseillé d'utiliser des numéros de
        révision explicites dans toutes vos références externes. Ainsi, vous
        conservez la possibilité de décider quand rapatrier une nouvelle
        version de vos informations externes et quelle version exacte
        rapatrier. En plus de vous éviter la surprise de recevoir des
        changements effectués sur des dépôts tiers dont vous n'avez pas la
        maîtrise, l'utilisation de numéros de révisions explicites signifie
        aussi que, si vous revenez à une version de travail antérieure, vos
        références externes reviendront elles aussi dans l'état où elles
        étaient au moment de cette version antérieure. Cela signifie aussi que
        les copies de travail externes sont actualisées pour refléter
        <emphasis>leur</emphasis> état au moment de la révision antérieure.
        Pour des projets logiciels, cela peut faire la différence entre la
        réussite et l'échec de la compilation d'une version antérieure d'un
        code source complexe.</para>
    </tip>

<!--
    <para>For most repositories, these three ways of formatting the
      externals definitions have the same ultimate effect.  They all
      bring the same benefits.  Unfortunately, they all bring the same
      annoyances, too.  Since the definitions shown use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with the
      renamed directory).  This can be confusing&mdash;even
      frustrating&mdash;in certain situations.  For example, say you
      have a top-level directory named
      <filename>my-project</filename>, and you've created an externals
      definition on one of its subdirectories
      (<filename>my-project/some-dir</filename>) that tracks the
      latest revision of another of its subdirectories
      (<filename>my-project/external-dir</filename>).</para>
-->
    <para>Pour la plupart des dépôts, les trois formats de références
      externes ont le même effet au final. Ils apportent tous les mêmes
      avantages. Malheureusement, ils possèdent aussi les mêmes
      inconvénients. Puisque les références indiquées utilisent des URL
      absolues, déplacer ou copier un répertoire auquel elles sont
      rattachées n'affecte pas ce qui est extrait en externe (alors
      qu'une référence relative est, bien évidemment, déplacée avec le
      répertoire). Cela peut vous induire en erreur, voire être
      assez frustrant, dans certaines situations. Par exemple, imaginons un
      dossier racine appelé <filename>mon-projet</filename> pour
      lequel nous avons défini des références externes dans un
      sous-dossier (<filename>mon-projet/un-rep</filename>)
      vers la dernière révision d'un autre sous-dossier
      (<filename>mon-projet/rep-externe</filename>).</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
&hellip;
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn propget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir-->
$ svn checkout http://svn.exemple.com/projets .
A    mon-projet
A    mon-projet/un-rep
A    mon-projet/rep-externe
&hellip;
Récupération de la référence externe dans 'mon-projet/un-rep/sous-rep'
Référence externe actualisée à la révision 11.

Actualisé à la révision 11.
$ svn propget svn:externals mon-projet/un-rep
sous-rep http://svn.exemple.com/projets/mon-projet/rep-externe

$
</screen>
    </informalexample>

<!--
    <para>Now you use <command>svn move</command> to rename the
      <filename>my-project</filename> directory.  At this point, your
      externals definition will still refer to a path under the
      <filename>my-project</filename> directory, even though that
      directory no longer exists.</para>
-->
    <para>Maintenant utilisez la commande
      <command>svn move</command> pour renommer le répertoire
      <filename>mon-projet</filename>. &Agrave; ce moment là, vos
      définitions de références externes pointent toujours vers un
      chemin sous le répertoire <filename>mon-projet</filename>, même si
      ce répertoire n'existe plus.</para>

    <informalexample>
      <screen> <!--
$ svn move -q my-project renamed-project
$ svn commit -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         renamed-project

Committed revision 12.
$ svn update
Updating '.':
svn: warning: W200000: Error handling externals definition for 'renamed-projec
t/some-dir/subdir':
svn: warning: W170000: URL 'http://svn.example.com/projects/my-project/externa
l-dir' at revision 12 doesn't exist
At revision 12.
svn: E205011: Failure occurred processing one or more externals definitions
-->
$ svn move -q mon-projet nouveau-projet
$ svn commit -m "Renommé mon-projet en nouveau-projet."
Suppression    mon-projet
Ajout          nouveau-projet

Révision 12 propagée.
$ svn update
Mise à jour de '.' :
svn: warning: W200000: Erreur dans la récupération de la référence externe dans 'nouveau-projet/un-rep/sous-rep'
svn: warning: W170000: Le dépôt http://svn.exemple.com/projets/mon-projet/rep-externe n'existe pas
À la révision 12.
$
</screen>
    </informalexample>

<!--
    <para>Also, absolute URLs can cause problems with repositories
      that are available via multiple URL schemes.  For example, if
      your Subversion server is configured to allow everyone to check
      out the repository over <literal>http://</literal> or
      <literal>https://</literal>, but only allow commits to come in
      via <literal>https://</literal>, you have an interesting problem
      on your hands.  If your externals definitions use the
      <literal>http://</literal> form of the repository URLs, you
      won't be able to commit anything from the working copies created
      by those externals.  On the other hand, if they use the
      <literal>https://</literal> form of the URLs, anyone who might
      be checking out via <literal>http://</literal> because his
      client doesn't support <literal>https://</literal> will be
      unable to fetch the external items.  Be aware, too, that if you
      need to reparent your working copy (using <command>svn
      relocate</command>), externals definitions will
      <emphasis>not</emphasis> also be reparented.</para>
-->
    <para>De plus, les URL absolues utilisées par les références
      externes peuvent causer des problèmes pour les dépôts accessibles
      via plusieurs types d'URL. Par exemple, si votre serveur
      Subversion est configuré pour autoriser tout le monde à consulter
      le dépôt <foreignphrase>via</foreignphrase> <literal>http://</literal> ou
      <literal>https://</literal>, mais que les opérations de propagation
      doivent être effectuées uniquement <foreignphrase>via</foreignphrase>
      <literal>https://</literal>, vous vous retrouvez  bien embêté. Si vos
      références externes pointent vers une URL de type
      <literal>http://</literal>, vous ne pouvez pas effectuer de propagation
      depuis les copies de travail créées <foreignphrase>via</foreignphrase>
      ces références externes. D'un autre côté, si vous utilisez la forme
      <literal>https://</literal> pour les URL, ceux qui voudront
      effectuer des consultations <foreignphrase>via</foreignphrase>
      <literal>http://</literal>, parce que leur client ne sait pas traiter le
      <literal>https://</literal>, sont incapables de récupérer les éléments
      externes. Soyez conscient également que si vous avez besoin de déplacer
      toute votre copie de travail (avec <command>svn switch</command> et
      l'option <option>--relocate</option>), les références externes ne
      seront pas mises à jour en conséquence.</para>

<!--
   <para>Subversion 1.5 takes a huge step in relieving these
     frustrations.  As mentioned earlier, the URLs used in the new
     externals definition format can be relative, and Subversion
     provides syntax magic for specifying multiple flavors of URL
     relativity.</para>
-->
   <para>Subversion 1.5 franchit un grand pas dans la résolution de ces
     soucis. Comme indiqué précédemment, les URL utilisées dans le
     nouveau format des définitions des références externes peuvent être
     relatives. Par ailleurs, Subversion autorise une syntaxe magique
     pour spécifier plusieurs types d'URL relatives.</para>

    <variablelist id="svn.advanced.externals.urlmagic">
      <indexterm>
<!--
        <primary>caret syntax</primary>
-->
        <primary>syntaxe circonflexe</primary>
      </indexterm>

      <varlistentry>
        <term><literal>../</literal></term>
<!--
        <listitem><para>Relative to the URL of the directory on which
          the <literal>svn:externals</literal> property is
          set</para></listitem>
-->
        <listitem><para>Relative à l'URL du répertoire sur lequel la
          propriété <literal>svn:externals</literal> est
          définie.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>^/</literal></term>
<!--
        <listitem><para>Relative to the root of the repository in
          which the <literal>svn:externals</literal> property is
          versioned</para></listitem>
-->
        <listitem><para>Relative à la racine du dépôt pour lequel la
          propriété <literal>svn:externals</literal> est suivie en
          versions.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>//</literal></term>
<!--
        <listitem><para>Relative to the scheme of the URL of the
          directory on which the <literal>svn:externals</literal>
          property is set</para></listitem>
-->
        <listitem><para>Relative au type d'URL du répertoire sur lequel
          la propriété <literal>svn:externals</literal> est
          définie.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>/</literal></term>
<!--
        <listitem><para>Relative to the root URL of the server on
          which the <literal>svn:externals</literal> property is
          versioned</para></listitem>
-->
        <listitem><para>Relative à l'URL du serveur sur lequel la
          propriété <literal>svn:externals</literal> est suivie en
          versions.</para></listitem>
      </varlistentry>

      <varlistentry>
<!--
        <term><literal>^/../<replaceable>REPO-NAME</replaceable></literal></term>
        <listitem><para>Relative to a sibling repository beneath the
          same <literal>SVNParentPath</literal> location as the
          repository in which the <literal>svn:externals</literal> is
          defined.</para></listitem>
-->
        <term><literal>^/../<replaceable>NOM-DÉPÔT</replaceable></literal></term>
        <listitem><para>Relative à un dépôt frère sous le même emplacement
        <literal>SVNParentPath</literal>-que le dépôt dans laquelle la
        référence <literal>svn:externals</literal> est
        définie.</para></listitem>
      </varlistentry>
    </variablelist>

<!--
    <para>So, looking a fourth time at our previous externals
      definition example, and making use of the new absolute URL
      syntax in various ways, we might now see:</para>
-->
    <para>Donc, considérons pour la quatrième fois la définition de
      nos références externes de l'exemple précédent et utilisons la
      nouvelle syntaxe de différentes manière. Nous
      obtenons&nbsp;:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc<!--
^/sounds third-party/sounds
/skinproj@148 third-party/skins
//svn.example.com/skin-maker@21 third-party/skins/toolkit-->
^/sons                             tierce-partie/sons
/themes@148                        tierce-partie/themes
//svn.exemple.com/outils-themes@21 tierce-partie/themes/outils
$
</screen>
    </informalexample>

<!--
    <para>Subversion 1.6 brought two more improvements to externals
      definitions.  First, it added a quoting and escape mechanism to
      the syntax so that the path of the external working copy may
      contain whitespace.  This was previously problematic, of course,
      because whitespace is used to delimit the fields in an externals
      definition.  Now you need only wrap such a path specification in
      double-quote (<literal>"<!- - " -.-></literal>) characters or
      escape the problematic characters in the path with a backslash
      (<literal>\</literal>) character.  Of course, if you have spaces
      in the <emphasis>URL</emphasis> portion of the external
      definition, you should use the standard URI-encoding mechanism
      to represent those.</para>
-->

    <para>Subversion 1.6 apporta deux nouvelles améliorations aux définitions
      de références externes. D'abord, il ajouta un mécanisme d'échappement et
      mise entre guillemets à la syntaxe afin de traiter correctement des
      chemins de copies de travail externes contenant des espaces. Cela posait
      auparavant des problèmes car l'espace est un délimiteur de champs dans
      les définitions de références externes. Maintenant, vous n'avez qu'à
      entourer la spécification du chemin entre des guillemets doubles
      (<literal>"<!-- " --></literal>) ou échapper les caractères qui posent
      problème dans le chemin avec la barre oblique inversée
      (<literal>\</literal>). Bien sûr, si l'<emphasis>URL</emphasis> de la
      référence externe comporte des espaces, vous devrez utiliser l'encodage
      standard des URI pour les représenter.</para>

    <informalexample>
      <screen>
$ svn propget svn:externals paint <!--
http://svn.thirdparty.com/repos/My%20Project "My Project"
http://svn.thirdparty.com/repos/%22Quotes%20Too%22 \"Quotes\ Too\" -->
http://svn.site-tiers.fr/depot/Mon%20projet "Mon projet"
http://svn.site-tiers.fr/depot/%22Avec%20des%20guillemets%22 \"Avec\ des\ guillemets\"
$
</screen>
    </informalexample>

<!--
    <para>
      <indexterm>
        <primary>externals</primary>
        <secondary>file</secondary>
      </indexterm>Subversion 1.6 also introduced support for external
      definitions for files.  <firstterm>File externals</firstterm>
      are configured just like externals for directories and appear as
      a versioned file in the working copy.</para>
-->
    <para>
      <indexterm>
        <primary>définition de références externes</primary>
        <secondary>fichier</secondary>
      </indexterm>Subversion 1.6 introduit également le support pour la
      <firstterm>définition de références externes de fichiers</firstterm>.
      Les définitions de références externes de fichiers sont configurées de
      la même manière que les répertoires externes et apparaissent comme des
      fichiers suivis en versions dans la copie de travail.</para>

<!--
    <para>For example, let's say you had the file
      <filename>/trunk/bikeshed/blue.html</filename> in your repository,
      and you wanted this file, as it appeared in revision 40,
      to appear in your working copy of <filename>/trunk/www/</filename>
      as <filename>green.html</filename>.</para>
-->
    <para>Par exemple, supposons que vous ayez le fichier
      <filename>/trunk/couleurs_vélo/bleu.html</filename> dans votre dépôt et
      que vous souhaitiez que ce fichier, tel qu'il était dans la révision 40,
      apparaisse dans votre copie de travail de
      <filename>/trunk/www/</filename> comme le fichier
      <filename>vert.html</filename>.</para>

<!--
    <para>The externals definition required to achieve this should
      look familiar by now:</para>
-->
    <para>La définition de référence externe nécessaire pour obtenir ce
      résultat devrait vous être familière maintenant&nbsp;:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals www/<!--
^/trunk/bikeshed/blue.html@40 green.html-->
^/trunk/couleurs_vélo/bleu.html@40 vert.html
$ svn update<!--
Updating '.':

Fetching external item into 'www'
E    www/green.html
Updated external to revision 40.

Update to revision 103.
-->
Mise à jour de '.' :

Récupération de la référence externe dans 'www' :
E    www/vert.html
Référence externe à la révision 40.

À la révision 103.
$ svn status<!--
    X   www/green.html-->
    X   www/vert.html
$
</screen>
    </informalexample>

<!--
    <para>As you can see in the previous output, Subversion denotes file
      externals with the letter <literal>E</literal> when they are
      fetched into the working copy, and with the letter
      <literal>X</literal> when showing the working copy status.</para>
-->
    <para>Comme vous pouvez le voir dans l'exemple ci-dessus, Subversion
      annote les fichiers externes avec la lettre <literal>E</literal> quand
      ils sont rappatriés vers la copie de travail et avec la lettre
      <literal>X</literal> lors de l'affichage de l'état de la copie de
      travail.</para>

    <!-- ### TODO: Is Subversion using 'E' in the update output to
         ### mean "external"?  Or is this 'E' an "exists" notification,
         ### the side-effect of the file externals implementation? -->

    <warning>
<!--
      <para>While directory externals can place the external
        directory at any depth, and any missing intermediate
        directories will be created, file externals must be placed
        into a working copy that is already checked out.</para>
-->
      <para>Alors que les définitions de références externes pour un répertoire
        peuvent placer le répertoire à n'importe quelle profondeur et créer les
        répertoires intermédiaires manquants, les définitions de fichiers
        externes doivent être placées dans une copie de travail qui a déjà
        fait l'objet d'une extraction.</para>
    </warning>

<!--
    <para>When examining the file external with
      <command>svn info</command>, you can see the URL and revision
      the external is coming from:</para>
-->
    <para>Lorsque vous examinez un fichier externe à l'aide de la commande
      <command>svn info</command>, vous pouvez voir l'URL et la révision
      qui sont à l'origine du fichier.</para>

    <informalexample>
      <screen><!--
$ svn info www/green.html
Path: www/green.html
Name: green.html
Working Copy Root Path: /home/harry/projects/my-project
URL: http://svn.example.com/projects/my-project/trunk/bikeshed/blue.html
Relative URL: ^/trunk/bikeshed/blue.html
Repository Root: http://svn.example.com/projects/my-project
Repository UUID: b2a368dc-7564-11de-bb2b-113435390e17
Revision: 40
Node kind: file
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 40
Last Changed Date: 2009-07-20 20:38:20 +0100 (Mon, 20 Jul 2009)
Text Last Updated: 2009-07-20 23:22:36 +0100 (Mon, 20 Jul 2009)
Checksum: 01a58b04617b92492d99662c3837b33b-->
$ svn info www/vert.html
Chemin : www/vert.html
Nom : green.html
Chemin racine de la copie de travail : /home/harry/projects/my-project
URL : http://svn.example.com/projects/my-project/trunk/bikeshed/blue.html
Relative URL: ^/trunk/bikeshed/blue.html
Racine du dépôt : http://svn.example.com/projects/my-project
UUID du dépôt : b2a368dc-7564-11de-bb2b-113435390e17
Révision: 40
Type de nœud : fichier
Tâche programmée : normale
Auteur de la dernière modification : harry
Révision de la dernière modification : 40
Date de la dernière modification : 2009-07-20 20:38:20 +0100 (lun. 20 juil. 2009)
Texte mis à jour : 2009-07-20 23:22:36 +0100 (lun. 20 juil. 2009)
Somme de contrôle : 01a58b04617b92492d99662c3837b33b
$
</screen>
    </informalexample>

<!--
    <para>Because file externals appear in the working copy as
      versioned files, they can be modified and even committed
      if they reference a file at the HEAD revision. The committed
      changes will then appear in the external as well as the file
      referenced by the external. However, in our example, we pinned
      the external to an older revision, so attempting to commit
      the external fails:</para>
-->
    <para>Parce que les fichier externes sont traités dans la copie de travail
      comme des fichiers suivis en versions, ils peuvent être modifiés et
      même propagés s'ils font référence à un fichier à la révision
      <literal>HEAD</literal>. Les modifications propagées sont répercutées
      dans le fichier externe comme dans le fichier référencé. Cependant, dans
      notre exemple, nous avons pointé vers un fichier à une révision
      antérieure, c'est pourquoi une tentative de propagation du fichier
      externe échoue&nbsp;:</para>

    <informalexample>
      <screen>
$ svn status <!--
M   X   www/green.html
$ svn commit -m "change the color" www/green.html
Sending        www/green.html
svn: E155011: Commit failed (details follow):
svn: E155011: File '/trunk/bikeshed/blue.html' is out of date
-->
M   X   www/vert.html
$ svn commit -m "change la couleur" www/vert.html
Envoi        www/vert.html
svn: E155011: Échec de la propagation (commit), détails :
svn: E155011: Fichier '/trunk/couleurs_vélo/bleu.html' obsolète
$
</screen>
    </informalexample>

<!--
    <para>Keep this in mind when defining file externals.
      If you need the external to refer to a certain revision
      of a file you will not be able to modify the external.
      If you want to be able to modify the external, you cannot
      specify a revision other than the <literal>HEAD</literal>
      revision, which is implied if no revision is specified.</para>
-->
    <para>Gardez cela à l'esprit quand vous définissez des références vers
      des fichiers externes. Si vous avez besoin de pointer vers une révision
      particulière d'un fichier, vous ne pourrez pas modifier ce fichier
      externe. Si vous voulez pouvoir modifier le fichier externe, vous ne
      pouvez pas spécifier une révision autre que <literal>HEAD</literal>,
      ce qui est implicite si aucune révision n'est spécifiée.</para>

<!--
    <para>Unfortunately, the support which exists for externals definitions
      in Subversion remains less than ideal.  Both file and directory
      externals have shortcomings. For either type of external, the
      local subdirectory part of the definition cannot contain
      <literal>..</literal> parent directory indicators (such as
      <filename>../../skins/myskin</filename>).  File externals cannot
      refer to files from other repositories. A file external's URL
      must always be in the same repository as the URL that the file
      external will be inserted into. Also, file externals cannot be
      moved or deleted. The <literal>svn:externals</literal> property
      must be modified instead. However, file externals can be copied.</para>
-->
    <para>Malheureusement, le support des références externes de Subversion
      reste largement perfectible. Les fichiers et les répertoires externes
      possèdent leur lot d'inconvénients. Quel que soit le type de référence
      externe, le sous-répertoire local faisant partie de la définition ne
      peut pas contenir d'indicateurs vers le répertoire parent
      <quote><literal>..</literal></quote> (par exemple
      <filename>../../skins/perso</filename>). Les fichiers externes ne
      peuvent pas faire référence à des fichiers d'autres dépôts. L'URL d'un
      fichier externe doit toujours être dans le même dépôt que sa cible.
      Aussi, les fichiers externes ne peuvent pas être déplacés ou effacés.
      C'est la propriété <literal>svn:externals</literal> qui doit être
      modifiée à la place. Cependant, les fichiers externes peuvent être
      copiés.</para>

<!--
    <para>Perhaps most disappointingly, the working copies created via the
      externals definition support are still disconnected from the primary
      working copy (on whose versioned directories the
      <literal>svn:externals</literal> property was actually set).
      And Subversion still truly operates only on nondisjoint working
      copies.  So, for example, if you want to commit changes that
      you've made in one or more of those external working copies, you
      must run <command>svn commit</command> explicitly on those
      working copies&mdash;committing on the primary working copy will
      not recurse into any external ones.</para>
-->
    <para>Ce qui est peut-être le plus ennuyeux, c'est que les copies de
      travail créées via le support de définition de références externes sont
      toujours déconnectées de la copie de travail primaire (sur laquelle le
      répertoire suivi en versions possède la propriété
      <literal>svn:externals</literal>). Et Subversion continue à fonctionner
      seulement sur des copies de travail conjointes. Ainsi, par exemple, si
      vous voulez propager des modifications que vous avez faites sur une ou
      plus de ces copies de travail externes, vous devez lancer
      <command>svn commit</command> explicitement sur ces copies de travail
      (la propagation sur la copie de travail initiale ne se répercute pas
      sur les copies externes).</para>

<!--
    <para>We've already mentioned some of the additional shortcomings
      of the old <literal>svn:externals</literal> format and how the
      newer Subversion 1.5 format improves upon it.  But be careful
      when making use of the new format that you don't inadvertently
      introduce new problems.  For example, while the latest clients
      will continue to recognize and support the original externals
      definition format, pre-1.5 clients will <emphasis>not</emphasis>
      be able to correctly parse the new format.  If you change all
      your externals definitions to the newer format, you effectively
      force everyone who uses those externals to upgrade their
      Subversion clients to a version that can parse them.  Also, be
      careful to avoid naively relocating
      the <literal>-r<replaceable>NNN</replaceable></literal> portion
      of the definition&mdash;the older format uses that revision as a
      peg revision, but the newer format uses it as an operative
      revision (with a peg revision of <literal>HEAD</literal> unless
      otherwise specified; see <xref linkend="svn.advanced.pegrevs" />
      for a full explanation of the distinction here).</para>
-->
    <para>Nous avons déjà mentionné quelques inconvénients de l'ancienne
      syntaxe <literal>svn:externals</literal> et comment la nouvelle syntaxe
      des versions plus récentes que Subversion 1.5 résolvent ce problème.
      Mais soyez vigilant lorsque vous utilisez cette nouvelle syntaxe de ne
      pas introduire de nouveaux problèmes par inadvertance. Par exemple,
      alors que les nouveaux clients sont capables de reconnaitre et
      prendre en charge l'ancienne syntaxe de défintion des références
      externes, les clients pré-1.5 <emphasis>ne peuvent pas</emphasis>
      analyser correctement la nouvelle syntaxe. Si vous changez vos
      définitions de références externes au nouveau format, vous forcez tous
      ceux qui utilisent ces références externes à effectivement mettre à
      niveau leur client Subversion vers une version capable de lire ce
      format. De même, soyez attentif à ne pas naïvement déplacer la portion
      <literal>-r<replaceable>NNN</replaceable></literal> de la définition
      (l'ancien format utilise cette révision comme pivot, mais le nouveau
      format l'utilise comme révision opérationnelle avec une révision pivot
      à <literal>HEAD</literal>, sauf mention contraire&nbsp; lisez <xref
      linkend="svn.advanced.pegrevs"/> pour une explication complète de cette
      distinction).</para>

<!--
    <warning>
      <para>External working copies are still completely
        self-sufficient working copies.  You can operate directly on
        them as you would any other working copy.  This can be a handy
        feature, allowing you to examine an external working copy
        independently of any primary working copy
        whose <literal>svn:externals</literal> property caused its
        instantiation.  Be careful, though, that you don't
        inadvertently modify your external working copy in subtle ways
        that cause problems.  For example, while an externals
        definition might specify that the external working copy should
        be held at a particular revision number, if you
        run <command>svn update</command> directly on the external
        working copy, Subversion will oblige, and now your external
        working copy is out of sync with its declaration in the
        primary working copy.  Using <command>svn switch</command> to
        directly switch the external working copy (or some portion
        thereof) to another URL could cause similar problems if the
        contents of the primary working copy are expecting particular
        contents in the external content.</para>
    </warning>
-->
    <warning>
      <para>
        Les copies de travail externes sont toujours des copies de travail
        totalement auto-suffisantes. Vous pouvez effectuez les opérations que
        vous effectueriez sur toute autre copie de travail. Cela peut
        s'avérer très utile, vous permettant d'examiner une copie de travail
        externe indépendamment de toute copie de travail primaire dont la
        propriété <literal>svn:externals</literal> a causé l'instanciation.
        Faites attention, cependant, à ne pas modifier par mégarde votre
        copie de travail externe par des modifications subtiles qui peuvent
        engendrer des problèmes. Par exemple, bien que des définitions de
        références externes peuvent spécifier que la copie de travail externe
        pointe vers un numéro de révision particulier, si vous lancez la
        commande <command>svn update</command> directement sur la copie de
        travail externe, Subversion s'exécutera et votre copie de travail
        sera maintenant désynchronisée de la déclaration dans la copie de
        travail primaire. Utiliser <command>svn switch</command> pour faire
        pointer directement la copie de travail externe vers une nouvelle URL
        engendre le même type de problème si le contenu de la copie de
        travail primaire s'attend à un contenu particulier de la copie de
        travail externe.</para>
    </warning>

<!--
    <para>
      <indexterm>
        <primary>working copies</primary>
        <secondary>disjoint</secondary>
      </indexterm>Besides the <command>svn checkout</command>, <command>svn
      update</command>, <command>svn switch</command>, and
      <command>svn export</command> commands which actually manage the
      <firstterm>disjoint</firstterm> (or disconnected) subdirectories
      into which externals are checked out, the <command>svn
      status</command> command also recognizes externals definitions.
      It displays a status code of <literal>X</literal> for the
      disjoint external subdirectories, and then recurses into those
      subdirectories to display the status of the external items
      themselves.  You can pass the
      <option>- -ignore-externals</option> option to any of these
      subcommands to disable externals definition processing.</para>
-->
    <para>
      <indexterm>
        <primary>copies de travail</primary>
        <secondary>disjointes</secondary>
      </indexterm>Tout comme les commandes <command>svn checkout</command>,
      <command>svn update</command>, <command>svn switch</command> et
      <command>svn export</command> qui gèrent les sous-répertoires
      <firstterm>disjoints</firstterm> (ou déconnectés) depuis lesquels les
      références externes sont extraites, la commande <command>svn
      status</command> reconnait les définitions de références externes. Elle
      affiche un statut sous le code <literal>X</literal> pour les
      sous-répertoires externes disjoints, puis explore récursivement ces
      sous-répertoires pour afficher le statut des éléments externes
      eux-mêmes. Vous pouvez spécifier l'option
      <option>--ignore-externals</option> à n'importe laquelle de ces
      sous-commandes pour désactiver le traitement des définitions des
      références externes.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.changelists">
<!--
    <title>Changelists</title>
-->
    <title>Listes de modifications</title>

<!--
    <para>It is commonplace for a developer to find himself working at
      any given time on multiple different, distinct changes to a
      particular bit of source code.  This isn't necessarily due to
      poor planning or some form of digital masochism.  A software
      engineer often spots bugs in his peripheral vision while working
      on some nearby chunk of source code.  Or perhaps he's halfway
      through some large change when he realizes the solution he's
      working on is best committed as several smaller logical units.
      Often, these logical units aren't nicely contained in some
      module, safely separated from other changes.  The units might
      overlap, modifying different files in the same module, or even
      modifying different lines in the same file.</para>
-->
    <para>Il est très courant pour un développeur d'avoir à effectuer,
      en même temps, des modifications multiples n'ayant rien à voir
      entre elles sur une portion de code donnée. Ce n'est pas
      nécessairement la preuve d'une mauvaise gestion de son temps,
      ni d'une forme de masochisme numérique. Un ingénieur de
      développement repère souvent des bogues annexes lorsqu'il
      travaille sur un morceau de code particulier. Ou alors c'est une
      fois rendu à mi-chemin d'un changement important qu'il prend
      conscience que la solution qu'il a choisie serait mieux propagée
      sous la forme de plusieurs unités logiques plus petites, ces
      unités pouvant se recouper, affecter des fichiers différents d'un
      même module ou même toucher à des lignes différentes d'un même
      fichier.</para>

<!--
    <para>Developers can employ various work methodologies
      to keep these logical changes organized.  Some use
      separate working copies of the same repository to hold each
      individual change in progress.  Others might choose to create
      short-lived feature branches in the repository and use a single
      working copy that is constantly switched to point to one such
      branch or another.  Still others use <command>diff</command> and
      <command>patch</command> tools to back up and restore uncommitted
      changes to and from patch files associated with each change.
      Each of these methods has its pros and cons, and to a large
      degree, the details of the changes being made heavily influence
      the methodology used to distinguish them.</para>
-->
    <para>Plusieurs méthodes sont à disposition des développeurs
      pour gérer ces ensembles de modifications. Certains développeurs
      utilisent des copies de travail séparées, du même dépôt, pour y
      conserver les progrès faits pour chaque changement. D'autres
      développeurs choisissent de créer au sein du dépôt des branches
      fonctionnelles à durée de vie très courte et d'utiliser une unique
      copie de travail qu'ils font pointer selon les besoins du moment
      vers une branche de ce type ou vers une autre. Enfin, d'autres
      développeurs utilisent les outils <command>diff</command> et
      <command>patch</command> pour sauvegarder et restaurer des
      changements non propagés sur les fichiers touchés par les
      modifications. Chacune de ces méthodes a des avantages et des
      inconvénients et, en général, le détail des changements à
      effectuer influence fortement le choix de la méthode
      utilisée pour les distinguer.</para>

<!--
    <para>
      <indexterm>
        <primary>changelists</primary>
      </indexterm>Subversion provides a <firstterm>changelists</firstterm>
      feature that adds yet another method to the mix.  Changelists
      are basically arbitrary labels (currently at most one per file)
      applied to working copy files for the express purpose of
      associating multiple files together.  Users of many of Google's
      software offerings are familiar with this concept already.  For
      example, <ulink url="http://mail.google.com/">Gmail</ulink>
      doesn't provide the traditional folders-based email organization
      mechanism.  In Gmail, you apply arbitrary labels to emails, and
      multiple emails can be said to be part of the same group if they
      happen to share a particular label.  Viewing only a group of
      similarly labeled emails then becomes a simple user interface
      trick.  Many other Web 2.0 sites have similar
      mechanisms&mdash;consider the <quote>tags</quote> used by sites
      such as <ulink url="http://www.youtube.com/">YouTube</ulink> and
      <ulink url="http://www.flickr.com/">Flickr</ulink>,
      <quote>categories</quote> applied to blog posts, and so on.
      Folks understand today that organization of data is critical,
      but that how that data is organized needs to be a flexible
      concept.  The old files-and-folders paradigm is too rigid for
      some applications.</para>
-->
    <para>
      <indexterm>
        <primary>listes de modifications</primary>
      </indexterm>Subversion fournit la fonctionnalité des
      <firstterm>listes de modifications</firstterm>, qui vient
      s'ajouter aux méthodes mentionnées ci-dessus. Les listes de
      modifications sont en gros des étiquettes arbitraires (une au
      plus par fichier pour l'instant) attachées à des fichiers de la
      copie de travail dans le seul but de regrouper plusieurs fichiers
      ensemble. Les utilisateurs de bon nombre de logiciels fournis par
      Google sont déjà habitués à ce concept. Dans
      <ulink url="http://mail.google.com/">Gmail</ulink>, vous associez
      des étiquettes arbitraires à des e-mails et plusieurs e-mails
      peuvent être considérés comme faisant partie du même groupe s'ils
      partagent une étiquette donnée. Dès lors, ne voir qu'un groupe
      d'e-mails portant la même étiquette n'est plus qu'un simple jeu
      d'affichage. De nombreux autres sites web 2.0 possèdent des
      mécanismes similaires. Prenez par exemple les <quote>tags</quote>
      (<quote>étiquette</quote> en anglais) utilisés sur des sites comme
      <ulink url="http://www.youtube.com/">YouTube</ulink> ou
      <ulink url="http://www.flickr.com/">Flickr</ulink>, les
      <quote>catégories</quote> utilisées pour regrouper les articles
      de blogs,&nbsp;etc. Aujourd'hui les gens ont compris que l'organisation
      des données est essentielle et la façon dont ces données sont
      organisées doit être flexible. Le vieux paradigme des répertoires
      et des fichiers est bien trop rigide pour certaines
      applications.</para>

<!--
    <para>Subversion's changelist support allows you to create
      changelists by applying labels to files you want to be
      associated with that changelist, remove those labels, and limit
      the scope of the files on which its subcommands operate to only
      those bearing a particular label.  In this section, we'll look
      in detail at how to do these things.</para>
-->
    <para>Cette fonctionnalité de Subversion vous permet de créer des
      listes de modifications en étiquetant les fichiers que vous voulez
      inclure, de supprimer ces étiquettes et de limiter le rayon
      d'action des sous-commandes aux seuls fichiers qui portent
      l'étiquette donnée. Dans ce paragraphe, nous allons voir en
      détails comment accomplir ces actions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.creating">
<!--
      <title>Creating and Modifying Changelists</title>
-->
      <title>Création et modification de listes de modifications</title>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>
        <indexterm>
          <primary>changelists</primary>
          <secondary>creating</secondary>
        </indexterm>You can create, modify, and delete changelists using the
        <command>svn changelist</command> command.  More accurately,
        you use this command to set or unset the changelist
        association of a particular working copy file.  A changelist
        is effectively created the first time you label a file with
        that changelist; it is deleted when you remove that label from
        the last file that had it.  Let's examine a usage scenario
        that demonstrates these concepts.</para>
-->
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>
        <indexterm>
          <primary>listes de modifications</primary>
          <secondary>création</secondary>
        </indexterm>Vous pouvez créer, modifier et supprimer des listes de
        modifications en utilisant la commande <command>svn
        changelist</command>. Plus précisément, vous pouvez utiliser
        cette commande pour activer ou désactiver l'association d'une
        liste de modifications avec un fichier donné de la copie de
        travail. La création d'une liste de modifications a lieu la
        première fois que vous étiquetez un fichier avec ce nom de
        liste&nbsp;; elle n'est supprimée que quand vous effacez
        l'étiquette du dernier fichier qui la portait. Examinons un cas
        concret pour illustrer ces notions.</para>

<!--
      <para>Harry is fixing some bugs in the calculator application's
        mathematics logic.  His work leads him to change a couple of
        files:</para>
-->
      <para>Harry est en train de corriger des bogues dans le module de
        logique mathématique de l'application <quote>calculatrice</quote>.
        Son travail l'amène à modifier deux fichiers&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status<!--
M       integer.c
M       mathops.c-->
M      entier.c
M      ops-math.c
$
</screen>
      </informalexample>

<!--
      <para>While testing his bug fix, Harry notices that his changes
        bring to light a tangentially related bug in the user
        interface logic found in <filename>button.c</filename>.  Harry
        decides that he'll go ahead and fix that bug, too, as a
        separate commit from his math fixes.  Now, in a small working
        copy with only a handful of files and few logical changes,
        Harry can probably keep his two logical change groupings
        mentally organized without any problem.  But today he's going
        to use Subversion's changelists feature as a special favor to
        the authors of this book.</para>
-->
      <para>En testant son correctif, Harry s'aperçoit que ses
        modifications lui indiquent qu'un bogue collatéral existe au
        sein de la logique de l'interface utilisateur, située dans le
        fichier <filename>bouton.c</filename>. Harry décide alors qu'il
        va aussi corriger ce bogue, dans une propagation séparée de ses
        propres correctifs mathématiques. Dans une copie de travail de
        petite taille, ne contenant qu'une poignée de fichiers, et pour
        juste quelques modifications logiques, Harry pourrait
        probablement gérer mentalement ces deux ensembles logiques de
        modifications sans le moindre problème. Mais aujourd'hui il a
        décidé qu'il allait utiliser les listes de modifications de
        Subversion, pour faire une faveur aux auteurs de ce livre.</para>

<!--
      <para>Harry first creates a changelist and associates with it
        the two files he's already changed.  He does this by using the
        <command>svn changelist</command> command to assign the same
        arbitrary changelist name to those files:</para>
-->
      <para>Harry commence par créer une première liste de
        modifications et y associe les deux premiers fichiers qu'il a
        déjà modifié. Pour ce faire, il utilise la commande
        <command>svn changelist</command> afin d'associer le même nom
        arbitraire de liste de modifications aux deux
        fichiers&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn changelist math-fixes integer.c mathops.c
A [math-fixes] integer.c
A [math-fixes] mathops.c-->
$ svn changelist correctifs-maths entier.c ops-math.c
A [correctifs-maths] entier.c
A [correctifs-maths] ops-math.c
$ svn status
<!--
- - - Changelist 'math-fixes':
M       integer.c
M       mathops.c
-->
--- Liste de changements 'correctifs-maths' :
M       entier.c
M       ops-math.c
$
</screen>
      </informalexample>

<!--
      <para>As you can see, the output of <command>svn
        status</command> reflects this new grouping.</para>
-->
      <para>Comme vous pouvez le constater, le résultat de <command>svn
        status</command> reflète bien ce nouvel ensemble.</para>

<!--
      <para>Harry now sets off to fix the secondary UI problem.  Since
        he knows which file he'll be changing, he assigns that path to
        a changelist, too.  Unfortunately, Harry carelessly assigns this
        third file to the same changelist as the previous two files:</para>
-->
      <para>Harry se lance alors dans la correction du problème
        d'interface graphique collatéral. Puisqu'il sait quel fichier il
        va modifier, il associe également ce chemin à une liste de
        modifications. Mais malencontreusement Harry associe ce
        troisième fichier à la même liste de modifications que les deux
        premiers&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn changelist math-fixes button.c
A [math-fixes] button.c-->
$ svn changelist correctifs-maths bouton.c
A [math-fixes] bouton.c
$ svn status
<!--
- - - Changelist 'math-fixes':
        button.c
M       integer.c
M       mathops.c
-->
--- :Liste de changements 'correctifs-maths' :
        bouton.c
M       entier.c
M       ops-math.c
$
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>
        <indexterm>
          <primary>changelists</primary>
          <secondary>removing</secondary>
        </indexterm>Fortunately, Harry catches his mistake.  At this
        point, he has two options.  He can remove the changelist
        association from <filename>button.c</filename>, and then
        assign a different changelist name:</para>
-->
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>
        <indexterm>
          <primary>listes de modifications</primary>
          <secondary>suppression</secondary>
        </indexterm>Par chance, Harry prend conscience de son erreur. Deux
        options se présentent alors à lui. Il peut supprimer
        l'association de <filename>bouton.c</filename> avec la liste de
        modifications, puis lui associer un nouveau nom de liste de
        modifications&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn changelist - -remove button.c
D [math-fixes] button.c
$ svn changelist ui-fix button.c
A [ui-fix] button.c-->
$ svn changelist --remove bouton.c
D [correctifs-maths] bouton.c
$ svn changelist correctifs-graphiques bouton.c
A [correctifs-graphiques] bouton.c
$
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>
        <indexterm>
          <primary>changelists</primary>
          <secondary>reassigning</secondary>
        </indexterm>Or, he can skip the removal and just assign a new
        changelist name.  In this case, Subversion will first warn
        Harry that <filename>button.c</filename> is being removed from
        the first changelist:</para>
-->
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>
        <indexterm>
          <primary>listes de modifications</primary>
          <secondary>réassignation</secondary>
        </indexterm>Ou alors il peut sauter l'étape de suppression et juste
        associer un nouveau nom de liste de modifications à
        <filename>bouton.c</filename>. Dans ce cas, Subversion signale à
        Harry que <filename>bouton.c</filename> va être supprimé de la
        première liste de modifications&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn changelist ui-fix button.c
D [math-fixes] button.c
A [ui-fix] button.c
$ svn status

- - - Changelist 'ui-fix':
        button.c

- - - Changelist 'math-fixes':
M       integer.c
M       mathops.c
-->
$ svn changelist correctifs-graphiques bouton.c
D [correctifs-maths] bouton.c
A [correctifs-graphiques] bouton.c
$ svn status

--- Liste de changements 'correctifs-graphiques' :
       bouton.c

--- Liste de changements 'correctifs-maths' :
M      entier.c
M      ops-maths.c
$
</screen>
      </informalexample>

<!--
      <para>Harry now has two distinct changelists present in his
        working copy, and <command>svn status</command> will group its
        output according to these changelist determinations.  Notice
        that even though Harry hasn't yet modified
        <filename>button.c</filename>, it still shows up in the output
        of <command>svn status</command> as interesting because it has
        a changelist assignment.  Changelists can be added to and
        removed from files at any time, regardless of whether they
        contain local modifications.</para>
-->
      <para>Harry dispose donc à présent de deux listes de modifications
        distinctes dans sa copie de travail et <command>svn
        status</command> présente ses résultats en les regroupant par
        liste de modifications. Notez que bien qu'Harry n'ait pas encore
        modifié <filename>bouton.c</filename>, celui-ci est quand même
        mentionné par <command>svn status</command> car une liste de
        modifications lui est associée. Les listes de modifications
        peuvent être associées, ou enlevées, aux fichiers à tout moment,
        indépendamment du fait que ces fichiers contiennent des
        modifications locales ou pas.</para>

<!--
      <para>Harry now fixes the user interface problem in
        <filename>button.c</filename>.</para>
-->
      <para>Harry règle maintenant le problème de l'interface graphique
        dans <filename>bouton.c</filename>.</para>

      <informalexample>
        <screen>
$ svn status

<!--
- - Changelist 'ui-fix':
M       button.c

- - Changelist 'math-fixes':
M       integer.c
M       mathops.c-->
--- Liste de changements 'correctifs-graphiques':
M      bouton.c

--- Liste de changements 'correctifs-maths':
M      entier.c
M      ops-math.c
$
</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.asfilters">
<!--
      <title>Changelists As Operation Filters</title>
-->
      <title>Listes de modifications&nbsp;: des filtres pour vos opérations</title>

<!--
      <para>The visual grouping that Harry sees in the output of
        <command>svn status</command> as shown in our previous section
        is nice, but not entirely useful.  The
        <command>status</command> command is but one of many
        operations that he might wish to perform on his working copy.
        Fortunately, many of Subversion's other operations understand
        how to operate on changelists via the use of the
        <option>- -changelist</option> option.</para>
-->
      <para>Le regroupement visuel qu'Harry constate en sortie de
        <command>svn status</command>, comme indiqué précédemment, est
        intéressant d'un point de vue esthétique, mais pas vraiment
        utile. La commande <command>status</command> n'est qu'une des
        commandes qu'il est susceptible de lancer sur sa copie de
        travail. Heureusement, bon nombre des autres opérations de
        Subversion sont capables d'agir sur les listes de modifications
        grâce à l'option <option>--changelist</option>.</para>

<!--
      <para>When provided with a <option>- -changelist</option> option,
        Subversion commands will limit the scope of their operation to
        only those files to which a particular changelist name is
        assigned.  If Harry now wants to see the actual changes he's
        made to the files in his <literal>math-fixes</literal>
        changelist, he <emphasis>could</emphasis> explicitly list only
        the files that make up that changelist on the <command>svn
        diff</command> command line.</para>
-->
      <para>Quand l'option <option>--changelist</option> est présente,
        les commandes Subversion limitent leur champ d'action aux
        fichiers auxquels est associé le nom de liste de modifications
        donné. Si Harry veut voir quels changements il a effectué sur
        les fichiers de sa liste <literal>correctifs-maths</literal>, il
        <emphasis>pourrait</emphasis> lister explicitement les fichiers
        faisant partie de cette liste de modifications avec la
        commande <command>svn diff</command>.</para>

      <informalexample>
        <screen><!--
$ svn diff integer.c mathops.c
Index: integer.c
===================================================================
- - integer.c	(revision 1157)
+++ integer.c	(working copy)
&hellip;
Index: mathops.c
===================================================================
- - mathops.c	(revision 1157)
+++ mathops.c	(working copy)-->
$ svn diff entier.c ops-math.c
Index: entier.c
===================================================================
--- entier.c	(révision 1157)
+++ entier.c	(copie de travail)
&hellip;
Index: ops-math.c
===================================================================
--- ops-math.c	(révision 1157)
+++ ops-math.c	(copie de travail)
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>That works okay for a few files, but what if Harry's
        change touched 20 or 30 files?  That would be an annoyingly
        long list of explicitly named files.  Now that he's using
        changelists, though, Harry can avoid explicitly listing the
        set of files in his changelist from now on, and instead
        provide just the changelist name:</para>
-->
      <para>Cette méthode fonctionne bien pour un petit nombre de fichiers,
        mais qu'en est-il si Harry a modifié une vingtaine ou une trentaine
        de fichiers&nbsp;? Fournir la liste de tous ces fichiers serait
        assez pénible. Mais puisqu'il utilise les listes de modifications,
        Harry peut désormais éviter de lister explicitement tous les
        fichiers et ne donner à la place que le nom de la liste de
        modifications&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn diff - -changelist math-fixes
Index: integer.c
===================================================================
- - integer.c	(revision 1157)
+++ integer.c	(working copy)
&hellip;
Index: mathops.c
===================================================================
- - mathops.c	(revision 1157)
+++ mathops.c	(working copy)-->
$ svn diff --changelist correctifs-maths

Index: entier.c
===================================================================
--- entier.c	(révision 1157)
+++ entier.c	(copie de travail)
&hellip;
Index: ops-math.c
===================================================================
--- ops-math.c	(révision 1157)
+++ ops-math.c	(copie de travail)
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>And when it's time to commit, Harry can again use the
        <option>- -changelist</option> option to limit the scope of the
        commit to files in a certain changelist.  He might commit his
        user interface fix by doing the following:</para>
-->
      <para>Et au moment de lancer la propagation, Harry peut à nouveau
        se servir de l'option <option>--changelist</option> pour limiter
        le rayon d'action de la propagation aux fichiers de sa liste de
        modifications. Par exemple, il peut propager ses changements
        concernant l'interface graphique en lançant&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Fix a UI bug found while working on math logic." \
             - -changelist ui-fix
Sending        button.c
Transmitting file data .
Committed revision 1158.
-->
$ svn commit -m "Corrigé un bug de l'interface graphique découvert en travaillant sur la logique mathématique." \
      --changelist correctifs-graphiques
Envoi        bouton.c
Transmission des données .
Révision 1158 propagée.
$
</screen>
      </informalexample>

<!--
      <para>In fact, the <command>svn commit</command> command
        provides a second changelists-related option:
        <option>- -keep-changelists</option>.  Normally, changelist
        assignments are removed from files after they are committed.
        But if <option>- -keep-changelists</option> is provided,
        Subversion will leave the changelist assignment on the
        committed (and now unmodified) files.  In any case, committing
        files assigned to one changelist leaves other changelists
        undisturbed.</para>
-->
      <para>En fait, la commande <command>svn commit</command> accepte
        une deuxième option liée aux listes de modifications&nbsp;:
        <option>--keep-changelists</option>. Normalement, l'association
        des listes de modifications avec les fichiers est supprimée dès
        que ceux-ci ont été propagés. Mais si l'option
        <option>--keep-changelists</option> est ajoutée sur la ligne de
        commande, les fichiers propagés (qui ne sont donc plus dans
        l'état modifié) restent associés aux listes de modifications
        en question. Dans tous les cas, propager des fichiers faisant
        partie d'une liste de modification laisse les autres listes de
        modifications intactes.</para>

      <informalexample>
        <screen>
$ svn status

<!--
- - Changelist 'math-fixes':
M       integer.c
M       mathops.c-->
--- Liste de changements 'correctifs-maths':
M      entier.c
M      ops-math.c
$
</screen>
      </informalexample>

<!--
      <note>
        <para>The <option>- -changelist</option> option acts only as a
          filter for Subversion command targets, and will not add
          targets to an operation.  For example, on a commit operation
          specified as <userinput>svn commit /path/to/dir</userinput>, the
          target is the directory <filename>/path/to/dir</filename>
          and its children (to infinite depth).  If you then add a
          changelist specifier to that command, only those files in
          and under <filename>/path/to/dir</filename> that are
          assigned that changelist name will be considered as targets
          of the commit&mdash;the commit will not include files
          located elsewhere (such as in
          <filename>/path/to/another-dir</filename>), regardless of
          their changelist assignment, even if they are part of the
          same working copy as the operation's target(s).</para>
      </note>
-->
      <note>
        <para>L'option <option>--changelist</option> agit comme un
          filtre sur les cibles des commandes Subversion et n'ajoute
          jamais de cible à une opération. Par exemple, lors d'une
          opération de propagation lancée via <userinput>svn commit
          /chemin/vers/rep</userinput>, la cible est le répertoire
          <filename>/chemin/vers/rep</filename> et ses fils (avec une
          profondeur infinie). Si ensuite vous ajoutez une option
          spécifiant une liste de modifications à cette commande, seuls
          les fichiers se trouvant sous le chemin
          <filename>/chemin/vers/rep</filename> et associés à cette
          liste de modifications sont pris en compte en tant que
          cibles de la propagation&nbsp;; ne sont pas inclus les
          fichiers situés ailleurs (tels ceux sous
          <filename>/chemin/vers/autre-rep</filename>), quelle que soit
          la liste de modifications à laquelle ils appartiennent, même
          s'il font partie de la même copie de travail que la ou les
          cibles de l'opération.</para>
      </note>

<!--
      <para>Even the <command>svn changelist</command> command accepts
        the <option>- -changelist</option> option.  This allows you to
        quickly and easily rename or remove a changelist:</para>
-->
      <para>Même la commande <command>svn changelist</command> accepte
        l'option <option>--changelist</option>. Ceci vous permet de
        renommer ou supprimer facilement une liste de
        modifications&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn changelist math-bugs - -changelist math-fixes - -depth infinity .
D [math-fixes] integer.c
A [math-bugs] integer.c
D [math-fixes] mathops.c
A [math-bugs] mathops.c
$ svn changelist - -remove - -changelist math-bugs - -depth infinity .
D [math-bugs] integer.c
D [math-bugs] mathops.c-->
$ svn changelist bogues-maths --changelist correctifs-maths --depth infinity .
D [correctifs-maths] entier.c
A [bogues-maths] entier.c
D [correctifs-maths] ops-math.c
A [bogues-maths] ops-math.c
$ svn changelist --remove --changelist bogues-maths --depth infinity .
D [bogues-maths] entier.c
D [bogues-maths] ops-math.c
$
</screen>
      </informalexample>

<!--
      <para>Finally, you can specify multiple instances of the
        <option>- -changelist</option> option on a single command
        line.  Doing so limits the operation you are performing to
        files found in any of the specified changesets.</para>
-->
      <para>Enfin, vous pouvez spécifier plusieurs instances de l'option
        <option>--changelist</option> dans une même ligne de commande.
        Ceci limite le champ d'action de votre opération aux fichiers
        faisant partie de toutes les listes de modifications
        spécifiées.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.limitations">
<!--
      <title>Changelist Limitations</title>
-->
      <title>Limitations des listes de modifications</title>

<!--
      <para>Subversion's changelist feature is a handy tool for
        grouping working copy files, but it does have a few limitations.
        Changelists are artifacts of a particular working copy, which
        means that changelist assignments cannot be propagated to the
        repository or otherwise shared with other users.  Changelists
        can be assigned only to files&mdash;Subversion doesn't
        currently support the use of changelists with directories.
        Finally, you can have at most one changelist assignment on a
        given working copy file.  Here is where the blog post category
        and photo service tag analogies break down&mdash;if you find
        yourself needing to assign a file to multiple changelists,
        you're out of luck.</para>
-->
      <para>La fonctionnalité de listes de modifications de Subversion
        est un outil très pratique pour créer des groupes de fichiers au
        sein de la copie de travail, mais elle a cependant quelques
        limitations. Les listes de modifications sont des objets
        contenus à l'intérieur d'une copie de travail, ce qui signifie
        que les associations entre fichiers et listes de modifications
        ne peuvent pas être propagées vers le dépôt, ni partagées avec
        d'autres utilisateurs. Les listes de modifications ne peuvent
        être associées qu'à des fichiers, Subversion n'offre pas cette
        possibilité pour les répertoires. Enfin, vous pouvez avoir
        au plus un nom de liste de modifications associé à un fichier
        donné. C'est ici que l'analogie avec les articles de blogs et
        les services d'étiquetage de photos en ligne part en fumée. S'il
        vous faut associer un fichier à plusieurs listes de
        modifications, vous êtes coincé.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.netmodel">
<!--
    <title>Network Model</title>
-->
    <title>Modèle de communication réseau</title>

<!--
    <para>At some point, you're going to need to understand how your
      Subversion client communicates with its server.  Subversion's
      networking layer is abstracted, meaning that Subversion clients
      exhibit the same general behaviors no matter what sort of server
      they are operating against.  Whether speaking the HTTP protocol
      (<literal>http://</literal>) with the Apache HTTP Server or
      speaking the custom Subversion protocol
      (<literal>svn://</literal>) with <command>svnserve</command>,
      the basic network model is the same.  In this section, we'll
      explain the basics of that network model, including how
      Subversion manages authentication and authorization
      matters.</para>
-->
    <para>À un moment ou à un autre, vous aurez besoin de
      comprendre comment le client Subversion communique avec le
      serveur. La couche réseau de Subversion est abstraite,
      c'est-à-dire que les clients Subversion ont le même comportement
      quel que soit le type de serveur auquel ils ont affaire. Qu'ils
      communiquent via le protocole HTTP (<literal>http://</literal>)
      avec un serveur HTTP Apache ou via le protocole Subversion
      (<literal>svn://</literal>) avec <command>svnserve</command>,
      le modèle de communication réseau est le même. Dans cette section,
      nous expliquons les fondamentaux de ce modèle de communication
      réseau, y compris la façon dont Subversion gère les
      authentifications et les autorisations.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.reqresp">
<!--
      <title>Requests and Responses</title>
-->
      <title>Requêtes et réponses</title>

<!--
      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a remote
        repository, however, it makes a network request, and the
        server responds with an appropriate answer.  The details of
        the network protocol are hidden from the user&mdash;the client
        attempts to access a URL, and depending on the URL scheme, a
        particular protocol is used to contact the server (see <xref
        linkend="svn.advanced.reposurls"/>).</para>
-->
      <para>Le client Subversion passe la plupart de son temps à gérer
        des copies de travail. Cependant, quand il a besoin
        d'informations disponibles dans un dépôt distant, il envoie une
        requête sur le réseau et le serveur lui répond. Les détails du
        protocole réseau sont cachés à l'utilisateur&nbsp;: le client
        essaie d'accéder à une URL et, suivant le format de cette URL,
        utilise un protocole particulier pour contacter le serveur
        (voir <xref linkend="svn.advanced.reposurls"/>).</para>

<!--
      <tip>
        <para>Run <userinput>svn - -version</userinput> to see which
          URL schemes and protocols the client knows how to use.</para>
      </tip>
-->
      <tip>
        <para>Tapez <userinput>svn --version</userinput> pour voir
          quels types d'URL et de protocoles sont utilisables par votre
          client.</para>
      </tip>

<!--
      <para>
        <indexterm>
          <primary>authentication</primary>
          <secondary>credentials</secondary>
        </indexterm>When the server process receives a client request, it
        often demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information that the client asked for.
        Notice that this system is different from systems such as CVS,
        where the client preemptively offers credentials (<quote>logs
        in</quote>) to the server before ever making a request.  In
        Subversion, the server <quote>pulls</quote> credentials by
        challenging the client at the appropriate moment, rather than
        the client <quote>pushing</quote> them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        the server will never issue an authentication challenge
        when a client attempts to <command>svn checkout</command>.</para>
-->
      <para>
        <indexterm>
          <primary>authentification</primary>
          <secondary>éléments d'authentification</secondary>
        </indexterm>Quand le serveur reçoit une requête d'un client, il
        demande souvent au client de s'identifier. Il envoie un défi
        d'authentification vers le client et le client répond en
        fournissant les <firstterm>éléments d'authentification</firstterm>
        au serveur. Une fois cette authentification terminée, le serveur
        répond à la requête originale du client. Remarquez que ce
        fonctionnement est différent de celui de CVS où le client envoie
        systématiquement au préalable ses identifiants de connexion
        (procédure de <quote>log in</quote>), avant même de formuler la
        moindre requête. Dans Subversion, le serveur requiert explicitement
        l'authentification du client (par un défi d'authentification)
        au moment approprié, au lieu que ce soit le client qui
        s'authentifie <foreignphrase>a priori</foreignphrase>. Certaines
        opérations sont donc effectuées plus élégamment. Par exemple, si un
        serveur est configuré pour laisser tout le monde accéder au dépôt en
        lecture, alors le serveur n'envoie jamais de défi d'authentification
        quand un client tente un <command>svn checkout</command>.</para>


<!--
      <para>If the particular network requests issued by the client
        result in a new revision being created in the repository
        (e.g., <command>svn commit</command>), Subversion uses the
        authenticated username associated with those requests as the
        author of the revision.  That is, the authenticated user's
        name is stored as the value of the
        <literal>svn:author</literal> property on the new revision
        (see <xref linkend="svn.advanced.props.ref"/>).  If the
        client was not authenticated (i.e., if the server never issued
        an authentication challenge), the revision's
        <literal>svn:author</literal> property is empty.</para>
-->
      <para>Si une requête d'un client conduit à la création d'une
        nouvelle révision du dépôt (par exemple un <command>svn
        commit</command>), alors Subversion utilise le nom d'utilisateur
        fourni lors de la phase d'authentification comme auteur de la
        révision. C'est-à-dire que le nom d'utilisateur est stocké dans
        la propriété <literal>svn:author</literal> de la nouvelle
        révision (voir <xref linkend="svn.advanced.props.ref"/>). Si le
        client n'a pas été authentifié (en d'autres termes, si le
        serveur n'a jamais envoyé de défi d'authentification), alors la
        propriété <literal>svn:author</literal> de la révision est
        vide.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.creds">
<!--
      <title>Client Credentials</title>
-->
      <title>Éléments d'authentification du client</title>

<!--
      <para>Many Subversion servers are configured to require
        authentication.  Sometimes anonymous read operations are
        allowed, while write operations must be authenticated.  In
        other cases, reads and writes alike require authentication.
        Subversion's different server options understand different
        authentication protocols, but from the user's point of view,
        authentication typically boils down to usernames and
        passwords.  Subversion clients offer several different ways to
        retrieve and store a user's authentication credentials, from
        interactive prompting for usernames and passwords to encrypted
        and non-encrypted on-disk data caches.</para>
-->
      <para>Beaucoup de serveurs sont configurés afin de requérir une
        authentification. Parfois, les opérations de lecture sont autorisées
        aux utilisateurs anonymes alors que les opérations d'écriture
        nécessitent une authentification. Dans d'autres cas, à la fois les
        opérations de lecture et d'écriture requièrent une authentification.
        Les différentes options du serveur Subversion gèrent différents
        protocoles d'authentification mais, du point de vue de l'utilisateur,
        l'authentification se résume typiquement à un identifiant et un mot
        de passe. Les clients Subversion offrent différentes façon de gérer
        les éléments d'authentification de l'utilisateur, depuis la saisie
        interactive de l'identifiant et du mot de passe jusqu'à la mise en
        cache des éléments dans un conteneur chiffré ou non sur le
        disque.</para>

<!--
      <para>The security-conscious reader will suspect immediately
        that there is reason for concern here.  <quote>Caching
        passwords on disk?  That's terrible!  You should never do
        that!</quote>  Don't worry&mdash;it's not as bad as it sounds.
        The following sections discuss the various types of credential
        caches that Subversion uses, when it uses them, and how to
        disable that functionality in whole or in part.</para>
-->
      <para>Ici, le lecteur soucieux de sécurité va immédiatement
        bondir de son siège&nbsp;: <quote>Mettre en cache des mots
        de passe sur le disque&nbsp;? Quelle horreur&nbsp;!
        Jamais&nbsp;!</quote>. Ne vous inquiétez pas outre mesure&nbsp;: ce
        n'est pas aussi terrible que ça en a l'air. Les paragraphes qui
        suivent vont détailler les différents types de cache pour les
        éléments d'authentification que Subversion utilise, les phases où
        il les utilise et comment désactiver cette fonctionnalité en totalité
        ou en partie.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.netmodel.credcache">
<!--
        <title>Caching credentials</title>
-->
        <title>Mise en cache des éléments d'authentification</title>

<!--
        <para>Subversion offers a remedy for the annoyance caused when
          users are forced to type their usernames and passwords over
          and over again.  By default, whenever the command-line
          client successfully responds to a server's authentication
          challenge, credentials are cached on disk and keyed on a
          combination of the server's hostname, port, and
          authentication realm.  This cache will then be automatically
          consulted in the future, avoiding the need for the user to
          re-type his or her authentication credentials.  If seemingly
          suitable credentials are not present in the cache, or if the
          cached credentials ultimately fail to authenticate, the
          client will, by default, fall back to prompting the user for
          the necessary information.</para>
-->
        <para>Subversion propose une solution à ceux qui en ont assez de
          taper leur nom d'utilisateur et mot de passe à tout bout de champs.
          Par défaut, dès que le client texte interactif passe avec succès
          un défi d'authentification, les éléments d'authentification sont
          mis en cache sur le disque et associés à la combinaison du nom
          du serveur, son port et le domaine d'authentification. Ce cache
          sera automatiquement consulté lors des prochains défis,
          l'utilisateur n'ayant plus à retaper ses éléments
          d'authentification. Si aucun élément convenable n'est présent dans
          le cache, ou si les éléments du cache échouent à
          l'authentification, le client invitera l'utilisateur à fournir les
          informations nécessaires.</para>

<!--
        <para>The Subversion developers recognize that on-disk caches
          of authentication credentials can be a security risk.  To
          offset this, Subversion works with available mechanisms
          provided by the operating system and environment to try to
          minimize the risk of leaking this information.</para>
-->
        <para>Les développeurs de Subversion reconnaissent que le stockage
          sur disque des éléments d'authentification peut consistuer une
          vulnérabilité. C'est pourquoi Subversion est capable de fonctionner
          avec les différents mécanismes offerts par le système
          d'exploitation et l'environnement de travail pour minimiser les
          risques de fuites d'information.</para>

        <itemizedlist>

<!--
          <listitem>
            <para>On Windows, the Subversion client stores passwords
              in the <filename>%APPDATA%/Subversion/auth/</filename>
              directory.  On Windows 2000 and later, the standard
              Windows cryptography services are used to encrypt the
              password on disk.  Because the encryption key is managed
              by Windows and is tied to the user's own login
              credentials, only the user can decrypt the cached
              password.  (Note that if the user's Windows account
              password is reset by an administrator, all of the cached
              passwords become undecipherable.  The Subversion client
              will behave as though they don't exist, prompting for
              passwords when required.)</para>
          </listitem>
-->
          <listitem>
            <para>Sous Windows, le client Subversion stocke les mots de
            passe dans le répertoire
            <filename>%APPDATA%/Subversion/auth/</filename>. Sous Windows
            2000 et ses successeurs, le client Subversion utilise les
            services cryptographiques standards de Windows pour chiffrer le
            mot de passe sur le disque. Comme la clé de chiffrement est gérée
            par Windows et qu'elle est associée à l'identifiant de connexion
            de l'utilisateur, lui seul peut déchiffrer le mot de passe en
            cache. Notez que si le mot de passe de l'utilisateur est
            réinitialisé par un administrateur, tous les mots de passe en
            cache deviennent indéchiffrables. Le client Subversion agit comme
            s'ils n'existaient pas, en redemandant le mot de passe quand
            c'est nécessaire.</para>
          </listitem>

<!--
          <listitem>
            <para>Similarly, on Mac OS X, the Subversion client stores
              all repository passwords in the login keyring (managed
              by the Keychain service), which is protected by the
              user's account password.  User preference settings can
              impose additional policies, such as requiring that the
              user's account password be entered each time the
              Subversion password is used.</para>
          </listitem>
-->
          <listitem>
            <para>De manière similaire, sur Mac OS X, le client Subversion
              stocke tous les mots de passe dans le jeton de connexion
              (géré par le service <quote>Keychain</quote>), qui est protégé
              par le mot de passe du compte utilisateur. La configuration des
              <quote>préférences utilisateur</quote> peut imposer une
              politique plus stricte, comme demander le mot de
              passe du compte utilisateur à chaque fois qu'un mot de passe
              Subversion est utilisé.</para>
        </listitem>

<!--
          <listitem>
            <para>For other Unix-like operating systems, no single
              standard <quote>keychain</quote> service exists.
              However, the Subversion client knows how to store
              passwords securely using the <quote>GNOME Keyring</quote>,
              <quote>KDE Wallet</quote>, and <quote>GnuPG
              Agent</quote> services.  Also, before storing
              unencrypted passwords in the
              <filename>~/.subversion/auth/</filename> caching area,
              the Subversion client will ask the user for permission
              to do so.  Note that the <filename>auth/</filename>
              caching area is still permission-protected so that only
              the user (owner) can read data from it, not the world at
              large.  The operating system's own file permissions protect
              the passwords from other non-administrative users on the
              same system, provided they have no direct physical access
              to the storage media of the home directory, or backups
              thereof.</para>
          </listitem>
-->
          <listitem>
            <para>Pour les systèmes de type Unix, il n'existe pas de
            standard de service de type <quote>Keychain</quote>. Cependant,
            le client Subversion sait stocker de manière sûre les mots de
            passe en utilisant les services <quote>Gnome Keyring</quote>,
            <quote>KDE Wallet</quote> et <quote>GnuPG Agent</quote>. Aussi,
            avant de stocker les mots de passe sans chiffrement dans la zone
            de cache <filename>~/.subversion/auth/</filename>, le client
            Subversion demandera à l'utilisateur l'autorisation de le faire.
            Notez que la zone de cache <filename>auth/</filename> reste
            protégée par les droits système et seul l'utilisateur (le
            propriétaire) des données peut les lire. Les droits sur les
            fichiers fournis par le système d'exploitation protègent les mots
            de passe vis-à-vis des autres utilisateurs non administrateurs
            sur le même système, pour autant qu'ils n'aient pas un accès
            physique direct au dispositif de stockage du répertoire de
            l'utilisateur ou aux sauvegardes.</para>
        </listitem>

        </itemizedlist>

<!--
        <para>Of course, for the truly paranoid, none of these
          mechanisms meets the test of perfection.  So for those folks
          willing to sacrifice convenience for the ultimate in security,
          Subversion provides various ways of disabling its credentials
          caching system altogether.</para>
-->
        <para>Bien sûr, si vous êtes complètement paranoïaque, aucun de
          ces mécanismes n'est parfait. Ainsi, pour ceux qui sont prêts à
          sacrifier le confort d'utilisation au profit de la sécurité
          absolue, Subversion fournit de nombreuses façons de désactiver
          les systèmes de cache d'authentification.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.disabling-password-caching">
<!--
        <title>Disabling password caching</title>
-->
        <title>Désactivation de la mise en cache des mots de passe</title>

<!--
        <para>When you perform a Subversion operation that requires
          you to authenticate, by default Subversion tries to cache
          your authentication credentials on disk in encrypted form.
          On some systems, Subversion may be unable to encrypt your
          authentication data.  In those situations, Subversion will
          ask whether you want to cache your credentials to disk in
          plaintext:</para>
-->
        <para>Quand vous effectuez une opération Subversion qui nécessite de
          vous authentifier, par défaut Subversion essaie de mettre en cache
          vos éléments d'authentification sur le disque sous une forme
          chiffrée. Sur certains systèmes, Subversion peut être incapable de
          chiffrer vos éléments d'authentification. Dans ce cas, Subversion
          vous demandera si vous voulez vraiment mettre en cache vos
          éléments d'authentification sur le disque sous forme
          claire&nbsp;:</para>


        <informalexample>
          <screen>
$ svn checkout https://host.example.com:443/svn/private-repo
-----------------------------------------------------------------------
ATTENTION!  Your password for authentication realm:

   &lt;https://host.example.com:443&gt; Subversion Repository

can only be stored to disk unencrypted!  You are advised to configure
your system so that Subversion can store passwords encrypted, if
possible.  See the documentation for details.

You can avoid future appearances of this warning by setting the value
of the 'store-plaintext-passwords' option to either 'yes' or 'no' in
'/tmp/servers'.
-----------------------------------------------------------------------
Store password unencrypted (yes/no)?
</screen>
        </informalexample>

<!--
        <para>If you want the convenience of not having to continually
          reenter your password for future operations, you can
          answer <literal>yes</literal> to this prompt.  If you're
          concerned about caching your Subversion passwords in
          plaintext and do not want to be asked about it again and
          again, you can disable caching of plaintext passwords either
          permanently, or on a server-by-server basis.</para>
-->
        <para>Si vous voulez profiter de la facilité de ne pas avoir à entrer
          votre mot de passe à chaque nouvelle opération, vous pouvez
          répondre <literal>yes</literal> à cette invite. Si vous ne voulez
          pas stocker votre mot de passe en clair et que vous ne voulez pas
          que Subversion vous pose la question à chaque fois, vous pouvez
          désactiver la mise en cache en clair des mots de passe, soit de
          manière permanente, soit en fonction du serveur auquel vous vous
          connectez.</para>

<!--
        <warning>
          <para>When considering how to use Subversion's password
            caching system, you'll want to consult any governing
            policies that are in place for your client
            computer&mdash;many companies have strict rules about the
            ways that their employees' authentication credentials
            should be stored.</para>
        </warning>
-->
        <warning>
          <para>Au moment de faire votre choix concernant la mise en cache
            des mots de passe, vérifier la politique de sécurité relative à
            votre poste de travail. Beaucoup d'entreprises ont des règles
            strictes sur le stockage des mots de passe de leurs
            employés.</para>
        </warning>

<!--
        <para>To permanently disable caching of passwords in
          plaintext, add the line <literal>store-plaintext-passwords =
          no</literal> to the <literal>[global]</literal> section in
          the <filename>servers</filename> configuration file on the
          local machine.  To disable plaintext password caching for a
          particular server, use the same setting in the appropriate
          group section in the <filename>servers</filename>
          configuration file.  (See
          <xref linkend="svn.advanced.confarea.opts"/> in
          <xref linkend="svn.customization"/> for details.)</para>
-->
        <para>Pour désactiver de manière permanente la mise en cache des
          mots de passe en clair, ajouter la ligne
          <literal>store-plaintext-passwords = no</literal> à la section
          <literal>[global]</literal> du fichier de configuration
          <filename>servers</filename> de votre machine locale. Pour la
          désactiver uniquement pour un serveur particulier, utiliser la
          même directive dans la section appropriée du fichier de
          configuration <filename>servers</filename> (pour plus de détails,
          reportez-vous à
          <xref linkend="svn.advanced.confarea.opts"/> dans
          <xref linkend="svn.customization"/>.)</para>

<!--
        <para>To disable password caching entirely for any single
          Subversion command-line operation, pass
          the <option>- -no-auth-cache</option> option to that command
          line.  To permanently disable caching entirely, add the
          line <literal>store-passwords = no</literal> to your local
          machine's Subversion configuration file.</para>
-->

        <para>Pour désactiver la mise en cache des mots de passe pour les
          opérations en ligne de commande, utilisez l'option
          <option>--no-auth-cache</option>. Pour désactiver la mise en cache
          de manière permanente, ajoutez l'option <literal>store-passwords =
          no</literal> dans le fichier de configuration Subversion de votre
          machine.</para>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.authn-cache-purge">
<!--
        <title>Removing cached credentials</title>
-->
        <title>Suppression des éléments d'authentification déjà en cache</title>

<!--
        <para>Sometimes users will want to remove specific credentials
          from the disk cache.  To do this, you need to navigate into
          the <filename>auth/</filename> area and manually delete the
          appropriate cache file.  Credentials are cached in individual
          files;  if you look inside each file, you will see keys and
          values.  The <literal>svn:realmstring</literal> key describes
          the particular server realm that the file is associated
          with:</para>
-->
        <para>Il arrive que les utilisateurs veuillent effacer certains
          mots de passe du cache disque. Pour ce faire, vous devez vous
          rendre dans la zone <filename>auth/</filename> et effacer
          manuellement le fichier de cache approprié. Les éléments
          d'authentification sont mis en cache dans des fichiers
          individuels&nbsp;; si vous affichez chaque fichier, vous voyez
          des clés et des valeurs. La clé
          <literal>svn:realmstring</literal> décrit le domaine du serveur
          auquel est associé le fichier&nbsp;:</para>

        <informalexample>
          <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45<!--
&lt;https://svn.domain.com:443&gt; Joe's repository -->
&lt;https://svn.domaine.fr:443&gt; dépôt de Paul
END
</screen>
        </informalexample>

<!--
        <para>Once you have located the proper cache file, just delete
          it.</para>
-->
        <para>Une fois le bon fichier trouvé, effacez-le.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.different-user">
<!--
        <title>Command-line authentication</title>
-->
        <title>Authentification en ligne de commande</title>

<!--
        <para>All Subversion command-line operations accept
          the <option>- -username</option>
          and <option>- -password</option> options, which allow you to
          specify your username and password, respectively, so that
          Subversion isn't forced to prompt you for that information.
          This is especially handy if you need to invoke Subversion
          from a script and cannot rely on Subversion being able to
          locate valid cached credentials for you.  These options are
          also helpful when Subversion has already cached
          authentication credentials for you, but you know they aren't
          the ones you want it to use.  Perhaps several system users
          share a login to the system, but each have distinct
          Subversion identities.  You can omit
          the <option>- -password</option> option from this pair if
          you wish Subversion to use only the provided username, but
          still prompt you for that username's password.</para>
-->
        <para>Toutes les opérations en ligne de commandes acceptent les
          options <option>--username</option> et <option>--password</option>,
          qui vous permettent de spécifier respectivement un nom
          d'utilisateur et un mot de passe afin que Subversion ne soit pas
          obligé de vous inviter à les entrer. C'est particulièrement
          pratique si vous devez invoquer Subversion dans un script et que
          vous ne pouvez pas vous fier au fait que Subversion trouvera des
          éléments d'authentification valides dans le cache pour vous. Ces
          options sont aussi utiles lorsque Subversion a déjà mis en cache
          les éléments d'authentification pour vous, mais que vous savez que
          vous ne voulez pas utiliser ces éléments. Vous pouvez omettre
          l'option <option>--password</option> si vous souhaitez que
          Subversion utilise seulement le nom d'utilisateur fourni mais
          continue à demander un mot de passe pour cet utilisateur.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.authn-wrapup">
<!--
        <title>Authentication wrap-up</title>
-->
        <title>Un dernier mot sur l'authentification</title>

<!--
        <para>One last word about <command>svn</command>'s
          authentication behavior, specifically regarding the
          <option>- -username</option> and <option>- -password</option>
          options.  Many client subcommands accept these options, but it
          is important to understand that using these options does
          <emphasis>not</emphasis> automatically send credentials to the
          server.  As discussed earlier, the server <quote>pulls</quote>
          credentials from the client when it deems necessary; the
          client cannot <quote>push</quote> them at will.  If a username
          and/or password are passed as options, they will be
          presented to the server only if the server requests them.  These
          options are typically used to authenticate as a different user
          than Subversion would have chosen by default (such as your
          system login name) or when trying to avoid interactive
          prompting (such as when calling <command>svn</command> from a
          script).</para>
-->
        <para>La façon dont <command>svn</command> gère
          l'authentification, avec un zoom sur les options
          <option>--username</option> et <option>--password</option>.
          Beaucoup de sous-commandes du client acceptent ces options, mais
          il est important de comprendre que l'utilisation de ces options
          <emphasis>n'envoie pas</emphasis> automatiquement les éléments
          d'authentification au serveur. Comme vu précédemment, le serveur
          <emphasis>demande</emphasis> explicitement l'authentification au
          client quand il estime que c'est nécessaire&nbsp;; le client ne
          les envoie pas à sa convenance. Même si un nom d'utilisateur
          et/ou un mot de passe sont passés en option, ils ne sont
          envoyés au serveur que si celui-ci les demande. Ces options sont
          couramment utilisées pour s'authentifier sous un nom
          d'utilisateur différent de celui que Subversion aurait choisi
          par défaut (comme votre nom de compte système), ou quand on ne
          veut pas de commande interactive (par exemple, utilisation de la
          commande <command>svn</command> dans un script).</para>

<!--
        <note>
          <para>A common mistake is to misconfigure a server so
            that it never issues an authentication challenge.  When
            users pass <option>- -username</option> and
            <option>- -password</option> options to the client, they're
            surprised to see that they're never used; that is, new
            revisions still appear to have been committed
            anonymously!</para>
        </note>
-->
        <note>
          <para>Une erreur classique consiste à mal configurer un serveur
            de telle sorte qu'il n'envoie jamais de défi
            d'authentification. Quand les utilisateurs passent les options
            <option>--username</option> et <option>--password</option>,
            ils sont surpris de voir qu'elles ne sont jamais utilisées,
            c'est-à-dire que les nouvelles révisions semblent toujours
            avoir été propagées de façon anonyme&nbsp;!</para>
      </note>

<!--
        <para>Here is a final summary that describes how a Subversion
          client behaves when it receives an authentication
          challenge.</para>
-->
        <para>En résumé, voici comment un client Subversion se comporte
          quand il reçoit un défi d'authentification&nbsp;:</para>

        <orderedlist>
          <listitem>
<!--
            <para>First, the client checks whether the user specified
              any credentials as command-line options
              (<option>- -username</option> and/or
              <option>- -password</option>).  If so, the client will try
              to use those credentials to authenticate against the
              server.</para>
-->
            <para>D'abord, le client vérifie si l'utilisateur a spécifié
              explicitement des éléments d'authentification dans la ligne
              de commande (options <option>--username</option> et/ou
              <option>--password</option>). Si c'est le cas, le client
              essaie de s'authentifier auprès du serveur avec ces
              éléménts.</para>
          </listitem>
          <listitem>
<!--
            <para>If no command-line credentials were provided, or the
              provided ones were invalid, the client looks up the server's
              hostname, port, and realm in the runtime configuration's
              <filename>auth/</filename> area, to see whether appropriate
              credentials are cached there.  If so, it attempts to use
              those credentials to authenticate.</para>
-->
            <para>Si les éléments d'authentification ne sont pas passés en
              ligne de commande, ou si ceux qui ont été fournis ne sont pas
              valides, le client regarde dans la zone
              <filename>auth/</filename> s'il trouve le nom, le port et
              le domaine du serveur pour voir si l'utilisateur a déjà les
              éléments d'authentification en cache. Si c'est le cas, il
              essaie d'utiliser ces éléments pour s'authentifier.</para>
          </listitem>
          <listitem>
<!--
            <para>Finally, if the previous mechanisms failed to
              successfully authenticate the user against the server, the
              client resorts to interactively prompting the user for
              valid credentials (unless instructed not to do so via the
              <option>- -non-interactive</option> option or its
              client-specific equivalents).</para>
-->
            <para>Finalement, si les mécanismes précédents ont abouti à
              des échecs d'authentification sur le serveur, le client se
              résout à demander les éléments à l'utilisateur (à moins
              qu'il ne lui ait été indiqué de ne pas le faire
              <foreignphrase>via</foreignphrase> l'option
              <option>--non-interactive</option> ou son équivalent
              spécifique au client).</para>
          </listitem>
        </orderedlist>

<!--
        <para>If the client successfully authenticates by any of these
          methods, it will attempt to cache the credentials on disk
          (unless the user has disabled this behavior, as mentioned
          earlier).</para>
-->
        <para>Si le client réussit à s'authentifier par l'une ou l'autre
          de ces méthodes, il essaie de mettre en cache les éléments
          d'authentification sur le disque (à moins que cette fonctionnalité
          ne soit désactivée, comme indiqué auparavant).</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.working-without-a-wc">
<!--
    <title>Working Without a Working Copy</title>
-->
    <title>Travail sans copie de travail</title>

<!--
    <para>As we described in <xref linkend="svn.basic.in-action.wc"
      />, the Subversion working copy is a sort of staging area where
      a user can privately make changes to his or her versioned data
      and then&mdash;when those changes are complete and ready for
      sharing with others&mdash;commit them to the repository.  It
      should come as no surprise, then, that most of the interaction
      you will have with Subversion will be in the form of asking your
      Subversion client to do <emphasis>something</emphasis> to one or
      more items in a local working copy.  Even for those operations
      which don't manipulate the working copy data itself (such
      as <command>svn log</command>), it's often just easier to use a
      working copy file or directory as a convenient target for that
      operation.</para>
-->
    <para>Comme nous l'avons indiqué dans <xref
      linkend="svn.basic.in-action.wc" />, la copie de travail Subversion est
      une sorte de zone de transit où l'utilisateur peut effectuer des
      modifications privées à ses données suivies en versions et, une fois
      que ces modifications sont terminées et prêtes à être partagées, il
      peut les propager vers le dépôt. Cela ne doit donc pas vous surprendre
      si l'on vous dit que la majeure partie des interactions que vous aurez
      avec Subversion seront des demandes au client Subversion de faire
      <emphasis>quelque chose</emphasis> concernant un ou plusieurs éléments
      de la copie de travail locale. Même pour les opérations qui ne
      manipulent pas de données de la copie de travail elle-même (telles que
      <command>svn log</command> par exemple), il est souvent plus facile
      d'utiliser un fichier ou un dossier de la copie de travail comme cible
      de l'opération.</para>

<!--
    <para>Clearly, the typical approach to making changes to
      your versioned data is via commits from a Subversion working
      copy.  Fortunately, it's not the only way.  Users of Subversion
      who need to make relatively simple changes to their versioned
      data can do so without the overhead of checking out a working
      copy.  We'll cover some of those supported operations in this
      section.</para>
-->
    <para>Clairement, l'approche canonique pour effectuer des modifications
      sur vos données suivies en versions se fait
      <foreignphrase>via</foreignphrase> une propagation d'une copie de
      travail Subversion. Heureusement, ce n'est pas l'unique façon de faire.
      Les utilisateurs de Subversion qui ont besoin de faire des
      modifications simples à leurs données suivies en versions peuvent le
      faire en s'affranchissant du coût d'une copie de travail. Dans cette
      section, nous allons décrire quelques opérations de ce type.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.working-without-a-wc.svn">
<!--
      <title>Remote command-line client operations</title>
-->
      <title>Opérations du client texte interactif à distance</title>

<!--
      <para>The Subversion command-line client supports a number of
        operations which can be performed directly against repository
        URLs in order to make simple changes without a working copy.
        Some of these are described elsewhere in this book, but we
        provide an exhaustive list of them here for your
        convenience.</para>
-->
      <para>Le client texte interactif Subversion sait faire plusieurs
        opérations en utilisant des URL du dépôt et sans copie de travail
        afin d'effectuer des modifications simples. Certaines sont
        décrites ailleurs dans ce livre, mais nous vous en donnons la liste
        exhaustive ici.  </para>

<!--
      <para>Perhaps the most obvious remote commit-like operation is
        the <command>svn import</command> command.  We describe that
        command in <xref linkend="svn.tour.importing.import" /> as
        part of explaining how you can easily get a whole tree of
        unversioned information into your Subversion repository so you
        can start doing version-controlled operations on it.</para>
-->
      <para>Certainement la plus évidente des opérations à distance de type
        propagation est la comande <command>svn import</command>. Nous
        décrivons cette commande dans <xref
        linkend="svn.tour.importing.import" /> lorsque nous expliquons
        comment insérer facilement une arborescence complète de données non
        suivies en versions dans un dépôt Subversion afin de démarrer le
        processus de suivi de versions sur ces données.</para>

<!--
      <para>The <command>svn mkdir</command> and <command>svn
        delete</command> commands, when used with URL targets, are
        also remote commit-type operations.  These allow the user to
        create one or more new versioned directories or remove
        (recursively) one or more versioned files or directories,
        respectively, without the use of a working copy.  Each time
        you issue one of these commands, the client communicates with
        the server in a way that's similar to how it would describe
        the commit of a directory added or of an item removed from the
        working copy.  If there's no problem or conflict detected with
        the requested operation, the server commits the additions or
        removals in a single new revision.</para>
-->
      <para>Les commandes <command>svn mkdir</command> et <command>svn
        delete</command>, lorsqu'elle ciblent des URL, sont aussi des
        opérations de type propagation. Elles permettent respectivement à
        l'utilisateur de créer un ou plusieurs nouveaux dossiers suivis en
        versions ou supprimer (récursivement) un ou plusieurs fichiers ou
        dossiers suivis en versions, sans l'utilisation d'une copie de
        travail. Chaque fois que vous entrez une de ces commandes, le client
        communique avec le serveur de la même manière que s'il décrivait la
        propagation de l'ajout d'un dossier ou de la suppression d'un élément
        de la copie de travail. S'il n'y a pas de problème ou de conflit
        détecté par cette opération, le serveur propage les ajouts ou les
        suppressions dans une nouvelle révision unique.</para>

<!--
      <para>You can use <command>svn copy</command> or <command>svn
        move</command> with two URLs&mdash;a copy/move source and a
        destination&mdash;to commit a copies and moves of files and
        directories directly in the repository.  These operations tend
        to be some of the most expensive ones when performed within a
        working copy, but they complete in constant time when
        performed remotely using repository URLs.  In fact,
        the <command>svn copy</command> remote operation is commonly
        used to create branches in Subversion, as we discuss later in
        <xref linkend="svn.branchmerge.using.create" />.</para>
-->
      <para>Vous pouvez utiliser <command>svn copy</command> ou <command>svn
        move</command> avec deux URL (une URL source de la copie/déplacement
        et une URL destination) pour propager des copies ou des déplacements
        de fichiers ou dossiers directement dans le dépôt. Ces opérations
        s'avèrent être les plus coûteuses quand elles sont effectuées à
        l'intérieur d'une copie de travail alors qu'elles s'exécutent en
        temps constant lorsqu'elles sont effectuées à distance en utilisant
        des URL du dépôt. En fait, l'opération distante <command>svn
        copy</command> est communément utilisée pour créer des branches dans
        Subversion, comme nous le montrons dans <xref
        linkend="svn.branchmerge.using.create" />.</para>

<!--
      <para>As with the regular <command>svn commit</command> command,
        you can supply a log message with any of these commands we've
        discussed so far to describe the changes you're making.  Use
        the <option>- -file (-F)</option> or <option>- -message
        (-m)</option> option, or otherwise allow the client to prompt
        you for the log message.</para>
-->
      <para>Comme pour la commande <command>svn commit</command> habituelle,
        vous pouvez spécifier un commentaire de propagation avec toutes ces
        commandes pour décrire les modifications que vous effectuez. Utilisez
        l'option <option>--file (-F)</option> ou <option>--message
        (-m)</option>, sinon autorisez le client à vous inviter à lui
        fournir un commentaire de propagation.</para>

<!--
      <para>Finally, there are a number of operations related to
        unversioned revision properties which can be performed
        directly against the repository.  In fact, revision properties
        are somewhat unique in this context, as they aren't stored in
        the working copy and therefore <emphasis>must</emphasis> be
        modified without working copy interaction.  See
        <xref linkend="svn.advanced.props" /> for a more detailed
        description of how to manage properties in Subversion.</para>
-->
      <para>Enfin, il y a plusieurs opérations relatives aux propriétés non
        suivies en versions que vous pouvez effectuer directement sur le
        dépôt. En fait, les propriétés de révisions sont quelques peu uniques
        dans ce contexte, puisqu'elles ne sont pas stockées dans les copies
        de travail et, par conséquent. <emphasis>doivent</emphasis> être
        modifiées sans toucher à la copie de travail. Reportez-vous
        à <xref linkend="svn.advanced.props" /> pour une description
        détaillée de la façon de gérer les propriétés dans Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.working-without-a-wc.svnmucc">
<!--
      <title>Using svnmucc</title>
-->
      <title>Utilisation de svnmucc</title>

<!--
      <para>One shortcoming of the remote commit operation support
        offered in the command-line client is that you are essentially
        limited to one operation&mdash;or, really, one type of
        operation&mdash;per commit.  For example, it's perfectly
        natural and supported to, say, use <command>svn
        delete</command> followed by <command>svn mkdir</command>
        within a working copy to replace an existing versioned
        directory with a brand new one.  When you commit the results
        of those operations, a single new revision is created in the
        repository, and that revision carries the full replacement of
        your directory.  You can't really do the same thing as remote
        operations using the command-line client while still
        preserving the it-happened-in-a-single-revision-ness of the
        change&mdash;<command>svn
        delete <replaceable>URL</replaceable></command> would create a
        new revision that removed the directory; <command>svn
        mkdir <replaceable>URL</replaceable></command> would generate
        a second revision for the directory's re-creation.</para>
-->
      <para>Un inconvénient de la propagation à distance par le
        client texte interactif est que vous êtes limité à une seule
        opération (réellement un type d'opération) par propagation. Par
        exemple, il est parfaitement naturel et possible de, disons,
        utiliser <command>svn delete </command> suivi de <command>svn
        mkdir</command> dans une copie de travail pour remplacer un
        répertoire suivi en versions existant avec un tout neuf. Lorsque vous
        propagez ces opérations, une seule nouvelle révision est créée dans
        le dépôt et cette révision comporte le remplacement complet de votre
        répertoire. Vous ne pouvez pas faire la même chose en opération à
        distance en utilisant le client texte interactif, tout en préservant
        l'unité de la transaction (<command>svn delete
        <replaceable>URL</replaceable></command> créera une nouvelle révision
        qui supprime le répertoire et <command>svn mkdir
        <replaceable>URL</replaceable></command> créera une deuxième révision
        qui recrée le répertoire).</para>

<!--
      <para>Fortunately, Subversion provides a separate tool which
        exists solely to allow users to string together a set of
        remote operations and commit them as one atomic change.  That
        tool is the <command>svnmucc</command> tool&mdash;the
        Subversion Multiple URL Command Client:</para>
-->
      <para>Heureusement, Subversion fournit un utilitaire séparé qui a pour
        vocation de permettre aux utilisateurs d'enchaîner un ensemble
        d'opérations à distance et de les propager comme une modification
        atomique. Cet outil est <command>svnmucc</command>, pour Subversion
        Multiple URL Command Client (que l'on pourrait traduire par client
        Subversion pour les commandes avec de multiples URL)&nbsp;:</para>

      <informalexample>
<!--
        <screen>
$ svnmucc - -help
Subversion multiple URL command client
usage: svnmucc ACTION...

  Perform one or more Subversion repository URL-based ACTIONs, committing
  the result as a (single) new revision.

Actions:
  cp REV URL1 URL2       : copy URL1@REV to URL2
  mkdir URL              : create new directory URL
  mv URL1 URL2           : move URL1 to URL2
  rm URL                 : delete URL
  put SRC-FILE URL       : add or modify file URL with contents copied from
                           SRC-FILE (use "-" to read from standard input)
  propset NAME VAL URL   : set property NAME on URL to value VAL
  propsetf NAME VAL URL  : set property NAME on URL to value from file VAL
  propdel NAME URL       : delete property NAME from URL
&hellip;
</screen>
-->
        <screen>
$ svnmucc --help
&hellip;Subversion multiple URL command client
usage: svnmucc ACTION...

  Perform one or more Subversion repository URL-based ACTIONs, committing
  the result as a (single) new revision.

Actions:
  cp REV SRC-URL DST-URL : copy SRC-URL@REV to DST-URL
  mkdir URL              : create new directory URL
  mv SRC-URL DST-URL     : move SRC-URL to DST-URL
  rm URL                 : delete URL
  put SRC-FILE URL       : add or modify file URL with contents copied from
                           SRC-FILE (use "-" to read from standard input)
  propset NAME VALUE URL : set property NAME on URL to VALUE
  propsetf NAME FILE URL : set property NAME on URL to value read from FILE
  propdel NAME URL       : delete property NAME from URL
&hellip;
</screen>
      </informalexample>

<!--
      <para><command>svnmucc</command> has been a part of the Subversion
        project's source code tree for many years
        (as <command>mucc</command> for most of that time), but it was
        only in Subversion 1.8 that it become a fully supported member
        of the Subversion command-line tool suite.</para>
-->
      <para><command>svnmucc</command> est inlus dans le code source du
        projet Subversion depuis de nombreuses années (en tant que
        commande <command>mucc</command> historiquement), mais c'est
        seulement à partir de Subversion 1.8 qu'il est devenu un membre à
        part entière de la panoplie des utilitaires en ligne de commande
        de Subversion.</para>

<!--
      <para>The <command>svnmucc</command> tool can perform any
        transformation on your versioned data that <command>svn</command>
        itself can.  But unlike <command>svn</command>, the functionality
        that <command>svnmucc</command> offers isn't broken up into
        subcommands.  Rather, you provide a list of actions and
        operands in a single command line (or from a file stream, via
        the <option>- -extra-args (-X)</option> option).  Some of the
        actions supported by <command>svnmucc</command> mimic those of
        the command-line client.  You'll notice in the previous
        command output actions such as <literal>cp</literal>,
        <literal>mkdir</literal>, <literal>mv</literal>,
        and <literal>rm</literal>, all of which are very similar to
        the commands we mentioned in
        <xref linkend="svn.advanced.working-without-a-wc.svn" />.  But
        remember, the key difference here is that you can use any
        number of these actions together in a single command
        invocation, resulting in a single committed revision in the
        repository.</para>
-->
      <para>L'utilitaire <command>svnmucc</command> peut effectuer toutes
        les manipulations que <command>svn</command> fait. Mais, au contraire
        de <command>svn</command>, <command>svnmucc</command> ne comporte pas
        de sous-commande. La syntaxe adoptée consiste à lui fournir une liste
        d'actions et d'opérandes dans une seule ligne de commande (ou depuis
        un fichier, <foreignphrase>via</foreignphrase> l'option
        <option>--extra-args (-X)</option>). Certaines actions autorisées
        par <command>svnmucc</command> singent le fonctionnement du client
        texte interactif. Vous aurez noté dans la sortie de la commande
        précédente que les <literal>cp</literal>, <literal>mkdir</literal>,
        <literal>mv</literal> et <literal>rm</literal> ressemblent
        bigrement aux commandes que nous avons citées dans
        <xref linkend="svn.advanced.working-without-a-wc.svn" />. Mais
        souvenez-vous que la différence fondamentale réside dans le fait que
        vous pouvez enchaîner plusieurs actions dans une seule ligne de
        commande et que cela ne générera qu'une seule révision dans le
        dépôt.</para>

<!--
      <para>Let's take our previous example of trying to simply
        replace a remote directory.  Using <command>svnmucc</command>,
        you would accomplish this as follows:</para>
-->
      <para>Prenons l'exemple précédent qui consiste à simplement remplacer
        un répertoire à distance. En utilisant <command>svnmucc</command>,
        vous le feriez ainsi&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svnmucc rm http://svn.example.com/projects/sandbox \
          mkdir http://svn.example.com/projects/sandbox \
          -m "Replace my old sandbox with a fresh new one."
r22 committed by harry at 2013-01-15T21:45:26.442865Z -->
$ svnmucc rm http://svn.exemple.fr/projets/pour-jouer \
          mkdir http://svn.exemple.fr/projets/pour-jouer \
          -m "Remplace mon vieux projet pour-jouer par un tout neuf."
r22 propagée par harry le 2013-01-15T21:45:26.442865Z
$
</screen>
      </informalexample>

<!--
      <para>As you can see, <command>svnmucc</command> accomplished in
        a single revision what <command>svn</command>&mdash;without
        the benefit of a working copy&mdash;required two revisions to
        complete.</para>
-->
      <para>Comme vous pouvez le constater, <command>svnmucc</command>
        a réalisé en une seule révision ce qui aurait nécessité deux
        révision pour <command>svn</command> (sans copie de travail à
        disposition).</para>

      <warning>
<!--
        <para>Another difference between <command>svnmucc</command>
          and <command>svn</command> is that the former currently will
          not prompt you for a commit log message if you fail to
          supply one via the command line.  Rather, it will use a
          stock (that is, relatively valueless) log message.</para>
-->
        <para>Une autre différence entre <command>svnmucc</command> et
          <command>svn</command> réside dans le fait que le premier ne vous
          demandera pas d'entrer un commentaire de propagation si vous ne le
          fournissez pas <foreignphrase>via</foreignphrase> la ligne de
          commande. En lieu et place, il utilisera un message par défaut (ce
          qui est relativement inutile).</para>
      </warning>

<!--
      <para>The <command>svnmucc</command> tool is not limited to
        merely remixing actions that <command>svn</command> itself can
        perform.  It introduces some additional functionality not
        found in the command-line client.  For example, you can use
        the <command>put</command> action to add or modify a file in
        the repository, copying the file's intended new contents from
        either a file on your local machine or from data piped in via
        standard input.  The tool also offers <command>propset</command>,
        <command>propsetf</command>, and <command>propdel</command>
        actions, useful for setting properties on versioned files and
        directories (explicitly, or by copying the property's value
        from a local file) and for deleting properties on the same.
        Those actions are unsupported in the command-line client at
        this time.</para>
-->
      <para>L'utilitaire <command>svnmucc</command> n'est pas simplement
        limité aux actions que <command>svn</command> ferait tout aussi bien.
        Il introduit des fonctionnalités supplémentaires que l'on ne trouve
        pas dans le client texte interactif. Par exemple, vous pouvez
        utiliser l'action <command>put</command> pour ajouter ou modifier un
        fichier dans le dépôt, en copiant le contenu d'un fichier présent sur
        votre machine locale ou depuis le flux de l'entrée standard. Cet
        outil permet aussi de manipuler les propriétés des fichiers et
        dossiers suivis en versions avec les actions
        <command>propset</command>, <command>propsetf</command> et
        <command>propdel</command>, explicitement ou en copiant les valeurs
        des propriétés à partir d'un fichier local. Ces actions ne sont pas
        possible depuis le client texte interactif à l'heure actuelle.</para>

<!--
      <para>At this point, though, it seems prudent to discuss the
        difference between what <emphasis>can</emphasis> be done
        with <command>svnmucc</command> and what
        <emphasis>should</emphasis> be done.  A pair of notable quotes
        comes to mind:</para>
-->
      <para>Il est temps de préciser la différence entre ce que
        <emphasis>peut</emphasis> faire <command>svnmucc</command> et ce
        qu'il est <emphasis>souhaitable</emphasis> qu'il fasse. Deux exemples
        viennent à l'esprit&nbsp;:</para>

      <blockquote>
        <attribution>Jesus</attribution>
<!--
        <para><quote>To whom much has been given, much will be
          expected.</quote></para>
-->
        <para><quote>On demandera beaucoup à qui l'on a beaucoup
          donné.</quote></para>
      </blockquote>

      <blockquote>
<!--
        <attribution>"Spiderman" Peter Parker's Uncle Ben</attribution>
        <para><quote>With great power comes great
          responsibility.</quote></para>
-->
        <attribution>"Spiderman" Oncle Ben de Peter Parker</attribution>
        <para><quote>Un grand pouvoir implique de grandes
          responsabilités.</quote></para>
      </blockquote>

<!--
      <para>Inherent in modifications without a working copy is the loss of
        the very conflict detection safeguards which make the use of a
        working copy so valuable.  When using <command>svn</command>
        in the typical way, changes are committed to the server
        against a specific base version of a file or directory so that
        you don't inadvertently overwrite contemporary changes made to
        the same item by another team member.  The server knows what
        version of the file you had before you changed it, and it
        knows if other folks have changed that same file since that
        revision was created.  That's all the information the server
        needs to deny your commit when it would clobber someone else's
        change, forcing you to integrate their change into your
        working copy and reconsider your own change.  Because there is
        no working copy in the mix here, <command>svnmucc</command>
        really gives you the power to bypass those safeguards and to
        act as if the current state of the repository is precisely the
        base state against which you are working.  But hopefully it is
        obvious to you that this is not a power you should cavalierly
        wield.</para>
-->
      <para>Comme vous travaillez sans copie de travail, il est impossible
        pour Subversion de détecter des conflits avant la propagation. Lors
        d'une utilisation classique de <command>svn</command>, les
        changements qui sont propagés vers le serveur sont comparés à une
        version de base déterminée du fichier ou du répertoire, afin de ne
        pas écraser par inadvertance des modifications concurrentes apportées
        par un autre membre de l'équipe. Le serveur connait la version du
        fichier que vous aviez avant vos modifications et il sait si d'autres
        gens ont changé ce fichier depuis la révision que vous détenez. Ce
        sont ces informations dont le serveur a besoin pour refuser votre
        propagation et qu'elle n'écrase pas les changements faits par
        quelqu'un d'autre&nbsp;; il vous force alors à intégrer ces
        changements dans votre copie de travail et à reconsidérer vos propres
        modifications. Avec <command>svnmucc</command>, il n'y a pas de copie
        de travail, ce qui vous donne la possibilité de contourner ces
        sécurités et d'agir comme si l'état courant du dépot était celui qui
        vous sert de base de travail. Heureusement, il est évident pour vous
        qu'un tel pouvoir ne s'utilise pas à la légère.</para>

<!--
      <para>Fortunately, <command>svnmucc</command> allows you to be
        more conservative in the way you use the tool.  In order to
        provide a safety mechanism similar to what is offered by the
        use of a working copy, <command>svnmucc</command> offers
        a <option>- -revision (-r)</option> option.  With this option,
        you can manually specify a base revision for the changes you
        are attempting to commit.  The base revision you choose
        is ideally the most recent revision in your repository of
        which you can reasonably claim knowledge.</para>
-->
      <para>Heureusement, <command>svnmucc</command> vous permet de poser un
        garde-fou lors de son utilisation. Afin d'offrir un mécanisme de
        sécurité comparable à l'utilisation d'une copie de travail,
        <command>svnmucc</command> propose l'option
        <option>--revision (-r)</option>. Avec cette option, vous pouvez
        spécifier manuellement une révision de base pour les modifications
        que vous essayez de propager. Cette révision de base est idéalement
        la plus récente du dépôt dont vous ayez connaissance.</para>

      <warning>
<!--
        <para>Users are strongly encouraged to use, and to use
          correctly, the <option>- -revision (-r)</option> option
          to <command>svnmucc</command>.</para>
-->
        <para>Nous encourageons fermement les utilisateurs à utiliser, et de
          manière appropriée, l'option <option>--revision (-r)</option> de
          <command>svnmucc</command>.</para>
      </warning>

<!--
      <para>Proper use of the <command>svnmucc put</command> action
        best demonstrates how this <option>- -revision (-r)</option>
        option should be used.  Say Harry wishes to change the
        contents of a versioned <filename>README</filename> file
        without bothering with a full checkout of a working copy.
        (We'll assume that there is no other value in using a working
        copy for this operation, such as the presence of scripts Harry
        should run in advance of his commit to verify that it's a
        reasonable one.)  The first decision he has to make is which
        revision of the file he wants to work with.  Typically, users
        wish to modify the most recent version of a file.  So Harry
        queries the revision in which the file was last modified, and
        then uses that revision to fetch the contents of the file into
        a temporary local file:</para>
-->
      <para>L'utilisation appropriée de <command>svnmucc put</command>
        démontre sans équivoque comment l'option
        <option>--revision (-r)</option> doit être invoquée. Considérons que
        Harry veuille modifier le fichier suivi en versions
        <filename>LISEZMOI</filename> sans s'embêter à rappatrier une copie
        de travail complète (nous supposons qu'il n'y a pas d'autre raison
        de disposer d'une copie de travail pour cette action, telles que le
        lancement de scripts avant de propager une révision pour vérifier
        qu'elle satisfait certains critères). Il doit en premier lieu décider
        avec quelle révision du fichier il va travailler. Typiquement, les
        utilisateurs souhaitent travailler avec la version la plus à jour
        d'un fichier. Ainsi, Harry effectue la requête relative à la
        révision de la dernière modification du fichier et modifie le contenu
        du fichier dans un fichier temporaire local&nbsp;:</para>

      <informalexample>
<!--
        <screen>
$ svn info http://svn.example.com/projects/sandbox/README
Path: README
URL: http://svn.example.com/projects/sandbox/README
Relative URL: ^/sandbox/README
Repository Root: http://svn.example.com/projects
Repository UUID: 13f79535-47bb-0310-9956-ffa450edef68
Revision: 22
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 14
Last Changed Date: 2012-09-02 10:34:09 -0400 (Sun, 02 Sep 2012)

$ svn cat -r 14 http://svn.example.com/projects/sandbox/README \
      > README.tmpfile
$
</screen>
-->
        <screen>
$ svn info http://svn.exemple.com/projets/bac-à-sable/LISEZMOI
Chemin : LISEZMOI
URL : http://svn.exemple.com/projets/bac-à-sable/LISEZMOI
Relative URL : ^/bac-à-sable/LISEZMOI
Racine du dépôt : http://svn.example.com/projects
UUID du dépôt : 13f79535-47bb-0310-9956-ffa450edef68
Révision : 22
Type de nœud : fichier
Auteur de la dernière modification : sally
Révision de la dernière modification : 14
Date de la dernière modification : 2012-09-02 10:34:09 -0400 (dim. 02 sep. 2012)

$ svn cat -r 14 http://svn.exemple.com/projets/bac-à-sable/LISEZMOI \
      > LISEZMOI.tempo
$
</screen>
      </informalexample>

<!--
      <para>Harry now has a copy of the <filename>README</filename>
        file as it looked when it it was last modified.  He makes the
        edits he wishes to make to this copy of the file.  Naturally,
        when he's finished, he wishes to then commit those changes to
        the repository.</para>
-->
      <para>Harry possède maintenant une copie du fichier
        <filename>LISEZMOI</filename> tel qu'il était lors de sa dernière
        modification. Il fait ses modifications dans cette copie du fichier.
        Naturellement, lorsqu'il a terminé, il veut propager ces
        modifications vers le dépôt.</para>

<!--
      <para>Now, if Harry naively uses <userinput>svnmucc put
        &hellip;</userinput> at this point to replace the contents of
        <filename>README</filename> in the repository with his locally
        modified contents, he has just abused the power
        that <command>svnmucc</command> affords.  What if, just
        microseconds prior to his commit, Sally had also modified
        the <filename>README</filename> file?  As with the
        <command>svn</command> program, <command>svnmucc</command>
        won't attempt some sort of server-side content merge in order
        to preserve both users' changes.  Rather,
        <command>svnmucc</command> will happily replace the current
        latest version of the file with the contents specified.  Harry
        will be oblivious.  Sally will be livid.</para>
-->
      <para>Maintenant, si Harry utilise naïvement
        <userinput>svnmucc put &hellip;</userinput>, pour remplacer le
        contenu de <filename>LISEZMOI</filename> dans le dépôt par le
        contenu de son fichier local, il fait un abus de pouvoir avec
        <command>svnmucc</command>. Que se passe-t-il si, quelques
        microsecondes avant sa propagation, Sally a aussi modifié le
        fichier <filename>LISEZMOI</filename>&nbsp;? Tout comme
        <command>svn</command>, <command>svnmucc</command> n'essaiera pas de
        fusionner sur le serveur les modifications de chacun pour les
        préserver. Non, <command>svnmucc</command> remplacera simplement la
        dernière version du fichier par la nouvelle qu'on lui donne. Harry
        n'en aura pas conscience, Sally sera furieuse.</para>

      <informalexample>
        <screen><!--
$ svnmucc put README.tmpfile \
          http://svn.example.com/projects/sandbox/README \
          -m "Tweak the README file."
r24 committed by harry at 2013-01-21T16:21:23.100133Z
$
Message from sally@shell.example.com on pts/2 at 16:26 ...
We need to talk.  Now.-->
$ svnmucc put LISEZMOI.tempo \
          http://svn.exemple.com/projets/bac-à-sable/LISEZMOI \
          -m "Modifié le fichier LISEZMOI."
r24 propagée par harry le 2013-01-21T16:21:23.100133Z
$
Message from sally@shell.example.com on pts/2 at 16:26 ...
Il faut qu'on se parle. Maintenant.
EOF
</screen>
      </informalexample>

<!--
      <para>Harry should instead recall the revision he originally
        used as the revision on which to base his changes, supplying
        that revision to <command>svnmucc</command> via
        the <option>- -revision (-r)</option> option, and thus giving
        the server the opportunity to bounce his commit if, by his own
        (perhaps ignorant) admission, he's attempting to modify an
        out-of-date item:</para>
-->
      <para>À la place, Harry doit rappeler la révision qu'il a utilisée
        comme base de travail à la commande <command>svnmucc</command>
        <foreignphrase>via</foreignphrase> l'option
        <option>--revision (-r)</option>. Ainsi, le serveur pourra rejeter
        la propagation si, par malheur, Harry essaie de modifier un élément
        obsolète&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svnmucc -r 14 put README.tmpfile \
          http://svn.example.com/projects/sandbox/README \
          -m "Tweak the README file."
svnmucc: E170004: Item '/sandbox/README' is out of date-->
$ svnmucc -r 14 put LISEZMOI.tempo \
          http://svn.exemple.com/projets/bac-à-sable/LISEZMOI \
          -m "Modifié le fichier LISEZMOI."
svnmucc: E170004: Item '/bac-à-sable/LISEZMOI' est obsolète.
$
</screen>
      </informalexample>

<!--
      <para>Like other <command>svnmucc</command> options,
        the <option>- -revision (-r)</option> option operates at a
        scope global to the whole command&mdash;every action specified
        in that command.  This enables you to have the same sort of
        safeguards you would have if you had checked out a working
        copy of your entire repository (and thus had a working copy
        entirely at a single uniform revision), made changes to that
        working copy, and then committed all those changes at
        once.</para>
-->
      <para>Comme toutes les autres options de <command>svnmucc</command>,
        l'option <option>--revision (-r)</option> est globale pour la
        commande, c'est-à-dire qu'elle s'applique à toutes les actions
        spécifiées dans la commande. Cela vous permet d'avoir les mêmes
        sortes de garde-fous que si vous aviez extrait une copie de travail
        du dépôt tout entier (et donc comme si vous travailliez sur une
        copie de travail uniformisée à la même révision), vous aviez effectué
        vos modifications sur cette copie de travail, puis vous aviez propagé
        toutes les modifications en même temps.</para>

<!--
      <para>As you can see, <command>svnmucc</command> is a handy
        addition to the Subversion user's tool chest.  For a complete
        reference of this tool's offerings, see
        <xref linkend="svn.ref.svnmucc" />.</para>
-->
      <para>Comme vous pouvez le constater, <command>svnmucc</command> trouve
        bien sa place dans la boite à outils Subversion. Pour une référence
        complète des possibilités de cet outil, reportez-vous à
        <xref linkend="svn.ref.svnmucc" />.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.summary">
<!--
    <title>Summary</title>
-->
    <title>Résumé</title>

<!--
    <para>After reading this chapter, you should have a firm grasp on
      some of Subversion's features that, while perhaps not used
      <emphasis>every</emphasis> time you interact with your version
      control system, are certainly handy to know about.  But don't
      stop here!  Read on to the following chapter, where you'll learn
      about branches, tags, and merging.  Then you'll have nearly full
      mastery of the Subversion client.  Though our lawyers won't
      allow us to promise you anything, this additional knowledge
      could make you measurably more cool.<footnote><para>No purchase
      necessary.  Certains terms and conditions apply.  No guarantee
      of coolness&mdash;implicit or otherwise&mdash;exists.  Mileage
      may vary.</para></footnote></para>
-->
    <para>Après avoir lu ce chapitre, vous devez désormais avoir une
      bonne compréhension de certaines fonctionnalités de Subversion
      qui, bien qu'elles ne servent pas systématiquement à chaque
      utilisation du système de gestion de versions, peuvent rendre de
      grands services. Ne vous arrêtez pas là&nbsp;! Lisez le chapitre
      suivant, où vous découvrirez les branches, les étiquettes et les
      fusions. Vous aurez alors la maîtrise quasi-complète du client
      Subversion. Bien que nos avocats ne nous autorisent pas à vous
      promettre quoi que ce soit, ces connaissances supplémentaires
      feront déjà de vous quelqu'un de bien plus branché.
      <footnote>
        <para>Aucun achat nécessaire. Offre soumise à conditions.
          Aucune garantie de branchitude, ni explicite ni implicite, n'est
          fournie. Les performances passées ne préjugent pas des performances
          futures.</para>
      </footnote>
    </para>
  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
