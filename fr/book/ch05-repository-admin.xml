<!-- -*- sgml -*- -->

<chapter id="svn.reposadmin">
<!--
  <title>Repository Administration</title>
-->
  <title>Administration d'un dépôt</title>

<!--
  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>
-->
  <para>Le dépôt Subversion est le centre de stockage de toutes vos
    données suivies en versions. Ainsi, il est <foreignphrase>de
    facto</foreignphrase> l'objet de toute l'attention et de tous les 
    soins de l'administrateur. Bien que ce soit un élément ne 
    nécessitant pas énormément de maintenance, il est important de 
    comprendre comment le configurer et le surveiller de manière à 
    éviter d'éventuels problèmes et à résoudre proprement ceux qui se 
    présentent.</para>

<!--
  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use various
    related tools provided with Subversion.  We'll address some common
    questions and mistakes and give some suggestions on how to arrange
    the data in the repository.</para>
-->
  <para>Dans ce chapitre, nous expliquons comment créer et configurer un
    dépôt Subversion. Nous abordons également la maintenance du dépôt,
    en donnant des exemples d'utilisation des divers outils fournis avec 
    Subversion. Nous étudions quelques questions et erreurs communes et 
    nous donnons des conseils sur l'organisation des données dans le 
    dépôt.</para>

<!--
  <para>If you plan to access a Subversion repository only in the role
    of a user whose data is under version control (i.e., via a
    Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,<footnote><para>This may sound really prestigious
    and lofty, but we're just talking about anyone who is interested
    in that mysterious realm beyond the working copy where everyone's
    data hangs out.</para></footnote> this chapter is for you.</para>
-->
  <para>Si vous n'envisagez pas d'utiliser un dépôt Subversion autrement
    qu'en simple utilisateur des données (c'est-à-dire en utilisant un
    client Subversion), vous pouvez sauter ce chapitre. Cependant, si
    vous êtes (ou si vous êtes appelé à être) l'administrateur d'un
    dépôt<footnote>
      <para>Cela peut sembler prestigieux et noble, mais nous ne faisons
        référence en fait qu'à une personne intéressée par le monde 
        mystérieux qui se cache derrière la copie de travail que chacun 
        détient.</para>
    </footnote>, ce chapitre est fait pour vous.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
<!--
    <title>The Subversion Repository, Defined</title>
-->
    <title>Définition d'un dépôt Subversion</title>

<!--
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective&mdash;how a repository looks and
      acts with respect to non-Subversion tools&mdash;and from a
      logical perspective&mdash;dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>
-->
    <para>Avant d'aborder le vaste sujet de l'administration d'un dépôt,
      définissons plus précisément ce qu'est un dépôt. À quoi
      ressemble-t-il&nbsp;? Que ressent-il&nbsp;? Est-ce qu'il préfère 
      son thé chaud ou glacé, sucré, avec une tranche de citron&nbsp;? 
      En tant qu'administrateur, vous vous devez de comprendre de quoi 
      est composé un dépôt, à la fois au niveau du système 
      d'exploitation (à quoi ressemble le dépôt et comment il réagit 
      vis-à-vis des outils autres que Subversion) et au niveau logique 
      de l'organisation des données (comment elles sont représentées
      <emphasis>à l'intérieur</emphasis> du dépôt).</para>

<!--
    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>
-->
    <para>Du point de vue d'un explorateur de fichiers classique (comme
      Windows Explorer) ou d'un outil de navigation du système de
      fichiers en ligne de commande, un dépôt Subversion n'est rien
      d'autre qu'un répertoire contenant plein de choses. Il y a des
      sous-dossiers avec des fichiers de configuration lisibles par
      un humain, des sous-dossiers avec des fichiers de données
      binaires déjà bien moins lisibles,&nbsp;etc. À l'instar d'autres
      parties de Subversion, la modularité est une préoccupation majeure
      et l'organisation hiérarchique prévaut sur le bazar. Ainsi, un 
      rapide coup d'œil dans un dépôt ordinaire est suffisant pour 
      obtenir la liste des composants essentiels d'un 
      dépôt&nbsp;:</para>

    <informalexample>
      <screen><!--
$ ls repos-->
$ ls dépot
conf/  db/  format  hooks/  locks/  README.txt
</screen>
    </informalexample>

<!--
    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology&mdash;detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>
-->
    <para>Effectuons un survol rapide de ce que nous voyons dans ce
      répertoire (ne vous inquiétez pas si vous ne comprenez pas tous
      les termes employés, ils sont expliqués dans ce chapitre ou
      ailleurs dans ce livre)&nbsp;:</para>

    <variablelist>
      <varlistentry>
        <term>conf/</term>
        <listitem>
<!--
          <para>This directory is a container for configuration
            files.</para>
-->
          <para>Un dossier destiné à accueillir les fichiers de 
            configuration.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db/</term>
        <listitem>
<!--
          <para>This directory contains the data store for all of your
            versioned data.<footnote><para>Strictly speaking,
            Subversion doesn't dictate that the versioned data live
            here, and there are known (albeit proprietary) alternative
            backend storage implementations which do not, in fact,
            store data in this directory.</para></footnote></para>
-->
          <para>Le magasin de données pour toutes vos données suivies en
            versions<footnote>
			<para>Strictement parlant, Subversion n'oblige pas à ce que
			les données suivies en versions soient stockées ici et il
			existe des variantes (quoique propriétaires) de stockage des 
			données qui ne stockent pas réellement leurs données dans ce 
			dossier.</para></footnote>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
<!--
          <para>This file describes the repository's internal
            organizational scheme.  (As it turns out,
            the <filename>db/</filename> subdirectory sometimes also
            contains a <filename>format</filename> file which
            describes only the contents of that subdirectory and which
            is not to be confused with this file.)</para>
-->
          <para>Ce fichier décrit le schéma d'organisation interne du
            dépôt. Il se trouve que le sous-dossier 
            <filename>db</filename> contient parfois aussi un fichier 
            <filename>format</filename> qui ne décrit que le contenu de
            ce sous-dossier et ne doit pas être confondu avec ce 
            fichier.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks/</term>
        <listitem>
<!--
          <para>This directory contains hook script templates and
            hook scripts, if any have been installed.</para>
-->
          <para>Ce dossier contient les modèles de procédures
            automatiques (et les procédures automatiques elles-mêmes,
            une fois installées).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks/</term>
        <listitem>
<!--
          <para>Subversion uses this directory to house repository
            lock files, used for managing concurrent access to the
            repository.</para>
-->
          <para>Ce répertoire est utilisé pour les fichiers de verrous 
            du dépôt Subversion, de façon à gérer les accès concurrents 
            au dépôt.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
<!--
          <para>This is a brief text file containing merely a notice
            to readers that the directory they are looking in is a
            Subversion repository.</para>
-->
          <para>Un petit fichier qui ne fait qu'informer son lecteur 
            qu'il se trouve dans un dépôt Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
<!--
      <para>

        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activities</secondary>
        </indexterm>Prior to Subversion 1.5, the on-disk repository
        structure also always contained a <filename>dav</filename>
        subdirectory. <filename>mod_dav_svn</filename> used this
        directory to store information about
        WebDAV <firstterm>activities</firstterm>&mdash;mappings of
        high-level WebDAV protocol concepts to Subversion commit
        transactions.  Subversion 1.5 changed that behavior, moving
        ownership of the activities directory, and the ability to
        configure its location, into <filename>mod_dav_svn</filename>
        itself.  Now, new repositories will not necessarily have
        a <filename>dav</filename> subdirectory
        unless <filename>mod_dav_svn</filename> is in use and hasn't
        been configured to store its activities database elsewhere.
        See <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" />
        for more information.</para>

-->
      <para>
        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activités</secondary>
        </indexterm>Avant Subversion 1.5, la structure du dépôt sur le
        disque contenait toujours un sous-dossier 
        <filename>dav</filename>. <filename>mod_dav_svn</filename> 
        utilisait ce dossier pour stocker des informations relatives aux
        <firstterm>activités</firstterm> WEBDAV (l'équivalent 
        haut-niveau du protocole WebDAV au concept de transaction dans
        les propagations Subversion). Subversion 1.5 a modifié cette
        situation en transférant la propriété du dossier activités et
        la possibilité de configurer son emplacement à
        <filename>mod_dav_svn</filename> lui-même. Dorénavant, les 
        dépôts ne possèdent pas nécessairement un sous-dossier 
        <filename>dav</filename>, à moins que vous n'utilisiez
        <filename>mod_dav_svn</filename> et que vous ne l'ayez pas
        configuré afin qu'il place la base de données relative à ses 
        activités ailleurs. Reportez-vous à   
        <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn"/>
        pour plus d'informations.</para>
    </note>

<!--
    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem&mdash;it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>
-->
    <para>Bien sûr, quand on y accède <foreignphrase>via</foreignphrase>
      les bibliothèques Subversion, cet ensemble de fichiers et de 
      dossiers se transforme en un système de fichiers suivis en 
      versions virtuel, complet et comportant une gestion des événements 
      personnalisable. Ce système de fichiers possède ses propres 
      notions de répertoires et de fichiers, très similaires aux notions 
      des systèmes de fichiers réels (tels que NTFS, FAT32, 
      ext3,&nbsp;etc.). Mais c'est un système de fichiers spécial&nbsp;: 
      il base ces répertoires et ces fichiers sur les révisions, 
      conservant l'historique de tous les changements effectués de 
      manière sûre et pérenne. C'est là que la totalité de vos données 
      suivies en versions réside.</para>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
<!--
    <title>Strategies for Repository Deployment</title>
-->
    <title>Stratégies de déploiement d'un dépôt</title>

<!--
    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>
-->
    <para>En grande partie grâce à la conception épurée du dépôt
      Subversion et des technologies sous-jacentes, il est
      particulièrement aisé de créer et configurer un dépôt. Il y a
      quelques choix préliminaires à faire mais l'essentiel du travail
      de création et de configuration d'un dépôt Subversion est simple
      et convivial, facilement reproductible si vous êtes amené à
      effectuer des installations multiples.</para>

<!--
    <para>Some things you'll want to consider beforehand, though, are:</para>
-->
    <para>Voici quelques questions à se poser avant toute chose&nbsp;:</para>

    <itemizedlist>
      <listitem>
<!--
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
-->
        <para>Quelles données vont être hébergées dans le dépôt (ou les
          dépôts) et quelle en sera l'organisation&nbsp;?</para>
      </listitem>
      <listitem>
<!--
        <para>Where will your repository live, and how will it be
          accessed?</para>
-->
        <para>Où sera placé le dépôt et comment les utilisateurs y
          accéderont-ils&nbsp;?</para>
      </listitem>
      <listitem>
<!--
        <para>What types of access control and repository event
          reporting do you need?</para>
-->
        <para>De quels types de contrôle d'accès et de notifications
          d'événements avez-vous besoin&nbsp;?</para>
      </listitem>
      <listitem>
<!--
        <para>Which of the available types of data store do you want
          to use?</para>
-->
        <para>Quel type de magasin de données désirez-vous
          utiliser&nbsp;?</para>
      </listitem>
    </itemizedlist>

<!--
    <para>In this section, we'll try to help you answer those
      questions.</para>
-->
    <para>Dans cette section, nous essayons de vous aider à répondre à 
      ces questions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
<!--
      <title>Planning Your Repository Organization</title>
-->
      <title>Stratégies d'organisation d'un dépôt</title>

<!--
      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>
-->
      <para>Bien que Subversion vous permette de déplacer des fichiers
        et des répertoires suivis en versions sans perte d'information
        et qu'il fournisse même des outils pour déplacer des ensembles
        complets de données suivies en version d'un dépôt à un autre,
        ces opérations peuvent perturber le travail des autres
        collaborateurs qui accèdent souvent au dépôt et qui s'attendent
        à trouver chaque chose à sa place. Ainsi, avant de créer un
        nouveau dépôt, essayez de vous projeter un peu dans le
        futur&nbsp;; préparez à l'avance le passage de vos données sous
        gestion de versions. Cette réflexion sur la manière d'organiser
        vos données dans le dépôt vous évitera de futurs et nombreux
        maux de tête.</para>

<!--
      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>
-->
      <para>Supposons qu'en tant qu'administrateur d'un dépôt, vous
        êtes responsable de l'administration du système de gestion de
        versions pour plusieurs projets. La première décision à prendre
        est de choisir entre un seul dépôt pour tous les projets et un
        dépôt par projet, ou bien un compromis entre ces deux
        solutions.</para>

<!--
      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>
-->
      <para>Un seul dépôt pour tous les projets offre des avantages, ne
        serait-ce que pour la maintenance unifiée. Un seul dépôt
        signifie qu'il n'y a qu'un seul jeu de procédures automatiques,
        une seule sauvegarde à gérer, un seul jeu d'opérations de
        déchargement et de chargement à effectuer si la nouvelle version
        de Subversion est incompatible avec l'ancienne version,&nbsp;etc.
        Vous pouvez également déplacer facilement des données entre les
        projets, sans perdre l'historique de ces informations.</para>

<!--
      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course&mdash;it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.<footnote><para>Whether founded in
        ignorance or in poorly considered concepts about how to derive
        legitimate software development metrics, global revision
        numbers are a silly thing to fear,
        and <emphasis>not</emphasis> the kind of thing you should
        weigh when deciding how to arrange your projects and
        repositories.</para></footnote></para>
-->
      <para>Les inconvénients à utiliser un seul dépôt sont que les
        différents projets auront certainement des besoins différents en
        termes de gestion des événements, comme la notification par
        e-mail des propagations à des listes d'adresses différentes ou
        des définitions différentes de ce qui constitue une propagation
        légitime. Bien sûr, ce ne sont pas des problèmes insurmontables
        &mdash; cela implique juste que vos procédures automatiques
        doivent tenir compte de l'organisation du dépôt dans lequel
        elles sont invoquées plutôt que de considérer que l'ensemble du
        dépôt est associé à un seul groupe d'utilisateurs. Rappelez-vous
        également que Subversion utilise des numéros de révisions
        globaux au dépôt. Bien que ces numéros ne possèdent pas de
        pouvoirs magiques particuliers, certaines personnes n'aiment pas
        voir le numéro de révision augmenter alors qu'elles n'ont pas
        touché à leur propre projet<footnote>
          <para>Que ce soit par ignorance ou par la définition absurde
            de métriques de développement, les numéros globaux de
            révision sont craints alors qu'ils sont bien peu de chose et
            <emphasis>certainement pas</emphasis> à prendre en
            considération quand vous décidez de l'agencement de vos
            projets et de vos dépôts.</para>
        </footnote>.
      </para>

<!--
      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>
-->
      <para>On peut aussi adopter une approche intermédiaire. Par
        exemple, les projets peuvent être regroupés par thème. Vous
        pouvez avoir quelques dépôts, avec une poignée de projets dans
        chaque dépôt. Ainsi, les projets susceptibles de partager des
        données le font aisément et les développeurs sont tenus au
        courant des avancées des projets en relation avec les leurs par
        le biais des nouvelles révisions du dépôt.</para>

<!--
      <para>
        <indexterm>
          <primary>project root</primary>
        </indexterm>

        After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each project
        root&mdash;the <quote>topmost</quote> directory
        that contains data related to that project&mdash;and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.<footnote><para>The <filename>trunk</filename>,
        <filename>tags</filename>, and <filename>branches</filename>
        trio is sometimes referred to as <quote>the TTB
        directories.</quote></para></footnote></para>
-->
      <para>
        <indexterm>
          <primary>racine de projet</primary>
        </indexterm>
        Une fois l'organisation des dépôts définie, il faut se
        préoccuper de la hiérarchie des répertoires à l'intérieur des
        dépôts eux-mêmes. Comme Subversion utilise de simples copies de
        répertoires pour créer les branches et les étiquettes (voir le
        <xref linkend="svn.branchmerge"/>), la communauté Subversion
        recommande de choisir un endroit dans le dépôt pour la
        <firstterm>racine</firstterm> de chaque projet (le répertoire
        dont la sous-arborescence contient toutes les données relatives
        à un projet) et d'y placer trois sous-répertoires&nbsp;:
        <filename>trunk</filename> (<quote>tronc</quote> en français),
        le dossier qui héberge les principaux développements
        du projet&nbsp;; <filename>branches</filename>, le dossier
        dans lequel seront créées les différentes variations de la
        ligne de développement principale&nbsp;; et
        <filename>tags</filename> (<quote>étiquettes</quote> en
        français), qui contient un ensemble d'instantanés de
        l'arborescence (les instantanés sont créés, voire détruits, mais
        jamais modifiés)<footnote>
          <para>Le trio <filename>trunk</filename>,
            <filename>tags</filename> et <filename>branches</filename>
            est quelquefois appelé <quote>les répertoires TTB</quote>
            (<foreignphrase>the TTB directories</foreignphrase>
            en anglais).</para>
        </footnote>.
        </para>

<!--
      <para>For example, your repository might look like this:</para>
-->
      <para>Par exemple, votre dépôt peut ressembler à 
        ceci&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      tags/
      branches/<!--
   calendar/-->
   calendrier/
      trunk/
      tags/
      branches/<!--
   spreadsheet/-->
   tableur
      trunk/
      tags/
      branches/
   &hellip;
</literallayout>
      </informalexample>

<!--
      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>
-->
      <para>Veuillez noter que l'emplacement du projet dans le dépôt
        n'est pas important. Si vous n'avez qu'un seul projet par dépôt,
        il est logique de placer la racine du projet à la racine du
        dépôt correspondant. Si vous avez plusieurs projets, vous
        voulez peut-être les classer par groupes dans des
        sous-répertoires communs du dépôt, en fonction des objectifs ou
        du code à partager par exemple, ou tout simplement en les
        groupant par ordre alphabétique. Voici un exemple&nbsp;:</para>

      <informalexample>
        <literallayout>
/<!--
   utils/-->
   utilitaires
      calc/
         trunk/
         tags/
         branches/<!--
      calendar/-->
      calendrier
         trunk/
         tags/
         branches/
      &hellip;<!--
   office/
      spreadsheet/-->
   bureautique/
      tableur/
         trunk/
         tags/
         branches/
      &hellip;
</literallayout>
      </informalexample>

<!--
      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>
-->
      <para>Organisez votre dépôt comme vous le sentez. Subversion n'a
        aucune exigence en la matière &mdash; pour lui, un répertoire
        est un répertoire. L'objectif est d'avoir une organisation qui
        réponde aux besoins des collaborateurs des différents
        projets.</para>

<!--
      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>
-->
      <para>Cependant, par souci de transparence, nous indiquons une
        autre organisation également très répandue. Dans cette
        organisation, les répertoires <filename>trunk</filename>,
        <filename>tags</filename> et <filename>branches</filename> sont
        situés à la racine du dépôt et les projets sont placés dans des
        sous-répertoires juste en dessous, comme ceci&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   trunk/
      calc/<!--
      calendar/
      spreadsheet/-->
      calendrier/
      tableur/
      &hellip;
   tags/
      calc/<!--
      calendar/
      spreadsheet/-->
      calendrier/
      tableur/
      &hellip;
   branches/
      calc/<!--
      calendar/
      spreadsheet/-->
      calendrier/
      tableur/
      &hellip;
</literallayout>
      </informalexample>

<!--
      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons&mdash;it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history&mdash;past, present, tagged, and branched&mdash;for
        that project and that project alone.</para>
-->
      <para>Il n'y a rien d'incorrect dans une telle organisation, mais
        elle peut ne pas être très intuitive pour vos utilisateurs. En
        particulier dans des situations complexes avec plusieurs projets
        et un grand nombre d'utilisateurs, dont la plupart ne
        connaissent qu'un ou deux projets du dépôt. Mais cette approche
        <quote>plusieurs projets par branche</quote> a tendance à
        favoriser l'ouverture de chaque projet sur les autres et pousse
        à envisager l'ensemble des projets comme une seule entité. Cela
        reste un problème social. Nous aimons l'organisation suggérée au
        début pour des raisons purement pratiques&nbsp;: il est plus
        facile de faire des requêtes (ou des modifications, des
        migrations) sur l'historique complet d'un projet quand une
        sous-arborescence du dépôt contient l'ensemble des données
        (passé, présent, étiquettes et branches) de ce projet et elles
        seules.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
<!--
      <title>Deciding Where and How to Host Your Repository</title>
-->
      <title>Stratégies d'hébergement d'un dépôt</title>

<!--
      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>
-->
      <para>Avant de créer votre dépôt Subversion, vous devez vous
        demander où il va résider. Cette question est fortement liée
        à une myriade d'autres questions telles que &nbsp;:
        qui sont les utilisateurs (sont-ils à l'intérieur de votre
        réseau interne, derrière le pare-feu de votre entreprise,
        ou bien s'agit-il de n'importe qui, n'importe où sur
        Internet&nbsp;?), comment les utilisateurs
        accèdent au dépôt (via un serveur Subversion ou directement),
        quels autres services vous fournissez autour de Subversion (une
        interface pour navigateur Web, des notifications par email des
        propagations,&nbsp;etc.), quelle est votre politique de 
        sauvegarde et ainsi de suite.</para>

<!--
      <para>We cover server choice and configuration in <xref
        linkend="svn.serverconfig" />, but the point we'd like to
        briefly make here is simply that the answers to some of these
        other questions might have implications that force your hand
        when deciding where your repository will live.  For example,
        certain deployment scenarios might require accessing the
        repository via a remote filesystem from multiple computers, in
        which case (as you'll read in the next section) your choice of
        a repository backend data store turns out not to be a choice
        at all because only one of the available backends will work
        in this scenario.</para>
-->
      <para>Le choix et la configuration du serveur sont abordés au
        <xref linkend="svn.serverconfig" />, mais nous voulons signaler
        dès maintenant que certains choix pour l'une ou l'autre de ces
        questions ont des implications sur l'endroit où implémenter
        votre serveur. Par exemple, certains scénarios de déploiement
        nécessitent, pour plusieurs ordinateurs, l'accès au dépôt via
        un système de fichiers distant et, dans ce cas (nous le verrons
        à la prochaine section), le choix du type de magasin de données 
        n'en est plus un, puisqu'un seul type de magasin de données 
        convient dans ce scénario.</para>

<!--
      <para>Addressing each possible way to deploy
        Subversion is both impossible and outside the scope of this
        book.  We simply encourage you to evaluate your options using
        these pages and other sources as your reference material and to
        plan ahead.</para>
-->
      <para>Décrire l'ensemble des possibilités de déploiement de
        Subversion est impossible et n'est pas l'objectif de ce livre.
        Nous vous encourageons simplement à évaluer vos choix avec ces
        quelques pages ainsi qu'avec d'autres ressources en guise de
        référence afin de planifier correctement les opérations.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
<!--
      <title>Choosing a Data Store</title>
-->
      <title>Choix du magasin de données</title>

<!--
      <para>
        <indexterm>
          <primary>FSFS</primary>
        </indexterm>
        <indexterm>
          <primary>Berkeley DB</primary>
        </indexterm>
        <indexterm>
          <primary>BDB</primary>
          <see>Berkeley DB</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem</secondary>
        </indexterm>Subversion provides two options for the
        type of underlying data store&mdash;often referred to as
        <quote>the backend</quote> or, somewhat confusingly,
        <quote>the (versioned) filesystem</quote>&mdash;that each
        repository uses.  One type of data store keeps everything in a
        Berkeley DB (or BDB) database environment; repositories that
        use this type are often referred to as being
        <quote>BDB-backed.</quote> The other type stores data in
        ordinary flat files, using a custom format.  Subversion
        developers have adopted the habit of referring to this latter
        data storage mechanism
        as <firstterm>FSFS</firstterm><footnote><para>Often
        pronounced <quote>fuzz-fuzz,</quote> if Jack Repenning has
        anything to say about it.  (This book, however, assumes that
        the reader is
        thinking <quote>eff-ess-eff-ess.</quote>)</para></footnote>&mdash;a
        versioned filesystem implementation that uses the native OS
        filesystem directly&mdash;rather than via a database library
        or some other abstraction layer&mdash;to store data.</para>
-->
      <para>
        <indexterm>
          <primary>FSFS</primary>
        </indexterm>
        <indexterm>
          <primary>Berkeley DB</primary>
        </indexterm>
        <indexterm>
          <primary>BDB</primary>
          <see>Berkeley DB</see>
        </indexterm>
        <indexterm>
          <primary>dépôts</primary>
          <secondary>système de fichiers</secondary>
        </indexterm>Subversion offre deux types de stockage interne pour 
        le magasin de données<footnote>
          <para>NdT&nbsp;: souvent désigné par
            <foreignphrase>backend</foreignphrase> en
            anglais (sans équivalent en français) ou, ce qui peut être
            source de confusion, <quote>le système de fichiers
            (suivi en versions)</quote></para>
        </footnote>
        utilisé par le dépôt. Un des types de magasin de données
        conserve tout dans une base de données Berkeley DB (ou
        BDB)&nbsp;; les dépôts qui utilisent ce type de magasin sont
        qualifiés de <quote>dépôts gérés par BDB</quote> ou
        <quote>dépôts BDB</quote>. L'autre type de magasin stocke les
        données dans des fichiers ordinaires, en utilisant un format
        particulier. Les développeurs de Subversion ont pris l'habitude
        d'appeler ce type de stockage
        <firstterm>FSFS</firstterm><footnote>
          <para>Souvent prononcé <quote>feuzz-feuzz</quote> si Jack
            Repenning en parle (ce livre, cependant, suppose que le
            lecteur pense <quote>eff-ess-eff-ess</quote>).</para>
        </footnote>
        &mdash; une implémentation d'un système de fichiers suivis
        en versions qui utilise le système de fichiers natif du système
        d'exploitation directement plutôt que par l'intermédiaire d'une
        bibliothèque de gestionnaire de base de données ou toute autre
        couche d'abstraction.</para>

<!--
      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        gives a comparative overview of Berkeley DB and FSFS
        repositories.</para>
-->
      <para>Une comparaison des dépôts utilisant Berkeley DB et FSFS 
        fait l'objet du <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />.
        </para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
<!--
        <title>Repository data store comparison</title>
-->
        <title>Comparaison des magasins de données de dépôts</title>
        <tgroup cols="4">
          <thead>
            <row>
<!--
              <entry>Category</entry>
              <entry>Feature</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
-->
              <entry>Catégorie</entry>
              <entry>Fonctionnalité</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
<!--
              <entry morerows="1">Reliability</entry>
              <entry>Data integrity</entry>
              <entry>When properly deployed, extremely reliable;
                Berkeley DB 4.4 brings auto-recovery</entry>
              <entry>Older versions had some rarely demonstrated, but
                data-destroying bugs</entry>
-->
              <entry morerows="1">Fiabilité</entry>
              <entry>Intégrité des données</entry>
              <entry>Très fiable quand déployé correctement&nbsp;;
                Berkeley DB 4.4 apporte l'auto-restauration</entry>
              <entry>Les vieilles versions avaient quelques bogues
                (rarement démontrés) qui détruisaient des
                données</entry>
            </row>
            <row>
<!--
              <entry>Sensitivity to interruptions</entry>
              <entry>Very; crashes and permission problems can leave the
                database <quote>wedged,</quote> requiring journaled
                recovery procedures</entry>
              <entry>Quite insensitive</entry>
-->
              <entry>Sensibilité aux interruptions</entry>
              <entry>Forte&nbsp;; les <quote>plantages</quote> et les
                problèmes de droits peuvent laisser la base de données
                dans un état instable, nécessitant le recours aux
                procédures de restauration issues de la
                journalisation</entry>
              <entry>Quasiment insensible</entry>
            </row>
            <row>
<!--
              <entry morerows="3">Accessibility</entry>
              <entry>Usable from a read-only mount</entry>
              <entry>No</entry>
              <entry>Yes</entry>
-->
              <entry morerows="3">Accessibilité</entry>
              <entry>Utilisable depuis un montage en lecture seule</entry>
              <entry>Non</entry>
              <entry>Oui</entry>
            </row>
            <row>
<!--
              <entry>Platform-independent storage</entry>
              <entry>No</entry>
              <entry>Yes</entry>
-->
              <entry>Stockage indépendant de la plateforme</entry>
              <entry>Non</entry>
              <entry>Oui</entry>
            </row>
            <row>
<!--
              <entry>Usable over network filesystems</entry>
              <entry>Generally, no</entry>
              <entry>Yes</entry>
-->
              <entry>Utilisable sur des systèmes de fichiers en 
                réseau</entry>
              <entry>Généralement non</entry>
              <entry>Oui</entry>
            </row>
            <row>
<!--
              <entry>Group permissions handling</entry>
              <entry>Sensitive to user umask problems; best if accessed
                by only one user</entry>
              <entry>Works around umask problems</entry>
-->
              <entry>Gestion des droits pour les groupes</entry>
              <entry>Sensible aux problèmes de umask de
                l'utilisateur&nbsp;; c'est mieux si un seul utilisateur
                y accède</entry>
              <entry>Contourne les problèmes de umask</entry>
            </row>
            <row>
<!--
              <entry morerows="2">Scalability</entry>
              <entry>Repository disk usage</entry>
              <entry>Larger (especially if logfiles aren't purged)</entry>
              <entry>Smaller</entry>
-->
              <entry morerows="2">Extensibilité</entry>
              <entry>Utilisation des disques sur le dépôt</entry>
              <entry>Plus grande (surtout si les fichiers de
                journalisation ne sont pas purgés) </entry>
              <entry>Plus faible</entry>
            </row>
            <row>
<!--
              <entry>Number of revision trees</entry>
              <entry>Database; no problems</entry>
              <entry>Some older native filesystems don't scale well with
                thousands of entries in a single directory</entry>
-->
              <entry>Nombre de révisions</entry>
              <entry>Base de données, pas de problème</entry>
              <entry>De vieux systèmes de fichiers fonctionnent moins
                bien lorsqu'il y a plusieurs milliers d'entrées dans un
                seul répertoire</entry>
            </row>
            <row>
<!--
              <entry>Directories with many files</entry>
              <entry>Slower</entry>
              <entry>Faster</entry>
-->
              <entry> Répertoires avec beaucoup de fichiers</entry>
              <entry>Plus lent</entry>
              <entry>Plus rapide</entry>
            </row>
            <row>
<!--
              <entry morerows="1">Performance</entry>
              <entry>Checking out latest revision</entry>
              <entry>No meaningful difference</entry>
              <entry>No meaningful difference</entry>
-->
              <entry morerows="1">Performances</entry>
              <entry>Extraire la dernière révision</entry>
              <entry>Pas de différence significative</entry>
              <entry>Pas de différence significative</entry>
            </row>
            <row>
<!--
              <entry>Large commits</entry>
              <entry>Slower overall, but cost is amortized across the
                lifetime of the commit</entry>
              <entry>Faster overall, but finalization delay may cause 
                client timeouts</entry>
-->
              <entry>Grosses propagations</entry>
              <entry>Globalement plus lent, mais mais cette lenteur est
                répartie sur toute la durée de la propagation</entry>
              <entry>Globalement plus rapide, mais le délai de
                finalisation peut amener le client à considérer que sa
                requête a expiré avant qu'il ne reçoive la
                réponse</entry>
            </row>
          </tbody>
        </tgroup>      
      </table>

<!--
      <para>There are advantages and disadvantages to each of these
        two backend types.  Neither of them is more
        <quote>official</quote> than the other, though the newer FSFS
        is the default data store as of Subversion 1.2.  Both are
        reliable enough to trust with your versioned data.  But as you
        can see in <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />, the FSFS
        backend provides quite a bit more flexibility in terms of its
        supported deployment scenarios.  More flexibility means you
        have to work a little harder to find ways to deploy it
        incorrectly.  Those reasons&mdash;plus the fact that not using
        Berkeley DB means there's one fewer component in the
        system&mdash;largely explain why today almost everyone uses
        the FSFS backend when creating new repositories.</para>
-->
      <para>Chaque type de magasin de données a ses avantages et ses
        inconvénients. Aucun n'est plus <quote>officiel</quote> que
        l'autre, même si le nouveau FSFS est le magasin par défaut
        depuis Subversion 1.2. Les deux sont suffisamment fiables pour
        y stocker vos données suivies en versions en toute confiance.
        Mais comme l'indique le <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />, FSFS est un
        peu plus souple à déployer. Plus de souplesse signifie que vous
        devez y mettre un peu plus du vôtre pour faire des erreurs lors
        du déploiement. C'est pourquoi, en plus du fait que ne pas
        utiliser Berkeley DB permet de compter un composant de moins
        dans le système, aujourd'hui, presque tout le monde utilise FSFS
        lors de la création de nouveaux dépôts.</para>

<!--
      <para>Fortunately, most programs that access Subversion
        repositories are blissfully ignorant of which backend data
        store is in use.  And you aren't even necessarily stuck with
        your first choice of a data store&mdash;in the event that you
        change your mind later, Subversion provides ways of migrating
        your repository's data into another repository that uses a
        different backend data store.  We talk more about that later
        in this chapter.</para>
-->
      <para>Heureusement, la plupart des programmes qui accèdent aux
        dépôts Subversion ignorent royalement quel type de magasin de
        données est utilisé. Et vous n'êtes même pas prisonnier de votre
        premier choix de magasin&nbsp;: si vous changez d'avis
        plus tard, Subversion offre différentes façons de migrer les
        données de votre dépôt dans un autre dépôt utilisant un magasin
        de données différent. Nous en reparlons plus loin dans ce
        chapitre.</para>

<!--
      <para>The following subsections provide a more detailed look at
        the available backend data store types.</para>
-->
      <para>Les paragraphes suivants abordent plus en détail les
        différents types de magasins de données disponibles.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>
        
<!--
        <para>
          <indexterm>
            <primary>Berkeley DB</primary>
          </indexterm>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open source license,
          transaction support, reliability, performance, API
          simplicity, thread safety, support for cursors, and so
          on.</para>
-->
        <para>
          <indexterm>
            <primary>Berkeley DB</primary>
          </indexterm>Lors de la conception initiale de Subversion, les
          développeurs ont décidé d'utiliser le gestionnaire de bases de
          données Berkeley DB pour tout un tas de raisons, entre autres
          sa licence Open Source, son support des transactions, sa
          fiabilité, ses performances, la simplicité de son interface de
          programmation (API), le bon support des processus légers
          (threads), le support des curseurs,&nbsp;etc.</para>

<!--
        <para>Berkeley DB provides real transaction
          support&mdash;perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database&mdash;not a database that
          is constantly changing at the hand of some other
          process&mdash;and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as though
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</para>
-->
        <para>Le gestionnaire de bases de données Berkeley DB apporte un
          support réel des transactions (c'est peut-être sa
          fonctionnalité la plus puissante). Si de nombreux processus
          accèdent en même temps au dépôt, ils n'ont pas à se soucier
          d'éventuelles corruptions de données de la part des autres
          processus. L'isolement créé par le système de transaction est
          tel que, pour une opération donnée, Subversion voit une base de
          données statique &mdash; pas une base de données en perpétuel
          changement en raison des autres processus &mdash; et peut donc
          prendre des décisions à partir de cette perspective. Si la
          décision entraîne un conflit avec ce que fait un autre
          processus, l'opération complète est annulée, tout se passe
          comme si elle n'avait jamais eu lieu et Subversion essaie une
          nouvelle fois son opération sur la base de données mise à jour
          (qui apparaît toujours statique).</para>

<!--
        <para>Another great feature of Berkeley DB is <firstterm>hot
          backups</firstterm>&mdash;the ability to back up the
          database environment without taking it
          <quote>offline.</quote> We'll discuss how to back up your
          repository later in this chapter (in <xref
          linkend="svn.reposadmin.maint.backup"/>), but the benefits
          of being able to make fully functional copies of your
          repositories without any downtime should be obvious.</para>
-->
        <para>Une autre fonctionnalité phare du gestionnaire de bases de
          données Berkeley DB est la <firstterm>sauvegarde à
          chaud</firstterm> &mdash; la capacité de sauvegarder
          l'environnement de la base de données sans la couper du
          réseau. Nous voyons comment réaliser une sauvegarde de votre
          dépôt plus loin dans ce chapitre (dans <xref
          linkend="svn.reposadmin.maint.backup"/>), mais le bénéfice de
          pouvoir faire des copies opérationnelles de vos dépôts sans
          interruption de service doit vous sauter aux yeux.</para>

<!--
        <para>Berkeley DB is also a very reliable database system when
          properly used.  Subversion uses Berkeley DB's logging
          facilities, which means that the database first writes to
          on-disk logfiles a description of any modifications it is
          about to make, and then makes the modification itself.  This
          is to ensure that if anything goes wrong, the database
          system can back up to a previous
          <firstterm>checkpoint</firstterm>&mdash;a location in the
          logfiles known not to be corrupt&mdash;and replay
          transactions until the data is restored to a usable state.
          See <xref linkend="svn.reposadmin.maint.diskspace"/> later
          in this chapter for more about Berkeley DB logfiles.</para>
-->
        <para>Le gestionnaire de bases de données Berkeley DB est aussi
          très fiable quand il est utilisé correctement. Subversion
          utilise les fonctions de journalisation du gestionnaire de
          bases de données Berkeley DB, ce qui veut dire que la base de
          données consigne d'abord dans un fichier de journalisation
          situé sur disque chaque modification qu'elle s'apprête à
          effectuer, puis effectue la modification elle-même. Cela
          garantit que si quelque chose se passe mal, le gestionnaire de
          base de données peut revenir à un <firstterm>point de
          contrôle</firstterm> précédent &mdash; un point précis des
          fichiers de journalisation dont il sait qu'il n'est pas
          corrompu &mdash; et rejouer les transactions jusqu'à ce que
          les données soient dans un état opérationnel. Voir <xref
          linkend="svn.reposadmin.maint.diskspace"/> plus loin dans ce
          chapitre pour plus de détails sur les fichiers de
          journalisation Berkeley DB.</para>

<!--
        <para>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture-independent,
          other aspects of the environment are not.
          Second, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems&mdash;if you need to house
          a BDB-backed repository on a Windows machine, stick with
          Windows 2000 or later.</para>
-->
        <para>Mais chaque médaille à son revers et nous devons vous
          avertir de quelques limitations du gestionnaire de bases de
          données Berkeley DB. Premièrement, les environnements du
          gestionnaire de bases de données Berkeley DB ne sont pas
          portables. Vous ne pouvez pas simplement copier un dépôt
          Subversion qui a été créé sur un système Unix vers un système
          Windows et espérer qu'il fonctionne. Bien que la majeure
          partie de la base de données Berkeley DB soit indépendante de
          l'architecture, d'autres aspects de l'environnement ne le sont
          pas. Deuxièmement, Subversion utilise le gestionnaire de bases
          de données Berkeley DB de telle façon que cela ne fonctionne
          pas sur un système Windows 95/98&nbsp;: si vous avez besoin
          d'héberger un dépôt géré par BDB sur une machine Windows,
          adoptez Windows 2000 ou plus.</para>

<!--
        <para>While Berkeley DB promises to behave correctly on
          network shares that meet a particular set of
          specifications,<footnote><para>Berkeley DB requires that the
          underlying filesystem implement strict POSIX locking
          semantics, and more importantly, the ability to map files
          directly into process memory.</para></footnote> most
          networked filesystem types and appliances do
          <emphasis>not</emphasis> actually meet those requirements.
          And in no case can you allow a BDB-backed repository that
          resides on a network share to be accessed by multiple
          clients of that share at once (which quite often is the
          whole point of having the repository live on a network share
          in the first place).</para>
-->
        <para>Alors que le gestionnaire de bases de données Berkeley DB
          prétend fonctionner correctement sur un système de fichiers en
          réseau, pour peu que celui-ci respecte des caractéristiques
          particulières<footnote>
            <para>Berkeley DB requiert que le système de fichiers
              sous-jacent implémente strictement la sémantique POSIX sur
              les verrous et, plus important encore, la possibilité de
              projeter les fichiers directement en mémoire vive.</para>
          </footnote>,
          la plupart des systèmes de fichiers en réseau et des systèmes
          dédiés <emphasis>n'atteignent pas</emphasis> ces pré-requis.
          Et en aucun cas il ne vous est possible de partager ce dépôt
          sur un système de fichiers en réseau entre plusieurs clients
          (alors que c'est quand même souvent le principal intérêt d'un 
          dépôt accessible sur un partage réseau).</para>

<!--
        <warning>
          <para>If you attempt to use Berkeley DB on a noncompliant
            remote filesystem, the results are unpredictable&mdash;you
            may see mysterious errors right away, or it may be months
            before you discover that your repository database is
            subtly corrupted.  You should strongly consider using the
            FSFS data store for repositories that need to live on a
            network share.</para>
        </warning>

-->
        <warning>
          <para>Si vous tentez d'utiliser le gestionnaire de bases de
            données Berkeley DB sur un système de fichiers en réseau non
            compatible, les résultats sont imprévisibles&nbsp;: vous
            vous apercevrez peut-être immédiatement de mystérieuses
            erreurs, mais il se peut qu'il se passe des mois avant que
            vous ne découvriez que votre base de données de dépôt est
            corrompue. Songez sérieusement à utiliser un magasin FSFS
            pour les dépôts qui doivent être hébergés sur un partage
            réseau.</para>
        </warning>

<!--
          
        <para>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and cleans up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to <quote>wedge</quote>
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.</para>
-->
        <para>Finalement, parce que la bibliothèque du gestionnaire de
          bases de données Berkeley DB est directement incluse dans
          Subversion, elle est plus sensible aux interruptions qu'une
          base de données relationnelle classique. La plupart des
          systèmes SQL, par exemple, disposent d'un processus serveur
          dédié qui coordonne tous les accès aux tables. Si un programme
          qui accède aux tables plante pour une raison ou une autre, le
          processus serveur de la base de données s'en aperçoit et fait
          le ménage. Et comme le processus serveur est le seul processus
          accédant réellement aux tables, les applications n'ont pas à
          se soucier des conflits de droits. Cependant, ce n'est pas le
          cas avec le gestionnaire de bases de données Berkeley DB.
          Subversion (et les programmes utilisant les bibliothèques de
          Subversion) accèdent aux tables directement, ce qui veut dire
          que le plantage d'un programme peut laisser la base de données
          dans un état temporairement incohérent et inaccessible. Quand
          cela arrive, un administrateur doit demander au gestionnaire
          de bases de données Berkeley DB de revenir à un point de
          contrôle, ce qui est assez ennuyeux. D'autres incidents
          peuvent faire planter la base de données, comme
          des conflits entre programmes pour la possession ou les droits
          sur les fichiers de la base de données.</para>

        <note>
<!--
          <para>Berkeley DB 4.4 brings (to Subversion 1.4 and later)
            the ability for Subversion to automatically and
            transparently recover Berkeley DB environments in need of
            such recovery.  When a Subversion process attaches to a
            repository's Berkeley DB environment, it uses some process
            accounting mechanisms to detect any unclean disconnections
            by previous processes, performs any necessary recovery,
            and then continues on as though nothing happened.  This
            doesn't completely eliminate instances of repository
            wedging, but it does drastically reduce the amount of
            human interaction required to recover from them.</para>
        </note>
-->
          <para>La version 4.4 du gestionnaire de bases de données
            Berkeley DB permet à Subversion (version 1.4 ou plus) de
            restaurer un environnement Berkeley DB automatiquement et de
            manière transparente en cas de besoin. Quand un processus
            Subversion se greffe sur l'environnement d'un dépôt
            Berkeley DB, il utilise un mécanisme d'enregistrement pour
            détecter d'éventuels problèmes de déconnexion antérieurs,
            effectue les restaurations nécessaires puis passe à la suite
            comme si de rien n'était. Cela n'élimine pas complètement
            les plantages du dépôt, mais les actions humaines
            nécessaires pour revenir à une situation normale sont
            considérablement réduites.</para>
        </note>

<!--
        <para>So while a Berkeley DB repository is quite fast and
          scalable, it's best used by a single server process running
          as one user&mdash;such as Apache's <command>httpd</command>
          or <command>svnserve</command> (see <xref
          linkend="svn.serverconfig"/>)&mdash;rather than accessing it
          as many different users via <literal>file://</literal> or
          <literal>svn+ssh://</literal> URLs.  If you're accessing a Berkeley
          DB repository directly as multiple users, be sure to read
          <xref linkend="svn.serverconfig.multimethod"/> later in this
          chapter.</para>
-->
        <para>Ainsi, bien qu'un dépôt Berkeley DB soit rapide et capable
          de monter en puissance, il faut privilégier une utilisation
          par un seul processus serveur tournant avec une identité
          unique (comme les serveurs Apache <command>httpd</command>
          ou <command>svnserve</command>&nbsp;: voir le <xref
          linkend="svn.serverconfig"/>) à un accès par de
          nombreux utilisateurs via des URL <literal>file://</literal>
          ou <literal>svn+ssh://</literal>. Si de multiples utilisateurs
          doivent avoir accès à un dépôt Berkeley DB, lisez
          <xref linkend="svn.serverconfig.multimethod"/> plus loin dans
          ce chapitre.</para>

      </sect3>
      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

<!--
        <para>
          <indexterm>
            <primary>FSFS</primary>
          </indexterm>In mid-2004, a second type of repository storage
          system&mdash;one that doesn't use a database at
          all&mdash;came into being.  An FSFS repository stores the
          changes associated with a revision in a single file, and so
          all of a repository's revisions can be found in a single
          subdirectory full of numbered files.  Transactions are
          created in separate subdirectories as individual files.
          When complete, the transaction file is renamed and moved
          into the revisions directory, thus guaranteeing that commits
          are atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          <quote>hot,</quote> just like a BDB-backed
          repository.</para>
-->
        <para>
          <indexterm>
            <primary>FSFS</primary>
          </indexterm>Mi-2004, un deuxième type de stockage pour le 
          dépôt, qui ne fait pas appel à une base de données, a fait son
          apparition. Un dépôt FSFS stocke les changements associés à
          une révision dans un fichier unique, ce qui fait que
          l'ensemble des révisions du dépôt se trouvent dans un seul
          sous-répertoire rempli de fichiers numérotés. Les transactions
          sont créées, en tant que fichiers individuels, dans des
          sous-répertoires séparés. Une fois la transaction terminée, le
          fichier de transaction est renommé et placé dans le répertoire
          des révisions, ce qui garantit l'atomicité des propagations.
          Et puisqu'un fichier de révision est permanent et non
          modifiable, le dépôt peut également être sauvegardé
          <quote>à chaud</quote> à l'instar d'un dépôt BDB.</para>

        <sidebar id="svn.reposadmin.basics.backends.fsfs.revfiles">
<!--
          <title>Revision files and shards</title>
-->
          <title>Revisionsdateien und Scherben</title>

<!--
          <para>FSFS repositories contain files that describe the
            changes made in a single revision, and files that contain
            the revision properties associated with a single revision.
            Repositories created in versions of Subversion prior to
            1.5 keep these files in two directories&mdash;one for each
            type of file.  As new revisions are committed to the
            repository, Subversion drops more files into these two
            directories&mdash;over time, the number of these files in
            each directory can grow to be quite large.  This has been
            observed to cause performance problems on certain
            network-based filesystems.</para>
-->
          <para>Les dépôts FSFS contiennent des fichiers de révision 
            qui décrivent, pour chaque révision, les modifications 
            apportées et les propriétés de la révision concernée. 
            Les dépôts créés avec des versions de Subversion antérieures 
            à 1.5 gardent ces fichiers dans deux dossiers (un dossier 
            pour chaque type de fichier). Au fur et à mesure que les 
            révisions sont propagées dans le dépôt, Subversion dépose 
            autant de fichiers dans ces dossiers. Avec le temps, le 
            nombre de fichiers dans chaque dossier peut se révéler 
            relativement important. Cela peut être la cause de chutes
            de performances sur certains systèmes de fichiers 
            réseaux.</para>

<!--
          <para>
            <indexterm>
              <primary>FSFS</primary>
              <secondary>sharding</secondary>
            </indexterm>Subversion 1.5 creates FSFS-backed
            repositories using a slightly modified layout in which the
            contents of these two directories
            are <firstterm>sharded</firstterm>, or scattered across
            several subdirectories.  This can greatly reduce the time
            it takes the system to locate any one of these files, and
            therefore increases the overall performance of Subversion
            when reading from the repository.</para>
-->
          <para>
            <indexterm>
              <primary>FSFS</primary>
              <secondary>fragmentation</secondary>
            </indexterm>Subversion 1.5 crée des dépôts avec le magasin
            FSFS et pour lequel le contenu des deux répertoires est
            fragmenté ou réparti dans plusieurs 
            sous-répertoires. Cela peut réduire de manière considérable
            le temps nécessaire au système pour trouver n'importe quel
            fichier et ainsi améliore la performance globale de 
            Subversion lors des lectures dans le dépôt.</para>

<!--
          <para>
            <indexterm>
              <primary>FSFS</primary>
              <secondary>packing</secondary>
            </indexterm>Subversion 1.6 and later takes the sharded
            layout one step further, allowing administrators to
            optionally <firstterm>pack</firstterm> each of their
            repository shards up into a single multi-revision file.
            This can have both performance and disk usage benefits.
            See
            <xref linkend="svn.reposadmin.maint.diskspace.fsfspacking"/>
            for more information.</para>
-->
          <para>
            <indexterm>
              <primary>FSFS</primary>
              <secondary>empaquetage</secondary>
            </indexterm>Subversion 1.6 et plus récents poussent le 
            concept d'éparpillement un cran plus loin en autorisant les
            administrateurs à éventuellement 
            <firstterm>empaqueter</firstterm> chacun des dépôts dans
            un unique fichier multi-révisions. Voir 
            <xref linkend="svn.reposadmin.maint.diskspace.fsfspacking"/>
            pour plus d'informations.</para>

        </sidebar>

<!--
        <para>The FSFS revision files describe a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          no journaling or shared-memory files are being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means the overall repository
          size is a bit smaller.</para>
-->
        <para>Les fichiers de révision FSFS décrivent la structure des
          répertoires de révision, le contenu des fichiers et les
          deltas vis-à-vis des autres arborescences à d'autres 
          révisions. Contrairement aux bases de données Berkeley DB, ce
          format de stockage est portable entre différents systèmes 
          d'exploitation et est indifférent à l'architecture du 
          processeur. Comme aucun fichier de journalisation ou de 
          mémoire partagée n'est utilisé, le répertoire peut être 
          accédé sans problème depuis un système de fichiers en réseau 
          et peut être consulté dans un environnement en lecture seule.
          L'absence de zone propre à une base de donnée permet également
          d'obtenir une taille de dépôt légèrement plus petite.</para>

<!--
        <para>FSFS has different performance characteristics, too.
          When committing a directory with a huge number of files,
          FSFS is able to more quickly append directory entries.  On
          the other hand, FSFS has a longer delay when finalizing a
          commit while it performs tasks that the BDB backend
          amortizes across the lifetime of the commit, which could in
          extreme cases cause clients to time out while waiting for a
          response.</para>
-->
        <para>FSF diffère également du point de vue des performances.
          Quand vous propagez un répertoire comptant un nombre de
          fichiers très élevé, FSFS est capable d'ajouter plus
          rapidement les éléments du répertoire. D'un autre côté, FSFS 
          est plus lent à la fin d'une propagation, faisant des tâches 
          que le magasin BDB effectue tout au long de la propagation, ce 
          qui peut conduire dans des cas extrêmes à ce que les clients 
          considèrent que la requête a expiré avant qu'ils ne recoivent
          de réponse.</para>

<!--
        <para>The most important distinction, however, is FSFS's
          imperviousness to wedging when something goes wrong.  If a
          process using a Berkeley DB database runs into a permissions
          problem or suddenly crashes, the database can be left in an
          unusable state until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</para>
-->
        <para>La différence la plus importante reste quand même la
          résistance aux plantages lorsque quelque chose va mal. Si un
          processus qui utilise une base de données Berkeley DB
          rencontre un problème de droits ou plante soudainement, la
          base de données risque de se retrouver dans un état instable
          jusqu'à ce qu'un administrateur la restaure. Si la même chose
          arrive à un processus utilisant un dépôt FSFS, le dépôt n'est
          en rien affecté. Au pire, quelques données de transaction sont
          égarées.</para>

      </sect3>
    </sect2>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
<!--
    <title>Creating and Configuring Your Repository</title>
-->
    <title>Création et configuration d'un dépôt</title>

<!--
    <para>Earlier in this chapter (in
      <xref linkend="svn.reposadmin.planning" />), we looked at some
      of the important decisions that should be made before creating
      and configuring your Subversion repository.  Now, we finally get
      to get our hands dirty!  In this section, we'll see how to
      actually create a Subversion repository and configure it to
      perform custom actions when special repository events
      occur.</para>
-->
    <para>Dans ce chapitre (dans <xref 
      linkend="svn.reposadmin.planning" />), nous avons passé en revue
      quelques décisions importantes à prendre avant de créer et de
      configurer votre dépôt Subversion. Maintenant nous allons enfin
      mettre les mains dans le cambouis&nbsp;! Dans cette section, nous
      voyons comment créer un dépôt Subversion et comment le configurer
      pour qu'il effectue des actions personnalisées lorsque certains
      événements ont lieu.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
<!--
      <title>Creating the Repository</title>
-->
      <title>Création d'un dépôt</title>
 
<!--
      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>
-->
      <para>La création d'un dépôt Subversion est une tâche
        incroyablement simple. L'utilitaire <command>svnadmin</command>,
        fourni avec Subversion, dispose d'une sous-commande qui est
        justement destinée à cela (<command>svnadmin
        create</command>) &nbsp;:</para>

<!--
      <informalexample>
        <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ # Créer un dépôt
$ svnadmin create /var/svn/depot
$
</screen>
      </informalexample>

<!--
      <para>Assuming that the parent directory 
        <filename>/var/svn</filename> exists and that you have
        sufficient permissions to modify that directory, the previous
        command creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store (FSFS).  You can explicitly choose the
        filesystem type using the <option>- -fs-type</option> argument,
        which accepts as a parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>
-->
      <para>Si l'on considère que le répertoire parent 
        <filename>/var/svn</filename> existe déjà et que vous avez les 
        droits suffisants pour modifier ce répertoire, la commande 
        précédente crée un nouveau dépôt dans le répertoire
        <filename>/var/svn/depot</filename> avec le magasin de données
        par défaut (FSFS). Vous pouvez choisir explicitement le type de 
        système de fichiers avec l'option <option>--fs-type</option> qui 
        accepte comme argument soit <literal>fsfs</literal>, 
        soit <literal>bdb</literal>.</para>

<!--
      <informalexample>
        <screen>
$ # Create an FSFS-backed repository
$ svnadmin create - -fs-type fsfs /var/svn/repos
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ # Créer un dépôt FSFS
$ svnadmin create --fs-type fsfs /var/svn/depot
$
</screen>
      </informalexample>

<!--
      <informalexample>
        <screen>
# Create a Berkeley-DB-backed repository
$ svnadmin create - -fs-type bdb /var/svn/repos
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ # Créer un dépôt Berkeley DB
$ svnadmin create --fs-type bdb /var/svn/depot
$
</screen>
      </informalexample>

<!--
      <para>After running this simple command, you have a Subversion
        repository.  Depending on how users will access this new
        repository, you might need to fiddle with its filesystem
        permissions.  But since basic system administration is rather
        outside the scope of this text, we'll leave further
        exploration of that topic as an exercise to the reader.</para>
-->
      <para>Après l'exécution de cette simple commande, vous disposez
        d'un dépôt Subversion. En fonction de la manière dont vos
        utilisateurs accéderont à ce nouveau dépôt, vous aurez peut-être
        besoin de bidouiller les droits du système de fichiers.
        Mais comme l'administration système de base est plutôt hors de
        propos dans ce livre, nous laissons en exercice au lecteur le
        soin d'explorer plus avant ce sujet.</para>

      <tip>
<!--
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities&mdash;they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
-->
        <para>Le chemin en argument de <command>svnadmin</command> est
          juste un chemin classique du système de fichiers, pas une URL
          comme celles que le client <command>svn</command> utilise pour
          spécifier un dépôt. Les commandes <command>svnadmin</command>
          et <command>svnlook</command> sont toutes les deux considérées
          comme des utilitaires coté serveur&nbsp;: elles sont utilisées
          sur la machine qui héberge le dépôt pour examiner ou modifier
          certains aspects du dépôt et ne sont pas capables d'effectuer
          des actions via le réseau. Une erreur classique des nouveaux
          utilisateurs de Subversion est d'essayer de passer une URL
          (même <quote>locale</quote> comme <literal>file://</literal>)
          à ces deux programmes.</para>
      </tip>

<!--
      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem.  Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>
-->
      <para>Dans le sous-répertoire <filename>db/</filename> de votre
        dépôt, vous trouvez l'implémentation du système de fichiers
        suivi en versions. Le nouveau système de fichiers suivi en
        versions de votre dépôt commence sa vie à la révision 0, qui est
        définie comme contenant le répertoire racine
        (<filename>/</filename>) et lui seul. Initialement, la révision 
        0 possède une seule propriété de révision, 
        <literal>svn:date</literal>, dont la valeur est la date de
        création du dépôt.</para>

<!--
      <para>Now that you have a repository, it's time to customize
        it.</para>
-->
      <para>Maintenant que vous disposez d'un dépôt, il est temps de le
        personnaliser.</para>

      <warning>
<!--
        <para>While some parts of a Subversion repository&mdash;such
          as the configuration files and hook scripts&mdash;are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools (such as Berkeley DB's tool suite) for
          tweaking relevant subsections of the repository.  Do
          <emphasis>not</emphasis> attempt manual manipulation of your
          version control history by poking and prodding around in
          your repository's data store files!</para>
-->
        <para>Alors que certaines parties d'un dépôt Subversion sont
          conçues pour être examinées et modifiées <quote>à la
          main</quote> (comme les fichiers de configuration et les
          procédures automatiques), vous ne devez pas (et vous ne
          devriez pas avoir besoin de) modifier les autres parties
          <quote>à la main</quote>. L'outil <command>svnadmin</command>
          est censé être suffisant pour toutes les modifications à
          apporter à votre dépôt, mais vous pouvez également vous servir 
          d'outils tiers (comme la suite d'outils Berkeley DB) pour
          configurer les parties adéquates du dépôt. Ne tentez
          <emphasis>surtout pas</emphasis> de manipuler manuellement
          l'historique du suivi de versions en touchant aux
          fichiers du magasin de données du dépôt&nbsp;!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.hooks">
<!--
      <title>Implementing Repository Hooks</title>
-->
      <title>Mise en place des procédures automatiques</title>

<!--
      <para>
        <indexterm>
          <primary>hook scripts</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>hook scripts</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>hooks</secondary>
          <see>hook scripts</see>
        </indexterm>A <firstterm>hook</firstterm> is a program
        triggered by some repository event, such as the creation of a
        new revision or the modification of an unversioned property.
        Some hooks (the so-called <quote>pre hooks</quote>) run in
        advance of a repository operation and provide a means by which
        to both report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine&mdash;but don't
        modify&mdash;the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
-->
      <para>
        <indexterm>
          <primary>procédures automatiques</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>procédures automatiques</see>
        </indexterm>
        <indexterm>
          <primary>dépôts</primary>
          <secondary>procédures automatiques</secondary>
          <see>procédures automatiques</see>
        </indexterm>Une <firstterm>procédure automatique</firstterm>
        (<foreignphrase>hook</foreignphrase> en anglais)
        est un programme activé par certains événements du
        dépôt, comme la création d'une nouvelle révision ou la
        modification d'une propriété non suivie en versions. Certaines
        procédures automatiques (appelées <quote>pré-hooks</quote>) sont
        déclenchées avant l'opération sur le dépôt et permettent à la
        fois de rendre compte de ce qui va se passer et d'empêcher que
        cela se passe. D'autres procédures automatiques (appelées
        <quote>post-hooks</quote>) sont déclenchées après la fin d'un
        événement et servent à effectuer des tâches de surveillance
        (mais pas de modification) du dépôt. Chaque procédure
        automatique reçoit suffisamment d'informations pour déterminer
        la nature de l'événement, les modifications proposées (ou
        effectuées) du dépôt et le nom d'utilisateur de la personne qui
        a déclenché l'événement.</para>
<!--
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>
-->
      <para>Le sous-répertoire <filename>hooks</filename> contient, par
        défaut, des modèles pour diverses procédures
        automatiques&nbsp;:</para>

      <informalexample>
        <screen><!--
$ ls repos/hooks/-->
$ ls depot/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
      </informalexample>

<!--
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
-->
      <para>Il y a un modèle pour chaque type de procédure automatique
        que le dépôt Subversion sait prendre en charge&nbsp;; en
        examinant le contenu de ces modèles de scripts, vous pouvez
        voir ce qui déclenche le script et quelles données sont passées
        en paramètres. Vous trouvez également dans beaucoup de ces
        scripts des exemples d'utilisation permettant de réaliser des
        tâches récurrentes utiles, en conjonction avec d'autres
        programmes fournis avec Subversion. Concrètement, pour activer
        une procédure automatique, il suffit de placer dans le
        répertoire <filename>depot/hooks</filename> un programme ou un
        script exécutable, qui sera invoqué 
        <foreignphrase>via</foreignphrase> le nom de la procédure
        automatique (comme <command>start-commit</command> pour le début
        d'une propagation ou <command>post-commit</command> pour la fin
        d'une propagation).</para>

<!--
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>
-->
      <para>Sur les plateformes Unix, cela veut dire fournir un
        programme ou un script (pouvant être un script shell, un
        programme Python, l'exécutable binaire d'un programme en C ou
        tout un tas d'autres choses) dont le nom est exactement le nom
        de la procédure automatique. Bien sûr, les modèles qui sont
        fournis ne le sont pas juste à titre d'information. Le moyen le
        plus facile pour mettre en place une procédure automatique sur
        les plateformes Unix consiste tout simplement à copier le
        fichier du modèle adéquat vers un nouveau fichier qui n'aura
        pas l'extension <filename>.tmpl</filename>, d'adapter son
        contenu à votre environnement et de vous assurer qu'il est
        exécutable. Sous Windows, comme l'extension du fichier détermine
        s'il est exécutable ou non, vous devez fournir un programme
        dont la base du nom est le nom de la procédure automatique et
        dont l'extension est l'une de celles reconnue comme exécutable
        par Windows, comme <filename>.exe</filename> pour les programmes
        ou <filename>.bat</filename> pour les fichiers batch.</para>

<!--
      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>
-->
      <para>Les procédures automatiques de Subversion sont lancées par
        l'utilisateur propriétaire du processus ayant accès au dépôt
        Subversion. La plupart du temps, on accède au dépôt via un
        serveur Subversion, donc cet utilisateur est le même que celui
        qui fait tourner le processus serveur sur le système. Les
        procédures automatiques elles-mêmes doivent être configurées
        pour être exécutables, au niveau du système d'exploitation, par
        ledit utilisateur. Cela implique également que tout programme ou
        fichier (y compris le dépôt Subversion) utilisé directement ou
        indirectement par la procédure automatique l'est par ledit
        utilisateur. En d'autres termes, faites bien attention aux
        problèmes de droits d'accès et d'exécution qui peuvent empêcher 
        les procédures automatiques d'effectuer correctement les tâches 
        pour lesquelles elles ont été conçues.</para>

<!--
      <para>There are several hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>
-->
      <para>Il y a plusieurs procédures automatiques implémentées dans
        le dépôt Subversion et vous pouvez obtenir des détails sur
        chacune d'elles dans <xref linkend="svn.ref.reposhooks" />. En
        tant qu'administrateur du dépôt, vous devez décider quelles
        procédures automatiques vous voulez mettre en œuvre
        (c'est-à-dire les nommer correctement et leur donner les droits
        appropriés) et de quelle manière. Lorsque vous prenez cette
        décision, gardez à l'esprit l'architecture de votre dépôt. Par
        exemple, si vous vous servez de la configuration du serveur pour
        déterminer les droits de propagation sur votre dépôt, vous
        n'avez pas besoin de mettre en place un contrôle d'accès de ce
        style <foreignphrase>via</foreignphrase> les procédures 
        automatiques.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.configuration">
<!--
        <title>Hook script environment configuration</title>
-->
        <title></title>

<!--
        <para>By default, Subversion executes hook scripts with an
          empty environment&mdash;that is, no environment variables
          are set at all, not even <literal>$PATH</literal>
          (or <literal>%PATH%</literal>, under Windows).  Because of
          this, many administrators are baffled when their hook
          program runs fine by hand, but doesn't work when invoked by
          Subversion.  Administrators have historically worked around
          this problem by manually setting all the environment
          variables their hook scripts need in the scripts
          themselves.</para>
-->
        <para>Par défaut, le dépôt Subversion exécute les procédures 
          automatiques avec un environnement vide &mdash; c'est-à-dire 
          sans aucune variable d'environnement définie, même pas 
          <literal>$PATH</literal> (ou <literal>%PATH%</literal>
          sous Windows). C'est ainsi que de nombreux administrateurs
          sont perplexes lorsque leurs programmes fonctionnent
          correctement à la main mais pas dans Subversion. Assurez-vous
          de définir explicitement toutes les variables d'environnement
          nécessaires dans votre procédure automatique.</para>

<!--
        <para>Subversion 1.8 introduces a new way to manage the
          environment of Subversion-executed hook scripts&mdash;the
          hook script environment configuration file.  If a Subversion
          server finds a file named <filename>hooks-env</filename> in
          the repository's <filename>conf/</filename> subdirectory, it
          parses that file as an INI-formatted configuration file and
          applies the option names and variables found therein to the
          hook script's execution environment as environment
          variables.</para>
-->
        <para>Subversion 1.8 introduit une nouvelle façon de gérer
          l'environnement dans lequel s'exécutent les procédures
          automatiques, le fichier de configuration de l'environnement
          des procédures automatiques. Si le serveur Subversion trouve
          un fichier nommé <filename>hooks-env</filename> dans le
          sous-répertoire <filename>conf/</filename> du dépôt, il 
          analyse ce fichier à la manière d'un fichier .INI et insère
          les options et variables qu'il a trouvées dans l'environnement
          de la procédure automatique <foreignphrase>via</foreignphrase>
          des variables d'environnement.</para>

<!--
        <para>The syntax of the <filename>hooks-env</filename> file is
          pretty straightforward: each section name is the name of a
          hook script (such as <literal>pre-commit</literal>
          or <literal>post-revprop-change</literal>, and the
          configuration items inside that section are treated as
          mappings of environment variable names to desired values.
          Additionally, there is a
          special <literal>[default]</literal> section, which can be
          used to configure environment variable mappings that should
          be applied to <emphasis>all</emphasis> hook scripts (unless
          explicitly overridden by per-hook-script settings).  See
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          for a sample <filename>hooks-env</filename> configuration
          file.</para>
-->
        <para>La syntaxe du fichier <filename>hooks-env</filename> est
          très simple&nbsp;: chaque nom de section correspond à la
          procédure automatique à laquelle la section s'applique (tels
          que <literal>pre-commit</literal> ou 
          <literal>post-revprop-change</literal>) et les éléments à 
          l'intérieur des sections sont les variables d'environnement 
          dont on souhaite définir les valeurs. En plus, il existe une
          section générale <literal>[default]</literal>, qui permet
          de définir la valeur de variables d'environnement pour
          <emphasis>toutes</emphasis> les procédures automatiques (sauf
          si cette variable est explicitement redéfinie à l'intérieur
          d'une section particulière à une procédure automatique). 
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          fournit un exemple de fichier de configuration 
          <filename>hooks-env</filename>.</para>

<!--
        <example id="svn.reposadmin.hooks.configuration.ex-1">
          <title>hooks-env (custom hook script environment
            configuration)</title>

          <programlisting>
# All scripts should use a UTF-8 locale and have our hook script
# utilities directory on the search path.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# The post-commit and post-revprop-change scripts want to run
# programs from our custom synctools replication software suite, too.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>
-->

        <example id="svn.reposadmin.hooks.configuration.ex-1">
          <title>hooks-env (configuration personnalisée de 
            l'environnement des procédures automatiques)</title>

          <programlisting>
# Toutes les procédures seront configurées en français encodé en UTF-8
# et auront le répertoire contenant nos utilitaires dans leur chemin
# par défaut.

[default]
LANG = fr_FR.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# Les procédures post-commit et post-revprop-change ont aussi besoin
# de nos programmes personnalisés pour la synchronisation

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>

        <note>
<!--
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> also demonstrates the nifty string substitution syntax
            found in Subversion's configuration file parser.  In this
            example, the value of the <literal>PATH</literal>
            option&mdash;pulled from the <literal>[default]</literal>
            section of the file&mdash;is substituted in place of
            the <literal>%(PATH)s</literal> placeholder text in the
            per-hook sections.  For more about this special syntax,
            see the <filename>README.txt</filename> file which lives
            in the Subversion runtime configuration directory.  (And
            for more information about that directory, see
            <xref linkend="svn.advanced.confarea" />.)</para>
-->
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"/> 
            montre aussi la fonctionnalité de substitution des chaînes
            de caractères de l'analyseur du fichier de configuration.
            Dans cet exemple, la valeur de l'option 
            <literal>PATH</literal> (récupérée depuis la section  
            <literal>[default]</literal> du fichier) remplacera à la 
            volée le texte <literal>%(PATH)s</literal> dans les sections
            dédiées à chaque procédure automatique. Pour plus 
            d'informations sur le fonctionnement de cette syntaxe, 
            reportez-vous au fichier <filename>README.txt</filename> qui
            se trouve dans le répertoire de configuration de Subversion
            (et pour plus d'information sur ce répertoire, lisez
            <xref linkend="svn.advanced.confarea" />).</para>
        </note>

<!--
        <para>Of course, having exact duplicates of your custom hook
          script environment configuration files in every single
          repository's <filename>conf/</filename> directory could get
          cumbersome, especially when you need to make changes to them
          all.  So Subversion's servers allow you to specify an
          alternate (possibly shared) location for this configuration
          information.</para>
-->
        <para>Bien sûr, avoir exactement les mêmes informations dans
          chaque fichier de configuration de l'environnement des 
          procédures automatiques, dans chaque répertoire 
          <filename>conf/</filename> de chaque dépôt serait vite très
          lourd, surtout quand vous devez les modifier tous. C'est 
          pourquoi le serveur Subversion vous permet de spécifier un 
          emplacement alternatif (possiblement partagé) pour ces 
          informations de configuration.</para>

        <!-- ### TODO:  Add cross reference for the above! -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.uses">
<!--
        <title>Common uses for hook scripts</title>
-->
        <title>Utilisations classiques des procédures automatiques</title>

<!--
        <para>Repository hook scripts can offer a wide range of
          utility, but most tend to fall into a few basic categories:
          notification, validation, and replication.</para>
-->
        <para>Les procédures automatiques du dépôt permettent de 
          réaliser une large palette de fonctions, mais la plupart sont
          en fait utilisées pour quelques actions simples&nbsp;:
          la notification, la validation et la réplication.</para>

<!--
        <para>Notification scripts are those which tell someone that
          something happened.  The most common of these found in a
          Subversion service offering involve programs which send
          commit and revision property change notification emails to
          project members, driven by the post-commit and
          post-revprop-change hooks, respectively.  There are numerous
          other notification approaches, from issue tracker integration
          scripts to scripts which operate as IRC bots to announce
          that something's changed in the repository.</para>
-->
        <para>Les procédures de notification sont celles qui indiquent
          à quelqu'un que quelque chose est arrivé. Celles que l'on
          retrouve le plus souvent dans l'utilisation de Subversion 
          envoient des courriels de compte-rendu de propagation (resp. 
          de modification de propriété de révision) aux membres du 
          projet, elles sont pilotées par la procédure automatique
          <literal>post-commit</literal> (resp.  
          <literal>post-revprop-change</literal>). Il existe beaucoup
          d'autres types de notification, depuis l'intégration dans
          un outil de suivi de bogues jusqu'au robot IRC qui annonce
          que quelque chose a changé dans le dépôt.</para>

<!--
        <para>On the validation side of things, the start-commit and
          pre-commit hooks are widely used to allow or disallow
          commits based on various criteria: the author of the commit,
          the formatting and/or content of the log message which describes the
          commit, and even the low-level details of the changes made
          to files and directories in the commit.  Likewise, the
          pre-revprop-change hook acts as the gateway to revision
          property changes, which is an especially valuable role
          considering the fact that revision properties are not
          themselves versioned, and can therefore only be modified
          destructively.</para>
-->
        <para>Pour ce qui concerne la validation, les procédures 
          automatiques <literal>start-commit</literal> et 
          <literal>pre-commit</literal> sont largement utilisées pour
          autoriser ou interdire des propagations en fonction de
          divers critères&nbsp;: l'auteur de la propagation, le format 
          ou le contenu du message de propagation voire même des 
          détails de bas-niveau relatifs aux modifications faites aux
          fichiers et dossiers par la propagation. De la même manière,
          la procédure automatique <literal>pre-revprop-change</literal>
          agit comme un point de passage obligé pour les modifications
          des propriétés de révisions, ce qui est particulièrement utile
          compte tenu du fait que les propriétés de révisions ne sont
          pas suivies en versions et ne sont donc modifiées qu'en
          détruisant l'ancienne valeur.</para>

<!--
        <para>One special class of change validation that has seen
          widespread use since Subversion 1.5 was released is
          validation of the committing client software itself.  When
          Subversion's merge tracking feature (described extensively
          in <xref linkend="svn.branchmerge" />) was introduced in
          that release, Subversion administrators needed a way to
          ensure that once users of their repositories started using
          the new feature that <emphasis>all</emphasis> their merges
          were tracked.  To reduce the chance of someone committing an
          untracked merge to the repository, they used start-commit
          hooks to examine the feature capabilities string advertised
          by Subversion clients.  If the committing client didn't
          advertise support for merge tracking, the commit was denied
          with instructions to the user to immediately update their
          Subversion client!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> provides
          an example of a start-commit script which does precisely
          this.</para>
-->
        <para>Une catégorie de validation des modifications se 
          généralise depuis la sortie de Subversion 1.5&nbsp;: la 
          validation du logiciel client lui-même. Quand la 
          fonctionnalité de suivi des fusions (qui est décrite en 
          détails dans <xref linkend="svn.branchmerge" />) est apparue
          dans Subversion 1.5, les administrateurs de Subversion ont eu
          besoin de s'assurer que, une fois que certains commençaient à
          utiliser cette fonctionnalité, alors <emphasis>tous</emphasis>
          leurs fusions devaient être suivies. Afin de réduire la chance
          que quelqu'un propage une fusion non suivie vers le dépôt, ils
          ont utilisé la procédure automatique 
          <literal>start-commit</literal> pour examiner les capacités 
          annoncées par le client Subversion. Si celui-ci n'indiquait 
          pas savoir suivre les fusions, la propagation était interdite
          avec un message pour l'utilisateur lui indiquant de mettre à
          niveau le client Subversion&nbsp;!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> donne un
          exemple de script <literal>start-commit</literal> qui 
          implémente précisément cette fonction.</para>

        <example id="svn.reposadmin.hooks.uses.ex-1">
<!--
          <title>start-commit hook to require merge tracking
            support</title>
-->
          <title>procédure automatique <literal>start-commit</literal>
            qui s'assure que le client sait suivre les fusions.</title>

          <programlisting>
#!/usr/bin/env python
import sys
<!--
# sys.argv[3] is a colon-delimited capabilities list -->
# sys.argv[3] contient la liste, séparée par des ':', des capacités du client
if 'mergeinfo' not in sys.argv[3].split(':'):
  sys.stderr.write("""\<!--
ERROR: Commits to this repository must be made using Subversion
clients which support the merge tracking feature.  Please upgrade
your client to at least Subversion 1.5.0. -->
ERREUR : les propagations (commit) vers ce dépôt ne sont possible
qu'avec des clients qui savent suivre les fusions. Veuillez mettre à
niveau votre client à Subversion 1.5 ou ultérieur.
""")
  sys.exit(1)
</programlisting>
        </example>

<!--
        <para>
          <indexterm>
            <primary>properties</primary>
            <secondary>ephemeral transaction properties</secondary>
          </indexterm>Beginning in Subversion 1.8, clients committing
          against a Subversion 1.8 server will still provide the
          feature capabilities string, but will also provide
          additional information about themselves by way
          of <firstterm>ephemeral transaction properties</firstterm>.
          Ephemeral transaction properties are essentially revision
          properties which are set on the commit transaction by the
          client at the earliest opportunity while committing, but
          which are automatically removed by the server immediately
          prior to the transaction becoming a finalized revision.  You
          can inspect these properties using the same tools with which
          you'd inspect other unversioned properties set on commit
          transactions during the timeframe between which the
          start-commit and pre-commit repository hook scripts would
          operate.</para>
-->
        <para>
          <indexterm>
            <primary>propriétés</primary>
            <secondary>propriétés éphémères de transaction</secondary>
          </indexterm>Depuis Subversion 1.8, les clients qui propagent
          des modifications sur un serveur Subversion 1.8 fournissent
          toujours une chaîne indiquant leurs capacités mais fournissent
          aussi des informations complémentaires les concernant en 
          utilisant des <firstterm>propriétés éphémères de 
          transaction</firstterm>. Ces propriétés éphémères de 
          transaction sont principalement des propriétés de révision qui
          sont définies sur la transaction de propagation par le client
          dès qu'il a l'occasion de le faire au moment de la 
          propagation. Elle sont automatiquement supprimées par le 
          serveur juste avant que la transaction ne devienne une 
          révision. Vous pouvez inspecter ces propriétés, pendant le 
          laps de temps séparant les procédures automatiques 
          <literal>start-commit</literal> et 
          <literal>pre-commit</literal>, à l'aide des 
          mêmes outils que ceux que vous utilisez pour inspecter les
          autres propriétés non suivies en versions.</para>

<!--
        <para>The following are the ephemeral transaction properties
          which Subversion currently provides and implements:</para>
-->
        <para>Vous trouverez ci-après les propriétés éphémères de 
          transactions que Subversion reconnait 
          actuellement&nbsp;:</para>

        <variablelist>

          <varlistentry>
            <term><literal>svn:txn-client-compat-version</literal></term>
            <listitem>
<!--
              <para>Carries the Subversion library version string with
                which the committing client claims compatibility.
                This is useful for deciding whether the client
                supports the minimal feature set required for proper
                handling of the repository data.</para>
-->
              <para>Contient la chaîne de caractères indiquant la 
                version de la bibliothèque Subversion dont le client se
                réclame compatible. C'est utile pour décider si le 
                client implémente le jeu de fonctionnalités suffisant
                pour gérer proprement les données du dépôt.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:txn-user-agent</literal></term>
            <listitem>
<!--
              <para>Carries the <quote>user agent</quote> string which
                describes the committing client program.  Subversion's
                libraries define the initial portion of this string,
                but third-party consumers of the API (GUI clients,
                etc.) can append custom information to it.</para>
-->
              <para>Contient la chaîne de caractères décrivant le
                <quote>programme utilisateur</quote> 
                (<foreignphrase>user agent</foreignphrase> en anglais)
                qui effectue la propagation. La bibliothèque Subversion
                définit la première partie de cette chaîne mais un 
                programme tiers qui utilise l'API (client avec une 
                interface graphique, etc.) peut y ajouter des 
                informations personnalisées.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>

        <!-- ### TODO: Show an example of these being used?  Or ### -->
        <!-- ###       do so in ch07 - Customizing Subversion   ### -->
        <!-- ###       with a cross-reference here.             ### -->

        <note>
<!--
          <para>While most clients will transmit ephemeral transaction
            properties early enough in the commit process that they
            may be inspected by the start-commit hook script, some
            configurations of Subversion will cause those properties
            to not be set on the transaction until later in the commit
            process.  Administrators should consider performing any
            validation based on ephemeral transaction properties in
            both the start-commit and pre-commit hooks&mdash;the
            former to rule out invalid clients before those clients
            transmit the commit payload; the latter <quote>just in
            case</quote> the validation checks couldn't be performed
            by the start-commit hook.</para>
-->
          <para>alors que la plupart des clients vont transmettre les 
            propriétés éphémères de transaction assez tôt dans le 
            processus de transaction et pouvoir ainsi être examinées par 
            la procédure automatique <literal>start-commit</literal>, 
            certaines configurations de Subversion vont entrainer que
            ces propriétés ne seront définies dans la transaction que
            plus tard dans le processus de propagation. Les 
            administrateurs doivent donc prendre le parti d'effectuer
            les validations basées sur les propriétés éphémères à la 
            fois dans les procédures automatiques 
            <literal>start-commit</literal> et 
            <literal>pre-commit</literal> (dans le premier cas pour 
            éviter qu'un client invalide ne transmette le contenu de la
            propagation, dans le deuxième cas <quote>juste au cas 
            où</quote> les vérifications n'auraient pas pu être 
            effectuées par la procédure automatique 
            <literal>start-commit</literal>).</para>
        </note>

<!--
        <para>As noted before, ephemeral transaction properties are
          removed from the transaction just before it is promoted to a
          new revision.  Some administrators may wish to preserve the
          information in those properties indefinitely.  We suggest
          that you do so by using the pre-commit hook script to copy
          the values of those properties to new property names.  In
          fact, the Subversion source code distribution provides a
          <filename>persist-ephemeral-txnprops.py</filename> script
          (in the <filename>tools/hook-scripts/</filename>
          subdirectory) for doing precisely that.</para>
-->
        <para>Comme nous l'avons déjà noté, les propriétés éphémères de
          transaction sont supprimées de la transaction juste avant 
          qu'elle ne soit promue en nouvelle révision. Certains 
          administrateurs peuvent vouloir conserver les informations de
          ces propriétés pour plus tard. Nous vous conseillons alors 
          d'utiliser la procédure automatique 
          <literal>pre-commit</literal> pour copier les valeurs des 
          propriétés vers de nouvelles propriétés avec un nom différent.
          En fait, le code source distribué avec Subversion fournit un
          script <filename>persist-ephemeral-txnprops.py</filename>
          (situé dans le dossier 
          <filename>tools/hook-scripts/</filename>),
          qui fait exactement cela.</para>

<!--
        <para>The third common type of hook script usage is for the
          purpose of replication.  Whether you are driving a simple
          backup process or a more involved remote repository
          mirroring scenario, hook scripts can be critical.  See
          <xref linkend="svn.reposadmin.maint.backup" /> and
          <xref linkend="svn.reposadmin.maint.replication" /> for more
          information about these aspects of repository
          maintenance.</para>
-->
        <para>La troisième catégorie que l'on rencontre souvent dans
          l'utilisation des procédures automatiques concerne la 
          réplication. Que ce soit pour simplement faire une copie de 
          sauvegarde ou pour un scénario impliquant des dépôts mirroirs,
          les procédures automatiques peuvent s'avérer critiques. Lisez
          <xref linkend="svn.reposadmin.maint.backup" /> et
          <xref linkend="svn.reposadmin.maint.replication" /> pour 
          davantage d'informations sur ces aspects de la maintenance du 
          dépôt.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.summary">
        <title>Trouver des procédures automatiques ou écrire les 
          vôtres</title>

<!--
        <para>As you might imagine, there is no shortage of Subversion
          hook programs and scripts that are freely available either
          from the Subversion community itself or elsewhere.  In fact,
          the Subversion distribution provides several commonly used
          hook scripts in its <filename>tools/hook-scripts/</filename>
          subdirectory.  However, if you are unable to find one that
          meets your specific needs, you might consider writing your
          own.  See <xref linkend="svn.developer" /> for information
          about developing software using Subversion's public
          APIs.</para>
-->
        <para>Comme vous pouvez l'imaginer, il n'est pas concevable 
          d'avoir un de procédures automatiques et de scripts divers
          qui ne soient librement accessibles que ce soit au sein de la 
          communauté Subversion ou ailleurs. En fait, la distribution 
          Subversion fournit plusieurs procédures automatiques utilisées
          un peu partout dans son répertoire 
          <filename>tools/hook-scripts/</filename>.
          Cependant, si vous ne trouvez pas votre bonheur dans ce 
          répertoire, vous pouvez écrire la vôtre. Lisez <xref 
          linkend="svn.developer" /> pour obtenir des informations sur
          le développement d'applications utilisant l'API publique de
          Subversion.</para>

<!--
        <warning>
          <para>While hook scripts can do almost anything, there is
            one dimension in which hook script authors should show
            restraint: do <emphasis>not</emphasis> modify a commit
            transaction using hook scripts.  While it might be
            tempting to use hook scripts to automatically correct
            errors, shortcomings, or policy violations present in the
            files being committed, doing so can cause problems.
            Subversion keeps client-side caches of certain bits of
            repository data, and if you change a commit transaction in
            this way, those caches become indetectably stale.  This
            inconsistency can lead to surprising and unexpected
            behavior.  Instead of modifying the transaction, you
            should simply <emphasis>validate</emphasis> the
            transaction in the <filename>pre-commit</filename> hook
            and reject the commit if it does not meet the desired
            requirements.  As a bonus, your users will learn the value
            of careful, compliance-minded work habits.</para>
        </warning>
-->
        <warning>
          <para>Bien que les procédures automatiques soient capables de
          faire tout et n'importe quoi, leurs auteurs devraient faire
          preuve de modération dans un domaine précis&nbsp;:
          <emphasis>ne modifiez pas</emphasis> une transaction de
          propagation en utilisant une procédure automatique. Bien que
          cela soit tentant de corriger automatiquement certaines
          erreurs, raccourcis ou violations de politique constatées dans
          les fichiers propagés, cela peut causer des problèmes.
          Subversion conserve en cache, côté client, certaines parties
          des données du dépôt et si vous modifiez une transaction de
          propagation de cette façon, ces caches seront périmés sans que
          cela ne puisse être détecté. De telles incohérences peuvent
          aboutir à des comportements surprenants et inattendus. Au lieu
          de modifier la transaction, contentez-vous de 
          <emphasis>vérifier</emphasis> la transaction dans la procédure 
          automatique <literal>pre-commit</literal> et rejetez-la si 
          elle ne remplit pas les conditions nécessaires. Entre autre 
          avantages,vos utilisateurs prendront ainsi des habitudes de 
          travail empreintes de respect des procédures et de 
          qualité.</para>
        </warning>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
<!--
      <title>Berkeley DB Configuration</title>
-->
      <title>Configuration de la base de données Berkeley DB</title>

<!--
      <para>A Berkeley DB environment is an encapsulation of one or
        more databases, logfiles, region files, and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things such as the number of database
        locks allowed to be taken out at any given time, the maximum
        size of the journaling logfiles, and so on.  Subversion's
        filesystem logic additionally chooses default values for some
        of the Berkeley DB configuration options.  However, sometimes
        your particular repository, with its unique collection of data
        and access patterns, might require a different set of
        configuration option values.</para>
-->
      <para>Un environnement Berkeley DB peut encapsuler une ou
        plusieurs bases de données, fichiers de journalisation, de
        région et de configuration. L'environnement Berkeley DB a un
        ensemble propre de valeurs configurées par défaut comme par
        exemple le nombre de verrous autorisés à un instant donné, la
        taille maximum des fichiers de journalisation,&nbsp;etc. La 
        logique du système de fichiers Subversion choisit des valeurs 
        par défaut pour différentes options de configuration du 
        gestionnaire Berkeley DB. Cependant, il se peut que votre dépôt 
        nécessite une configuration différente en raison de 
        l'architecture de vos données et des méthodes d'accès.</para>

<!--
      <para>The producers of Berkeley DB understand that different
        applications and database environments have different
        requirements, so they have provided a mechanism for overriding
        at runtime many of the configuration values for the Berkeley
        DB environment.  BDB checks for the presence of a file named
        <filename>DB_CONFIG</filename> in the environment directory
        (namely, the repository's <filename>db</filename>
        subdirectory), and parses the options found in that file.
        Subversion itself creates this file when it creates the rest
        of the repository.  The file initially contains some default
        options, as well as pointers to the Berkeley DB online
        documentation so that you can read about what those options do.  Of
        course, you are free to add any of the supported Berkeley DB
        options to your <filename>DB_CONFIG</filename> file.  Just be
        aware that while Subversion never attempts to read or
        interpret the contents of the file and makes no direct use of
        the option settings in it, you'll want to avoid any
        configuration changes that may cause Berkeley DB to behave in
        a fashion that is at odds with what Subversion might expect.
        Also, changes made to <filename>DB_CONFIG</filename> won't
        take effect until you recover the database environment (using
        <command>svnadmin recover</command>).</para>
-->
      <para>Les concepteurs du gestionnaire de bases de données Berkeley
        DB savent que les besoins varient entre les différentes
        applications et environnements de bases de données, c'est
        pourquoi ils proposent des mécanismes pour modifier, à
        l'exécution, une grande partie des valeurs des options de
        configuration. BDB vérifie la présence d'un fichier nommé
        <filename>DB_CONFIG</filename> dans le répertoire
        d'environnement (à savoir le sous-répertoire 
        <filename>db</filename> du dépôt) et en extrait les valeurs des 
        options. Subversion crée ce fichier lorsqu'il crée le reste du 
        dépôt. Initialement, le fichier contient des options par défaut 
        ainsi que des pointeurs vers la documentation en ligne de 
        Berkeley DB afin de vous renseigner sur l'utilisation de ces 
        options. Bien sûr, vous êtes libre d'ajouter n'importe quelle 
        option prise en compte par Berkeley DB dans votre fichier 
        <filename>DB_CONFIG</filename>. Soyez juste attentif au fait 
        que, bien que Subversion n'essaie jamais de lire ou interpréter 
        le contenu de ce fichier et qu'il n'en utilise pas directement 
        la configuration, les changements induits dans le comportement 
        de Berkeley DB ne doivent pas aller à l'encontre du comportement 
        attendu par Subversion. Par ailleurs, les changements effectués 
        dans <filename>DB_CONFIG</filename> ne sont pris en 
        considération qu'après avoir effectué une restauration de 
        l'environnement de la base de données avec la commande
        <command>svnadmin recover</command>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.fsfs">
<!--
      <title>FSFS Configuration</title>
-->
      <title></title>

<!--
      <para>As of Subversion 1.6, FSFS filesystems have several
        configurable parameters which an administrator can use to
        fine-tune the performance or disk usage of their repositories.
        You can find these options&mdash;and the documentation for
        them&mdash;in the <filename>db/fsfs.conf</filename> file in
        the repository.</para>
-->
      <para>Avec Subversion 1.6, le système de fichiers FSFS possède
        plusieurs paramètres que l'administrateur peut configurer pour
        piloter finement les performances ou l'utilisation du disque
        de leurs dépôts. Vous pouvez trouver ces options (et leur 
        documentation) dans le fichier <filename>db/fsfs.conf</filename> 
        du dépôt.</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
<!--
    <title>Repository Maintenance</title>
-->
    <title>Maintenance d'un dépôt</title>

<!--
    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>
-->
    <para>Assurer la maintenance d'un dépôt Subversion peut être
      intimidant, certainement parce que les systèmes qui comprennent
      une base de données sont complexes. Le faire bien est une question
      de maîtrise des outils &mdash; connaître leur fonction, quand les 
      utiliser et comment. Cette section vous présente les outils 
      fournis par Subversion pour assurer l'administration du dépôt et 
      décrit leur maniement pour réaliser des opérations telles que 
      migrations de données, mises à jour, sauvegardes et 
      nettoyages.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
<!--
      <title>An Administrator's Toolkit</title>
-->
      <title>Boîte à outils de l'administrateur</title>

<!--
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</para>
-->
      <para>Subversion fournit une poignée d'utilitaires pour créer,
        inspecter, modifier et réparer votre dépôt. Étudions de plus
        près chacun de ces outils. Ensuite, nous abordons rapidement
        quelques utilitaires inclus dans le gestionnaire de bases de
        données Berkeley DB qui fournissent des fonctionnalités
        spécifiques au magasin de données de votre dépôt qui ne sont pas
        assurées par les propres outils de Subversion.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

<!--
        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>
-->
        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>Le programme <command>svnadmin</command> est le 
          meilleur ami de l'administrateur de dépôts. En plus de fournir 
          la possibilité de créer des dépôts Subversion, ce programme 
          vous permet d'effectuer de nombreuses opérations de 
          maintenance sur ces dépôts. La syntaxe de 
          <command>svnadmin</command> est similaire à celle des autres 
          programmes en ligne de commande de Subversion&nbsp;:</para>

        <informalexample>
          <screen>
$ svnadmin help<!--
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS & OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin - -version' to see the program version and FS modules.

Available subcommands: -->
usage général : svnadmin SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnadmin help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnadmin --version' pour avoir la version et les modules de stockages.

Sous-commandes disponibles :
   crashtest
   create
   deltify
&hellip;
</screen>
        </informalexample>

<!--
        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>
-->
        <para>Au début de ce chapitre (dans <xref
          linkend="svn.reposadmin.basics.creating"/>), nous vous avons
          présenté la sous-commande <command>svnadmin create</command>.
          La plupart des autres sous-commandes 
          <command>svnadmin</command> sont couvertes plus loin dans ce 
          chapitre. Vous pouvez également consulter <xref 
          linkend="svn.ref.svnadmin" /> pour une liste complète des 
          sous-commandes et des fonctionnalités qu'elles 
          apportent.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

<!--
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>revisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
-->
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>révisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> est un outil de 
          Subversion pour examiner les différentes révisions et
          <firstterm>transactions</firstterm> (qui sont des révisions en
          cours de création) dans un dépôt. Aucune modification n'est
          faite au dépôt par cet outil. <command>svnlook</command>
          est généralement utilisé par les procédures automatiques du
          dépôt pour signaler les changements qui vont être propagés
          (dans le cas de la procédure automatique
          <command>pre-commit</command>) ou qui viennent d'être propagés
          (dans le cas de la procédure automatique
          <command>post-commit</command>). Un administrateur peut être
          amené à utiliser cet outil à des fins de diagnostic.</para>

<!--
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
-->
        <para>La syntaxe de <command>svnlook</command> est
          particulièrement simple&nbsp;:</para>

        <informalexample>
          <screen>
$ svnlook help<!--
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '- -revision' and '- -transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help <subcommand>' for help on a specific subcommand.
Type 'svnlook - -version' to see the program version and FS modules.-->
usage général : svnlook SOUS_COMMANDE CHEMIN_DÉPÔT [ARGS &amp; OPTIONS...]
Note : Quand --revision ou --transaction ne sont pas précisées, les sous-
       commandes qui en ont besoin utilisent la révision la plus récente.
Entrer 'svnlook help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnlook --version' pour avoir la version et les modules de stockage.
&hellip;
</screen>
        </informalexample>

<!--
        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>- -revision</option>
          (<option>-r</option>) and <option>- -transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>- -revision</option> (<option>-r</option>)
          and <option>- -transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>
-->
        <para>La plupart des sous-commandes <command>svnlook</command>
          peuvent être appliquées soit à une révision soit à une
          arborescence de transaction, affichant les informations à
          propos de l'arborescence elle-même ou les différences par
          rapport à la révision précédente du dépôt. Pour spécifier
          quelle révision ou quelle transaction examiner, utilisez
          respectivement les options <option>--revision</option>
          (<option>-r</option>) et <option>--transaction</option>
          (<option>-t</option>). En l'absence des options
          <option>--revision</option> (<option>-r</option>)
          ou <option>--transaction</option> (<option>-t</option>),
          <command>svnlook</command> examine la révision la plus
          récente (la révision <literal>HEAD</literal>) du dépôt.
          Ainsi, les deux commandes suivantes font exactement la même
          chose si la révision la plus récente du dépôt situé à
          l'emplacement <filename>/var/svn/depot</filename> porte le
          numéro 19&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19-->
$ svnlook info /var/svn/depot
$ svnlook info /var/svn/depot -r 19
</screen>
        </informalexample>

<!--
        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>
-->
        <para>Signalons une exception à ces règles concernant les
          sous-commandes&nbsp;: la sous-commande <command>svnlook 
          youngest</command> ne prend aucune option et affiche 
          simplement le numéro de la révision la plus récente du
          dépôt&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook youngest /var/svn/repos-->
$ svnlook youngest /var/svn/depot
19
$
</screen>
        </informalexample>

        <note>
<!--
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>- -revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
-->
          <para>Gardez à l'esprit que les seules transactions que vous
            pouvez examiner sont celles qui n'ont pas été propagées. La
            plupart des dépôts ne comportent pas de transactions de ce
            type parce que les transactions sont habituellement soit
            propagées (auquel cas vous devriez y avoir accès sous la
            forme de révisions via l'option <option>--revision</option>
            (<option>-r</option>)), soit annulées et supprimées.</para>
        </note>

<!--
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>
-->
        <para>La sortie de <command>svnlook</command> est conçue pour
          être à la fois lisible par un humain et analysable par une
          machine. Prenons, par exemple, la sortie de la sous-commande
          <command>svnlook info</command>&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
-->
$ svnlook info /var/svn/depot
sally
2002-11-04 09:29:13 -0600 (lun. 04 nov. 2002)
27
J'ai ajouté le traditionnel
Arbre grec.
$
</screen>
        </informalexample>

<!--
        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>
-->
        <para>La sortie de <command>svnlook info</command> est 
          constituée des éléments suivants, par ordre 
          d'apparition&nbsp;:</para>

        <orderedlist>
          <listitem>
<!--
            <para>The author, followed by a newline</para>
-->
            <para>L'auteur, suivi d'un passage à la ligne.</para>
          </listitem>
          <listitem>
<!--
            <para>The date, followed by a newline</para>
-->
            <para>La date, suivie d'un passage à la ligne.</para>
          </listitem>
          <listitem>
<!--
            <para>The number of characters in the log message,
              followed by a newline</para>
-->
            <para>Le nombre de caractères du message de propagation,
              suivi d'un passage à la ligne.</para>
          </listitem>
          <listitem>
<!--
            <para>The log message itself, followed by a newline</para>
-->
            <para>Le message de propagation lui-même, suivi d'un passage
              à la ligne.</para>
          </listitem>
        </orderedlist>

<!--
        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
-->
        <para>Cette sortie est lisible par un humain, ce qui veut dire
          que les éléments tels que la date sont représentés par du
          texte simple au lieu d'un obscur code (comme le nombre de
          nanosecondes depuis le passage aux nouveaux francs). Mais
          cette sortie est aussi analysable par une machine &mdash;
          parce que le message de propagation peut comporter plusieurs
          lignes et n'est pas limité en taille,
          <command>svnlook</command> affiche la longueur du message
          avant le message lui-même. Cela permet aux scripts et autres
          utilitaires faisant appel à cette commande de
          prendre des décisions opportunes à propos du message de
          propagation, comme savoir combien de mémoire allouer pour le
          message ou au moins savoir combien d'octets sauter dans le cas
          où les données affichées par <command>svnlook</command> ne
          sont pas les dernières données du flux.</para>

<!--
        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>
-->
        <para><command>svnlook</command> peut répondre à un tas d'autres
          requêtes&nbsp;: afficher des sous-ensembles des informations
          précédemment citées, lister récursivement les arborescences
          suivies en versions des répertoires, lister les chemins 
          modifiés lors de telle révision ou transaction, afficher les 
          différences de contenu et de propriétés pour les fichiers et 
          répertoires, &nbsp;etc. Reportez-vous à <xref 
          linkend="svn.ref.svnlook" /> pour la liste complète des 
          fonctionnalités offertes par 
          <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

<!--
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>
-->
        <para>Bien que ce ne soit pas l'outil qu'un administrateur
          utilise le plus, <command>svndumpfilter</command> fournit une 
          fonctionnalité d'un genre très particulier qui est d'une 
          grande utilité&nbsp;: la possibilité de modifier rapidement
          et facilement des flux de l'historique du dépôt Subversion en
          agissant en tant que filtre sur les chemins.</para>

<!--
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
-->
        <para>La syntaxe de <command>svndumpfilter</command> est la
          suivante&nbsp;:</para>

        <informalexample>
          <screen>
$ svndumpfilter help<!--
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type 'svndumpfilter help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svndumpfilter - -version' to see the program version.
  
Available subcommands:-->
usage général : svndumpfilter SOUS_COMMANDE [ARGS &amp; OPTIONS ...]
Entrer 'svndumpfilter help &lt;sous-commande&gt;' pour l'aide spécifique.
Entrer 'svndumpfilter - -version' pour avoir le numéro de version du programme.

Sous-commandes disponibles :
   exclude
   include
   help (?, h)
</screen>
        </informalexample>

<!--
        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>
-->
        <para>Il n'y a que deux sous-commandes intéressantes&nbsp;:
          <command>svndumpfilter exclude</command> et
          <command>svndumpfilter include</command>. Elles vous
          permettent de choisir entre l'inclusion implicite et
          l'inclusion explicite des chemins dans le flux. Vous en saurez 
          plus sur ces sous-commandes et sur l'utilité si particulière 
          de <command>svndumpfilter</command> plus loin dans ce 
          chapitre, dans <xref 
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnrdump">
        <title>svnrdump</title>

<!--
        <para>The <command>svnrdump</command> program is, to put it
          simply, essentially just network-aware flavors of
          the <command>svnadmin dump</command> and <command>svnadmin
          load</command> subcommands, rolled up into a separate
          program.</para>
-->
        <para>Le programme <command>svnrdump</command> est, pour faire 
          simple, essentiellement une variante qui fonctionne avec un
          réseau des sous-commandes <command>svnadmin dump</command> et
          <command>svnadmin load</command>.</para>

        <informalexample>
          <screen>
$ svnrdump help<!--
general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]
Type 'svnrdump help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnrdump - -version' to see the program version and RA modules.

Available subcommands:-->
usage général : svnrdump SOUS_COMMANDE DÉPÔT [-r BAS[:HAUT]]
Entrer 'svnrdump help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnrdump - -version' pour la version et les modules d'accès (RA).

Sous-commandes disponibles :
   dump
   load
   help (?, h)

$
</screen>
        </informalexample>

<!--
        <para>We discuss the use of <command>svnrdump</command> and
          the aforementioned <command>svnadmin</command> commands
          later in this chapter (see
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>
-->
        <para>Nous entrerons dans le détail de l'utilisation des 
          commandes <command>svnrdump</command> et 
          <command>svnadmin</command> plus loin dans ce chapitre (voir
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

<!--
        <para>The <command>svnsync</command> program provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote><footnote><para>Or is that,
          the <quote>sync</quote>?</para></footnote> repositories may
          be on different computers from each other and
          from <command>svnsync</command> itself.</para>
-->
        <para>Le programme <command>svnsync</command> fournit toutes les 
          fonctionnalités requises pour faire fonctionner un miroir en 
          lecture seule d'un dépôt Subversion. Ce programme a une et une 
          seule fonction&nbsp;: transférer l'historique d'un dépôt vers 
          un autre dépôt. Et, bien qu'il y ait différentes manières de
          faire, sa force réside dans sa capacité de travailler à
          distance&nbsp;: les dépôts <quote>source</quote> et
          <quote>destination</quote> peuvent être sur deux ordinateurs
          différents et <command>svnsync</command> sur un
          troisième.</para>

<!--
        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>
-->
        <para>Comme vous vous en doutez, <command>svnsync</command>
          possède une syntaxe très proche des autres programmes déjà
          mentionnés dans ce chapitre&nbsp;:</para>

        <informalexample>
          <screen>
$ svnsync help<!--
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync - -version' to see the program version and RA modules.

Available subcommands:-->
usage général : svnsync SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnsync help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnsync - -version' pour la version et les modules d'accès (RA).

Sous-commandes disponibles :
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)
$
</screen>
        </informalexample>

<!--
        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>
-->
        <para>Nous revenons en détail sur la réplication de dépôts avec
          <command>svnsync</command> plus loin dans ce chapitre (voir
          <xref linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

<!--
        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  As described in the sidebar
          <xref linkend="svn.reposadmin.basics.backends.fsfs.revfiles"/>,
          FSFS repositories use individual files to house information
          about each revision.  Sometimes these files all live in a
          single directory; sometimes they are sharded across many
          directories.  But the neat thing is that the number of
          directories used to house these files is configurable.
          That's where <command>fsfs-reshard.py</command> comes
          in.</para>
-->
        <para>Bien qu'il ne fasse pas officiellement partie des outils
          Subversion, le script <command>fsfs-reshard.py</command>
          (situé dans le répertoire 
          <filename>tools/server-side</filename> du code source de 
          Subversion) est un outil particulièrement utile à 
          l'administrateur pour optimiser les performances de dépôts 
          Subversion utilisant un magasin de données FSFS. Comme indiqué
          dans la note <xref 
          linkend="svn.reposadmin.basics.backends.fsfs.revfiles"/>, les
          dépôts FSFS contiennent des fichiers qui décrivent les
          changements apportés dans chaque révision. Parfois ces 
          fichiers sont conservés dans un même répertoire, parfois ils
          sont répartis (<foreignphrase>sharded</foreignphrase> en 
          anglais, d'où le nom du script) dans plusieurs répertoires. La 
          bonne nouvelle, c'est que le nombre de répertoires utilisés 
          pour conserver ces fichiers est configurable. Et c'est ici que 
          <command>fsfs-reshard.py</command> joue son rôle.</para>

<!--
        <para><command>fsfs-reshard.py</command> reshuffles the
          repository's file structure into a new arrangement that
          reflects the requested number of sharding subdirectories and
          updates the repository configuration to preserve this
          change.  When used in conjunction with the <command>svnadmin
          upgrade</command> command, this is especially useful for
          upgrading a pre-1.5 Subversion (unsharded) repository to the
          latest filesystem format and sharding its data files (which
          Subversion will not automatically do for you).  This script
          can also be used for fine-tuning an already sharded
          repository.</para>
-->
        <para><command>fsfs-reshard.py</command> remanie la structure du 
          dépôt pour se conformer au nombre de sous-répertoires demandés
          et met à jour la configuration du dépôt pour conserver cette
          modification. Utilisé en combinaison avec <command>svnadmin
          upgrade</command> , c'est particulièrement utile pour 
          convertir un dépôt Subversion pre-1.5 vers le dernier schéma
          réparti de Subversion (ce que Subversion ne fait pas
          automatiquement pour vous). Vous pouvez aussi ajuster finement  
          cette valeur dans un dépôt déjà réparti.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
<!--
        <title>Berkeley DB utilities</title>
-->
        <title>Utilitaires Berkeley DB</title>

<!--
        <para>If you're using a Berkeley DB repository, all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db/</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory and can therefore
          be used in conjunction with any of the Berkeley database
          tools, typically provided as part of the Berkeley DB
          distribution.</para>
-->
        <para>Si vous utilisez un dépôt avec une base Berkeley DB,
          à la fois les données et la structure de votre système de
          fichiers suivis en version résident dans un ensemble de
          tables de la base de données qui sont situées dans le 
          sous-répertoire <filename>db/</filename> de votre dépôt.
          Ce sous-répertoire est un répertoire d'environnement classique 
          de base de données Berkeley DB et n'importe quel outil de base 
          de données Berkeley, généralement fourni avec la distribution 
          Berkeley, peut y être utilisé.</para>

<!--
        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> utility, and <command>svnadmin
          recover</command> reflects the common use cases of the
          <command>db_recover</command> utility.</para>
-->
        <para>Pour un usage quotidien, ces outils ne sont pas
          nécessaires. La plupart des fonctionnalités dont les dépôts
          Subversion ont besoin ont été dupliquées dans l'outil
          <command>svnadmin</command>. Par exemple,
          <command>svnadmin list-unused-dblogs</command> et
          <command>svnadmin list-dblogs</command> fournissent un
          sous-ensemble des fonctionnalités offertes par l'utilitaire
          <command>db_archive</command> de Berkeley DB et
          <command>svnadmin recover</command> reproduit les utilisations
          courantes de l'utilitaire 
          <command>db_recover</command>.</para>

<!--
        <para>However, there are still a few Berkeley DB utilities
          that you might find useful.  The <command>db_dump</command>
          and <command>db_load</command> programs write and read,
          respectively, a custom file format that describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  As we describe later in this chapter, you
          can also use <command>svnadmin dump</command> and
          <command>svnadmin load</command> for similar purposes, but
          <command>db_dump</command> and <command>db_load</command>
          can do certain jobs just as well and much faster.  They can
          also be useful if the experienced Berkeley DB hacker needs
          to do in-place tweaking of the data in a BDB-backed
          repository for some reason, which is something Subversion's
          utilities won't allow.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>
-->
        <para>Cependant, il reste quelques utilitaires Berkeley DB que
          vous pourriez trouver utiles. Les programmes
          <command>db_dump</command> et <command>db_load</command>
          fonctionnent avec, pour la lecture et l'écriture 
          respectivement, un format de fichier personnalisé qui décrit 
          les clés et les valeurs d'une base de données Berkeley DB. 
          Puisque les bases de données Berkeley DB ne sont pas portables 
          d'une architecture de machine à une autre, ce format est utile 
          pour transférer les bases de données entre deux machines, 
          indépendamment de l'architecture et du système d'exploitation. 
          Comme nous le décrivons plus loin dans ce chapitre, vous 
          pouvez aussi utiliser <command>svnadmin dump</command> et
          <command>svnadmin load</command> pour faire la même chose,
          mais <command>db_dump</command> et <command>db_load</command>
          peuvent accomplir certaines tâches tout aussi bien et beaucoup
          plus vite. Ils peuvent aussi être utiles si un expert Berkeley
          DB, pour une raison ou pour une autre, doit manipuler les
          données directement dans la base de données d'un dépôt BDB
          (les utilitaires Subversion ne vous le permettent pas). De
          plus, l'utilitaire <command>db_stat</command> peut fournir des
          informations utiles sur l'état de votre environnement Berkeley
          DB, y compris des statistiques détaillées concernant les
          sous-systèmes de verrouillage et de stockage.</para>

<!--
        <para>For more information on the Berkeley DB tool chain,
          visit the documentation section of the Berkeley DB section
          of Oracle's web site, located at <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>
-->
        <para>Pour davantage d'informations sur la suite d'outils
          Berkeley DB, consultez la documentation en ligne sur le site
          Internet d'Oracle, dans la section Berkeley DB&nbsp;: <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          /> (ce site est en anglais).</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Commit Log Message Correction</title>
            
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> hook; see
        <xref linkend="svn.reposadmin.hooks" />) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>

      <informalexample>
        <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      </informalexample>
      
      <para>The <command>svnadmin setlog</command> command, by
        default, is still bound by the same protections against
        modifying unversioned properties as a remote client
        is&mdash;the <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
 
      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Managing Disk Space</title>

      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>How Subversion saves disk space</title>

        <para>
          <indexterm>
            <primary>deltification</primary>
          </indexterm>To keep the repository small, Subversion uses
          <firstterm>deltification</firstterm> (or delta-based storage)
          within the repository itself.  Deltification involves
          encoding the representation of a chunk of data as a
          collection of differences against some other chunk of data.
          If the two pieces of data are very similar, this
          deltification results in storage savings for the deltified
          chunk&mdash;rather than taking up space equal to the size of
          the original data, it takes up only enough space to
          say, <quote>I look just like this other piece of data over
          here, except for the following couple of changes.</quote>
          The result is that most of the repository data that tends to
          be bulky&mdash;namely, the contents of versioned
          files&mdash;is stored at a much smaller size than the
          original full-text representation of that data.</para>

        <para>
          <indexterm>
            <primary>representation sharing</primary>
          </indexterm>While deltified storage has been a part of Subversion's
          design since the very beginning, there have been additional
          improvements made over the years.  Subversion repositories
          created with Subversion 1.4 or later benefit from
          compression of the full-text representations of file
          contents.  Repositories created with Subversion 1.6 or later
          further enjoy the disk space savings afforded by
          <firstterm>representation sharing</firstterm>, a feature
          which allows multiple files or file revisions with identical
          file content to refer to a single shared instance of that data
          rather than each having their own distinct copy thereof.</para>

        <note>
          <para>Because all of the data that is subject to
            deltification in a BDB-backed repository is stored in a
            single Berkeley DB database file, reducing the size of the
            stored values will not immediately reduce the size of the
            database file itself.  Berkeley DB will, however, keep
            internal records of unused areas of the database file and
            consume those areas first before growing the size of the
            database file.  So while deltification doesn't produce
            immediate space savings, it can drastically slow future
            growth of the database.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removing dead transactions</title>

        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>

        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>

        <informalexample>
          <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
        </informalexample>

        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>--transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>

        <informalexample>
          <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
        </informalexample>

        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (reporting outstanding transactions)</title>

          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>

        <informalexample>
          <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
        </informalexample>

        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>

        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Purging unused Berkeley DB logfiles</title>

        <para>Until recently, the largest offender of disk space usage
          with respect to BDB-backed Subversion repositories were the
          logfiles in which Berkeley DB performs its prewrites before
          modifying the actual database files.  These files capture
          all the actions taken along the route of changing the
          database from one state to another&mdash;while the database
          files, at any given time, reflect a particular state, the
          logfiles contain all of the many changes along the way
          <emphasis>between</emphasis> states.  Thus, they can grow
          and accumulate quite rapidly.</para>

        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused logfiles automatically.  Any
          repositories created using <command>svnadmin</command>
          when compiled against Berkeley DB version 4.2 or later
          will be configured for this automatic logfile removal.  If
          you don't want this feature enabled, simply pass the
          <option>--bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this or change your mind at a later time, simply edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line that contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn.reposadmin.create.bdb"/> for more information about
          database configuration.</para>

        <para>Without some sort of automatic logfile removal in
          place, logfiles will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the logfiles, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the logfiles that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          logfiles:</para>

        <informalexample>
          <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## disk space reclaimed!
</screen>
        </informalexample>

        <warning>
          <para>BDB-backed repositories whose logfiles are used as
            part of a backup or disaster recovery plan should
            <emphasis>not</emphasis> make use of the logfile
            autoremoval feature.  Reconstruction of a repository's
            data from logfiles can only be accomplished only when
            <emphasis>all</emphasis> the logfiles are available.  If
            some of the logfiles are removed from disk before the
            backup system has a chance to copy them elsewhere, the
            incomplete set of backed-up logfiles is essentially
            useless.</para> </warning>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.fsfspacking">
        <title>Packing FSFS filesystems</title>

        <para>As described in the sidebar
          <xref linkend="svn.reposadmin.basics.backends.fsfs.revfiles"/>,
          FSFS-backed Subversion repositories create, by default, a
          new on-disk file for each revision added to the repository.
          Having thousands of these files present on your Subversion
          server&mdash;even when housed in separate shard
          directories&mdash;can lead to inefficiencies.</para>

        <para>The first problem is that the operating system has to
          reference many different files over a short period of time.
          This leads to inefficient use of disk caches and, as a
          result, more time spent seeking across large disks.  Because
          of this, Subversion pays a performance penalty when
          accessing your versioned data.</para>

        <para>The second problem is a bit more subtle.  Because of the
          ways that most filesystems allocate disk space, each file
          claims more space on the disk than it actually uses.  The
          amount of extra space required to house a single file can
          average anywhere from 2 to 16 kilobytes <emphasis>per
          file</emphasis>, depending on the underlying
          filesystem in use.  This translates directly
          into a per-revision disk usage penalty for FSFS-backed
          repositories.  The effect is most pronounced in repositories
          which have many small revisions, since the overhead involved
          in storing the revision file quickly outgrows the size of
          the actual data being stored.</para>

        <para>To solve these problems, Subversion 1.6 introduced the
          <command>svnadmin pack</command> command.  By concatenating
          all the files of a completed shard into a single <quote>pack</quote> file
          and then removing the original per-revision
          files, <command>svnadmin pack</command> reduces the file
          count within a given shard down to just a single file.  In
          doing so, it aids filesystem caches and reduces (to one) the
          number of times a file storage overhead penalty is
          paid.</para>

        <para>Subversion can pack existing sharded repositories which
          have been upgraded to the 1.6 filesystem format or later (see
          <xref linkend="svn.ref.svnadmin.c.upgrade"/>) in
          <xref linkend="svn.ref.svnadmin"/>.  To do so, just
          run <command>svnadmin pack</command> on the
          repository:</para>

        <informalexample>
          <screen>
$ svnadmin pack /var/svn/repos
Packing shard 0...done.
Packing shard 1...done.
Packing shard 2...done.
&hellip;
Packing shard 34...done.
Packing shard 35...done.
Packing shard 36...done.
$
</screen>
        </informalexample>

        <para>Because the packing process obtains the required locks
          before doing its work, you can run it on live repositories,
          or even as part of a post-commit hook.  Repacking packed
          shards is legal, but will have no effect on the disk usage
          of the repository.</para>

        <para><command>svnadmin pack</command> has no effect on
          BDB-backed Subversion repositories.</para>

      </sect3>
    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Berkeley DB Recovery</title>

      <para>As mentioned in <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, a Berkeley DB
        repository can sometimes be left in a frozen state if not closed
        properly.  When this happens, an administrator needs to rewind
        the database back into a consistent state.  This is unique to
        BDB-backed repositories, though&mdash;if you are using
        FSFS-backed ones instead, this won't apply to you.  And for
        those of you using Subversion 1.4 with Berkeley DB 4.4 or
        later, you should find that Subversion has become much more
        resilient in these types of situations.  Still, wedged
        Berkeley DB repositories do occur, and an administrator needs
        to know how to safely deal with this circumstance.</para>

      <para>To protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.  (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; we try to clear up the confusion caused by
        this terminology collision in the sidebar <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>In the course of using your Subversion repository, fatal
        errors or interruptions can prevent a process from having the
        chance to remove the locks it has placed in the database.  The
        result is that the backend database system gets
        <quote>wedged.</quote>  When this happens, any attempts to
        access the repository hang indefinitely (since each new
        accessor is waiting for a lock to go away&mdash;which isn't
        going to happen).</para>

      <para>If this happens to your repository, don't panic.  The
        Berkeley DB filesystem takes advantage of database
        transactions, checkpoints, and prewrite journaling to ensure
        that only the most catastrophic of events<footnote><para>For
        example, hard drive + huge electromagnet =
        disaster.</para></footnote> can permanently destroy a database
        environment.  A sufficiently paranoid repository administrator
        will have made off-site backups of the repository data in some
        fashion, but don't head off to the tape backup storage closet
        just yet.</para>

      <para>Instead, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
   
      <orderedlist>
        <listitem>
          <para>Make sure no processes are accessing (or
            attempting to access) the repository.  For networked
            repositories, this also means shutting down the Apache HTTP
            Server or svnserve daemon.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged.</quote></para>
        </listitem>
        <listitem>
          <para>Run the command <userinput>svnadmin recover
            /var/svn/repos</userinput>.  You should see output such as
            this:</para>

          <informalexample>
            <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          </informalexample>
          <para>This command may take many minutes to complete.</para>
        </listitem>
        <listitem>
          <para>Restart the server process.</para>
        </listitem>
      </orderedlist>
            
      <para>This procedure fixes almost every case of repository
        wedging.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve re-creating from scratch various database files (shared
        memory regions, e.g.).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository directory aside
        (perhaps by renaming it to something like
        <filename>repos.BROKEN</filename>) and then restore your
        latest backup of it.  Then, send an email to the Subversion
        users mailing list (at <email>users@subversion.apache.org</email>)
        describing your problem in detail.  Data integrity is an
        extremely high priority to the Subversion developers.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrating Repository Data Elsewhere</title>
    
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>

      <para>
        <indexterm>
          <primary>repository dump streams</primary>
        </indexterm>
        <indexterm>
          <primary>dump files</primary>
          <see>repository dump streams</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands, respectively,
        and the <command>svnrdump</command> program.</para>

      <warning>
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      </warning>

      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>

      <note>
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      </note>

      <para>The Subversion repository dump format also enables
        conversion from a different storage mechanism or version
        control system altogether.  Because the dump file format is,
        for the most part, human-readable, it should be relatively
        easy to describe generic sets of changes&mdash;each of which
        should be treated as a new revision&mdash;using this file
        format.  In fact, the <command>cvs2svn</command> utility (see
        <xref linkend="svn.forcvs.convert" />) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>

      <para>For now, we'll concern ourselves only with migration of
        repository data between Subversion repositories, which we'll
        describe in detail in the sections which follow.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnadmin">
        <title>Repository data migration using svnadmin</title>

        <para>Whatever your reason for migrating repository history,
          using the <command>svnadmin dump</command> and
          <command>svnadmin load</command> subcommands is
          straightforward.  <command>svnadmin dump</command> will output
          a range of repository revisions that are formatted using
          Subversion's custom filesystem dump format.  The dump format
          is printed to the standard output stream, while informative
          messages are printed to the standard error stream.  This
          allows you to redirect the output stream to a file while
          watching the status output in your terminal window.  For
          example:</para>

        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
        </informalexample>

        <para>At the end of the process, you will have a single file
          (<filename>dumpfile</filename> in the previous example) that
          contains all the data stored in your repository in the
          requested range of revisions.  Note that <command>svnadmin
          dump</command> is reading revision trees from the repository
          just like any other <quote>reader</quote> process would
          (e.g., <command>svn checkout</command>), so it's safe
          to run this command at any time.</para>

        <para>The other subcommand in the pair, <command>svnadmin
          load</command>, parses the standard input stream as a
          Subversion repository dump file and effectively replays those
          dumped revisions into the target repository for that
          operation.  It also gives informative feedback, this time
          using the standard output stream:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        </informalexample>

        <para>The result of a load is new revisions added to a
          repository&mdash;the same thing you get by making commits
          against that repository from a regular Subversion client.
          Just as in a commit, you can use hook programs to perform
          actions before and after each of the commits made during a
          load process.  By passing the
          <option>--use-pre-commit-hook</option> and
          <option>--use-post-commit-hook</option> options to
          <command>svnadmin load</command>, you can instruct
          Subversion to execute the pre-commit and post-commit hook
          programs, respectively, for each loaded revision.  You might
          use these, for example, to ensure that loaded revisions pass
          through the same validation steps that regular commits pass
          through.  Of course, you should use these options with
          care&mdash;if your post-commit hook sends emails to a
          mailing list for each new commit, you might not want to spew
          hundreds or thousands of commit emails in rapid succession
          at that list!  You can read more about the use of hook
          scripts in <xref linkend="svn.reposadmin.hooks" />.</para>

        <para>Note that because <command>svnadmin</command> uses
          standard input and output streams for the repository dump and
          load processes, people who are feeling especially saucy can try
          things such as this (perhaps even using different versions of
          <command>svnadmin</command> on each side of the pipe):</para>

        <informalexample>
          <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>
        </informalexample>

        <para>By default, the dump file will be quite large&mdash;much
          larger than the repository itself.  That's because by default
          every version of every file is expressed as a full text in the
          dump file.  This is the fastest and simplest behavior, and
          it's nice if you're piping the dump data directly into some other
          process (such as a compression program, filtering program, or
          loading process).  But if you're creating a dump file
          for longer-term storage, you'll likely want to save disk space
          by using the <option>--deltas</option> option.  With this
          option, successive revisions of files will be output as
          compressed, binary differences&mdash;just as file revisions
          are stored in a repository.  This option is slower, but it
          results in a dump file much closer in size to the original
          repository.</para>

        <para>We mentioned previously that <command>svnadmin
          dump</command> outputs a range of revisions.  Use the
          <option>--revision</option> (<option>-r</option>) option to
          specify a single revision, or a range of revisions, to dump.
          If you omit this option, all the existing repository revisions
          will be dumped.</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>
        </informalexample>

        <para>As Subversion dumps each new revision, it outputs only
          enough information to allow a future loader to re-create that
          revision based on the previous one.  In other words, for any
          given revision in the dump file, only the items that were
          changed in that revision will appear in the dump.  The only
          exception to this rule is the first revision that is dumped
          with the current <command>svnadmin dump</command>
          command.</para>

        <para>By default, Subversion will not express the first dumped
          revision as merely differences to be applied to the previous
          revision.  For one thing, there is no previous revision in the
          dump file!  And second, Subversion cannot know the state of
          the repository into which the dump data will be loaded (if it
          ever is).  To ensure that the output of each
          execution of <command>svnadmin dump</command> is
          self-sufficient, the first dumped revision is, by default, a
          full representation of every directory, file, and property in
          that revision of the repository.</para>

        <para>However, you can change this default behavior.  If you add
          the <option>--incremental</option> option when you dump your
          repository, <command>svnadmin</command> will compare the first
          dumped revision against the previous revision in the
          repository&mdash;the same way it treats every other revision that
          gets dumped.  It will then output the first revision exactly
          as it does the rest of the revisions in the dump
          range&mdash;mentioning only the changes that occurred in that
          revision.  The benefit of this is that you can create several
          small dump files that can be loaded in succession, instead of
          one large one, like so:</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>
        </informalexample>

        <para>These dump files could be loaded into a new repository
          with the following command sequence:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
        </informalexample>

        <para>Another neat trick you can perform with this
          <option>--incremental</option> option involves appending to an
          existing dump file a new range of dumped revisions.  For
          example, you might have a <literal>post-commit</literal> hook
          that simply appends the repository dump of the single revision
          that triggered the hook.  Or you might have a script that runs
          nightly to append dump file data for all the revisions that
          were added to the repository since the last time the script
          ran.  Used like this, <command>svnadmin dump</command> can be
          one way to back up changes to your repository over time in case
          of a system crash or some other catastrophic event.</para>

        <para>The dump format can also be used to merge the contents of
          several different repositories into a single repository.  By
          using the <option>--parent-dir</option> option of
          <command>svnadmin load</command>, you can specify a new
          virtual root directory for the load process.  That means if
          you have dump files for three repositories&mdash;say
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename>, and
          <filename>ss-dumpfile</filename>&mdash;you can first create a new
          repository to hold them all:</para>

        <informalexample>
          <screen>
$ svnadmin create /var/svn/projects
$
</screen>
        </informalexample>

        <para>Then, make new directories in the repository that will
          encapsulate the contents of each of the three previous
          repositories:</para>

        <informalexample>
          <screen>
$ svn mkdir -m "Initial project roots" \
            file:///var/svn/projects/calc \
            file:///var/svn/projects/calendar \
            file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>
        </informalexample>

        <para>Lastly, load the individual dump files into their
          respective locations in the new repository:</para>

        <informalexample>
          <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnrdump">
        <title>Repository data migration using svnrdump</title>

        <para>In Subversion 1.7, <command>svnrdump</command> joined
          the set of stock Subversion tools.  It offers fairly
          specialized functionality, essentially as a network-aware
          version of the <command>svnadmin dump</command>
          and <command>svnadmin load</command> commands which we
          discuss in depth in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> will generate a dump
          stream from a remote repository, spewing it to standard
          output; <command>svnrdump load</command> will read a dump
          stream from standard input and load it into a remote
          repository.  Using <command>svnrdump</command>, you can
          generate incremental dumps just as you might
          with <command>svnadmin dump</command>.  You can even dump a
          subtree of the repository&mdash;something
          that <command>svnadmin dump</command> cannot do.</para>

        <para>The primary difference is that instead of requiring
          direct access to the repository, <command>svnrdump</command>
          operates remotely, using the very same Repository Access
          (RA) protocols that the Subversion client does.  As such,
          you might need to provide authentication credentials.  Also,
          your remote interactions are subject to any authorization
          limitations configured on the Subversion server.</para>

        <note>
          <para><command>svnrdump dump</command> requires that the
            remote server be running Subversion 1.4 or newer.  It
            currently generates dump streams only of the sort which
            are created when you pass the <option>--deltas</option>
            option to <command>svnadmin dump</command>.  This isn't
            interesting in the typical use-cases, but might impact
            specific types of custom transformations you might wish to
            apply to the resulting dump stream.</para>
        </note>

        <note>
          <para>Because it modifies revision properties after
            committing new revisions, <command>svnrdump load</command>
            requires that the target repository have revision property
            changes enabled via the pre-revprop-change hook.  See
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/> for details.</para>
        </note>

        <para>As you might expect, you can use
          <command>svnadmin</command> and <command>svnrdump</command>
          in concert.  You can, for example, use <command>svnrdump
          dump</command> to generate a dump stream from a remote
          repository, and pipe the results thereof through
          <command>svnadmin load</command> to copy all that repository
          history into a local repository.  Or you can do the reverse,
          copying history from a local repository into a remote
          one.</para>

        <tip>
          <para>By using <literal>file://</literal>
            URLs, <command>svnrdump</command> can also access local
            repositories, but it will be doing so via Subversion's
            Repository Access (RA) abstraction layer&mdash;you'll get
            better performance out of <command>svnadmin</command> in
            such situations.</para>
        </tip>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtering Repository History</title>

      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion generally
        doesn't provide an easy way to remove that
        data.<footnote><para>That's rather the reason you use version
        control at all, right?</para></footnote>  But inevitably, there
        will be times when you would like to manipulate the history of
        your repository.  You might need to strip out all instances of
        a file that was accidentally added to the repository (and
        shouldn't be there for whatever
        reason).<footnote><para>Conscious, cautious removal of certain
        bits of versioned data is actually supported by real use
        cases.  That's why an <quote>obliterate</quote> feature has
        been one of the most highly requested Subversion features, and
        one which the Subversion developers hope to soon
        provide.</para></footnote>  Or, perhaps you have multiple
        projects sharing a single repository, and you decide to split
        them up into their own repositories.  To accomplish tasks such
        as these, administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>

      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> or <command>svnrdump
        dump</command> command to generate the dump data,
        and <command>svnadmin load</command> or <command>svnrdump
        load</command> to populate a new repository with it.  The
        great thing about the human-readability aspect of the dump
        format is that, if you aren't careless about it, you can
        manually inspect and modify it.  Of course, the downside is
        that if you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>

      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>

      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>

      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>

      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
      </informalexample>

      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>

      <informalexample>
        <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>
      </informalexample>

      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>

      <informalexample>
        <programlisting>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</programlisting>
      </informalexample>

      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>

      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>

      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
      </informalexample>

      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>If empty revisions are dropped (using the
              <option>--drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>

      <informalexample>
        <programlisting>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</programlisting>
      </informalexample>

      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an
        inconsistent usage of leading slashes for some
        reason,<footnote><para>While <command>svnadmin dump</command>
        has a consistent leading slash policy (to not include them),
        other programs that generate dump data might not be so
        consistent.</para></footnote> you should probably normalize
        those paths so that they all have, or all lack, leading
        slashes.</para> <!-- ### FIXME: Is this still accurate?
                             Surely we've fixed ### this by now! -->

      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>

      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Repository Replication</title>

      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>

      <para>Subversion provides a program for managing scenarios such
        as these.  <command>svnsync</command> works by essentially
        asking the Subversion server to <quote>replay</quote>
        revisions, one at a time.  It then uses that revision
        information to mimic a commit of the same to another
        repository.  Neither repository needs to be locally accessible
        to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>

      <note>
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync">
        <title>Replication with svnsync</title>

        <para>Assuming you already have a source repository that you'd
          like to mirror, the next thing you need is a target repository
          that will actually serve as that mirror.  This target
          repository can use either of the available filesystem
          data-store backends (see
          <xref linkend="svn.reposadmin.basics.backends"
          />)&mdash;Subversion's abstraction layers ensure that such
          details don't matter.  But by default, it must
          not yet have any version history in it.  (We'll discuss an
          exception to this later in this section.)</para>
  
        <para>The protocol that <command>svnsync</command> uses to
          communicate revision information is highly sensitive to
          mismatches between the versioned histories contained in the
          source and target repositories.  For this reason,
          while <command>svnsync</command>
          cannot <emphasis>demand</emphasis> that the target repository
          be read-only,<footnote><para>In fact, it can't truly be
          read-only, or <command>svnsync</command> itself would have a
          tough time copying revision history into it.</para></footnote>
          allowing the revision history in the target repository to
          change by any mechanism other than the mirroring process is a
          recipe for disaster.</para>

        <warning>
          <para>Do <emphasis>not</emphasis> modify a mirror repository
            in such a way as to cause its version history to deviate
            from that of the repository it mirrors.  The only commits
            and revision property modifications that ever occur on that
            mirror repository should be those performed by the
            <command>svnsync</command> tool.</para>
        </warning>

        <para>Another requirement of the target repository is that the
          <command>svnsync</command> process be allowed to modify
          revision properties.  Because <command>svnsync</command> works
          within the framework of that repository's hook system, the
          default state of the repository (which is to disallow revision
          property changes; see <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) is insufficient.
          You'll need to explicitly implement the pre-revprop-change
          hook, and your script must allow <command>svnsync</command>
          to set and change revision properties.  With those
          provisions in place, you are ready to start mirroring
          repository revisions.</para>

        <tip>
          <para>It's a good idea to implement authorization measures
            that allow your repository replication process to perform
            its tasks while preventing other users from modifying the
            contents of your mirror repository at all.</para>
        </tip>

        <para>Let's walk through the use of <command>svnsync</command>
          in a somewhat typical mirroring scenario.  We'll pepper this
          discourse with practical recommendations, which you are free to
          disregard if they aren't required by or suitable for your
          environment.</para>

        <para>We will be mirroring the public Subversion repository
          which houses the source code for this very book and exposing
          that mirror publicly on the Internet, hosted on a different
          machine than the one on which the original Subversion source
          code repository lives.  This remote host has a global
          configuration that permits anonymous users to read the
          contents of repositories on the host, but requires users to
          authenticate to modify those repositories.  (Please forgive
          us for glossing over the details of Subversion server
          configuration for the moment&mdash;those are covered
          thoroughly in <xref linkend="svn.serverconfig" />.)  And for
          no other reason than that it makes for a more interesting
          example, we'll be driving the replication process from a
          third machine&mdash;the one that we currently find ourselves
          using.</para>

        <para>First, we'll create the repository which will be our
          mirror.  This and the next couple of steps do require shell
          access to the machine on which the mirror repository will
          live.  Once the repository is all configured, though, we
          shouldn't need to touch it directly again.</para>

        <informalexample>
          <screen>
$ ssh admin@svn.example.com "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>
        </informalexample>

        <para>At this point, we have our repository, and due to our
          server's configuration, that repository is now
          <quote>live</quote> on the Internet.  Now, because we don't
          want anything modifying the repository except our replication
          process, we need a way to distinguish that process from other
          would-be committers.  To do so, we use a dedicated username
          for our process.  Only commits and revision property
          modifications performed by the special username
          <literal>syncuser</literal> will be allowed.</para>

        <para>We'll use the repository's hook system both to allow the
          replication process to do what it needs to do and to enforce
          that only it is doing those things.  We accomplish this by
          implementing two of the repository event
          hooks&mdash;pre-revprop-change and start-commit.  Our
          <filename>pre-revprop-change</filename> hook script is found
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />, and basically verifies that the user attempting the
          property changes is our <literal>syncuser</literal> user.  If
          so, the change is allowed; otherwise, it is denied.</para>

        <example id="svn.reposadmin.maint.replication.pre-revprop-change">
          <title>Mirror repository's pre-revprop-change hook script</title>
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
        </example>

        <para>That covers revision property changes.  Now we need to
          ensure that only the <literal>syncuser</literal> user is
          permitted to commit new revisions to the repository.  We do
          this using a <filename>start-commit</filename> hook script
          such as the one in <xref
          linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>

        <example id="svn.reposadmin.maint.replication.start-commit">
          <title>Mirror repository's start-commit hook script</title>
  
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
        </example>

        <para>After installing our hook scripts and ensuring that they
          are executable by the Subversion server, we're finished with
          the setup of the mirror repository.  Now, we get to actually
          do the mirroring.</para>

        <para>The first thing we need to do with
          <command>svnsync</command> is to register in our target
          repository the fact that it will be a mirror of the source
          repository.  We do this using the <command>svnsync
          initialize</command> subcommand.  The URLs we provide point
          to the root directories of the target and source
          repositories, respectively.  In Subversion 1.4, this is
          required&mdash;only full mirroring of repositories is
          permitted.  Beginning with Subversion 1.5, though, you can
          use <command>svnsync</command> to mirror only some subtree
          of the repository, too.</para>

        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svnbook.googlecode.com/svn \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0 (svn:sync-* properties skipped).
NOTE: Normalized svn:* properties to LF line endings (1 rev-props, 0 node-props).
$
</screen>
        </informalexample>

        <para>Our target repository will now remember that it is a
          mirror of the public Subversion source code repository.
          Notice that we provided a username and password as arguments
          to <command>svnsync</command>&mdash;that was required by the
          pre-revprop-change hook on our mirror repository.</para>

        <note>
          <para>In Subversion 1.4, the values given to
            <command>svnsync</command>'s <option>--username</option> and
            <option>--password</option> command-line options were used
            for authentication against both the source and destination
            repositories.  This caused problems when a user's
            credentials weren't exactly the same for both repositories,
            especially when running in noninteractive mode (with the
            <option>--non-interactive</option> option).  This was
            fixed in Subversion 1.5 with the introduction of two new
            pairs of options.  Use
            <option>--source-username</option> and
            <option>--source-password</option> to provide authentication
            credentials for the source repository; use
            <option>--sync-username</option> and
            <option>--sync-password</option> to provide credentials for
            the destination repository.  (The old
            <option>--username</option> and <option>--password</option>
            options still exist for compatibility, but we advise against
            using them.)</para>
        </note>

        <para>And now comes the fun part.  With a single subcommand, we
          can tell <command>svnsync</command> to copy all the
          as-yet-unmirrored revisions from the source repository to the
          target.<footnote><para>Be forewarned that while it will take
          only a few seconds for the average reader to parse this
          paragraph and the sample output that follows it, the actual
          time required to complete such a mirroring operation is, shall
          we say, quite a bit longer.</para></footnote> The
          <command>svnsync synchronize</command> subcommand will peek
          into the special revision properties previously stored on the
          target repository and determine how much of the source
          repository has been previously mirrored&mdash;in this case,
          the most recently mirrored revision is r0.  Then it will query
          the source repository and determine what the latest revision
          in that repository is.  Finally, it asks the source
          repository's server to start replaying all the revisions
          between 0 and that latest revision.  As
          <command>svnsync</command> gets the resultant response from
          the source repository's server, it begins forwarding those
          revisions to the target repository's server as new
          commits.</para>

        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL [SOURCE_URL]

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      http://svnbook.googlecode.com/svn
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data .
Committed revision 4063.
Copied properties for revision 4063.
Transmitting file data .
Committed revision 4064.
Copied properties for revision 4064.
Transmitting file data ....
Committed revision 4065.
Copied properties for revision 4065.
$
</screen>
        </informalexample>

        <para>Of particular interest here is that for each mirrored
          revision, there is first a commit of that revision to the
          target repository, and then property changes follow.  This
          two-phase replication is required because the initial commit
          is performed by (and attributed to) the user
          <literal>syncuser</literal> and is datestamped with the time
          as of that revision's creation.  <command>svnsync</command>
          has to follow up with an immediate series of property
          modifications that copy into the target repository all the
          original revision properties found for that revision in the
          source repository, which also has the effect of fixing the
          author and datestamp of the revision to match that of the
          source repository.</para>

        <para>Also noteworthy is that <command>svnsync</command>
          performs careful bookkeeping that allows it to be safely
          interrupted and restarted without ruining the integrity of the
          mirrored data.  If a network glitch occurs while mirroring a
          repository, simply repeat the <command>svnsync
          synchronize</command> command, and it will happily pick up
          right where it left off.  In fact, as new revisions appear in
          the source repository, this is exactly what you do
          to keep your mirror up to date.</para>

        <warning>
          <para>As part of its bookkeeping, <command>svnsync</command>
            records in the mirror repository the URL with which the
            mirror was initialized.  Because of this, invocations of
            <command>svnsync</command> which follow the initialization
            step do not <emphasis>require</emphasis> that you provide
            the source URL on the command line again.  However, for
            security purposes, we recommend that you continue to do so.
            Depending on how it is deployed, it may not be safe for
            <command>svnsync</command> to trust the source URL which it
            retrieves from the mirror repository, and from which it
            pulls versioned data.</para>
        </warning>

        <sidebar>
          <title>svnsync Bookkeeping</title>

          <para><command>svnsync</command> needs to be able to set and
            modify revision properties on the mirror repository because
            those properties are part of the data it is tasked with
            mirroring.  As those properties change in the source
            repository, those changes need to be reflected in the mirror
            repository, too.  But <command>svnsync</command> also uses a
            set of custom revision properties&mdash;stored in revision 0
            of the mirror repository&mdash;for its own internal
            bookkeeping.  These properties contain information such as
            the URL and UUID of the source repository, plus some
            additional state-tracking information.</para>

          <para>One of those pieces of state-tracking information is a
            flag that essentially just means <quote>there's a
            synchronization in progress right now.</quote> This is used
            to prevent multiple <command>svnsync</command> processes
            from colliding with each other while trying to mirror data
            to the same destination repository.  Now, generally you
            won't need to pay any attention whatsoever to
            <emphasis>any</emphasis> of these special properties (all of
            which begin with the prefix <literal>svn:sync-</literal>).
            Occasionally, though, if a synchronization fails
            unexpectedly, Subversion never has a chance to remove this
            particular state flag.  This causes all future
            synchronization attempts to fail because it appears that a
            synchronization is still in progress when, in fact, none is.
            Fortunately, recovering from this situation is easy to do.
            In Subversion 1.7, you can use the newly introduced
            <option>--steal-lock</option> option with
            <command>svnsync</command>'s commands.  In previous
            Subversion versions, you need only to remove the
            <literal>svn:sync-lock</literal> property which serves as
            this flag from revision 0 of the mirror repository:</para>

          <informalexample>
            <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
          </informalexample>

          <para>Also, <command>svnsync</command> stores the source
            repository URL provided at mirror initialization time in a
            bookkeeping property on the mirror repository.  Future
            synchronization operations against that mirror which omit
            the source URL at the command line will consult the
            special <literal>svn:sync-from-url</literal> property
            stored on the mirror itself to know where to synchronize
            from.  This value is used literally by the synchronization
            process, though.  Be wary of using non-fully-qualified
            domain names (such as referring
            to <literal>svnbook.red-bean.com</literal> as
            simply <literal>svnbook</literal> because that happens to
            work when you are connected directly to
            the <literal>red-bean.com</literal> network), domain names
            which don't resolve or resolve differently depending on
            where you happen to be operating from, or IP addresses
            (which can change over time).  But here again, if you need
            an existing mirror to start referring to a different URL
            for the same source repository, you can change the
            bookkeeping property which houses that information.  Users
            of Subversion 1.7 or better can use <command>svnsync init
            --allow-non-empty</command> to reinitialize their mirrors
            with new source URL:</para>

          <informalexample>
            <screen>
$ svnsync initialize --allow-non-empty http://svn.example.com/svn-mirror \
                                       <replaceable>NEW-SOURCE-URL</replaceable>
Copied properties for revision 4065.
$
</screen>
          </informalexample>

          <para>If you are running an older version of Subversion,
            you'll need to manually tweak
            the <literal>svn:sync-from-url</literal> bookkeeping
            property:</para>
          
          <informalexample>
            <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>
          </informalexample>

          <para>Another interesting thing about these special
            bookkeeping properties is that <command>svnsync</command>
            will not attempt to mirror any of those properties when they
            are found in the source repository.  The reason is probably
            obvious, but basically boils down to
            <command>svnsync</command> not being able to distinguish the
            special properties it has merely copied from the source
            repository from those it needs to consult and maintain for
            its own bookkeeping needs.  This situation could occur if,
            for example, you were maintaining a mirror of a mirror of a
            third repository.  When <command>svnsync</command> sees its
            own special properties in revision 0 of the source
            repository, it simply ignores them.</para>

          <para>An <command>svnsync info</command> subcommand was
            added in Subversion 1.6 to easily display the special
            bookkeeping properties in the destination
            repository.</para>

          <informalexample>
            <screen>
$ svnsync help info
info: usage: svnsync info DEST_URL

Print information about the synchronization destination repository
located at DEST_URL.
&hellip;
$ svnsync info http://svn.example.com/svn-mirror
Source URL: http://svnbook.googlecode.com/svn
Source Repository UUID: 931749d0-5854-0410-9456-f14be4d6b398
Last Merged Revision: 4065
$
</screen>
          </informalexample>
        </sidebar>

        <para>There is, however, one bit of inelegance in the process.
          Because Subversion revision properties can be changed at any
          time throughout the lifetime of the repository, and because
          they don't leave an audit trail that indicates when they were
          changed, replication processes have to pay special attention
          to them.  If you've already mirrored the first 15 revisions of
          a repository and someone then changes a revision property on
          revision 12, <command>svnsync</command> won't know to go back
          and patch up its copy of revision 12.  You'll need to tell it
          to do so manually by using (or with some additional tooling
          around) the <command>svnsync copy-revprops</command>
          subcommand, which simply rereplicates all the revision
          properties for a particular revision or range thereof.</para>

        <informalexample>
          <screen>
$ svnsync help copy-revprops
copy-revprops: usage:

    1. svnsync copy-revprops DEST_URL [SOURCE_URL]
    2. svnsync copy-revprops DEST_URL REV[:REV2]

&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>
        </informalexample>

        <para>That's repository replication
          via <command>svnsync</command> in a nutshell.  You'll likely
          want some automation around such a process.  For example,
          while our example was a pull-and-push setup, you might wish to
          have your primary repository push changes to one or more
          blessed mirrors as part of its post-commit and
          post-revprop-change hook implementations.  This would enable
          the mirror to be up to date in as near to real time as is
          likely possible.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-partial">
        <title>Partial replication with svnsync</title>

        <para><command>svnsync</command> isn't limited to full copies
          of everything which lives in a repository.  It can handle
          various shades of partial replication, too.  For example,
          while it isn't very commonplace to do so,
          <command>svnsync</command> does gracefully mirror repositories
          in which the user as whom it authenticates has only partial
          read access.  It simply copies only the bits of the repository
          that it is permitted to see.  Obviously, such a mirror is not
          useful as a backup solution.</para>

        <para>As of Subversion 1.5, <command>svnsync</command> also
          has the ability to mirror a subset of a repository rather than
          the whole thing.  The process of setting up and maintaining
          such a mirror is exactly the same as when mirroring a whole
          repository, except that instead of specifying the source
          repository's root URL when running <command>svnsync
          init</command>, you specify the URL of some subdirectory
          within that repository.  Synchronization to that mirror will
          now copy only the bits that changed under that source
          repository subdirectory.  There are some limitations to this
          support, though.  First, you can't mirror multiple disjoint
          subdirectories of the source repository into a single mirror
          repository&mdash;you'd need to instead mirror some parent
          directory that is common to both.  Second, the filtering
          logic is entirely path-based, so if the subdirectory you are
          mirroring was renamed at some point in the past, your mirror
          would contain only the revisions since the directory appeared
          at the URL you specified.  And likewise, if the source
          subdirectory is renamed in the future, your synchronization
          processes will stop mirroring data at the point that the
          source URL you specified is no longer valid.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-init-nonempty">
        <title>A quick trick for mirror creation</title>

        <para>We mentioned previously the cost of setting up an
          initial mirror of an existing repository.  For many folks,
          the sheer cost of transmitting thousands&mdash;or
          millions&mdash;of revisions of history to a new mirror
          repository via <command>svnsync</command> is a show-stopper.
          Fortunately, Subversion 1.7 provides a workaround by way of
          a new <option>--allow-non-empty</option> option to
          <command>svnsync initialize</command>.  This option allows
          you to initialize one repository as a mirror of another
          while bypassing the verification that the to-be-initialized
          mirror has no version history present in it.  Per our
          previous warnings about the sensitivity of this whole
          replication process, you should rightly discern that this is
          an option to be used only with great caution.  But it's
          wonderfully handy when you have administrative access to the
          source repository, where you can simply make a physical copy
          of the repository and then initialize that copy as a new
          mirror:</para>

        <informalexample>
          <screen>
$ svnadmin hotcopy /path/to/repos /path/to/mirror-repos
$ ### create /path/to/mirror-repos/hooks/pre-revprop-change
$ svnsync initialize file:///path/to/mirror-repos \
                     file:///path/to/repos
svnsync: E000022: Destination repository already contains revision history; co
nsider using --allow-non-empty if the repository's revisions are known to mirr
or their respective revisions in the source repository
$ svnsync initialize --allow-non-empty file:///path/to/mirror-repos \
                                       file:///path/to/repos
Copied properties for revision 32042.
$
</screen>
        </informalexample>

        <para>Admins who are running a version of Subversion prior to
          1.7 (and thus do not have access to <command>svnsync
          initialize</command>'s <option>--allow-non-empty</option>
          feature) can accomplish effectively the same thing that that
          feature does through <emphasis>careful</emphasis>
          manipulation of the r0 revision properties on the copy of
          the repository which is slated to become a mirror of the
          original.  Use <command>svnadmin setrevprop</command> to
          create the same bookkeeping properties
          that <command>svnsync</command> would have created
          there.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.wrapup">
        <title>Replication wrap-up</title>

        <para>We've discussed a couple of ways to replicate revision
          history from one repository to another.  So let's look now
          at the user end of these operations.  How does replication
          and the various situations which call for it affect
          Subversion clients?</para>

        <para>As far as user interaction with repositories and mirrors
          goes, it <emphasis>is</emphasis> possible to have a single
          working copy that interacts with both, but you'll have to
          jump through some hoops to make it happen.  First, you need
          to ensure that both the primary and mirror repositories have
          the same repository UUID (which is not the case by default).
          See <xref linkend="svn.reposadmin.maint.uuids" /> later in
          this chapter for more about this.</para>
        
        <para>Once the two repositories have the same UUID, you can use
          <command>svn relocate</command> to point your working
          copy to whichever of the repositories you wish to operate
          against, a process that is described in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref.svn"/>.  There is a possible danger here,
          though, in that if the primary and mirror repositories
          aren't in close synchronization, a working copy up to date
          with, and pointing to, the primary repository will, if
          relocated to point to an out-of-date mirror, become confused
          about the apparent sudden loss of revisions it fully expects
          to be present, and it will throw errors to that effect.  If
          this occurs, you can relocate your working copy back to the
          primary repository and then either wait until the mirror
          repository is up to date, or backdate your working copy to a
          revision you know is present in the sync repository, and
          then retry the relocation.</para>

        <para>Finally, be aware that the revision-based replication
          provided by <command>svnsync</command> is only
          that&mdash;replication of revisions.  Only the kinds of
          information carried by the Subversion repository dump file
          format are available for replication.  As such, tools such
          as <command>svnsync</command>
          (and <command>svnrdump</command>, which we discuss in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />)
          are limited in ways similar to that of the repository dump
          stream.  They do not include in their replicated information
          such things as the hook implementations, repository or
          server configuration data, uncommitted transactions, or
          information about user locks on repository paths.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>

      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutiae involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>

      <informalexample>
        <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>
      </informalexample>

      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>When making copies of a Berkeley DB repository, you can
        even instruct <command>svnadmin hotcopy</command> to purge any
        unused Berkeley DB logfiles (see <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) from the
        original repository upon completion of the copy.  Simply
        provide the <option>--clean-logs</option> option on the
        command line.</para>

      <informalexample>
        <screen>
$ svnadmin hotcopy --clean-logs /var/svn/bdb-repos /var/svn/bdb-repos-backup
</screen>
      </informalexample>

      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>

      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with
        the <option>--incremental</option> option to perform an
        incremental backup of a given revision or range of revisions.
        And of course, you can achieve a full backup variation of this
        by omitting the <option>--incremental</option> option to that
        command.  There is some value in these methods, in that the
        format of your backed-up information is flexible&mdash;it's
        not tied to a particular platform, versioned filesystem type,
        or release of Subversion or Berkeley DB.  But that flexibility
        comes at a cost, namely that restoring that data can take a
        long time&mdash;longer with each new revision committed to
        your repository.  Also, as is the case with so many of the
        various backup methods, revision property changes that are
        made to already backed-up revisions won't get picked up by a
        nonoverlapping, incremental dump generation.  For these
        reasons, we recommend against relying solely on dump-based
        backup approaches.</para>

      <para>Beginning with Subversion 1.8, <command>svnadmin hotcopy</command>
        accepts <option>--incremental</option> option and supports incremental
        hotcopy mode for FSFS repositories.  In incremental hotcopy mode,
        revision data which has already been copied from the source to the
        destination repository will not be copied again. When
        <option>--incremental</option> option is used with
        <command>svnadmin hotcopy</command>, Subversion will only copy new
        revisions, and revisions which have changed in size or had their
        modification time stamp changed since the previous hotcopy
        operation.  Moreover, unlike with <command>svnsync</command> or
        <command>svnadmin dump --incremental</command>, performance of
        <command>svnadmin hotcopy --incremental</command> is only limited to
        disk I/O.  Therefore, incremental hotcopy can be a huge
        time saver when making a backup of a large repository.</para>

      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>

      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>

      <para>In any backup scenario, repository administrators need to
        be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change
        hooks.<footnote><para><command>svnadmin setlog</command> can
        be called in a way that bypasses the hook interface
        altogether.</para></footnote>  And since you can change
        revision properties without respect to chronological
        order&mdash;you can change any revision's properties at any
        time&mdash;an incremental backup of the latest few revisions
        might not catch a property modification to a revision that was
        included as part of a previous backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
            
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of
        Fate,<footnote><para>You know&mdash;the collective term for
        all of her <quote>fickle fingers.</quote></para></footnote> it
        should certainly help you recover from those trying
        times.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
      <title>Managing Repository UUIDs</title>

      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>

      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>

      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>

      <informalexample>
        <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load --force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>.</para>

      <informalexample>
        <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
    <title>Moving and Removing Repositories</title>

    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>

    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>

    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including
      their UUIDs.  In some circumstances, this might be desirable.
      But in the instances where it is not, you'll need to generate a
      new UUID for one of these identical repositories.  See
      <xref linkend="svn.reposadmin.maint.uuids" /> for more about
      managing repository UUIDs.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
