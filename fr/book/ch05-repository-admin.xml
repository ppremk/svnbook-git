<!-- -*- sgml -*- -->

<chapter id="svn.reposadmin">
<!--
  <title>Repository Administration</title>
-->
  <title>Administration d'un dépôt</title>

<!--
  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>
-->
  <para>Le dépôt Subversion est le centre de stockage de toutes vos
    données suivies en versions. Ainsi, il est <foreignphrase>de
    facto</foreignphrase> l'objet de toute l'attention et de tous les
    soins de l'administrateur. Bien que ce soit un élément ne
    nécessitant pas énormément de maintenance, il est important de
    comprendre comment le configurer et le surveiller de manière à
    éviter d'éventuels problèmes et à résoudre proprement ceux qui se
    présentent.</para>

<!--
  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use various
    related tools provided with Subversion.  We'll address some common
    questions and mistakes and give some suggestions on how to arrange
    the data in the repository.</para>
-->
  <para>Dans ce chapitre, nous expliquons comment créer et configurer un
    dépôt Subversion. Nous abordons également la maintenance du dépôt,
    en donnant des exemples d'utilisation des divers outils fournis avec
    Subversion. Nous étudions quelques questions et erreurs communes et
    nous donnons des conseils sur l'organisation des données dans le
    dépôt.</para>

<!--
  <para>If you plan to access a Subversion repository only in the role
    of a user whose data is under version control (i.e., via a
    Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,<footnote><para>This may sound really prestigious
    and lofty, but we're just talking about anyone who is interested
    in that mysterious realm beyond the working copy where everyone's
    data hangs out.</para></footnote> this chapter is for you.</para>
-->
  <para>Si vous n'envisagez pas d'utiliser un dépôt Subversion autrement
    qu'en simple utilisateur des données (c'est-à-dire en utilisant un
    client Subversion), vous pouvez sauter ce chapitre. Cependant, si
    vous êtes (ou si vous êtes appelé à être) l'administrateur d'un
    dépôt<footnote>
      <para>Cela peut sembler prestigieux et noble, mais nous ne faisons
        référence en fait qu'à une personne intéressée par le monde
        mystérieux qui se cache derrière la copie de travail que chacun
        détient.</para>
    </footnote>, ce chapitre est fait pour vous.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
<!--
    <title>The Subversion Repository, Defined</title>
-->
    <title>Définition d'un dépôt Subversion</title>

<!--
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective&mdash;how a repository looks and
      acts with respect to non-Subversion tools&mdash;and from a
      logical perspective&mdash;dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>
-->
    <para>Avant d'aborder le vaste sujet de l'administration d'un dépôt,
      définissons plus précisément ce qu'est un dépôt. À quoi
      ressemble-t-il&nbsp;? Que ressent-il&nbsp;? Est-ce qu'il préfère
      son thé chaud ou glacé, sucré, avec une tranche de citron&nbsp;?
      En tant qu'administrateur, vous vous devez de comprendre de quoi
      est composé un dépôt, à la fois au niveau du système
      d'exploitation (à quoi ressemble le dépôt et comment il réagit
      vis-à-vis des outils autres que Subversion) et au niveau logique
      de l'organisation des données (comment elles sont représentées
      <emphasis>à l'intérieur</emphasis> du dépôt).</para>

<!--
    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>
-->
    <para>Du point de vue d'un explorateur de fichiers classique (comme
      Windows Explorer) ou d'un outil de navigation du système de
      fichiers en ligne de commande, un dépôt Subversion n'est rien
      d'autre qu'un répertoire contenant plein de choses. Il y a des
      sous-dossiers avec des fichiers de configuration lisibles par
      un humain, des sous-dossiers avec des fichiers de données
      binaires déjà bien moins lisibles,&nbsp;etc. À l'instar d'autres
      parties de Subversion, la modularité est une préoccupation majeure
      et l'organisation hiérarchique prévaut sur le bazar. Ainsi, un
      rapide coup d'œil dans un dépôt ordinaire est suffisant pour
      obtenir la liste des composants essentiels d'un
      dépôt&nbsp;:</para>

    <informalexample>
      <screen><!--
$ ls repos-->
$ ls dépot
conf/  db/  format  hooks/  locks/  README.txt
</screen>
    </informalexample>

<!--
    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology&mdash;detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>
-->
    <para>Effectuons un survol rapide de ce que nous voyons dans ce
      répertoire (ne vous inquiétez pas si vous ne comprenez pas tous
      les termes employés, ils sont expliqués dans ce chapitre ou
      ailleurs dans ce livre)&nbsp;:</para>

    <variablelist>
      <varlistentry>
        <term>conf/</term>
        <listitem>
<!--
          <para>This directory is a container for configuration
            files.</para>
-->
          <para>Un dossier destiné à accueillir les fichiers de
            configuration.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db/</term>
        <listitem>
<!--
          <para>This directory contains the data store for all of your
            versioned data.<footnote><para>Strictly speaking,
            Subversion doesn't dictate that the versioned data live
            here, and there are known (albeit proprietary) alternative
            backend storage implementations which do not, in fact,
            store data in this directory.</para></footnote></para>
-->
          <para>Le magasin de données pour toutes vos données suivies en
            versions<footnote>
            <para>Strictement parlant, Subversion n'oblige pas à ce que
            les données suivies en versions soient stockées ici et il
            existe des variantes (quoique propriétaires) de
            stockage des données qui ne stockent pas réellement leurs
            données dans ce dossier.</para></footnote>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
<!--
          <para>This file describes the repository's internal
            organizational scheme.  (As it turns out,
            the <filename>db/</filename> subdirectory sometimes also
            contains a <filename>format</filename> file which
            describes only the contents of that subdirectory and which
            is not to be confused with this file.)</para>
-->
          <para>Ce fichier décrit le schéma d'organisation interne du
            dépôt. Il se trouve que le sous-dossier
            <filename>db</filename> contient parfois aussi un fichier
            <filename>format</filename> qui ne décrit que le contenu de
            ce sous-dossier et ne doit pas être confondu avec ce
            fichier.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks/</term>
        <listitem>
<!--
          <para>This directory contains hook script templates and
            hook scripts, if any have been installed.</para>
-->
          <para>Ce dossier contient les modèles de procédures
            automatiques (et les procédures automatiques elles-mêmes,
            une fois installées).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks/</term>
        <listitem>
<!--
          <para>Subversion uses this directory to house repository
            lock files, used for managing concurrent access to the
            repository.</para>
-->
          <para>Ce répertoire est utilisé pour les fichiers de verrous
            du dépôt Subversion, de façon à gérer les accès concurrents
            au dépôt.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
<!--
          <para>This is a brief text file containing merely a notice
            to readers that the directory they are looking in is a
            Subversion repository.</para>
-->
          <para>Un petit fichier qui ne fait qu'informer son lecteur
            qu'il se trouve dans un dépôt Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
<!--
      <para>
        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activities</secondary>
        </indexterm>Prior to Subversion 1.5, the on-disk repository
        structure also always contained a <filename>dav</filename>
        subdirectory. <filename>mod_dav_svn</filename> used this
        directory to store information about
        WebDAV <firstterm>activities</firstterm>&mdash;mappings of
        high-level WebDAV protocol concepts to Subversion commit
        transactions.  Subversion 1.5 changed that behavior, moving
        ownership of the activities directory, and the ability to
        configure its location, into <filename>mod_dav_svn</filename>
        itself.  Now, new repositories will not necessarily have
        a <filename>dav</filename> subdirectory
        unless <filename>mod_dav_svn</filename> is in use and hasn't
        been configured to store its activities database elsewhere.
        See <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" />
        for more information.</para>
-->
      <para>
        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activités</secondary>
        </indexterm>Avant Subversion 1.5, la structure du dépôt sur le
        disque contenait toujours un sous-dossier
        <filename>dav</filename>. <filename>mod_dav_svn</filename>
        utilisait ce dossier pour stocker des informations relatives aux
        <firstterm>activités</firstterm> WEBDAV (l'équivalent
        haut-niveau du protocole WebDAV au concept de transaction dans
        les propagations Subversion). Subversion 1.5 a modifié cette
        situation en transférant la propriété du dossier activités et
        la possibilité de configurer son emplacement à
        <filename>mod_dav_svn</filename> lui-même. Dorénavant, les
        dépôts ne possèdent pas nécessairement un sous-dossier
        <filename>dav</filename>, à moins que vous n'utilisiez
        <filename>mod_dav_svn</filename> et que vous ne l'ayez pas
        configuré afin qu'il place la base de données relative à ses
        activités ailleurs. Reportez-vous à
        <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn"/>
        pour plus d'informations.</para>
    </note>

<!--
    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem&mdash;it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>
-->
    <para>Bien sûr, quand on y accède <foreignphrase>via</foreignphrase>
      les bibliothèques Subversion, cet ensemble de fichiers et de
      dossiers se transforme en un système de fichiers suivis en
      versions virtuel, complet et comportant une gestion des événements
      personnalisable. Ce système de fichiers possède ses propres
      notions de répertoires et de fichiers, très similaires aux notions
      des systèmes de fichiers réels (tels que NTFS, FAT32,
      ext3,&nbsp;etc.). Mais c'est un système de fichiers spécial&nbsp;:
      il base ces répertoires et ces fichiers sur les révisions,
      conservant l'historique de tous les changements effectués de
      manière sûre et pérenne. C'est là que la totalité de vos données
      suivies en versions réside.</para>

    <sidebar id="svn.reposadmin.basics.backends">
<!--
      <title>Speaking of Filesystems&hellip;</title>
-->
      <title>À propos des magasins de données</title>

<!--
      <para>When the initial design phase of Subversion was in
        progress, the developers decided to use Berkeley DB (BDB) as
        the storage mechanism behind the virtual versioned filesystem
        implementation.  Berkeley DB was a logical choice for a
        variety of reasons, including its open source license,
        transaction support, reliability, performance, API simplicity,
        thread safety, support for cursors, and so on.</para>
-->
      <para>Lors de la conception initiale de Subversion, les
        développeurs ont décidé d'utiliser le gestionnaire de bases de
        données Berkeley DB pour tout un tas de raisons, entre autres
        sa licence Open Source, son support des transactions, sa
        fiabilité, ses performances, la simplicité de son interface de
        programmation (API), le bon support des processus légers
        (threads), le support des curseurs,&nbsp;etc.</para>

<!--
      <para>In the years since, the
        newer <firstterm>FSFS</firstterm><footnote><para>While it is
        often pronounced <quote>fuzz-fuzz,</quote> per Jack
        Repenning's rendition, this book assumes that the reader is
        thinking <quote>eff-ess-eff-ess.</quote></para></footnote>
        backend was introduced.  This so-called <quote>filesystem
        filesystem</quote> was a versioned filesystem implemented not
        within an opaque database container, but instead as a larger
        collection of more transparent files stored in the OS's
        filesystem.  FSFS enjoyed continual development and
        improvement, and eventually earned the right to be the default
        Subversion backend.  But improvements to that backend kept
        coming, and ultimately the FSFS storage layer surpassed the
        Berkeley DB one in nearly every meaningful metric, from
        performance to scalability to reliability and beyond.</para>
-->

      <para>Le temps passant, un nouveau magasin de données<footnote>
          <para>NdT&nbsp;: souvent désigné par
            <foreignphrase>backend</foreignphrase> en
            anglais (sans équivalent en français) ou, ce qui peut être
            source de confusion,
            <quote>le système de fichiers)</quote></para>
        </footnote>, dénommé <firstterm>FSFS</firstterm><footnote>
          <para>Souvent prononcé <quote>feuzz-feuzz</quote> par Jack
            Repenning (ce livre, cependant, suppose que le
            lecteur pense <quote>eff-ess-eff-ess</quote>).</para>
        </footnote> a fait son apparition. Ce que l'on pourrait appeler
        <quote>le système de fichiers du système de fichiers</quote>
        était un système de fichiers suivis en versions. Cependant, il
        utilise le système de fichiers natif du système d'exploitation
        directement plutôt que le côté obscur d'une base de données.
        FSFS a fait l'objet d'améliorations et de développement en
        continu, ce qui lui a permis finalement de devenir le magasin
        de données par défaut de Subversion. Les améliorations se sont
        toujours poursuivies et, en fin de compte, la couche de
        stockage FSFS a surpassé Berkeley DB dans presque toutes les
        caractéristiques significatives, de la performance à la
        fiabilité en passant par la capacité à monter en charge.</para>
<!--

      <para>These days, it is generally assumed that if you are using
        the open source Subversion product, you are using the FSFS
        backend for your repositories.  In fact, beginning with
        Subversion 1.8, the Berkeley DB Subversion repository
        filesystem backend has been officially deprecated.  Subversion
        repositories which still use this storage layer option will
        continue to function with newer Subversion 1.x releases, but
        no further development&mdash;including feature introduction or
        expansion&mdash;is planned for the Berkeley DB backend.
        Subversion effectively offers a single viable repository
        storage layer option.  FSFS won.</para>
-->
      <para>De nos jours, on considère en général que si vous utilisez
        le produit standard Subversion, les magasins de données de vos
        dépôts sont au format FSFS. En fait, à partir de Subversion 1.8,
        le magasin Berkeley DB est officiellement obsolète. Les dépôts
        qui utilisent toujours ce magasin continueront à fonctionner avec
        les nouvelles versions Subversion 1.x, mais aucun développement
        (ce qui inclut l'ajout de fonctionnalités ou d'extensions) n'est
        planifié pour le magasin Berkeley DB. Subversion ne promeut
        qu'un seul magasin de données pour les dépôts&nbsp;: FSFS.</para>

<!--
      <para>This book will continue to provide information relevant to
        administrators of BDB-backed repositories where it makes sense
        to do so, but most of this chapter will assume what the rest
        of the world does: that FSFS is <emphasis>the</emphasis>
        Subversion storage backend implementation.  Please refer to
        <xref linkend="svn.berkeleydb"/> or to older versions of this
        documentation for more complete information about
        administering such repositories.</para>
-->
      <para>Ce livre continue à fournir les informations nécessaires aux
        administrateurs de magasins BDB autant que nécessaire, mais une
        grande partie de ce chapitre considère que, à l'instar du reste
        du monde, FSFS est <emphasis>le</emphasis> magasin de données
        de Subversion. Reportez-vous à <xref linkend="svn.berkeleydb"/> ou
        à d'anciennes versions de la documentation pour obtenir des
        informations complètes quant à l'administration de tels
        dépôts.</para>
    </sidebar>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
<!--
    <title>Strategies for Repository Deployment</title>
-->
    <title>Stratégies de déploiement d'un dépôt</title>

<!--
    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>
-->
    <para>En grande partie grâce à la conception épurée du dépôt
      Subversion et des technologies sous-jacentes, il est
      particulièrement aisé de créer et configurer un dépôt. Il y a
      quelques choix préliminaires à faire mais l'essentiel du travail
      de création et de configuration d'un dépôt Subversion est simple
      et convivial, facilement reproductible si vous êtes amené à
      effectuer des installations multiples.</para>

<!--
    <para>Some things you'll want to consider beforehand, though, are:</para>
-->
    <para>Voici quelques questions à se poser avant toute chose&nbsp;:</para>

    <itemizedlist>
      <listitem>
<!--
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
-->
        <para>Quelles données vont être hébergées dans le dépôt (ou les
          dépôts) et quelle en sera l'organisation&nbsp;?</para>
      </listitem>
      <listitem>
<!--
        <para>Where will your repository live, and how will it be
          accessed?</para>
-->
        <para>Où sera placé le dépôt et comment les utilisateurs y
          accéderont-ils&nbsp;?</para>
      </listitem>
      <listitem>
<!--
        <para>What types of access control do you need?</para>
-->
        <para>De quels types de contrôle d'accès avez-vous
          besoin&nbsp;?</para>
      </listitem>
    </itemizedlist>

<!--
    <para>In this section, we'll try to help you answer those
      questions.</para>
-->
    <para>Dans cette section, nous essayons de vous aider à répondre à
      ces questions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
<!--
      <title>Planning Your Repository Organization</title>
-->
      <title>Stratégies d'organisation d'un dépôt</title>

<!--
      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>
-->
      <para>Bien que Subversion vous permette de déplacer des fichiers
        et des répertoires suivis en versions sans perte d'information
        et qu'il fournisse même des outils pour déplacer des ensembles
        complets de données suivies en version d'un dépôt à un autre,
        ces opérations peuvent perturber le travail des autres
        collaborateurs qui accèdent souvent au dépôt et qui s'attendent
        à trouver chaque chose à sa place. Ainsi, avant de créer un
        nouveau dépôt, essayez de vous projeter un peu dans le
        futur&nbsp;; préparez à l'avance le passage de vos données sous
        gestion de versions. Cette réflexion sur la manière d'organiser
        vos données dans le dépôt vous évitera de futurs et nombreux
        maux de tête.</para>

<!--
      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>
-->
      <para>Supposons qu'en tant qu'administrateur d'un dépôt, vous
        êtes responsable de l'administration du système de gestion de
        versions pour plusieurs projets. La première décision à prendre
        est de choisir entre un seul dépôt pour tous les projets et un
        dépôt par projet, ou bien un compromis entre ces deux
        solutions.</para>

<!--
      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>
-->
      <para>Un seul dépôt pour tous les projets offre des avantages, ne
        serait-ce que pour la maintenance unifiée. Un seul dépôt
        signifie qu'il n'y a qu'un seul jeu de procédures automatiques,
        une seule sauvegarde à gérer, un seul jeu d'opérations de
        déchargement et de chargement à effectuer si la nouvelle version
        de Subversion est incompatible avec l'ancienne version,&nbsp;etc.
        Vous pouvez également déplacer facilement des données entre les
        projets, sans perdre l'historique de ces informations.</para>

<!--
      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course&mdash;it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.<footnote><para>Whether founded in
        ignorance or in poorly considered concepts about how to derive
        legitimate software development metrics, global revision
        numbers are a silly thing to fear,
        and <emphasis>not</emphasis> the kind of thing you should
        weigh when deciding how to arrange your projects and
        repositories.</para></footnote></para>
-->
      <para>Les inconvénients à utiliser un seul dépôt sont que les
        différents projets auront certainement des besoins différents en
        termes de gestion des événements, comme la notification par
        e-mail des propagations à des listes d'adresses différentes ou
        des définitions différentes de ce qui constitue une propagation
        légitime. Bien sûr, ce ne sont pas des problèmes insurmontables
        &mdash; cela implique juste que vos procédures automatiques
        doivent tenir compte de l'organisation du dépôt dans lequel
        elles sont invoquées plutôt que de considérer que l'ensemble du
        dépôt est associé à un seul groupe d'utilisateurs. Rappelez-vous
        également que Subversion utilise des numéros de révisions
        globaux au dépôt. Bien que ces numéros ne possèdent pas de
        pouvoirs magiques particuliers, certaines personnes n'aiment pas
        voir le numéro de révision augmenter alors qu'elles n'ont pas
        touché à leur propre projet<footnote>
          <para>Que ce soit par ignorance ou par la définition absurde
            de métriques de développement, les numéros globaux de
            révision sont craints alors qu'ils sont bien peu de chose et
            <emphasis>certainement pas</emphasis> à prendre en
            considération quand vous décidez de l'agencement de vos
            projets et de vos dépôts.</para>
        </footnote>.
      </para>

<!--
      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>
-->
      <para>On peut aussi adopter une approche intermédiaire. Par
        exemple, les projets peuvent être regroupés par thème. Vous
        pouvez avoir quelques dépôts, avec une poignée de projets dans
        chaque dépôt. Ainsi, les projets susceptibles de partager des
        données le font aisément et les développeurs sont tenus au
        courant des avancées des projets en relation avec les leurs par
        le biais des nouvelles révisions du dépôt.</para>

<!--
      <para>
        <indexterm>
          <primary>project root</primary>
        </indexterm>

        After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each project
        root&mdash;the <quote>topmost</quote> directory
        that contains data related to that project&mdash;and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.<footnote><para>The <filename>trunk</filename>,
        <filename>tags</filename>, and <filename>branches</filename>
        trio is sometimes referred to as <quote>the TTB
        directories.</quote></para></footnote></para>
-->
      <para>
        <indexterm>
          <primary>racine de projet</primary>
        </indexterm>
        Une fois l'organisation des dépôts définie, il faut se
        préoccuper de la hiérarchie des répertoires à l'intérieur des
        dépôts eux-mêmes. Comme Subversion utilise de simples copies de
        répertoires pour créer les branches et les étiquettes (voir le
        <xref linkend="svn.branchmerge"/>), la communauté Subversion
        recommande de choisir un endroit dans le dépôt pour la
        <firstterm>racine</firstterm> de chaque projet (le répertoire
        dont la sous-arborescence contient toutes les données relatives
        à un projet) et d'y placer trois sous-répertoires&nbsp;:
        <filename>trunk</filename> (<quote>tronc</quote> en français),
        le dossier qui héberge les principaux développements
        du projet&nbsp;; <filename>branches</filename>, le dossier
        dans lequel seront créées les différentes variations de la
        ligne de développement principale&nbsp;; et
        <filename>tags</filename> (<quote>étiquettes</quote> en
        français), qui contient un ensemble d'instantanés de
        l'arborescence (les instantanés sont créés, voire détruits, mais
        jamais modifiés)<footnote>
          <para>Le trio <filename>trunk</filename>,
            <filename>tags</filename> et <filename>branches</filename>
            est quelquefois appelé <quote>les répertoires TTB</quote>
            (<foreignphrase>the TTB directories</foreignphrase>
            en anglais).</para>
        </footnote>.
        </para>

<!--
      <para>For example, your repository might look like this:</para>
-->
      <para>Par exemple, votre dépôt peut ressembler à
        ceci&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      tags/
      branches/<!--
   calendar/-->
   calendrier/
      trunk/
      tags/
      branches/<!--
   spreadsheet/-->
   tableur
      trunk/
      tags/
      branches/
   &hellip;
</literallayout>
      </informalexample>

<!--
      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>
-->
      <para>Veuillez noter que l'emplacement du projet dans le dépôt
        n'est pas important. Si vous n'avez qu'un seul projet par dépôt,
        il est logique de placer la racine du projet à la racine du
        dépôt correspondant. Si vous avez plusieurs projets, vous
        voulez peut-être les classer par groupes dans des
        sous-répertoires communs du dépôt, en fonction des objectifs ou
        du code à partager par exemple, ou tout simplement en les
        groupant par ordre alphabétique. Voici un exemple&nbsp;:</para>

      <informalexample>
        <literallayout>
/<!--
   utils/-->
   utilitaires
      calc/
         trunk/
         tags/
         branches/<!--
      calendar/-->
      calendrier
         trunk/
         tags/
         branches/
      &hellip;<!--
   office/
      spreadsheet/-->
   bureautique/
      tableur/
         trunk/
         tags/
         branches/
      &hellip;
</literallayout>
      </informalexample>

<!--
      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>
-->
      <para>Organisez votre dépôt comme vous le sentez. Subversion n'a
        aucune exigence en la matière &mdash; pour lui, un répertoire
        est un répertoire. L'objectif est d'avoir une organisation qui
        réponde aux besoins des collaborateurs des différents
        projets.</para>

<!--
      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>
-->
      <para>Cependant, par souci de transparence, nous indiquons une
        autre organisation également très répandue. Dans cette
        organisation, les répertoires <filename>trunk</filename>,
        <filename>tags</filename> et <filename>branches</filename> sont
        situés à la racine du dépôt et les projets sont placés dans des
        sous-répertoires juste en dessous, comme ceci&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   trunk/
      calc/<!--
      calendar/
      spreadsheet/-->
      calendrier/
      tableur/
      &hellip;
   tags/
      calc/<!--
      calendar/
      spreadsheet/-->
      calendrier/
      tableur/
      &hellip;
   branches/
      calc/<!--
      calendar/
      spreadsheet/-->
      calendrier/
      tableur/
      &hellip;
</literallayout>
      </informalexample>

<!--
      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons&mdash;it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history&mdash;past, present, tagged, and branched&mdash;for
        that project and that project alone.</para>
-->
      <para>Il n'y a rien d'incorrect dans une telle organisation, mais
        elle peut ne pas être très intuitive pour vos utilisateurs. En
        particulier dans des situations complexes avec plusieurs projets
        et un grand nombre d'utilisateurs, dont la plupart ne
        connaissent qu'un ou deux projets du dépôt. Mais cette approche
        <quote>plusieurs projets par branche</quote> a tendance à
        favoriser l'ouverture de chaque projet sur les autres et pousse
        à envisager l'ensemble des projets comme une seule entité. Cela
        reste un problème social. Nous aimons l'organisation suggérée au
        début pour des raisons purement pratiques&nbsp;: il est plus
        facile de faire des requêtes (ou des modifications, des
        migrations) sur l'historique complet d'un projet quand une
        sous-arborescence du dépôt contient l'ensemble des données
        (passé, présent, étiquettes et branches) de ce projet et elles
        seules.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
<!--
      <title>Deciding Where and How to Host Your Repository</title>
-->
      <title>Stratégies d'hébergement d'un dépôt</title>

<!--
      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>
-->
      <para>Avant de créer votre dépôt Subversion, vous devez vous
        demander où il va résider. Cette question est fortement liée
        à une myriade d'autres questions telles que &nbsp;:
        qui sont les utilisateurs (sont-ils à l'intérieur de votre
        réseau interne, derrière le pare-feu de votre entreprise,
        ou bien s'agit-il de n'importe qui, n'importe où sur
        Internet&nbsp;?), comment les utilisateurs
        accèdent au dépôt (via un serveur Subversion ou directement),
        quels autres services vous fournissez autour de Subversion (une
        interface pour navigateur Web, des notifications par email des
        propagations,&nbsp;etc.), quelle est votre politique de
        sauvegarde et ainsi de suite.</para>

<!--
      <para>We cover server choice and configuration in
        <xref linkend="svn.serverconfig" />, but the point we'd like
        to briefly make here is simply that the answers to some of
        these other questions might have implications that force your
        hand when deciding where your repository will live.  For
        example, certain deployment scenarios might require accessing
        the repository via a remote filesystem from multiple
        computers, or using multiple repositories with syncronized
        contents distributed geographically to permit more performant
        access to that data by users around the globe.  Addressing
        each possible way to deploy Subversion is both impossible and
        outside the scope of this book.  We simply encourage you to
        evaluate your options using these pages and other sources as
        your reference material and to plan ahead.</para>
-->
      <para>Le choix et la configuration du serveur sont abordés au
        <xref linkend="svn.serverconfig" />, mais nous voulons signaler
        dès maintenant que certains choix pour l'une ou l'autre de ces
        questions ont des implications sur l'endroit où implémenter
        votre serveur. Par exemple, certains scénarios de déploiement
        nécessitent, pour plusieurs ordinateurs, l'accès au dépôt
        <foreignphrase>via</foreignphrase> un système de fichiers distant ou
        l'utilisation de plusieurs dépôts dont les contenus sont répartis
        géographiquement afin d'offrir des accès performants à tous les
        utilisateurs quels que soient leurs emplacements. Étudier chaque cas
        possible de déploiement de Subversion est à la fois impossible et
        hors du champ de ce livre. Nous vous encourageons simplement à
        considérer les différentes options présentées dans ces pages et
        ailleurs dans d'autres références, puis de planifier vos déploiements
        en conséquence.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.accesscontrol">
<!--
      <title>Controlling Access to Your Repository</title>
-->
      <title>Contrôle d'accès au dépôt</title>

<!--
      <para>Access control in Subversion is almost entirely managed by
        the Subversion server processes.  We discuss the available
        Subversion servers in <xref linkend="svn.serverconfig" />, and
        explain path-based access control specifically in
        <xref linkend="svn.serverconfig.pathbasedauthz" />.  In
        addition to those user-level access control questions, you'll also
        want to ensure that your repository is accessible by the
        programs on your hosting machine which need to access it.
        Consider the OS-level user and group ownership that makes
        sense for your repository.  Once again, the information found
        in <xref linkend="svn.serverconfig" /> should be able to help
        you make these decisions.</para>
-->
      <para>Le contrôle d'accès dans Subversion est presqu'entièrement
        géré par le processus serveur. Nous abordons les serveurs
        fournis par Subversion dans <xref linkend="svn.serverconfig" />
        et nous expliquons le contrôle d'accès basé sur les chemins
        spécifiquement dans <xref
        linkend="svn.serverconfig.pathbasedauthz" />. En complément
        du contrôle d'accès des utilisateurs, vous devez vous assurer de
        l'accès à votre dépôt par les programmes hébergés sur votre machine
        et qui ont besoin cet accès. Là encore, reportez-vous à <xref
        linkend="svn.serverconfig" /> pour trouver toutes les informtions
        utiles pour prendre vos décisions.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
<!--
    <title>Creating and Configuring Your Repository</title>
-->
    <title>Création et configuration d'un dépôt</title>

<!--
    <para>Earlier in this chapter (in
      <xref linkend="svn.reposadmin.planning" />), we looked at some
      of the important decisions that should be made before creating
      and configuring your Subversion repository.  Now, we finally get
      to get our hands dirty!  In this section, we'll see how to
      actually create a Subversion repository and configure it to
      perform custom actions when special repository events
      occur.</para>
-->
    <para>Dans ce chapitre (dans <xref
      linkend="svn.reposadmin.planning" />), nous avons passé en revue
      quelques décisions importantes à prendre avant de créer et de
      configurer votre dépôt Subversion. Maintenant nous allons enfin
      mettre les mains dans le cambouis&nbsp;! Dans cette section, nous
      voyons comment créer un dépôt Subversion et comment le configurer
      pour qu'il effectue des actions personnalisées lorsque certains
      événements ont lieu.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
<!--
      <title>Creating the Repository</title>
-->
      <title>Création d'un dépôt</title>

<!--
      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>
-->
      <para>La création d'un dépôt Subversion est une tâche
        incroyablement simple. L'utilitaire <command>svnadmin</command>,
        fourni avec Subversion, dispose d'une sous-commande qui est
        justement destinée à cela (<command>svnadmin
        create</command>) &nbsp;:</para>

      <informalexample>
        <screen> <!--
$ # Create a repository
$ svnadmin create /var/svn/repos-->
$ # Créer un dépôt
$ svnadmin create /var/svn/depot
$
</screen>
      </informalexample>

<!--
      <para>Assuming that the parent directory
        <filename>/var/svn</filename> exists and that you have
        sufficient permissions to modify that directory, the previous
        command creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store (FSFS).  You can explicitly choose the
        filesystem type using the <option>- -fs-type</option> argument,
        which accepts as a parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>
-->
      <para>Si l'on considère que le répertoire parent
        <filename>/var/svn</filename> existe déjà et que vous avez les
        droits suffisants pour modifier ce répertoire, la commande
        précédente crée un nouveau dépôt dans le répertoire
        <filename>/var/svn/depot</filename> avec le magasin de données
        par défaut (FSFS). Vous pouvez choisir explicitement le type de
        système de fichiers avec l'option <option>--fs-type</option> qui
        accepte comme argument soit <literal>fsfs</literal>,
        soit <literal>bdb</literal>.</para>

      <informalexample>
        <screen><!--
$ # Create an FSFS-backed repository
$ svnadmin create - -fs-type fsfs /var/svn/repos-->
$ # Créer un dépôt FSFS
$ svnadmin create --fs-type fsfs /var/svn/depot
$
</screen>
      </informalexample>

      <informalexample>
        <screen><!--
# Create a legacy Berkeley-DB-backed repository
$ svnadmin create - -fs-type bdb /var/svn/repos-->
$ # Créer un dépôt Berkeley DB
$ svnadmin create --fs-type bdb /var/svn/depot
$
</screen>
      </informalexample>

<!--
      <para>After running this simple command, you have a Subversion
        repository.  Depending on how users will access this new
        repository, you might need to fiddle with its filesystem
        permissions.  But since basic system administration is rather
        outside the scope of this text, we'll leave further
        exploration of that topic as an exercise to the reader.</para>
-->
      <para>Après l'exécution de cette simple commande, vous disposez
        d'un dépôt Subversion. En fonction de la manière dont vos
        utilisateurs accéderont à ce nouveau dépôt, vous aurez peut-être
        besoin de bidouiller les droits du système de fichiers.
        Mais comme l'administration système de base est plutôt hors de
        propos dans ce livre, nous laissons en exercice au lecteur le
        soin d'explorer plus avant ce sujet.</para>

      <tip>
<!--
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities&mdash;they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
-->
        <para>Le chemin en argument de <command>svnadmin</command> est
          juste un chemin classique du système de fichiers, pas une URL
          comme celles que le client <command>svn</command> utilise pour
          spécifier un dépôt. Les commandes <command>svnadmin</command>
          et <command>svnlook</command> sont toutes les deux considérées
          comme des utilitaires coté serveur&nbsp;: elles sont utilisées
          sur la machine qui héberge le dépôt pour examiner ou modifier
          certains aspects du dépôt et ne sont pas capables d'effectuer
          des actions via le réseau. Une erreur classique des nouveaux
          utilisateurs de Subversion est d'essayer de passer une URL
          (même <quote>locale</quote> comme <literal>file://</literal>)
          à ces deux programmes.</para>
      </tip>

<!--
      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem.  Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>
-->
      <para>Dans le sous-répertoire <filename>db/</filename> de votre
        dépôt, vous trouvez l'implémentation du système de fichiers
        suivi en versions. Le nouveau système de fichiers suivi en
        versions de votre dépôt commence sa vie à la révision 0, qui est
        définie comme contenant le répertoire racine
        (<filename>/</filename>) et lui seul. Initialement, la révision
        0 possède une seule propriété de révision,
        <literal>svn:date</literal>, dont la valeur est la date de
        création du dépôt.</para>

<!--
      <para>Now that you have a repository, it's time to customize
        it.</para>
-->
      <para>Maintenant que vous disposez d'un dépôt, il est temps de le
        personnaliser.</para>

      <warning>
<!--
        <para>While some parts of a Subversion repository&mdash;such
          as the configuration files and hook scripts&mdash;are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools for tweaking relevant subsections of the
          repository.  Do <emphasis>not</emphasis> attempt manual
          manipulation of your version control history by poking and
          prodding around in your repository's data store
          files!</para>
-->
        <para>Alors que certaines parties d'un dépôt Subversion sont
          conçues pour être examinées et modifiées <quote>à la
          main</quote> (comme les fichiers de configuration et les
          procédures automatiques), vous ne devez pas (et vous ne
          devriez pas avoir besoin de) modifier les autres parties
          <quote>à la main</quote>. L'outil <command>svnadmin</command>
          est censé être suffisant pour toutes les modifications à
          apporter à votre dépôt, mais vous pouvez également vous servir
          d'outils tiers pour configurer les parties adéquates du dépôt. Ne
          tentez <emphasis>surtout pas</emphasis> de manipuler manuellement
          l'historique du suivi de versions en touchant aux fichiers du
          magasin de données du dépôt&nbsp;!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.hooks">
<!--
      <title>Implementing Repository Hooks</title>
-->
      <title>Mise en place des procédures automatiques</title>

<!--
      <para>
        <indexterm>
          <primary>hook scripts</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>hook scripts</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>hooks</secondary>
          <see>hook scripts</see>
        </indexterm>A <firstterm>hook</firstterm> is a program
        triggered by some repository event, such as the creation of a
        new revision or the modification of an unversioned property.
        Some hooks (the so-called <quote>pre hooks</quote>) run in
        advance of a repository operation and provide a means by which
        to both report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine&mdash;but don't
        modify&mdash;the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
-->
      <para>
        <indexterm>
          <primary>procédures automatiques</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>procédures automatiques</see>
        </indexterm>
        <indexterm>
          <primary>dépôts</primary>
          <secondary>procédures automatiques</secondary>
          <see>procédures automatiques</see>
        </indexterm>Une <firstterm>procédure automatique</firstterm>
        (<foreignphrase>hook</foreignphrase> en anglais)
        est un programme activé par certains événements du
        dépôt, comme la création d'une nouvelle révision ou la
        modification d'une propriété non suivie en versions. Certaines
        procédures automatiques (appelées <quote>pré-hooks</quote>) sont
        déclenchées avant l'opération sur le dépôt et permettent à la
        fois de rendre compte de ce qui va se passer et d'empêcher que
        cela se passe. D'autres procédures automatiques (appelées
        <quote>post-hooks</quote>) sont déclenchées après la fin d'un
        événement et servent à effectuer des tâches de surveillance
        (mais pas de modification) du dépôt. Chaque procédure
        automatique reçoit suffisamment d'informations pour déterminer
        la nature de l'événement, les modifications proposées (ou
        effectuées) du dépôt et le nom d'utilisateur de la personne qui
        a déclenché l'événement.</para>
<!--
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>
-->
      <para>Le sous-répertoire <filename>hooks</filename> contient, par
        défaut, des modèles pour diverses procédures
        automatiques&nbsp;:</para>

      <informalexample>
        <screen><!--
$ ls repos/hooks/-->
$ ls depot/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
      </informalexample>

<!--
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
-->
      <para>Il y a un modèle pour chaque type de procédure automatique
        que le dépôt Subversion sait prendre en charge&nbsp;; en
        examinant le contenu de ces modèles de scripts, vous pouvez
        voir ce qui déclenche le script et quelles données sont passées
        en paramètres. Vous trouvez également dans beaucoup de ces
        scripts des exemples d'utilisation permettant de réaliser des
        tâches récurrentes utiles, en conjonction avec d'autres
        programmes fournis avec Subversion. Concrètement, pour activer
        une procédure automatique, il suffit de placer dans le
        répertoire <filename>depot/hooks</filename> un programme ou un
        script exécutable, qui sera invoqué
        <foreignphrase>via</foreignphrase> le nom de la procédure
        automatique (comme <command>start-commit</command> pour le début
        d'une propagation ou <command>post-commit</command> pour la fin
        d'une propagation).</para>

<!--
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>
-->
      <para>Sur les plateformes Unix, cela veut dire fournir un
        programme ou un script (pouvant être un script shell, un
        programme Python, l'exécutable binaire d'un programme en C ou
        tout un tas d'autres choses) dont le nom est exactement le nom
        de la procédure automatique. Bien sûr, les modèles qui sont
        fournis ne le sont pas juste à titre d'information. Le moyen le
        plus facile pour mettre en place une procédure automatique sur
        les plateformes Unix consiste tout simplement à copier le
        fichier du modèle adéquat vers un nouveau fichier qui n'aura
        pas l'extension <filename>.tmpl</filename>, d'adapter son
        contenu à votre environnement et de vous assurer qu'il est
        exécutable. Sous Windows, comme l'extension du fichier détermine
        s'il est exécutable ou non, vous devez fournir un programme
        dont la base du nom est le nom de la procédure automatique et
        dont l'extension est l'une de celles reconnue comme exécutable
        par Windows, comme <filename>.exe</filename> pour les programmes
        ou <filename>.bat</filename> pour les fichiers batch.</para>

<!--
      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>
-->
      <para>Les procédures automatiques de Subversion sont lancées par
        l'utilisateur propriétaire du processus ayant accès au dépôt
        Subversion. La plupart du temps, on accède au dépôt
        <foreignphrase>via</foreignphrase> un serveur Subversion, donc cet
        utilisateur est le même que celui qui fait tourner le processus
        serveur sur le système. Les procédures automatiques elles-mêmes
        doivent être configurées pour être exécutables, au niveau du système
        d'exploitation, par ledit utilisateur. Cela implique également que
        tout programme ou fichier (y compris le dépôt Subversion) utilisé
        directement ou indirectement par la procédure automatique l'est par
        ledit utilisateur. En d'autres termes, faites bien attention aux
        problèmes de droits d'accès et d'exécution qui peuvent empêcher
        les procédures automatiques d'effectuer correctement les tâches
        pour lesquelles elles ont été conçues.</para>

<!--
      <para>There are several hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>
-->
      <para>Il y a plusieurs procédures automatiques implémentées dans
        le dépôt Subversion et vous pouvez obtenir des détails sur
        chacune d'elles dans <xref linkend="svn.ref.reposhooks" />. En
        tant qu'administrateur du dépôt, vous devez décider quelles
        procédures automatiques vous voulez mettre en œuvre
        (c'est-à-dire les nommer correctement et leur donner les droits
        appropriés) et de quelle manière. Lorsque vous prenez cette
        décision, gardez à l'esprit l'architecture de votre dépôt. Par
        exemple, si vous vous servez de la configuration du serveur pour
        déterminer les droits de propagation sur votre dépôt, vous
        n'avez pas besoin de mettre en place un contrôle d'accès de ce
        style <foreignphrase>via</foreignphrase> les procédures
        automatiques.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.configuration">
<!--
        <title>Hook script environment configuration</title>
-->
        <title>Configuration de l'environnement des procédures
          automatiques</title>

<!--
        <para>By default, Subversion executes hook scripts with an
          empty environment&mdash;that is, no environment variables
          are set at all, not even <literal>$PATH</literal>
          (or <literal>%PATH%</literal>, under Windows).  Because of
          this, many administrators are baffled when their hook
          program runs fine by hand, but doesn't work when invoked by
          Subversion.  Administrators have historically worked around
          this problem by manually setting all the environment
          variables their hook scripts need in the scripts
          themselves.</para>
-->
        <para>Par défaut, le dépôt Subversion exécute les procédures
          automatiques avec un environnement vide &mdash; c'est-à-dire
          sans aucune variable d'environnement définie, même pas
          <literal>$PATH</literal> (ou <literal>%PATH%</literal>
          sous Windows). C'est ainsi que de nombreux administrateurs
          sont perplexes lorsque leurs programmes fonctionnent
          correctement à la main mais pas dans Subversion. Assurez-vous
          de définir explicitement toutes les variables d'environnement
          nécessaires dans votre procédure automatique.</para>

<!--
        <para>Subversion 1.8 introduces a new way to manage the
          environment of Subversion-executed hook scripts&mdash;the
          hook script environment configuration file.  If a Subversion
          server finds a file named <filename>hooks-env</filename> in
          the repository's <filename>conf/</filename> subdirectory, it
          parses that file as an INI-formatted configuration file and
          applies the option names and variables found therein to the
          hook script's execution environment as environment
          variables.</para>
-->
        <para>Subversion 1.8 introduit une nouvelle façon de gérer
          l'environnement dans lequel s'exécutent les procédures
          automatiques, le fichier de configuration de l'environnement
          des procédures automatiques. Si le serveur Subversion trouve
          un fichier nommé <filename>hooks-env</filename> dans le
          sous-répertoire <filename>conf/</filename> du dépôt, il
          analyse ce fichier à la manière d'un fichier .INI et insère
          les options et variables qu'il a trouvées dans l'environnement
          de la procédure automatique <foreignphrase>via</foreignphrase>
          des variables d'environnement.</para>

<!--
        <para>The syntax of the <filename>hooks-env</filename> file is
          pretty straightforward: each section name is the name of a
          hook script (such as <literal>pre-commit</literal>
          or <literal>post-revprop-change</literal>), and the
          configuration items inside that section are treated as
          mappings of environment variable names to desired values.
          Additionally, there is a
          special <literal>[default]</literal> section, which can be
          used to configure environment variable mappings that should
          be applied to <emphasis>all</emphasis> hook scripts (unless
          explicitly overridden by per-hook-script settings).  See
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          for a sample <filename>hooks-env</filename> configuration
          file.</para>
-->
        <para>La syntaxe du fichier <filename>hooks-env</filename> est
          très simple&nbsp;: chaque nom de section correspond à la
          procédure automatique à laquelle la section s'applique (tels
          que <literal>pre-commit</literal> ou
          <literal>post-revprop-change</literal>) et les éléments à
          l'intérieur des sections sont les variables d'environnement
          dont on souhaite définir les valeurs. En plus, il existe une
          section générale <literal>[default]</literal>, qui permet
          de définir la valeur de variables d'environnement pour
          <emphasis>toutes</emphasis> les procédures automatiques (sauf
          si cette variable est explicitement redéfinie à l'intérieur
          d'une section particulière à une procédure automatique).
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          fournit un exemple de fichier de configuration
          <filename>hooks-env</filename>.</para>

        <example id="svn.reposadmin.hooks.configuration.ex-1">
<!--
          <title>hooks-env (custom hook script environment
            configuration)</title>

          <programlisting>
# All scripts should use a UTF-8 locale and have our hook script
# utilities directory on the search path.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# The post-commit and post-revprop-change scripts want to run
# programs from our custom synctools replication software suite, too.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>
-->
          <title>hooks-env (configuration personnalisée de
            l'environnement des procédures automatiques)</title>

          <programlisting>
# Toutes les procédures seront configurées en français encodé en UTF-8
# et auront le répertoire contenant nos utilitaires dans leur chemin
# par défaut.

[default]
LANG = fr_FR.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# Les procédures post-commit et post-revprop-change ont aussi besoin
# de nos programmes personnalisés pour la synchronisation

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>

        <note>
<!--
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> also demonstrates the nifty string substitution syntax
            found in Subversion's configuration file parser.  In this
            example, the value of the <literal>PATH</literal>
            option&mdash;pulled from the <literal>[default]</literal>
            section of the file&mdash;is substituted in place of
            the <literal>%(PATH)s</literal> placeholder text in the
            per-hook sections.  For more about this special syntax,
            see the <filename>README.txt</filename> file which lives
            in the Subversion runtime configuration directory.  (And
            for more information about that directory, see
            <xref linkend="svn.advanced.confarea" />.)</para>
-->
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"/>
            montre aussi la fonctionnalité de substitution des chaînes
            de caractères de l'analyseur du fichier de configuration.
            Dans cet exemple, la valeur de l'option
            <literal>PATH</literal> (récupérée depuis la section
            <literal>[default]</literal> du fichier) remplacera à la
            volée le texte <literal>%(PATH)s</literal> dans les sections
            dédiées à chaque procédure automatique. Pour plus
            d'informations sur le fonctionnement de cette syntaxe,
            reportez-vous au fichier <filename>README.txt</filename> qui
            se trouve dans le répertoire de configuration de Subversion
            (et pour plus d'information sur ce répertoire, lisez
            <xref linkend="svn.advanced.confarea" />).</para>
        </note>

<!--
        <para>Of course, having exact duplicates of your custom hook
          script environment configuration files in every single
          repository's <filename>conf/</filename> directory could get
          cumbersome, especially when you need to make changes to them
          all.  So Subversion's servers allow you to specify an
          alternate (possibly shared) location for this configuration
          information.</para>
-->
        <para>Bien sûr, avoir exactement les mêmes informations dans
          chaque fichier de configuration de l'environnement des
          procédures automatiques, dans chaque répertoire
          <filename>conf/</filename> de chaque dépôt serait vite très
          lourd, surtout quand vous devez les modifier tous. C'est
          pourquoi le serveur Subversion vous permet de spécifier un
          emplacement alternatif (possiblement partagé) pour ces
          informations de configuration.</para>

        <!-- ### TODO:  Add cross reference for the above! -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.uses">
<!--
        <title>Common uses for hook scripts</title>
-->
        <title>Utilisations classiques des procédures automatiques</title>

<!--
        <para>Repository hook scripts can offer a wide range of
          utility, but most tend to fall into a few basic categories:
          notification, validation, and replication.</para>
-->
        <para>Les procédures automatiques du dépôt permettent de
          réaliser une large palette de fonctions, mais la plupart sont
          en fait utilisées pour quelques actions simples&nbsp;:
          la notification, la validation et la réplication.</para>

<!--
        <para>Notification scripts are those which tell someone that
          something happened.  The most common of these found in a
          Subversion service offering involve programs which send
          commit and revision property change notification emails to
          project members, driven by the post-commit and
          post-revprop-change hooks, respectively.  There are numerous
          other notification approaches, from issue tracker integration
          scripts to scripts which operate as IRC bots to announce
          that something's changed in the repository.</para>
-->
        <para>Les procédures de notification sont celles qui indiquent
          à quelqu'un que quelque chose est arrivé. Celles que l'on
          retrouve le plus souvent dans l'utilisation de Subversion
          envoient des courriels de compte-rendu de propagation (resp.
          de modification de propriété de révision) aux membres du
          projet, elles sont pilotées par la procédure automatique
          <literal>post-commit</literal> (resp.
          <literal>post-revprop-change</literal>). Il existe beaucoup
          d'autres types de notification, depuis l'intégration dans
          un outil de suivi de bogues jusqu'au robot IRC qui annonce
          que quelque chose a changé dans le dépôt.</para>

<!--
        <para>On the validation side of things, the start-commit and
          pre-commit hooks are widely used to allow or disallow
          commits based on various criteria: the author of the commit,
          the formatting and/or content of the log message which describes the
          commit, and even the low-level details of the changes made
          to files and directories in the commit.  Likewise, the
          pre-revprop-change hook acts as the gateway to revision
          property changes, which is an especially valuable role
          considering the fact that revision properties are not
          themselves versioned, and can therefore only be modified
          destructively.</para>
-->
        <para>Pour ce qui concerne la validation, les procédures
          automatiques <literal>start-commit</literal> et
          <literal>pre-commit</literal> sont largement utilisées pour
          autoriser ou interdire des propagations en fonction de
          divers critères&nbsp;: l'auteur de la propagation, le format
          ou le contenu du commentaire de propagation voire même des
          détails de bas-niveau relatifs aux modifications faites aux
          fichiers et dossiers par la propagation. De la même manière,
          la procédure automatique <literal>pre-revprop-change</literal>
          agit comme un point de passage obligé pour les modifications
          des propriétés de révisions, ce qui est particulièrement utile
          compte tenu du fait que les propriétés de révisions ne sont
          pas suivies en versions et ne sont donc modifiées qu'en
          détruisant l'ancienne valeur.</para>

<!--
        <para>One special class of change validation that has seen
          widespread use since Subversion 1.5 was released is
          validation of the committing client software itself.  When
          Subversion's merge tracking feature (described extensively
          in <xref linkend="svn.branchmerge" />) was introduced in
          that release, Subversion administrators needed a way to
          ensure that once users of their repositories started using
          the new feature that <emphasis>all</emphasis> their merges
          were tracked.  To reduce the chance of someone committing an
          untracked merge to the repository, they used start-commit
          hooks to examine the feature capabilities string advertised
          by Subversion clients.  If the committing client didn't
          advertise support for merge tracking, the commit was denied
          with instructions to the user to immediately update their
          Subversion client!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> provides
          an example of a start-commit script which does precisely
          this.</para>
-->
        <para>Une catégorie de validation des modifications se
          généralise depuis la sortie de Subversion 1.5&nbsp;: la
          validation du logiciel client lui-même. Quand la
          fonctionnalité de suivi des fusions (qui est décrite en
          détails dans <xref linkend="svn.branchmerge" />) est apparue
          dans Subversion 1.5, les administrateurs de Subversion ont eu
          besoin de s'assurer que, une fois que certains commençaient à
          utiliser cette fonctionnalité, alors <emphasis>tous</emphasis>
          leurs fusions devaient être suivies. Afin de réduire la chance
          que quelqu'un propage une fusion non suivie vers le dépôt, ils
          ont utilisé la procédure automatique
          <literal>start-commit</literal> pour examiner les capacités
          annoncées par le client Subversion. Si celui-ci n'indiquait
          pas savoir suivre les fusions, la propagation était interdite
          avec un message pour l'utilisateur lui indiquant de mettre à
          niveau le client Subversion&nbsp;!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> donne un
          exemple de script <literal>start-commit</literal> qui
          implémente précisément cette fonction.</para>

        <example id="svn.reposadmin.hooks.uses.ex-1">
<!--
          <title>start-commit hook to require merge tracking
            support</title>
-->
          <title>procédure automatique <literal>start-commit</literal>
            qui s'assure que le client sait suivre les fusions.</title>

          <programlisting>
#!/usr/bin/env python
import sys
<!--
# sys.argv[3] is a colon-delimited capabilities list -->
# sys.argv[3] contient la liste, séparée par des ':', des capacités du client
if 'mergeinfo' not in sys.argv[3].split(':'):
  sys.stderr.write("""\<!--
ERROR: Commits to this repository must be made using Subversion
clients which support the merge tracking feature.  Please upgrade
your client to at least Subversion 1.5.0. -->
ERREUR : les propagations (commit) vers ce dépôt ne sont possible
qu'avec des clients qui savent suivre les fusions. Veuillez mettre à
niveau votre client à Subversion 1.5 ou ultérieur.
""")
  sys.exit(1)
</programlisting>
        </example>

<!--
        <para>
          <indexterm>
            <primary>properties</primary>
            <secondary>ephemeral transaction properties</secondary>
          </indexterm>Beginning in Subversion 1.8, clients committing
          against a Subversion 1.8 server will still provide the
          feature capabilities string, but will also provide
          additional information about themselves by way
          of <firstterm>ephemeral transaction properties</firstterm>.
          Ephemeral transaction properties are essentially revision
          properties which are set on the commit transaction by the
          client at the earliest opportunity while committing, but
          which are automatically removed by the server immediately
          prior to the transaction becoming a finalized revision.  You
          can inspect these properties using the same tools with which
          you'd inspect other unversioned properties set on commit
          transactions during the timeframe between which the
          start-commit and pre-commit repository hook scripts would
          operate.</para>
-->
        <para>
          <indexterm>
            <primary>propriétés</primary>
            <secondary>propriétés éphémères de transaction</secondary>
          </indexterm>Depuis Subversion 1.8, les clients qui propagent
          des modifications sur un serveur Subversion 1.8 fournissent
          toujours une chaîne indiquant leurs capacités mais fournissent
          aussi des informations complémentaires les concernant en
          utilisant des <firstterm>propriétés éphémères de
          transaction</firstterm>. Ces propriétés éphémères de
          transaction sont principalement des propriétés de révision qui
          sont définies sur la transaction de propagation par le client
          dès qu'il a l'occasion de le faire au moment de la
          propagation. Elle sont automatiquement supprimées par le
          serveur juste avant que la transaction ne devienne une
          révision. Vous pouvez inspecter ces propriétés, pendant le
          laps de temps séparant les procédures automatiques
          <literal>start-commit</literal> et
          <literal>pre-commit</literal>, à l'aide des
          mêmes outils que ceux que vous utilisez pour inspecter les
          autres propriétés non suivies en versions.</para>

<!--
        <para>The following are the ephemeral transaction properties
          which Subversion currently provides and implements:</para>
-->
        <para>Vous trouverez ci-après les propriétés éphémères de
          transactions que Subversion reconnait
          actuellement&nbsp;:</para>

        <variablelist>

          <varlistentry>
            <term><literal>svn:txn-client-compat-version</literal></term>
            <listitem>
<!--
              <para>Carries the Subversion library version string with
                which the committing client claims compatibility.
                This is useful for deciding whether the client
                supports the minimal feature set required for proper
                handling of the repository data.</para>
-->
              <para>Contient la chaîne de caractères indiquant la
                version de la bibliothèque Subversion dont le client se
                réclame compatible. C'est utile pour décider si le
                client implémente le jeu de fonctionnalités suffisant
                pour gérer proprement les données du dépôt.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:txn-user-agent</literal></term>
            <listitem>
<!--
              <para>Carries the <quote>user agent</quote> string which
                describes the committing client program.  Subversion's
                libraries define the initial portion of this string,
                but third-party consumers of the API (GUI clients,
                etc.) can append custom information to it.</para>
-->
              <para>Contient la chaîne de caractères décrivant le
                <quote>programme utilisateur</quote>
                (<foreignphrase>user agent</foreignphrase> en anglais)
                qui effectue la propagation. La bibliothèque Subversion
                définit la première partie de cette chaîne mais un
                programme tiers qui utilise l'API (client avec une
                interface graphique, etc.) peut y ajouter des
                informations personnalisées.</para>
            </listitem>
          </varlistentry>

        </variablelist>

        <!-- ### TODO: Show an example of these being used?  Or ### -->
        <!-- ###       do so in ch07 - Customizing Subversion   ### -->
        <!-- ###       with a cross-reference here.             ### -->

        <note>
<!--
          <para>While most clients will transmit ephemeral transaction
            properties early enough in the commit process that they
            may be inspected by the start-commit hook script, some
            configurations of Subversion will cause those properties
            to not be set on the transaction until later in the commit
            process.  Administrators should consider performing any
            validation based on ephemeral transaction properties in
            both the start-commit and pre-commit hooks&mdash;the
            former to rule out invalid clients before those clients
            transmit the commit payload; the latter <quote>just in
            case</quote> the validation checks couldn't be performed
            by the start-commit hook.</para>
-->
          <para>alors que la plupart des clients vont transmettre les
            propriétés éphémères de transaction assez tôt dans le
            processus de transaction et pouvoir ainsi être examinées par
            la procédure automatique <literal>start-commit</literal>,
            certaines configurations de Subversion vont entrainer que
            ces propriétés ne seront définies dans la transaction que
            plus tard dans le processus de propagation. Les
            administrateurs doivent donc prendre le parti d'effectuer
            les validations basées sur les propriétés éphémères à la
            fois dans les procédures automatiques
            <literal>start-commit</literal> et
            <literal>pre-commit</literal> (dans le premier cas pour
            éviter qu'un client invalide ne transmette le contenu de la
            propagation, dans le deuxième cas <quote>juste au cas
            où</quote> les vérifications n'auraient pas pu être
            effectuées par la procédure automatique
            <literal>start-commit</literal>).</para>
        </note>

<!--
        <para>As noted before, ephemeral transaction properties are
          removed from the transaction just before it is promoted to a
          new revision.  Some administrators may wish to preserve the
          information in those properties indefinitely.  We suggest
          that you do so by using the pre-commit hook script to copy
          the values of those properties to new property names.  In
          fact, the Subversion source code distribution provides a
          <filename>persist-ephemeral-txnprops.py</filename> script
          (in the <filename>tools/hook-scripts/</filename>
          subdirectory) for doing precisely that.</para>
-->
        <para>Comme nous l'avons déjà noté, les propriétés éphémères de
          transaction sont supprimées de la transaction juste avant
          qu'elle ne soit promue en nouvelle révision. Certains
          administrateurs peuvent vouloir conserver les informations de
          ces propriétés pour plus tard. Nous vous conseillons alors
          d'utiliser la procédure automatique
          <literal>pre-commit</literal> pour copier les valeurs des
          propriétés vers de nouvelles propriétés avec un nom différent.
          En fait, le code source distribué avec Subversion fournit un
          script <filename>persist-ephemeral-txnprops.py</filename>
          (situé dans le dossier
          <filename>tools/hook-scripts/</filename>),
          qui fait exactement cela.</para>

<!--
        <para>The third common type of hook script usage is for the
          purpose of replication.  Whether you are driving a simple
          backup process or a more involved remote repository
          mirroring scenario, hook scripts can be critical.  See
          <xref linkend="svn.reposadmin.maint.backup" /> and
          <xref linkend="svn.reposadmin.maint.replication" /> for more
          information about these aspects of repository
          maintenance.</para>
-->
        <para>La troisième catégorie que l'on rencontre souvent dans
          l'utilisation des procédures automatiques concerne la
          réplication. Que ce soit pour simplement faire une copie de
          sauvegarde ou pour un scénario impliquant des dépôts mirroirs,
          les procédures automatiques peuvent s'avérer critiques. Lisez
          <xref linkend="svn.reposadmin.maint.backup" /> et
          <xref linkend="svn.reposadmin.maint.replication" /> pour
          davantage d'informations sur ces aspects de la maintenance du
          dépôt.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.summary">
<!--
        <title>Finding hook scripts or rolling your own</title>
-->
        <title>Trouver des procédures automatiques ou écrire les
          vôtres</title>

<!--
        <para>As you might imagine, there is no shortage of Subversion
          hook programs and scripts that are freely available either
          from the Subversion community itself or elsewhere.  In fact,
          the Subversion distribution provides several commonly used
          hook scripts in its <filename>tools/hook-scripts/</filename>
          subdirectory.  However, if you are unable to find one that
          meets your specific needs, you might consider writing your
          own.  See <xref linkend="svn.developer" /> for information
          about developing software using Subversion's public
          APIs.</para>
-->
        <para>Comme vous pouvez l'imaginer, il n'est pas concevable
          d'avoir un de procédures automatiques et de scripts divers
          qui ne soient librement accessibles que ce soit au sein de la
          communauté Subversion ou ailleurs. En fait, la distribution
          Subversion fournit plusieurs procédures automatiques utilisées
          un peu partout dans son répertoire
          <filename>tools/hook-scripts/</filename>.
          Cependant, si vous ne trouvez pas votre bonheur dans ce
          répertoire, vous pouvez écrire la vôtre. Lisez <xref
          linkend="svn.developer" /> pour obtenir des informations sur
          le développement d'applications utilisant l'API publique de
          Subversion.</para>

<!--
        <warning>
          <para>Hook scripts can do almost anything, but hook script
            authors should show restraint.  It might be tempting to,
            say, use hook scripts to automatically correct errors,
            shortcomings, or policy violations present in the files
            being committed.  Unfortunately, doing so can cause
            problems.  Subversion keeps client-side caches of certain
            bits of repository data, and if you change a commit
            transaction in this way, those caches become indetectably
            stale, leading to surprising and unexpected behavior.
            While it is generally okay to add new commit transaction
            properties via a hook script, essentially everything else
            about a commit transaction should be considered read-only.
            Instead of modifying a transaction to polish its payload,
            simply <emphasis>validate</emphasis> the transaction in
            the pre-commit hook and reject the
            commit if it does not meet the desired requirements.  As a
            bonus, your users will learn the value of careful,
            compliance-minded work habits.</para>
        </warning>
-->
        <warning>
          <para>les procédures automatiques sont capables de faire tout et
          n'importe quoi, mais leurs auteurs doivent faire preuve de
          modération. Il pourrait être tentant, disons, d'utiliser les
          procédures automatiques pour corriger automatiquement des erreurs,
          des coquilles ou des violations de la politique dans les fichiers
          propagés. Malheureusement, une telle action peut engendrer des
          problèmes. Subversion conserve en cache, côté client, certaines
          parties des données du dépôt et, si vous modifiez une transaction
          de propagation de cette façon, ces caches seront périmés sans que
          cela ne puisse être détecté. De telles incohérences peuvent
          aboutir à des comportements surprenants et inattendus. Autant il
          est généralement correct d'ajouter des propriétés de transaction
          par une procédure automatique, autant tout le reste dans une
          transaction de propagation doit être considéré comme en lecture
          seule. Au lieu de modifier une transaction pour la rendre plus
          policée, contentez-vous de <emphasis>vérifier</emphasis> la
          transaction dans la procédure automatique
          <literal>pre-commit</literal> et rejetez-la si elle ne remplit pas
          les conditions nécessaires. Entre autre avantages, vos utilisateurs
          prendront ainsi des habitudes de travail empreintes de respect des
          procédures et de qualité.</para>
        </warning>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.fsfs">
<!--
      <title>FSFS Configuration</title>
-->
      <title>Configuration de FSFS</title>

<!--
      <para>As of Subversion 1.6, FSFS filesystems have several
        configurable parameters which an administrator can use to
        fine-tune the performance or disk usage of their repositories.
        You can find these options&mdash;and the documentation for
        them&mdash;in the <filename>db/fsfs.conf</filename> file in
        the repository.</para>
-->
      <para>Avec Subversion 1.6, le système de fichiers FSFS possède
        plusieurs paramètres que l'administrateur peut configurer pour
        piloter finement les performances ou l'utilisation du disque
        de leurs dépôts. Vous pouvez trouver ces options (et leur
        documentation) dans le fichier <filename>db/fsfs.conf</filename>
        du dépôt.</para>

      <!-- TODO: Document the fsfs.conf options herein. -->

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
<!--
    <title>Repository Maintenance</title>
-->
    <title>Maintenance d'un dépôt</title>

<!--
    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>
-->
    <para>Assurer la maintenance d'un dépôt Subversion peut être
      intimidant, certainement parce que les systèmes qui comprennent
      une base de données sont complexes. Le faire bien est une question
      de maîtrise des outils &mdash; connaître leur fonction, quand les
      utiliser et comment. Cette section vous présente les outils
      fournis par Subversion pour assurer l'administration du dépôt et
      décrit leur maniement pour réaliser des opérations telles que
      migrations de données, mises à jour, sauvegardes et
      nettoyages.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
<!--
      <title>An Administrator's Toolkit</title>
-->
      <title>Boîte à outils de l'administrateur</title>

<!--
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your
        repository.  Let's look more closely at each of those
        tools.</para>
-->
      <para>Subversion fournit une poignée d'utilitaires pour créer,
        inspecter, modifier et réparer votre dépôt. Étudions de plus
        près chacun de ces outils.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

<!--
        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>
-->
        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>Le programme <command>svnadmin</command> est le
          meilleur ami de l'administrateur de dépôts. En plus de fournir
          la possibilité de créer des dépôts Subversion, ce programme
          vous permet d'effectuer de nombreuses opérations de
          maintenance sur ces dépôts. La syntaxe de
          <command>svnadmin</command> est similaire à celle des autres
          programmes en ligne de commande de Subversion&nbsp;:</para>

        <informalexample>
          <screen>
$ svnadmin help<!--
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS & OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin - -version' to see the program version and FS modules.

Available subcommands: -->
usage général : svnadmin SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnadmin help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnadmin --version' pour avoir la version et les modules de stockages.

Sous-commandes disponibles :
   crashtest
   create
   deltify
&hellip;
</screen>
        </informalexample>

<!--
        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>
-->
        <para>Au début de ce chapitre (dans <xref
          linkend="svn.reposadmin.basics.creating"/>), nous vous avons
          présenté la sous-commande <command>svnadmin create</command>.
          Beaucoup d'autres sous-commandes
          <command>svnadmin</command> sont couvertes plus loin dans ce
          chapitre. Vous pouvez également consulter <xref
          linkend="svn.ref.svnadmin" /> pour une liste complète des
          sous-commandes et des fonctionnalités qu'elles
          apportent.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

<!--
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>revisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          pre-commit hook) or that were just
          committed (in the case of the post-commit
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
-->
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>révisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> est un outil de
          Subversion pour examiner les différentes révisions et
          <firstterm>transactions</firstterm> (qui sont des révisions en
          cours de création) dans un dépôt. Aucune modification n'est
          faite au dépôt par cet outil. <command>svnlook</command>
          est généralement utilisé par les procédures automatiques du
          dépôt pour signaler les changements qui vont être propagés
          (dans le cas de la procédure automatique
          <literal>pre-commit</literal>) ou qui viennent d'être propagés
          (dans le cas de la procédure automatique
          <literal>post-commit</literal>). Un administrateur peut être
          amené à utiliser cet outil à des fins de diagnostic.</para>

<!--
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
-->
        <para>La syntaxe de <command>svnlook</command> est
          particulièrement simple&nbsp;:</para>

        <informalexample>
          <screen>
$ svnlook help<!--
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '- -revision' and '- -transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help <subcommand>' for help on a specific subcommand.
Type 'svnlook - -version' to see the program version and FS modules.-->
usage général : svnlook SOUS_COMMANDE CHEMIN_DÉPÔT [ARGS &amp; OPTIONS...]
Note : Quand --revision ou --transaction ne sont pas précisées, les sous-
       commandes qui en ont besoin utilisent la révision la plus récente.
Entrer 'svnlook help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnlook --version' pour avoir la version et les modules de stockage.
&hellip;
</screen>
        </informalexample>

<!--
        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>- -revision</option>
          (<option>-r</option>) and <option>- -transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>- -revision</option> (<option>-r</option>)
          and <option>- -transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>
-->
        <para>Beaucoup de sous-commandes <command>svnlook</command>
          peuvent être appliquées soit à une révision soit à une
          arborescence de transaction, affichant les informations à
          propos de l'arborescence elle-même ou les différences par
          rapport à la révision précédente du dépôt. Pour spécifier
          quelle révision ou quelle transaction examiner, utilisez
          respectivement les options <option>--revision</option>
          (<option>-r</option>) et <option>--transaction</option>
          (<option>-t</option>). En l'absence des options
          <option>--revision</option> (<option>-r</option>)
          ou <option>--transaction</option> (<option>-t</option>),
          <command>svnlook</command> examine la révision la plus
          récente (la révision <literal>HEAD</literal>) du dépôt.
          Ainsi, les deux commandes suivantes font exactement la même
          chose si la révision la plus récente du dépôt situé à
          l'emplacement <filename>/var/svn/depot</filename> porte le
          numéro 19&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19-->
$ svnlook info /var/svn/depot
$ svnlook info /var/svn/depot -r 19
</screen>
        </informalexample>

<!--
        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>
-->
        <para>Signalons une exception à ces règles concernant les
          sous-commandes&nbsp;: la sous-commande <command>svnlook
          youngest</command> ne prend aucune option et affiche
          simplement le numéro de la révision la plus récente du
          dépôt&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook youngest /var/svn/repos-->
$ svnlook youngest /var/svn/depot
19
$
</screen>
        </informalexample>

        <note>
<!--
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>- -revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
-->
          <para>Gardez à l'esprit que les seules transactions que vous
            pouvez examiner sont celles qui n'ont pas été propagées. La
            plupart des dépôts ne comportent pas de transactions de ce
            type parce que les transactions sont habituellement soit
            propagées (auquel cas vous devriez y avoir accès sous la
            forme de révisions <foreignphrase>via</foreignphrase>
            l'option <option>--revision</option>
            (<option>-r</option>)), soit annulées et supprimées.</para>
        </note>

<!--
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>
-->
        <para>La sortie de <command>svnlook</command> est conçue pour
          être à la fois lisible par un humain et analysable par une
          machine. Prenons, par exemple, la sortie de la sous-commande
          <command>svnlook info</command>&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
-->
$ svnlook info /var/svn/depot
sally
2002-11-04 09:29:13 -0600 (lun. 04 nov. 2002)
27
J'ai ajouté le traditionnel
Arbre grec.
$
</screen>
        </informalexample>

<!--
        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>
-->
        <para>La sortie de <command>svnlook info</command> est
          constituée des éléments suivants, par ordre
          d'apparition&nbsp;:</para>

        <orderedlist>
          <listitem>
<!--
            <para>The author, followed by a newline</para>
-->
            <para>L'auteur, suivi d'un passage à la ligne.</para>
          </listitem>
          <listitem>
<!--
            <para>The date, followed by a newline</para>
-->
            <para>La date, suivie d'un passage à la ligne.</para>
          </listitem>
          <listitem>
<!--
            <para>The number of characters in the log message,
              followed by a newline</para>
-->
            <para>Le nombre de caractères du commentaire de propagation,
              suivi d'un passage à la ligne.</para>
          </listitem>
          <listitem>
<!--
            <para>The log message itself, followed by a newline</para>
-->
            <para>Le commentaire de propagation lui-même, suivi d'un passage
              à la ligne.</para>
          </listitem>
        </orderedlist>

<!--
        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
-->
        <para>Cette sortie est lisible par un humain, ce qui veut dire
          que les éléments tels que la date sont représentés par du
          texte simple au lieu d'un obscur code (comme le nombre de
          nanosecondes depuis le passage aux nouveaux francs). Mais
          cette sortie est aussi analysable par une machine &mdash;
          parce que le commentaire de propagation peut comporter plusieurs
          lignes et n'est pas limité en taille,
          <command>svnlook</command> affiche la longueur du commentaire
          avant le commentaire lui-même. Cela permet aux scripts et autres
          utilitaires faisant appel à cette commande de
          prendre des décisions opportunes à propos du commentaire de
          propagation, comme savoir combien de mémoire allouer pour le
          commentaire ou au moins savoir combien d'octets sauter dans le cas
          où les données affichées par <command>svnlook</command> ne
          sont pas les dernières données du flux.</para>

<!--
        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>
-->
        <para><command>svnlook</command> peut répondre à un tas d'autres
          requêtes&nbsp;: afficher des sous-ensembles des informations
          précédemment citées, lister récursivement les arborescences
          suivies en versions des répertoires, lister les chemins
          modifiés lors de telle révision ou transaction, afficher les
          différences de contenu et de propriétés pour les fichiers et
          répertoires, &nbsp;etc. Reportez-vous à <xref
          linkend="svn.ref.svnlook" /> pour la liste complète des
          fonctionnalités offertes par
          <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

<!--
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>
-->
        <para>Bien que ce ne soit pas l'outil qu'un administrateur
          utilise le plus, <command>svndumpfilter</command> fournit une
          fonctionnalité d'un genre très particulier qui est d'une
          grande utilité&nbsp;: la possibilité de modifier rapidement
          et facilement des flux de l'historique du dépôt Subversion en
          agissant en tant que filtre sur les chemins.</para>

<!--
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
-->
        <para>La syntaxe de <command>svndumpfilter</command> est la
          suivante&nbsp;:</para>

        <informalexample>
          <screen>
$ svndumpfilter help<!--
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type 'svndumpfilter help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svndumpfilter - -version' to see the program version.

Available subcommands:-->
usage général : svndumpfilter SOUS_COMMANDE [ARGS &amp; OPTIONS ...]
Entrer 'svndumpfilter help &lt;sous-commande&gt;' pour l'aide spécifique.
Entrer 'svndumpfilter --version' pour avoir le numéro de version du programme.

Sous-commandes disponibles :
   exclude
   include
   help (?, h)
</screen>
        </informalexample>

<!--
        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>
-->
        <para>Il n'y a que deux sous-commandes intéressantes&nbsp;:
          <command>svndumpfilter exclude</command> et
          <command>svndumpfilter include</command>. Elles vous
          permettent de choisir entre l'inclusion implicite et
          l'inclusion explicite des chemins dans le flux. Vous en saurez
          plus sur ces sous-commandes et sur l'utilité si particulière
          de <command>svndumpfilter</command> plus loin dans ce
          chapitre, dans <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnrdump">
        <title>svnrdump</title>

<!--
        <para>The <command>svnrdump</command> program is, to put it
          simply, essentially just network-aware flavors of
          the <command>svnadmin dump</command> and <command>svnadmin
          load</command> subcommands, rolled up into a separate
          program.</para>
-->
        <para>Le programme <command>svnrdump</command> est, pour faire
          simple, essentiellement une variante qui fonctionne avec un
          réseau des sous-commandes <command>svnadmin dump</command> et
          <command>svnadmin load</command>.</para>

        <informalexample>
          <screen>
$ svnrdump help<!--
general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]
Type 'svnrdump help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnrdump - -version' to see the program version and RA modules.

Available subcommands:-->
usage général : svnrdump SOUS_COMMANDE DÉPÔT [-r BAS[:HAUT]]
Entrer 'svnrdump help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnrdump --version' pour la version et les modules d'accès (RA).

Sous-commandes disponibles :
   dump
   load
   help (?, h)

$
</screen>
        </informalexample>

<!--
        <para>We discuss the use of <command>svnrdump</command> and
          the aforementioned <command>svnadmin</command> commands
          later in this chapter (see
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>
-->
        <para>Nous entrerons dans le détail de l'utilisation des
          commandes <command>svnrdump</command> et
          <command>svnadmin</command> plus loin dans ce chapitre (voir
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

<!--
        <para>The <command>svnsync</command> program provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote><footnote><para>Or is that,
          the <quote>sync</quote>?</para></footnote> repositories may
          be on different computers from each other and
          from <command>svnsync</command> itself.</para>
-->
        <para>Le programme <command>svnsync</command> fournit toutes les
          fonctionnalités requises pour faire fonctionner un miroir en
          lecture seule d'un dépôt Subversion. Ce programme a une et une
          seule fonction&nbsp;: transférer l'historique d'un dépôt vers
          un autre dépôt. Et, bien qu'il y ait différentes manières de
          faire, sa force réside dans sa capacité de travailler à
          distance&nbsp;: les dépôts <quote>source</quote> et
          <quote>destination</quote> peuvent être sur deux ordinateurs
          différents et <command>svnsync</command> sur un
          troisième.</para>

<!--
        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>
-->
        <para>Comme vous vous en doutez, <command>svnsync</command>
          possède une syntaxe très proche des autres programmes déjà
          mentionnés dans ce chapitre&nbsp;:</para>

        <informalexample>
          <screen>
$ svnsync help<!--
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync - -version' to see the program version and RA modules.

Available subcommands:-->
usage général : svnsync SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnsync help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnsync --version' pour la version et les modules d'accès (RA).

Sous-commandes disponibles :
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)
$
</screen>
        </informalexample>

<!--
        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>
-->
        <para>Nous revenons en détail sur la réplication de dépôts avec
          <command>svnsync</command> plus loin dans ce chapitre (voir
          <xref linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

<!--
        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories use individual
          files to house information about each revision.  Sometimes
          these files all live in a single directory; sometimes they
          are sharded across many directories.</para>
-->
        <para>Bien qu'il ne fasse pas officiellement partie des outils
          Subversion, le script <command>fsfs-reshard.py</command>
          (situé dans le répertoire
          <filename>tools/server-side</filename> du code source de
          Subversion) est un outil particulièrement utile à
          l'administrateur pour optimiser les performances de dépôts
          Subversion utilisant un magasin de données FSFS. Les dépôts FSFS
          contiennent des fichiers qui décrivent les changements apportés
          dans chaque révision. Parfois ces
          fichiers sont conservés dans un même répertoire, parfois ils
          sont répartis (<foreignphrase>sharded</foreignphrase> en
          anglais, d'où le nom du script) dans plusieurs répertoires.</para>

<!--
        <para>The earliest FSFS release versions would house all the
          revision files within a single directory that grew&mdash;one
          file per revision&mdash;throughout the lifetime of your
          repository.  This created problems on systems which have
          hard limits on the number of files permitted in a given
          directory, and was a performance burden even on systems
          where such limits didn't exist or were set sufficiently
          high.</para>
-->
          <para>Les versions anciennes de FSFS contenaient tous les
            fichiers de révision dans un répertoire unique qui
            grandissait (un fichier par nouvelle révision) au fur et
            à mesure. Cela entrainait des problèmes sur les systèmes
            qui ont des limites fixées sur le nombre maximum de
            fichiers dans un répertoire et cela pouvait engendrer des
            chutes de performances sur certains systèmes.</para>
<!--

        <para>Beginning in version 1.5, Subversion creates FSFS-backed
          repositories using a slightly modified layout in which the
          contents of the revision files directory (and other
          always-growing directories)
          are <firstterm>sharded</firstterm>, or scattered across
          several subdirectories.  This can greatly reduce the time it
          takes the system to locate any one of these files, and
          therefore increases the overall performance of Subversion
          when reading from the repository.</para>
-->
          <para>>À partir de la version 1.5, Subversion crée des dépôts
            FSFS en utilisant une disposition légèrement modifiée dans
            laquelle le contenu du répertoire des fichiers de révisions
            est éparpillé (c'est-à-dire réparti dans plusieurs
            sous-répertoires). Cela peut réduire de manière considérable
            le temps nécessaire au système pour trouver n'importe quel
            fichier et ainsi améliore la performance globale de
            Subversion lors des lectures dans le dépôt.</para>
<!--

        <para>The number of files permitted to live in a given
          subdirectory is a configurable thing (though the defaults
          are reasonable ones for most known platforms), but changing
          that configuration after the repository has been in use for
          some time could cause Subversion to be unable to locate the
          files it is looking for.  That's
          where <command>fsfs-reshard.py</command> comes in.</para>
-->
          <para>Le nombre de fichiers autorisés dans un sous-répertoire
            donné est configurable (les valeurs par défaut sont toutefois
            raisonnables pour la plupart des plateformes connues), mais
            modifier cette configuration après que le dépôt a été utilisé
            depuis quelque temps peut empêcher Subversion de retrouver
            les fichiers qu'il cherche. C'est l'objet de la commande
            <command>fsfs-reshard.py</command>.</para>

<!--
        <para><command>fsfs-reshard.py</command> reshuffles the
          repository's file structure into a new arrangement that
          reflects the requested number of sharding subdirectories and
          updates the repository configuration to preserve this
          change.  When used in conjunction with the <command>svnadmin
          upgrade</command> command, this is especially useful for
          upgrading a pre-1.5 Subversion (unsharded) repository to the
          latest filesystem format and sharding its data files (which
          Subversion will not automatically do for you).  This script
          can also be used for fine-tuning an already sharded
          repository.</para>
-->
        <para><command>fsfs-reshard.py</command> remanie la structure du
          dépôt pour se conformer au nombre de sous-répertoires demandés
          et met à jour la configuration du dépôt pour conserver cette
          modification. Utilisé en combinaison avec <command>svnadmin
          upgrade</command> , c'est particulièrement utile pour
          convertir un dépôt Subversion pre-1.5 vers le dernier schéma
          réparti de Subversion (ce que Subversion ne fait pas
          automatiquement pour vous). Vous pouvez aussi ajuster finement
          cette valeur dans un dépôt déjà réparti.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
<!--
      <title>Commit Log Message Correction</title>
-->
      <title>Correction des commentaires de propagation</title>
<!--
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        pre-revprop-change hook; see
        <xref linkend="svn.reposadmin.hooks" />) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>
-->
      <para>Il arrive qu'un utilisateur se trompe dans son commentaire de
        propagation (une faute d'orthographe ou une coquille, par
        exemple). Si le dépôt est configuré (en utilisant la procédure
        automatique <literal>pre-revprop-change</literal>, voir <xref
        linkend="svn.reposadmin.hooks"/>) pour accepter les
        modifications de ce commentaire après la fin de la propagation,
        l'utilisateur peut corriger son commentaire à distance en utilisant
        <command>svn propset</command> (voir <xref
        linkend="svn.ref.svn.c.propset"/>). Cependant, en raison de la
        possibilité de perte d'information irrémédiable, les dépôts
        Subversion ne sont pas configurés, par défaut, pour autoriser
        les modifications de propriétés non suivies en versions &mdash;
        sauf de la part d'un administrateur.</para>

<!--
      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
-->
      <para>Si un administrateur est amené à changer un commentaire de
        propagation, il peut le faire avec <command>svnadmin
        setlog</command>. Cette commande change le commentaire de
        propagation (la propriété <literal>svn:log</literal>) d'une
        révision donnée du dépôt, la nouvelle valeur étant lue dans un
        fichier.</para>

      <informalexample>
        <screen><!--
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
-->
$ echo "Voici le nouveau commentaire de propagation, en version corrigée" &gt; nouveau-commentaire.txt
$ svnadmin setlog mon-depot nouveau-commentaire.txt -r 388
</screen>
      </informalexample>

<!--
      <para>The <command>svnadmin setlog</command> command, by
        default, is still bound by the same protections against
        modifying unversioned properties as a remote client
        is&mdash;the pre-revprop-change and
        post-revprop-change hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>- -bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
-->
      <para>La commande <command>svnadmin setlog</command>, par défaut,
        possède les mêmes garde-fous pour empêcher de modifier des
        propriétés non suivies en versions qu'un client distant (les
        procédures automatiques <literal>pre-revprop-change</literal> et
        <literal>post-revprop-change</literal> sont toujours activées et
        doivent donc être configurées afin d'accepter ce type de
        changement. Mais un administrateur peut contourner ces
        protections en passant l'option <option>--bypass-hooks</option>
        à la commande <command>svnadmin setlog</command>.</para>

      <warning>
<!--
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
-->
        <para>Souvenez-vous cependant que, en contournant les procédures
          automatiques, vous êtes susceptible de ne pas activer
          certaines actions telles que la notification par email du
          changement des propriétés, la sauvegarde par les systèmes qui
          surveillent les propriétés non suivies en versions,&nbsp;etc.
          En d'autres termes, faites particulièrement attention aux
          changements que vous apportez et à la manière dont vous le
          faites.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
<!--
      <title>Managing Disk Space</title>
-->
      <title>Gestion de l'espace disque</title>

<!--
      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>
-->
      <para>Bien que le coût de stockage ait diminué de manière
        drastique ces dernières années, l'utilisation de l'espace disque
        reste une des préoccupations de l'administrateur qui doit suivre
        en versions de grandes quantités de données. Chaque élément de
        l'historique de chaque donnée stockée dans un dépôt actif doit
        être sauvegardé ailleurs, peut-être même de nombreuses fois dans
        le cas de sauvegardes tournantes. Il est utile de savoir quelles
        données d'un dépôt Subversion doivent rester sur le site de
        production, lesquelles doivent être sauvegardées et lesquelles
        peuvent être supprimées sans risque.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
<!--
        <title>How Subversion saves disk space</title>
-->
        <title>Économie d'espace disque</title>

<!--
        <para>
          <indexterm>
            <primary>deltification</primary>
          </indexterm>To keep the repository small, Subversion uses
          <firstterm>deltification</firstterm> (or delta-based storage)
          within the repository itself.  Deltification involves
          encoding the representation of a chunk of data as a
          collection of differences against some other chunk of data.
          If the two pieces of data are very similar, this
          deltification results in storage savings for the deltified
          chunk&mdash;rather than taking up space equal to the size of
          the original data, it takes up only enough space to
          say, <quote>I look just like this other piece of data over
          here, except for the following couple of changes.</quote>
          The result is that most of the repository data that tends to
          be bulky&mdash;namely, the contents of versioned
          files&mdash;is stored at a much smaller size than the
          original full-text representation of that data.</para>
-->
        <para>
          <indexterm>
            <primary>différenciation</primary>
          </indexterm>Pour garder un dépôt petit, Subversion utilise la
          <firstterm>différenciation</firstterm> (ou <quote>stockage
          différentiel</quote>) à l'intérieur du dépôt lui-même. La
          différenciation implique l'encodage de la représentation d'un
          groupe de données sous la forme d'un ensemble de différences
          par rapport à un autre groupe de données. Si les deux groupes
          de données sont très similaires, la différenciation économise
          de l'espace pour le groupe différencié &mdash; au lieu de
          prendre le même espace que les données originales, le groupe
          occupe juste l'espace nécessaire pour dire&nbsp;: <quote>je
          ressemble à l'autre groupe de données là-bas, sauf pour les
          deux ou trois changements qui suivent</quote>. Au final,
          l'espace occupé par l'ensemble des données du dépôt
          (c'est-à-dire le contenu des fichiers suivis en versions) est
          beaucoup plus petit que la représentation textuelle originale
          de ces données.</para>

<!--
        <para>
          <indexterm>
            <primary>representation sharing</primary>
          </indexterm>While deltified storage has been a part of Subversion's
          design since the very beginning, there have been additional
          improvements made over the years.  Subversion repositories
          created with Subversion 1.4 or later benefit from
          compression of the full-text representations of file
          contents.  Repositories created with Subversion 1.6 or later
          further enjoy the disk space savings afforded by
          <firstterm>representation sharing</firstterm>, a feature
          which allows multiple files or file revisions with identical
          file content to refer to a single shared instance of that data
          rather than each having their own distinct copy thereof.</para>
-->
        <para>
          <indexterm>
            <primary>partage de représentation</primary>
          </indexterm>Le stockage sous forme différenciée a fait partie
            de l'architecture conceptuelle de Subverson dès le début de
            sa conception&nbsp;; et il a subi des améliorations au cours
            des ans. Les dépôts créés avec la version 1.4 ou ultérieure
            de Subversion bénéficient de la compression du contenu des
            fichiers <quote>pleins-textes</quote>. Les dépôts créés
            avec la version 1.6 ou ultérieure de Subversion économisent
            davantage d'espace disque grace au <firstterm>partage de
            représentation</firstterm>, une fonctionnalité qui permet
            à plusieurs fichiers ou révisions de fichiers dont le
            contenu est identique de faire référence à une seule
            instance partagée de ce contenu plutôt que chacun n'en
            conserve sa propre copie.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
<!--
        <title>Removing dead transactions</title>
-->
        <title>Suppression des transactions mortes</title>

<!--
        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>
-->
        <para>Bien que rares, il y a des circonstances dans lesquelles
          le déroulement d'une propagation Subversion peut mal se
          terminer, laissant derrière elle dans le dépôt des restes de
          cette tentative de propagation&nbsp;: une transaction
          inachevée et toutes les modifications de fichiers et de
          répertoires associées. Il peut y avoir plusieurs raisons à cet
          échec&nbsp;: l'utilisateur a peut-être brutalement interrompu
          l'opération côté client ou bien une coupure réseau s'est
          peut-être produite au milieu de l'opération. Quoi qu'il en
          soit, des transactions mortes peuvent apparaître. Elles ne
          sont pas dangereuses mais elles consomment inutilement de
          l'espace disque. Un administrateur consciencieux se doit
          néanmoins de les supprimer.</para>

<!--
        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>
-->
        <para>Vous pouvez utiliser la commande <command>svnadmin
          lstxns</command> pour obtenir la liste des noms des
          transactions non encore réglées&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnadmin lstxns myrepos -->
$ svnadmin lstxns mon-depot
19
3a1
a45
$
</screen>
        </informalexample>

<!--
        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>- -transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>
-->
        <para>Chaque élément de la sortie de cette commande peut être
          passé en argument de <command>svnlook</command> (avec l'option
          <option>--transaction</option> (<option>-t</option>))
          pour déterminer qui est à l'origine de la transaction, quand
          elle a eu lieu et quels types de changements ont été effectués
          &mdash; ces informations sont très utiles pour savoir si on
          peut supprimer la transaction sans arrière pensée&nbsp;! Si
          vous décidez effectivement de supprimer la transaction, son
          nom peut être passé à <command>svnadmin rmtxns</command> qui
          fera le nettoyage adéquat. En fait, <command>svnadmin
          rmtxns</command> peut directement prendre en entrée la sortie
          de <command>svnadmin lstxns</command>&nbsp;!</para>

        <informalexample>
          <screen> <!--
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos` -->
$ svnadmin rmtxns mon-depot `svnadmin lstxns mon-depot`
$
</screen>
        </informalexample>

<!--
        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>
-->
        <para>Si vous utilisez ces deux sous-commandes ainsi, vous
          devriez envisager de rendre votre dépôt temporairement
          indisponible pour les clients. De cette manière, personne ne
          peut initier une transaction légitime avant que le nettoyage
          n'ait commencé. L'exemple <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contient quelques lignes de script shell qui peuvent produire
          les informations relatives à chaque transaction inachevée de
          votre dépôt.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1"><!--
          <title>txn-info.sh (reporting outstanding transactions)</title>
-->
          <title>txn-info.sh (lister les transactions inachevées)</title>

<!--
          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do
  echo "- -[ Transaction ${TXN} ]- - - - - - - - - - - - - - - - - - - - - -"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
-->
          <programlisting>
#!/bin/sh

### Produit les informations relatives à toutes les transactions
### inachevées d'un dépôt Subversion

DEPOT="${1}"
if [ "x$DEPOT" = x ] ; then
  echo "utilisation: $0 CHEMIN_VERS_LE_DEPOT"
  exit
fi

for TXN in `svnadmin lstxns ${DEPOT}`; do
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${DEPOT}" -t "${TXN}"
done
</programlisting>
        </example>

<!--
        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>
-->
        <para>La sortie produite par ce script est, en bref, la
          concaténation des différents groupes d'informations fournis
          par <command>svnlook info</command> (voir <xref
          linkend="svn.reposadmin.maint.tk.svnlook"/>) et ressemble à
          ceci&nbsp;:</para>

<!--
        <informalexample>
          <screen>
$ txn-info.sh myrepos
- -[ Transaction 19 ]- - - - - - - - - - - - - - - - - - - - - -
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
- -[ Transaction 3a1 ]- - - - - - - - - - - - - - - - - - - - - -
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
- -[ Transaction a45 ]- - - - - - - - - - - - - - - - - - - - - -
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ txn-info.sh mon-depot
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (mar. 04 sep. 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (lun. 10 sep. 2001)
39
Tentative de propagation dans un réseau capricieux
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (mer. 12 sep. 2001)
0
$
</screen>
        </informalexample>

<!--
        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>
-->
        <para>Une transaction initiée depuis longtemps correspond en
          général à une propagation qui a été interrompue ou qui a
          échoué. L'horodatage de la transaction peut fournir des
          informations intéressantes &mdash; par exemple, quelle est la
          probabilité qu'une transaction commencée il y a neuf mois soit
          toujours active&nbsp;?</para>

<!--
        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>
-->
        <para>En résumé, la décision de supprimer une transaction ne
          doit pas être prise à la légère. D'autres sources
          d'informations (comme les journaux d'Apache sur les erreurs et
          les accès, les journaux opérationnels de Subversion,
          l'historique des révisions Subversion,&nbsp;etc.) peuvent
          aider à la prise de décision. Et bien sûr, l'administrateur
          peut toujours entrer en contact (par email, par exemple) avec
          l'auteur d'une transaction qui semble abandonnée pour vérifier
          que c'est bien le cas.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.fsfspacking">
<!--
        <title>Packing FSFS filesystems</title>
-->
        <title>Tasser le système de fichiers FSFS</title>

<!--
        <para>FSFS repositories contain files that describe the
          changes made in a single revision, and files that contain
          the revision properties associated with a single revision.
          Repositories created in versions of Subversion prior to 1.5
          keep these files in two directories&mdash;one for each type
          of file.  As new revisions are committed to the repository,
          Subversion drops more files into these two
          directories&mdash;over time, the number of these files in
          each directory can grow to be quite large.  This has been
          observed to cause performance problems on certain
          network-based filesystems.</para>
-->
        <para>Les dépôts FSFS contiennent des fichiers de révision
          qui décrivent, pour chaque révision, les modifications
          apportées et les propriétés de la révision concernée.
          Les dépôts créés avec des versions de Subversion antérieures
          à 1.5 gardent ces fichiers dans deux dossiers (un dossier
          pour chaque type de fichier). Au fur et à mesure que les
          révisions sont propagées dans le dépôt, Subversion dépose
          autant de fichiers dans ces dossiers. Avec le temps, le
          nombre de fichiers dans chaque dossier peut se révéler
          relativement important. Cela peut être la cause de chutes
          de performances sur certains systèmes de fichiers
          réseaux.</para>

<!--
        <para>The first problem is that the operating system has to
          reference many different files over a short period of time.
          This leads to inefficient use of disk caches and, as a
          result, more time spent seeking across large disks.  Because
          of this, Subversion pays a performance penalty when
          accessing your versioned data.</para>
-->
        <para>Le premier problème est que le système d'exploitation doit
          référencer ces fichiers sur une courte période de temps. Cela
          conduit à une mauvaise utilisation du cache disque et, en
          conséquence, à plus de temps pour les recherches sur les gros
          disques. C'est pour cette raison que Subversion est pénalisé
          lorsqu'il accède à vos données suivies en versions.</para>

<!--
        <para>The second problem is a bit more subtle.  Because of the
          ways that most filesystems allocate disk space, each file
          claims more space on the disk than it actually uses.  The
          amount of extra space required to house a single file can
          average anywhere from 2 to 16 kilobytes <emphasis>per
          file</emphasis>, depending on the underlying
          filesystem in use.  This translates directly
          into a per-revision disk usage penalty for FSFS-backed
          repositories.  The effect is most pronounced in repositories
          which have many small revisions, since the overhead involved
          in storing the revision file quickly outgrows the size of
          the actual data being stored.</para>
-->
        <para>Le deuxième problème est un peu plus subtil. En raison de
          la manière dont la plupart des systèmes de fichiers allouent
          l'espace disque, chaque fichier utilise sur le disque plus de
          place qu'il n'en prend réellement. Cette quantité d'espace
          disque nécessaire pour stocker un seul fichier peut atteindre
          de 2 à 16 kilooctets <emphasis>par fichier</emphasis>, en
          fonction du type de système de fichiers. Cela se traduit
          directement par un gachis d'espace disque à chaque révision
          pour les dépôts FSFS. L'effet est d'autant plus sensible pour
          les dépôts qui ont de petites révisions, puisque le surplus
          d'espace nécessaire pour stocker le fichier de révision
          dépasse rapidement la taille des données effectivement
          stockées.</para>

<!--
        <para>To solve these problems, Subversion 1.6 introduced the
          <command>svnadmin pack</command> command.  By concatenating
          all the files of a completed shard into a single <quote>pack</quote> file
          and then removing the original per-revision
          files, <command>svnadmin pack</command> reduces the file
          count within a given shard down to just a single file.  In
          doing so, it aids filesystem caches and reduces (to one) the
          number of times a file storage overhead penalty is
          paid.</para>
-->
        <para>Afin de résoudre ce problème, Subversion 1.6 introduit la
          commande <command>svnadmin pack</command>. En
          <quote>tassant</quote> (<foreignphrase>pack</foreignphrase> en
          anglais) tous les fichiers d'un dépôt fragmenté dans un seul
          fichier et en supprimant les fichiers correspondants à chaque
          révision, <command>svnadmin pack</command> remplace la
          fragmentation par un seul fichier. Ainsi,le cache
          du système de fichiers est plus performant et le temps d'accès
          aux fichiers est réduit.</para>

<!--
        <para>Subversion can pack existing sharded repositories which
          have been upgraded to the 1.6 filesystem format or later (see
          <xref linkend="svn.ref.svnadmin.c.upgrade"/>) in
          <xref linkend="svn.ref.svnadmin"/>.  To do so, just
          run <command>svnadmin pack</command> on the
          repository:</para>
-->
        <para>Subversion peut tasser des dépôts fragmentés qui ont été
          mis à niveau vers le système de fichiers 1.6 ou ultérieur
          (voir <xref linkend="svn.ref.svnadmin.c.upgrade"/> dans
          <xref linkend="svn.ref.svnadmin"/>). Pour le faire, lancez
          simplement  <command>svnadmin pack</command> sur le
          dépôt:</para>

        <informalexample>
          <screen> <!--
$ svnadmin pack /var/svn/repos -->
$ svnadmin pack /var/svn/depot
Packing shard 0...done.
Packing shard 1...done.
Packing shard 2...done.
&hellip;
Packing shard 34...done.
Packing shard 35...done.
Packing shard 36...done.
$
</screen>
        </informalexample>

<!--
        <para>Because the packing process obtains the required locks
          before doing its work, you can run it on live repositories,
          or even as part of a post-commit hook.  Repacking packed
          shards is legal, but will have no effect on the disk usage
          of the repository.</para>
-->
        <para>Comme le processus de tassage obtient les verrous
          nécessaires avant de faire son travail, vous pouvez lancer la
          commande sur un dépôt en service, ou même comme action dans la
          procédure automatique <literal>post-commit</literal>. Tasser
          un dépôt déjà tassé est autorisé, mais n'aura aucun effet sur
          l'utilisation de l'espace disque par le dépôt.</para>

<!--
        <para><command>svnadmin pack</command> has no effect on
          BDB-backed Subversion repositories.</para>
-->
        <para>La commande <command>svnadmin pack</command> n'a aucun
          effet sur un dépôt BDB.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
<!--
      <title>Migrating Repository Data Elsewhere</title>
-->
      <title>Migration des données d'un dépôt</title>
<!--
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>
-->
      <para>Un système de fichiers Subversion a ses données réparties
        dans les fichiers du dépôt d'une manière que seuls les
        développeurs Subversion eux-mêmes comprennent (et s'y
        intéressent). Il peut cependant y avoir des circonstances qui
        obligent à copier ou déplacer l'ensemble (ou une partie) des
        données d'un dépôt à un autre.</para>

<!--
      <para>
        <indexterm>
          <primary>repository dump streams</primary>
        </indexterm>
        <indexterm>
          <primary>dump files</primary>
          <see>repository dump streams</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands, respectively,
        and the <command>svnrdump</command> program.</para>
-->
      <para>
        <indexterm>
          <primary>flux de déchargement d'un dépôt</primary>
        </indexterm>
        <indexterm>
          <primary>fichiers dump</primary>
          <see>flux de déchargement d'un dépôt</see>
        </indexterm>
        <indexterm>
          <primary>dump</primary>
          <see>flux de déchargement d'un dépôt</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion fournit cette fonctionnalité par le biais
        des <firstterm>flux de déchargement du dépôt</firstterm>. Un
        flux de déchargement de dépôt (<quote>fichier dump</quote> ou
        <foreignphrase>dump file</foreignphrase> en anglais, quand il
        est stocké dans un fichier sur le disque) est un format de
        fichier portable, contenant des données brutes, qui décrit les
        différentes révisions de votre dépôt &mdash; ce qui a été
        modifié, par qui, quand,&nbsp;etc. Ce fichier dump est le
        principal mécanisme utilisé pour réorganiser des historiques de
        versions &mdash; en partie ou en totalité, avec ou sans
        modification &mdash; entre des dépôts. Et Subversion fournit les
        outils nécessaires à la création et au chargement de ces
        fichiers dump&nbsp;: les sous-commandes <command>svnadmin
        dump</command> et <command>svnadmin load</command>
        respectivement.</para>

      <warning>
<!--
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
-->
        <para>Bien que le format des fichiers dump de Subversion
          contienne des parties lisibles par les humains et une
          structure familière (elle ressemble au format décrit par la
          RFC 822, utilisé pour la plupart des emails), <emphasis>ce
          n'est pas </emphasis> un format de fichier purement textuel.
          C'est un format de fichier binaire, très sensible aux
          modifications faites à son contenu. Par exemple, de nombreux
          éditeurs de textes corrompent le fichier en convertissant
          les caractères de fin de ligne.</para>
      </warning>

<!--
      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>
-->
      <para>Il existe de nombreuses raisons de décharger et recharger
        les données d'un dépôt Subversion. Aux premiers temps de
        Subversion, la principale raison était l'évolution de Subversion
        lui-même. Au fur et à mesure que Subversion gagnait en maturité,
        des changements faits sur les schémas des magasins de données
        sous-jacents entraînaient des problèmes de compatibilité avec
        les versions précédentes du dépôt, ce qui obligeait les
        utilisateurs à décharger les données de leurs dépôts en
        utilisant la version précédente de Subversion puis à recharger
        ces données dans un dépôt tout neuf créé avec la nouvelle
        version de Subversion. Il n'y a pas eu de changement de schéma
        de ce type depuis la version 1.0 de Subversion et les
        développeurs ont promis de ne pas forcer les utilisateurs à
        décharger et recharger leurs dépôts lors du passage d'une
        version mineure à une autre (par exemple entre la
        version 1.3 et la version 1.4) de Subversion. Mais il existe
        néanmoins des raisons de décharger et recharger ses données,
        comme le redéploiement d'un dépôt Berkeley DB sur un nouveau
        système d'exploitation ou sur une architecture CPU différente,
        la migration du magasin de données de Berkeley DB à FSFS et
        réciproquement ou (comme nous le voyons dans ce chapitre à <xref
        linkend="svn.reposadmin.maint.filtering" />) la purge de données
        suivies en version de l'historique du dépôt.</para>

<!--
      <note>
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      </note>
-->
      <note>
        <para>Le format de déchargement des dépôts Subversion ne décrit
          que l'évolution des éléments suivis en version. Il ne contient
          pas d'information sur les transactions inachevées, les verrous
          utilisateurs sur les chemins du système de fichiers, la
          configuration personnalisée du dépôt ou du serveur (y compris
          les procédures automatiques) et ainsi de suite.</para></note>

<!--
      <para>The Subversion repository dump format also enables
        conversion from a different storage mechanism or version
        control system altogether.  Because the dump file format is,
        for the most part, human-readable, it should be relatively
        easy to describe generic sets of changes&mdash;each of which
        should be treated as a new revision&mdash;using this file
        format.  In fact, the <command>cvs2svn</command> utility (see
        <xref linkend="svn.forcvs.convert" />) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>
-->
      <para>Le format de déchargement des dépôts permet la conversion
        depuis un système de stockage différent ou depuis un autre
        système de gestion de versions. Comme le format du fichier est,
        pour sa plus grande partie, lisible par un humain, il doit être
        relativement facile de décrire des ensembles de modifications
        génériques (chacun étant traité comme une nouvelle révision) en
        utilisant ce format de fichier. En fait, l'utilitaire
        <command>cvs2svn</command> (voir <xref
        linkend="svn.forcvs.convert" />) utilise le format dump pour
        décrire le contenu d'un dépôt CVS afin de pouvoir le copier dans
        un dépôt Subversion.</para>

<!--
      <para>For now, we'll concern ourselves only with migration of
        repository data between Subversion repositories, which we'll
        describe in detail in the sections which follow.</para>
-->
      <para>Pour le moment, nous nous concentrons sur la migration de
        données d'un dépôt entre différents dépôts Subversion et cela
        fait l'objet des sections qui suivent.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnadmin">
<!--
        <title>Repository data migration using svnadmin</title>
-->
        <title>Migration des données d'un dépôt à l'aide de svnadmin</title>

<!--
        <para>Whatever your reason for migrating repository history,
          using the <command>svnadmin dump</command> and
          <command>svnadmin load</command> subcommands is
          straightforward.  <command>svnadmin dump</command> will output
          a range of repository revisions that are formatted using
          Subversion's custom filesystem dump format.  The dump format
          is printed to the standard output stream, while informative
          messages are printed to the standard error stream.  This
          allows you to redirect the output stream to a file while
          watching the status output in your terminal window.  For
          example:</para>
-->
        <para>Quelle que soit la raison pour laquelle vous voulez migrer
          votre historique de dépôt, l'utilisation des sous-commandes
          <command>svnadmin dump</command> et <command>svnadmin
          load</command> est simplissime. <command>svnadmin
          dump</command> affiche un intervalle de révisions du dépôt,
          chacune utilisant le format des fichiers dump Subversion. Le
          fichier dump est envoyé sur la sortie standard tandis que les
          messages d'information sont envoyés sur la sortie d'erreur.
          Ceci vous permet de rediriger le flux standard vers un fichier
          tout en visualisant ce qui se passe dans votre terminal. Par
          exemple&nbsp;:</para>

<!--
        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnlook youngest mon-depot
26
$ svnadmin dump mon-depot &gt; fichier-dump
* Révision 0 déchargée.
* Révision 1 déchargée.
* Révision 2 déchargée.
&hellip;
* Révision 25 déchargée.
* Révision 26 déchargée.
</screen>
        </informalexample>

<!--
        <para>At the end of the process, you will have a single file
          (<filename>dumpfile</filename> in the previous example) that
          contains all the data stored in your repository in the
          requested range of revisions.  Note that <command>svnadmin
          dump</command> is reading revision trees from the repository
          just like any other <quote>reader</quote> process would
          (e.g., <command>svn checkout</command>), so it's safe
          to run this command at any time.</para>
-->
        <para>À la fin de la procédure, vous obtiendrez un fichier
          unique (<filename>fichier-dump</filename> dans l'exemple
          précédent) qui contient toutes les données stockées dans votre
          dépôt pour l'intervalle de révisions demandé. Notez que
          <command>svnadmin dump</command> lit les arborescences des
          révisions du dépôt de la même manière que tout autre processus
          <quote>lecteur</quote> (par exemple <command>svn
          checkout</command>), vous pouvez donc sans risque lancer cette
          commande à n'importe quel moment.</para>

<!--
        <para>The other subcommand in the pair, <command>svnadmin
          load</command>, parses the standard input stream as a
          Subversion repository dump file and effectively replays those
          dumped revisions into the target repository for that
          operation.  It also gives informative feedback, this time
          using the standard output stream:</para>
-->
        <para>La commande jumelle, <command>svnadmin load</command>,
          recherche dans l'entrée standard la structure d'un fichier
          dump Subversion puis insère les révisions déchargées dans le
          dépôt de destination spécifié. Elle fournit elle aussi des
          informations sur le déroulement de l'opération, cette fois en
          utilisant la sortie standard&nbsp;:</para>

<!--
        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
- - - - Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

- - - - Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

- - - - Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

- - - - Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnadmin load nouveau-depot &lt; fichier-dump
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
       * édition du chemin : A ... fait.
       * édition du chemin : A/B ... fait.
       &hellip;
  ------- Révision 1 propagée (commit) &gt;&gt;&gt;

  &lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 2
       * édition du chemin : A/mu ... fait.
       * édition du chemin : A/D/G/rho ... fait.

  ------- Révision 2 propagée (commit) &gt;&gt;&gt;

  &hellip;

  &lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 25
       * édition du chemin : A/D/gamma ... fait.

  ------- Révision 25 propagée (commit) &gt;&gt;&gt;

  &lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 26
       * édition du chemin : A/Z/zeta ... fait.
       * édition du chemin : A/mu ... fait.

  ------- Révision 26 propagée (commit) &gt;&gt;&gt;
</screen>
        </informalexample>

<!--
        <para>The result of a load is new revisions added to a
          repository&mdash;the same thing you get by making commits
          against that repository from a regular Subversion client.
          Just as in a commit, you can use hook programs to perform
          actions before and after each of the commits made during a
          load process.  By passing the
          <option>- -use-pre-commit-hook</option> and
          <option>- -use-post-commit-hook</option> options to
          <command>svnadmin load</command>, you can instruct
          Subversion to execute the pre-commit and post-commit hook
          programs, respectively, for each loaded revision.  You might
          use these, for example, to ensure that loaded revisions pass
          through the same validation steps that regular commits pass
          through.  Of course, you should use these options with
          care&mdash;if your post-commit hook sends emails to a
          mailing list for each new commit, you might not want to spew
          hundreds or thousands of commit emails in rapid succession
          at that list!  You can read more about the use of hook
          scripts in <xref linkend="svn.reposadmin.hooks" />.</para>
-->
        <para>Le résultat d'un chargement est l'ajout de nouvelle
          révisions à un dépôt &mdash; comme si vous faisiez des
          propagations vers ce dépôt avec un client Subversion
          classique. De la même manière que pour une propagation, vous
          pouvez utiliser les procédures automatiques pour effectuer des
          actions particulières avant et après chaque propagation faite
          par la procédure de chargement. En passant les options
          <option>--use-pre-commit-hook</option> et
          <option>--use-post-commit-hook</option> (respectivement) à
          <command>svnadmin load</command>, vous demandez à Subversion
          d'exécuter les procédures automatiques
          <literal>pre-commit</literal> et
          <literal>post-commit</literal> (respectivement) pour chaque
          révision chargée. Un exemple d'utilisation de ces options est
          de s'assurer que les révisions chargées passent par les mêmes
          étapes de validation qu'une propagation normale. Bien sûr,
          utilisez ces options avec prudence &mdash; si votre
          procédure automatique <literal>post-commit</literal> envoie
          des emails à une liste de diffusion pour chaque nouvelle
          propagation, vous ne voulez peut-être pas envoyer des
          centaines voire des milliers d'emails de notification à la
          suite vers cette liste&nbsp;! Vous pouvez en apprendre
          davantage sur l'utilisation des procédures automatiques dans
          <xref linkend="svn.reposadmin.hooks"/>.</para>

<!--
        <para>Note that because <command>svnadmin</command> uses
          standard input and output streams for the repository dump and
          load processes, people who are feeling especially saucy can try
          things such as this (perhaps even using different versions of
          <command>svnadmin</command> on each side of the pipe):</para>
-->
        <para>Notez que puisque <command>svnadmin</command> utilise
          l'entrée et la sortie standards pour le déchargement et le
          rechargement, les administrateurs les plus intrépides peuvent
          tenter des choses du genre (peut-être même en utilisant
          différentes versions de <command>svnadmin</command> de chaque
          côté de la barre verticale <literal>|</literal>)&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos -->
$ svnadmin create nouveau-depot
$ svnadmin dump vieux-depot | svnadmin load nouveau-depot
</screen>
        </informalexample>

<!--
        <para>By default, the dump file will be quite large&mdash;much
          larger than the repository itself.  That's because by default
          every version of every file is expressed as a full text in the
          dump file.  This is the fastest and simplest behavior, and
          it's nice if you're piping the dump data directly into some other
          process (such as a compression program, filtering program, or
          loading process).  But if you're creating a dump file
          for longer-term storage, you'll likely want to save disk space
          by using the <option>- -deltas</option> option.  With this
          option, successive revisions of files will be output as
          compressed, binary differences&mdash;just as file revisions
          are stored in a repository.  This option is slower, but it
          results in a dump file much closer in size to the original
          repository.</para>
-->
        <para>Par défaut, un fichier dump prend beaucoup de place
         (beaucoup plus que le dépôt lui-même). C'est parce que, par
          défaut, chaque version de chaque fichier est écrite en entier
          dans le fichier dump. C'est le comportement le plus simple et
          le plus rapide et cela convient bien si vous redirigez le flux
          de données directement vers un autre processus (comme un
          programme de compression, de filtrage ou de chargement). Mais
          si vous créez un fichier dump dans une optique de stockage à
          long terme, vous voudrez sans doute économiser de l'espace
          disque en utilisant l'option <option>--deltas</option>. Avec
          cette option, les révisions successives des fichiers sont
          écrites en tant que différences binaires et compressées (de la
          même manière que pour le stockage des fichiers dans le dépôt).
          Cette option ralentit le processus mais le fichier résultant a
          une taille beaucoup plus proche de celle du dépôt
          original.</para>

<!--
        <para>We mentioned previously that <command>svnadmin
          dump</command> outputs a range of revisions.  Use the
          <option>- -revision</option> (<option>-r</option>) option to
          specify a single revision, or a range of revisions, to dump.
          If you omit this option, all the existing repository revisions
          will be dumped.</para>
-->
        <para>Nous avons mentionné auparavant que <command>svnadmin
          dump</command> affiche un intervalle de révisions. Pour
          spécifier une révision unique ou un intervalle à décharger,
          utilisez l'option <option>--revision</option>
          (<option>-r</option>). Si vous omettez cette option, toutes
          les révisions existantes sont affichées&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile -->
$ svnadmin dump mon-depot -r 23 &gt; rev-23.fichier-dump
$ svnadmin dump mon-depot -r 100:200 &gt; revs-100-200.fichier-dump
</screen>
        </informalexample>

<!--
        <para>As Subversion dumps each new revision, it outputs only
          enough information to allow a future loader to re-create that
          revision based on the previous one.  In other words, for any
          given revision in the dump file, only the items that were
          changed in that revision will appear in the dump.  The only
          exception to this rule is the first revision that is dumped
          with the current <command>svnadmin dump</command>
          command.</para>
-->
        <para>Au fur et à mesure que Subversion décharge chaque nouvelle
          révision, il n'affiche que le minimum d'informations
          nécessaire à un futur chargement pour re-générer la révision à
          partir de la précédente. En d'autres termes, pour n'importe
          quelle révision du fichier dump, seuls les éléments ayant subi
          une modification dans cette révision apparaissent dans le
          fichier dump. La seule exception à cette règle concerne la
          première  révision qui est déchargée par la commande
          <command>svnadmin dump</command> courante.</para>

<!--
        <para>By default, Subversion will not express the first dumped
          revision as merely differences to be applied to the previous
          revision.  For one thing, there is no previous revision in the
          dump file!  And second, Subversion cannot know the state of
          the repository into which the dump data will be loaded (if it
          ever is).  To ensure that the output of each
          execution of <command>svnadmin dump</command> is
          self-sufficient, the first dumped revision is, by default, a
          full representation of every directory, file, and property in
          that revision of the repository.</para>
-->
        <para>Par défaut, Subversion n'exprime pas la première révision
          déchargée sous forme de différences à appliquer à la révision
          précédente. En effet, il n'y a pas de révision précédente dans
          le fichier dump&nbsp;! Et puis Subversion ne peut pas
          connaître l'état du dépôt dans lequel les données vont être
          chargées (si jamais elles le sont). Pour s'assurer que la
          sortie de chaque exécution de <command>svnadmin dump</command>
          est auto-suffisante, la première révision déchargée est, par
          défaut, une représentation complète de chaque répertoire, de
          chaque fichier et de chaque propriété de cette révision du
          dépôt.</para>

<!--
        <para>However, you can change this default behavior.  If you add
          the <option>- -incremental</option> option when you dump your
          repository, <command>svnadmin</command> will compare the first
          dumped revision against the previous revision in the
          repository&mdash;the same way it treats every other revision that
          gets dumped.  It will then output the first revision exactly
          as it does the rest of the revisions in the dump
          range&mdash;mentioning only the changes that occurred in that
          revision.  The benefit of this is that you can create several
          small dump files that can be loaded in succession, instead of
          one large one, like so:</para>
-->
        <para>Vous pouvez toujours modifier ce comportement par défaut.
          Si vous ajoutez l'option <option>--incremental</option> quand
          vous déchargez le dépôt, <command>svnadmin</command> compare
          la première révision déchargée à la révision précédente du
          dépôt (de la même manière qu'il traite toutes les autres
          révisions qui sont déchargées). Il affiche alors la première
          révision de la même manière que le reste des révisions dans
          l'intervalle demandé (en ne mentionnant que les changements
          contenus dans cette révision). L'avantage est que vous pouvez
          créer plusieurs petits fichiers dump qui peuvent être chargés
          les uns à la suite des autres au lieu d'un unique gros
          fichier. Par exemple&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 - -incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 - -incremental &gt; dumpfile3 -->
$ svnadmin dump mon-depot -r 0:1000 &gt; fichier-dump1
$ svnadmin dump mon-depot -r 1001:2000 --incremental &gt; fichier-dump2
$ svnadmin dump mon-depot -r 2001:3000 --incremental &gt; fichier-dump3
</screen>
        </informalexample>

<!--
        <para>These dump files could be loaded into a new repository
          with the following command sequence:</para>
-->
        <para>Ces fichiers dump peuvent maintenant être chargés dans un
        nouveau dépôt avec la séquence de commandes
        suivante&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3 -->
$ svnadmin load nouveau-depot &lt; fichier-dump1
$ svnadmin load nouveau-depot &lt; fichier-dump2
$ svnadmin load nouveau-depot &lt; fichier-dump3
</screen>
        </informalexample>

<!--
        <para>Another neat trick you can perform with this
          <option>- -incremental</option> option involves appending to an
          existing dump file a new range of dumped revisions.  For
          example, you might have a post-commit hook
          that simply appends the repository dump of the single revision
          that triggered the hook.  Or you might have a script that runs
          nightly to append dump file data for all the revisions that
          were added to the repository since the last time the script
          ran.  Used like this, <command>svnadmin dump</command> can be
          one way to back up changes to your repository over time in case
          of a system crash or some other catastrophic event.</para>
-->
        <para>Une autre astuce consiste à utiliser l'option
          <option>--incremental</option> pour ajouter un nouvel
          intervalle de révisions à un fichier dump existant.
          Par exemple, vous pouvez avoir une procédure automatique
          <literal>post-commit</literal> qui ajoute simplement à un
          fichier dump le contenu de la révision qui a déclenché la
          procédure. Ou alors vous pouvez avoir un script qui tourne la
          nuit pour ajouter à un fichier dump les données de toutes les
          révisions qui ont eu lieu depuis le dernier lancement du
          script. Ainsi, <command>svnadmin dump</command> est une
          manière de réaliser des sauvegardes des changements de votre
          dépôt au fil du temps, dans l'éventualité d'un plantage
          système ou de toute autre événement catastrophique.</para>

<!--
        <para>The dump format can also be used to merge the contents of
          several different repositories into a single repository.  By
          using the <option>- -parent-dir</option> option of
          <command>svnadmin load</command>, you can specify a new
          virtual root directory for the load process.  That means if
          you have dump files for three repositories&mdash;say
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename>, and
          <filename>ss-dumpfile</filename>&mdash;you can first create a new
          repository to hold them all:</para>
-->
        <para>Les fichiers dump peuvent aussi être utilisés pour
          fusionner le contenu de différents dépôts en un seul dépôt. En
          utilisant l'option <option>--parent-dir</option> de
          <command>svnadmin load</command>, vous pouvez spécifier un
          nouveau répertoire racine virtuel pour la procédure de
          chargement. Ainsi, si vous avez des fichiers dump pour trois
          dépôts (disons <filename>fichier-dump-calc</filename>,
          <filename>fichier-dump-cal</filename> et
          <filename>fichier-dump-tab</filename>) vous pouvez commencer
          par créer un nouveau dépôt pour les héberger
          tous&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnadmin create /var/svn/projects-->
$ svnadmin create /var/svn/projets
$
</screen>
        </informalexample>

<!--
        <para>Then, make new directories in the repository that will
          encapsulate the contents of each of the three previous
          repositories:</para>
-->
        <para>Ensuite, créez dans le dépôt les nouveaux répertoires qui
          vont encapsuler le contenu de chacun des trois dépôts
          précédents&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn mkdir -m "Initial project roots" \
            file:///var/svn/projects/calc \
            file:///var/svn/projects/calendar \
            file:///var/svn/projects/spreadsheet
Committed revision 1.
-->
$ svn mkdir -m "Racines initiales des projets" \
      file:///var/svn/projets/calc \
      file:///var/svn/projets/calendrier \
      file:///var/svn/projets/tableur
Révision 1 propagée.
$
</screen>
        </informalexample>

<!--
        <para>Lastly, load the individual dump files into their
          respective locations in the new repository:</para>
-->
        <para>Enfin, chargez chaque fichier dump dans le répertoire
          correspondant du nouveau dépôt&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnadmin load /var/svn/projects - -parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects - -parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects - -parent-dir spreadsheet &lt; ss-dumpfile-->
$ svnadmin load /var/svn/projets --parent-dir calc &lt; fichier-dump-calc
&hellip;
$ svnadmin load /var/svn/projets --parent-dir calendrier &lt; fichier-dump-cal
&hellip;
$ svnadmin load /var/svn/projets --parent-dir spreadsheet &lt; fichier-dump-tab
&hellip;
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnrdump">
<!--
        <title>Repository data migration using svnrdump</title>
-->
        <title>Migration des données d'un dépôt en utilisant
          svnrdump</title>

<!--
        <para>In Subversion 1.7, <command>svnrdump</command> joined
          the set of stock Subversion tools.  It offers fairly
          specialized functionality, essentially as a network-aware
          version of the <command>svnadmin dump</command>
          and <command>svnadmin load</command> commands which we
          discuss in depth in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> will generate a dump
          stream from a remote repository, spewing it to standard
          output; <command>svnrdump load</command> will read a dump
          stream from standard input and load it into a remote
          repository.  Using <command>svnrdump</command>, you can
          generate incremental dumps just as you might
          with <command>svnadmin dump</command>.  You can even dump a
          subtree of the repository&mdash;something
          that <command>svnadmin dump</command> cannot do.</para>
-->
        <para>Dans Subversion 1.7, la commande
          <command>svnrdump</command> a rejoint la trousse à outils
          Subversion. Elle est plutôt spécialisée en tant que version
          réseau de <command>svnadmin dump</command> et
          <command>svnadmin load</command>, que nous avons vu en détail
          dans <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> génère un flux dump à
          partir d'un dépôt distant, en l'affichant sur la sortie
          standard&nbsp;; <command>svnrdump load</command> lit un flux
          depuis l'entrée standard et le charge dans un dépôt distant.
          En utilisant <command>svnrdump</command>, vous pouvez générer
          des dumps incrémentaux tout comme vous le feriez avec
          <command>svnadmin dump</command>. Vous pouvez même décharger
          une sous-arborescence d'un dépôt (ce que ne peut pas faire
          <command>svnadmin dump</command>).</para>

<!--
        <para>The primary difference is that instead of requiring
          direct access to the repository, <command>svnrdump</command>
          operates remotely, using the very same Repository Access
          (RA) protocols that the Subversion client does.  As such,
          you might need to provide authentication credentials.  Also,
          your remote interactions are subject to any authorization
          limitations configured on the Subversion server.</para>
-->
        <para>La principale différence est que vous n'avez pas besoin
          d'avoir un accès direct au dépôt avec
          <command>svnrdump</command> car elle utilise les mêmes
          protocoles définis par Repository Access (RA) que le client
          texte interactif Subversion. Ainsi, vous serez peut-être amené
          à fournir des éléments d'authentification. Aussi, vous actions
          à distance sont soumises aux droits qui vous sont octroyés par
          la configuration du serveur Subversion.</para>

        <note>
<!--
          <para><command>svnrdump dump</command> requires that the
            remote server be running Subversion 1.4 or newer.  It
            currently generates dump streams only of the sort which
            are created when you pass the <option>- -deltas</option>
            option to <command>svnadmin dump</command>.  This isn't
            interesting in the typical use-cases, but might impact
            specific types of custom transformations you might wish to
            apply to the resulting dump stream.</para>
-->
          <para><command>svnrdump dump</command> requiert que le serveur
            soit en version 1.4 au moins. Elle génère des flux dump du
            type de ceux générés lorsque vous spécifiez l'option
            <option>--deltas</option> à <command>svnadmin
            dump</command>. Ce n'est pas significatif pour l'utilisation
            courante de cette commande mais peut vous impacter si vous
            avez en tête de transformer le flux dump de sortie.</para>
        </note>

        <note>
<!--
          <para>Because it modifies revision properties after
            committing new revisions, <command>svnrdump load</command>
            requires that the target repository have revision property
            changes enabled via the pre-revprop-change hook.  See
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/> for details.</para>
-->
          <para>Comme elle modifie les propriétés de révisions après
            avoir propagé les nouvelles révisions,  <command>svnrdump
            load</command> requiert que le dépôt cible soit configuré
            afin d'autoriser les modifications de propriétés
            <foreignphrase>via</foreignphrase> la procédure automatique
            <literal>pre-revprop-change</literal>. Reportez-vous à
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" />
            dans <xref linkend="svn.ref.reposhooks"/> pour plus de
            détails.</para>
        </note>

<!--
        <para>As you might expect, you can use
          <command>svnadmin</command> and <command>svnrdump</command>
          in concert.  You can, for example, use <command>svnrdump
          dump</command> to generate a dump stream from a remote
          repository, and pipe the results thereof through
          <command>svnadmin load</command> to copy all that repository
          history into a local repository.  Or you can do the reverse,
          copying history from a local repository into a remote
          one.</para>
-->
        <para>Comme vous pouvez vous y attendre, vous pouvez utiliser
          <command>svnadmin</command> et <command>svnrdump</command>
          de concert. Vous pouvez, par exemple, utililser
          <command>svnrdump dump</command> pour générer un flux dump
          depuis un dépôt distant et rediriger ce flux vers
          <command>svnadmin load</command> pour copier tout l'historique
          de ce dépôt vers un dépôt local. Vous pouvez tout aussi bien
          effectuer l'inverse, copier l'historique d'un dépôt local vers
          un distant.</para>

        <tip>
<!--
          <para>By using <literal>file://</literal>
            URLs, <command>svnrdump</command> can also access local
            repositories, but it will be doing so via Subversion's
            Repository Access (RA) abstraction layer&mdash;you'll get
            better performance out of <command>svnadmin</command> in
            such situations.</para>
-->
          <para>Si vous utiliser des URL de type
            <literal>file://</literal>, <command>svnrdump</command> peut
            alors accéder à des dépôts locaux, mais il le fera en
            utilisant la couche d'abstraction Repository Access (RA)
            de Subversion&nbsp;; vous obtiendrez de bien meilleures
            performances en utilisant <command>svnadmin</command> dans
            de tels cas de figure.</para>
        </tip>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
<!--
      <title>Filtering Repository History</title>
-->
      <title>Filtrage de l'historique d'un dépôt</title>

<!--
      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion generally
        doesn't provide an easy way to remove that
        data.<footnote><para>That's rather the reason you use version
        control at all, right?</para></footnote>  But inevitably, there
        will be times when you would like to manipulate the history of
        your repository.  You might need to strip out all instances of
        a file that was accidentally added to the repository (and
        shouldn't be there for whatever
        reason).<footnote><para>Conscious, cautious removal of certain
        bits of versioned data is actually supported by real use
        cases.  That's why an <quote>obliterate</quote> feature has
        been one of the most highly requested Subversion features, and
        one which the Subversion developers hope to soon
        provide.</para></footnote>  Or, perhaps you have multiple
        projects sharing a single repository, and you decide to split
        them up into their own repositories.  To accomplish tasks such
        as these, administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>
-->
      <para>Puisque Subversion stocke votre historique du suivi de
        versions en utilisant, au minimum, des algorithmes de
        différenciation binaire et de la compression de données (le
        tout, potentiellement, dans un système de gestion de bases de
        données complètement opaque), il est maladroit, et en tous cas
        fortement déconseillé, d'essayer de le modifier manuellement,
        sachant qu'en plus c'est assez difficile. Et une fois que des
        données ont été stockées dans votre dépôt, Subversion ne fournit
        généralement pas de moyen simple pour enlever ces
        données<footnote>
          <para>C'est d'ailleurs pour cela que vous utilisez un système
            de gestion de versions, non&nbsp;?</para>
        </footnote>.
        Mais, inévitablement, il y a des cas où vous voulez manipuler
        l'historique de votre dépôt. Par exemple pour supprimer tous les
        occurrences d'un fichier qui a été accidentellement ajouté au
        dépôt (alors qu'il ne devrait pas y être)<footnote>
          <para>Des suppressions délibérées et avisées
            de données suivies en versions peuvent effectivement
            être justifiées par des cas d'utilisation réels.
            C'est pourquoi une fonctionnalité
            <quote>d'oblitération</quote> est une des fonctionnalités
            les plus demandées pour Subversion et les développeurs de
            Subversion espèrent pouvoir la fournir bientôt.</para>
        </footnote>.
        Ou bien lorsque vous avez plusieurs projets qui partagent le
        même dépôt et que vous décidez de leur attribuer chacun le leur.
        Pour accomplir ce genre de tâches, les administrateurs ont
        besoin d'une représentation des données de leurs dépôts plus
        souple et plus facile à gérer&nbsp;: les fichiers dump
        Subversion.</para>

<!--
      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> or <command>svnrdump
        dump</command> command to generate the dump data,
        and <command>svnadmin load</command> or <command>svnrdump
        load</command> to populate a new repository with it.  The
        great thing about the human-readability aspect of the dump
        format is that, if you aren't careless about it, you can
        manually inspect and modify it.  Of course, the downside is
        that if you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>
-->
      <para>Comme indiqué précédemment dans <xref
        linkend="svn.reposadmin.maint.migrate" />, le format des
        fichiers dump Subversion est une représentation lisible par les
        humains des modifications apportées au cours du temps aux
        données suivies en versions. Utilisez la commande
        <command>svnadmin dump</command> ou <command>svnrdump
        dump</command> pour extraire les données et <command>svnadmin
        load</command> ou <command>svnrdump load</command> pour les
        charger dans un nouveau dépôt. Le gros atout de l'aspect
        <quote>lisible par les humains</quote> des fichiers dump est
        que, si vous y tenez, vous pouvez en inspecter le contenu et le
        modifier. Bien sûr, la contrepartie est que, si vous avez un
        fichier dump d'un dépôt actif depuis plusieurs années, cela vous
        prendra un certain temps pour en inspecter manuellement le
        contenu et le modifier, un temps certain même.</para>

<!--
      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>
-->
      <para>C'est là qu'intervient <command>svndumpfilter</command>. Ce
        programme agit comme un filtre sur les chemins pour les flux de
        déchargement/chargement d'un dépôt. Vous n'avez qu'à lui
        fournir une liste de chemins que vous voulez conserver ou une
        liste de chemins que vous voulez éliminer et ensuite rediriger
        le flux de dump de vos données à travers ce filtre. Vous
        obtenez un flux modifié qui ne contient que les données suivies
        en versions des chemins que vous avez demandés (explicitement ou
        implicitement).</para>

<!--
      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>
-->
      <para>Prenons un exemple concret d'utilisation de ce programme.
        Précédemment dans ce chapitre (voir <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), nous avons
        décrit le processus de décision permettant de choisir
        l'organisation des données de votre dépôt (utiliser un dépôt par
        projet ou les combiner, comment organiser les répertoires au
        sein du dépôt,&nbsp;etc.). Mais il peut arriver qu'après un
        certain nombre de révisions vous repensiez votre organisation et
        vouliez la modifier. Une modification classique est de déplacer
        plusieurs projets qui partagent le même dépôt vers des dépôts
        propres à chacun d'eux.</para>

<!--
      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>
-->
      <para>Notre dépôt imaginaire contient trois projets&nbsp;:
        <literal>calc</literal>, <literal>calendrier</literal> et
        <literal>tableur</literal>. Ils se trouvent côte à côte comme
        ceci&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      branches/
      tags/<!--
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/-->
   calendrier/
      trunk/
      branches/
      tags/
   tableur/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

<!--
      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>
-->
      <para>Pour placer ces trois projets dans leur dépôts propres, nous
        commençons par décharger tout le dépôt&nbsp;:</para>

<!--
      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ svnadmin dump /var/svn/depot &gt; fichier-dump-depot
* Révision 0 déchargée.
* Révision 1 déchargée.
* Révision 2 déchargée.
* Révision 3 déchargée.
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>
-->
      <para>Ensuite, nous passons ce fichier dump à travers le filtre,
        en n'incluant à chaque fois qu'un seul répertoire racine. Nous
        obtenons trois nouveaux fichiers dump&nbsp;:</para>

      <informalexample>
        <screen> <!--
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile -->
$ svndumpfilter include calc &lt; fichier-dump-depot &gt; fichier-dump-calc
&hellip;
$ svndumpfilter include calendrier &lt; fichier-dump-depot &gt; fichier-dump-cal
&hellip;
$ svndumpfilter include tableur &lt; fichier-dump-depot &gt; fichier-dump-tab
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>
-->
      <para>C'est le moment de prendre une décision. Chacun de vos
        fichiers dump générera un dépôt valide, mais il conservera les
        chemins exactement comme ils étaient dans le dépôt original.
        Cela veut dire que même si vous obtenez un dépôt propre à votre
        projet <literal>calc</literal> ce dépôt aura toujours un
        répertoire racine <filename>calc</filename>. Si vous voulez que
        les répertoires <filename>trunk</filename>,
        <filename>tags</filename> et <filename>branches</filename> soient
        placés à la racine de votre dépôt, vous devez alors éditer les
        fichiers dump, en modifiant les en-têtes
        <literal>Node-path</literal> et
        <literal>Node-copyfrom-path</literal> pour qu'ils ne contiennent
        plus de référence au répertoire <filename>calc/</filename>. Vous
        devez également supprimer la section des données qui crée le
        répertoire <filename>calc</filename>. Elle ressemble à
        ceci&nbsp;:</para>

      <informalexample>
        <programlisting>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</programlisting>
      </informalexample>

<!--
      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>
-->
      <warning>
        <para>Si vous envisagez d'éditer à la main le fichier dump pour
          enlever un répertoire à la racine, assurez-vous que votre
          éditeur n'est pas configuré pour convertir les caractères de
          fin de ligne vers le format natif (par exemple
          de <literal>\r\n</literal> vers <literal>\n</literal>), sinon
          le contenu ne serait plus conforme aux métadonnées. Cela
          corromprait le fichier dump de manière irréversible.</para>
      </warning>

<!--
      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>
-->
      <para>Tout ce qu'il reste à faire à présent, c'est de créer vos
        trois nouveaux dépôts et de charger chaque fichier dump dans le
        bon dépôt, en ignorant l'UUID contenu dans chaque flux
        dump&nbsp;:</para>

<!--
      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load - -ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load - -ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load - -ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; fichier-dump-calc
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
     * édition du chemin : Makefile ... fait.
     * édition du chemin : bouton.c ... fait.
&hellip;
$ svnadmin create calendrier
$ svnadmin load --ignore-uuid calendrier &lt; fichier-dump-cal
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
     * édition du chemin : Makefile ... fait.
     * édition du chemin : cal.c ... fait.
&hellip;
$ svnadmin create tableur
$ svnadmin load --ignore-uuid tableur &lt; fichier-dump-tab
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
     * édition du chemin : Makefile ... fait.
     * édition du chemin : tableur.c ... fait.
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>
-->
      <para>Les deux sous-commandes <command>svndumpfilter</command>
        possèdent des options pour décider comment traiter les révisions
        <quote>vides</quote>. Si une révision donnée ne contient que des
        modifications concernant des chemins qui ont été filtrés, cette
        révision dorénavant vide peut être considérée comme
        inintéressante voire indésirable. Pour permettre à l'utilisateur
        de décider que faire de telles révisions,
        <command>svndumpfilter</command> propose les options
        suivantes&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
<!--
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
-->
            <para>Ne générer aucune révision vide&nbsp;; elles sont tout
              simplement ignorées.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
<!--
            <para>If empty revisions are dropped (using the
              <option>- -drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
-->
            <para>Si les révisions vides sont ignorées (avec l'option
              <option>--drop-empty-revs</option>), changer les numéros
              de révision restants pour qu'il n'y ait pas de trous
              dans la séquence de numérotation.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
<!--
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
-->
            <para>Si les révisions vides ne sont pas ignorées, garder
              les propriétés de la révision (commentaire de propagation,
              auteur, date, propriétés personnalisées,&nbsp;etc.) pour
              ces révisions vides. Autrement les révisions vides ne
              contiennent que l'horodatage original et un message
              expliquant que c'est à cause de
              <command>svndumpfilter</command> que cette révision est
              vide.</para>
          </listitem>
        </varlistentry>
      </variablelist>

<!--
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>
-->
      <para>Alors que <command>svndumpfilter</command> peut s'avérer
        très utile et permet de gagner énormément de temps, il est
        affublé malheureusement de deux chausse-trappes. D'abord, cet
        utilitaire est extrêmement sensible à la sémantique des chemins.
        Prêtez attention à la manière dont sont spécifiés les chemins
        dans votre fichier dump, avec ou sans barre oblique
        (<literal>/</literal>) initiale. Regardez pour cela les en-têtes
        <literal>Node-path</literal> et
        <literal>Node-copyfrom-path</literal>.</para>

      <informalexample>
        <programlisting>
&hellip;<!--
Node-path: spreadsheet/Makefile -->
Node-path: tableur/Makefile
&hellip;
</programlisting>
      </informalexample>

<!--
      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an
        inconsistent usage of leading slashes for some
        reason,<footnote><para>While <command>svnadmin dump</command>
        has a consistent leading slash policy (to not include them),
        other programs that generate dump data might not be so
        consistent.</para></footnote> you should probably normalize
        those paths so that they all have, or all lack, leading
        slashes.</para>
-->
      <para>Si les chemins ont une barre oblique initiale, vous devez
        inclure des barres obliques au début de chaque chemin que vous
        indiquez à <command>svndumpfilter include</command> et
        <command>svndumpfilter exclude</command> (et s'ils n'en ont pas,
        n'incluez pas de barre oblique au début). Pour aller plus loin,
        si votre fichier dump contient à la fois des chemins avec et des
        chemins sans barre oblique initiale, pour quelque raison que ce
        soit<footnote>
          <para>Bien que <command>svnadmin dump</command> ait une
            politique cohérente concernant la barre oblique initiale
            (aussi appelée <quote>slash</quote> &mdash; il ne l'inclut
            pas), d'autres programmes qui génèrent des fichiers dump
            sont susceptibles de ne pas être aussi cohérents.</para>
        </footnote>,
        vous devrez probablement normaliser les chemins en adoptant une
        des deux conventions.</para>

<!--
      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>
-->
      <para>En outre, les chemins qui ont été copiés peuvent vous donner
        quelques soucis. Subversion supporte les opérations de copie
        dans le dépôt, c'est-à-dire quand un nouveau chemin est créé par
        la copie d'un autre chemin qui existe déjà. Il est possible qu'à
        un certain moment de la vie de votre dépôt, vous ayez copié un
        fichier ou un répertoire d'un endroit que
        <command>svndumpfilter</command> a exclu vers un endroit qui est
        inclus. Pour rendre les données du dump cohérentes,
        <command>svndumpfilter</command> doit bien inclure l'ajout du
        nouveau chemin &mdash; y compris le contenu de tous les fichiers
        créés par la copie &mdash; mais en tant que copie d'un chemin
        source qui n'existe pas dans le flux des données filtrées. Mais
        puisque le format dump de Subversion ne contient que ce qui a
        été modifié dans chaque révision, le contenu de la source de la
        copie risque de ne pas être disponible. Si vous êtes susceptible
        d'avoir la moindre copie de ce type dans votre dépôt, vous
        devrez peut-être repenser votre ensemble de chemins à
        inclure/exclure, pour y inclure aussi les chemins qui ont servi
        de sources à des opérations de copie qui vous posent
        problème.</para>

<!--
      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>
-->
      <para>Enfin, <command>svndumpfilter</command> effectue un filtrage
        des chemins pour le moins littéral. Si vous essayez de copier
        l'historique d'un projet dont la racine est
        <filename>trunk/mon-projet</filename> et de le déplacer dans
        son propre dépôt, vous utiliserez évidemment la commande
        <command>svndumpfilter include</command> pour conserver tous les
        changements dans et sous <filename>trunk/mon-projet</filename>.
        Mais le fichier dump résultant ne fait aucune hypothèse sur le
        dépôt dans lequel vous allez charger ces données. En
        particulier, les données déchargées peuvent commencer par la
        révision qui a ajouté le répertoire
        <filename>trunk/mon-projet</filename> mais <emphasis>ne pas
        contenir</emphasis> les directives pour créer le
        répertoire <filename>trunk</filename> lui-même (parce que
        <filename>trunk</filename> ne correspond pas au filtre utilisé).
        Vous devez vous assurer que tous les répertoires à la présence
        desquels le flux de données déchargées s'attend existent
        réellement dans le dépôt destination, avant d'essayer de charger
        le flux de données à l'intérieur.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
<!--
      <title>Repository Replication</title>
-->
      <title>Réplication d'un dépôt</title>

<!--
      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>
-->
      <para>Divers scénarios montrent l'intérêt d'avoir un dépôt
        Subversion dont l'historique des versions est exactement le même
        que celui d'un autre dépôt. Le plus évident est probablement
        celui de maintenir un dépôt de secours, utilisé quand le dépôt
        principal est inaccessible en raison d'un problème matériel,
        d'une coupure réseau ou de tout autre souci de ce type. D'autres
        scénarios comprennent le déploiement de dépôts redondants pour
        distribuer la charge sur plusieurs serveurs, les mises à niveau
        transparentes et d'autres encore.</para>

<!--
      <para>Subversion provides a program for managing scenarios such
        as these.  <command>svnsync</command> works by essentially
        asking the Subversion server to <quote>replay</quote>
        revisions, one at a time.  It then uses that revision
        information to mimic a commit of the same to another
        repository.  Neither repository needs to be locally accessible
        to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>
-->
      <para>Subversion fournit un programme pour gérer de tels
        scénarios&nbsp;: <command>svnsync</command>. Il fonctionne
        essentiellement en demandant au serveur Subversion de
        <quote>rejouer</quote> les révisions, une par une. Il utilise
        ces informations sur les révisions pour répéter une propagation
        identique sur un autre dépôt. Aucun des deux dépôts n'a besoin
        d'être accessible localement sur la machine où
        <command>svnsync</command> tourne&nbsp;: ses paramètres sont
        des URL de dépôt et tout le travail est effectué
        <foreignphrase>via</foreignphrase> les interfaces d'accès au
        dépôt (<foreignphrase>Repository Access</foreignphrase> en
        anglais, ou <foreignphrase>RA</foreignphrase>) de Subversion.
        Tout ce dont il a besoin est un accès en lecture
        au dépôt source et un accès en lecture/écriture au dépôt de
        destination.</para>

      <note>
<!--
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
-->
        <para>Quand vous utilisez <command>svnsync</command> sur un
          dépôt source distant, le serveur Subversion de ce dépôt doit
          être en version 1.4 ou supérieure.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync">
<!--
        <title>Replication with svnsync</title>
-->
        <title>Réplication avec svnsync</title>

<!--
        <para>Assuming you already have a source repository that you'd
          like to mirror, the next thing you need is a target repository
          that will actually serve as that mirror.  This target
          repository can use either of the available filesystem
          data-store backends (see
          <xref linkend="svn.reposadmin.basics.backends"
          />)&mdash;Subversion's abstraction layers ensure that such
          details don't matter.  But by default, it must
          not yet have any version history in it.  (We'll discuss an
          exception to this later in this section.)</para>
-->
        <para>Supposons que vous avez un dépôt source que vous voulez
          répliquer&nbsp;; il vous faut alors disposer d'un dépôt
          destination qui servira de miroir. Ce dépôt cible peut
          utiliser n'importe quel magasin de données disponible (voir
          <xref linkend="svn.reposadmin.basics.backends" />), les
          couches d'abstraction de Subversion s'assurent que ces détails
          ne vous impactent pas. Par défaut, ce dépôt ne doit comporter
          aucun historique (nous aborderons une exception à cette règle
          plus loin dans cette section).</para>

<!--
        <para>The protocol that <command>svnsync</command> uses to
          communicate revision information is highly sensitive to
          mismatches between the versioned histories contained in the
          source and target repositories.  For this reason,
          while <command>svnsync</command>
          cannot <emphasis>demand</emphasis> that the target repository
          be read-only,<footnote><para>In fact, it can't truly be
          read-only, or <command>svnsync</command> itself would have a
          tough time copying revision history into it.</para></footnote>
          allowing the revision history in the target repository to
          change by any mechanism other than the mirroring process is a
          recipe for disaster.</para>
-->
        <para>Le protocole utilisé par <command>svnsync</command> pour
          transmettre les informations de révision est particulièrement
          sensible aux divergences entre les historiques suivies en
          versions de la source et de la destination. Pour cette raison,
          bien que <command>svnsync</command> ne puisse pas
          <emphasis>exiger</emphasis> que le dépôt destination soit en
          lecture seule<footnote>
          <para>En fait, le dépôt ne peut pas être complètement en
            lecture seule, sinon <command>svnsync</command> lui-même
            aurait du mal à y copier l'historique des révisions.</para>
          </footnote>, autoriser des modifications d'historique sur le
          dépôt destination par un mécanisme externe autre que le
          processus de réplication mène droit au désastre.</para>

        <warning>
<!--
          <para>Do <emphasis>not</emphasis> modify a mirror repository
            in such a way as to cause its version history to deviate
            from that of the repository it mirrors.  The only commits
            and revision property modifications that ever occur on that
            mirror repository should be those performed by the
            <command>svnsync</command> tool.</para>
-->
          <para><emphasis>Ne modifiez pas</emphasis> le dépôt miroir de
          sorte que son historique de version diffère de celui du dépôt
          source. Les seules propagations et modifications de propriétés
          de révisions qui doivent avoir lieu sur ce dépôt miroir sont
          celles effectuées par l'outil <command>svnsync</command>.</para>
        </warning>

<!--
        <para>Another requirement of the target repository is that the
          <command>svnsync</command> process be allowed to modify
          revision properties.  Because <command>svnsync</command> works
          within the framework of that repository's hook system, the
          default state of the repository (which is to disallow revision
          property changes; see <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) is insufficient.
          You'll need to explicitly implement the pre-revprop-change
          hook, and your script must allow <command>svnsync</command>
          to set and change revision properties.  With those
          provisions in place, you are ready to start mirroring
          repository revisions.</para>
-->
        <para>Une autre exigence concernant le dépôt destination est que
          le processus <command>svnsync</command> doit être autorisé à
          modifier les propriétés de révision. Comme
          <command>svnsync</command> fonctionne dans le cadre du système
          des procédures automatiques du dépôt, l'état par défaut du
          dépôt (qui consiste à interdire les modifications des
          propriétés de révision, voir <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> dans
          <xref linkend="svn.ref.reposhooks"/>) n'est pas suffisant.
          Vous devez activer explicitement la procédure automatique
          <literal>pre-revprop-change</literal> et votre script doit
          autoriser <command>svnsync</command> à définir et à modifier
          les propriétés de révision. Une fois ces dispositions prises,
          vous êtes parés pour commencer la réplication des révisions du
          dépôt.</para>

        <tip>
<!--
          <para>It's a good idea to implement authorization measures
            that allow your repository replication process to perform
            its tasks while preventing other users from modifying the
            contents of your mirror repository at all.</para>
-->
          <para>Il est de bon ton de mettre un place un contrôle d'accès
            pour autoriser le processus de réplication de votre dépôt à
            faire ce qu'il a à faire tout en interdisant aux autres
            utilisateurs de modifier le contenu de votre dépôt
            miroir.</para>
        </tip>

<!--
        <para>Let's walk through the use of <command>svnsync</command>
          in a somewhat typical mirroring scenario.  We'll pepper this
          discourse with practical recommendations, which you are free to
          disregard if they aren't required by or suitable for your
          environment.</para>
-->
        <para>Examinons maintenant l'utilisation de
          <command>svnsync</command> dans un scénario classique de
          réplication. Nous saupoudrons le discours de quelques
          recommandations pratiques que vous êtes libre d'ignorer si
          elles ne sont pas nécessaires ou pas applicables à votre
          environnement.</para>

<!--
        <para>We will be mirroring the public Subversion repository
          which houses the source code for this very book and exposing
          that mirror publicly on the Internet, hosted on a different
          machine than the one on which the original Subversion source
          code repository lives.  This remote host has a global
          configuration that permits anonymous users to read the
          contents of repositories on the host, but requires users to
          authenticate to modify those repositories.  (Please forgive
          us for glossing over the details of Subversion server
          configuration for the moment&mdash;those are covered
          thoroughly in <xref linkend="svn.serverconfig" />.)  And for
          no other reason than that it makes for a more interesting
          example, we'll be driving the replication process from a
          third machine&mdash;the one that we currently find ourselves
          using.</para>
-->
        <para>nous allons répliquer le dépôt public qui contient le code
          source de ce livre et mettre ce miroir à disposition sur
          Internet, sur une machine différente de celle qui héberge le
          dépôt original. Cet hôte distant possède une configuration
          globale qui autorise les accès anonymes en lecture mais
          requiert une authentification pour modifier les dépôts
          (pardonnez-nous de passer rapidement sur les détails de la
          configuration du serveur Subversion pour le moment, mais ces
          aspects sont traités en profondeur dans le <xref
          linkend="svn.serverconfig" />.). Et pour rendre l'exemple plus
          intéressant, et uniquement pour cela, nous piloterons la
          réplication depuis une troisième machine &mdash; en
          l'occurrence, celle que nous sommes en train d'utiliser.</para>

<!--
        <para>First, we'll create the repository which will be our
          mirror.  This and the next couple of steps do require shell
          access to the machine on which the mirror repository will
          live.  Once the repository is all configured, though, we
          shouldn't need to touch it directly again.</para>
-->
        <para>Dans un premier temps, nous allons créer le dépôt qui
          servira de miroir. Cette étape et les deux suivantes
          requièrent l'accès à la ligne de commande de la machine sur
          laquelle le miroir sera hébergé. Toutefois, une fois que ce
          dépôt sera complètement configuré, nous n'aurons plus besoin
          d'y avoir accès directement.</para>

        <informalexample>
          <screen> <!--
$ ssh admin@svn.example.com "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ******** -->
$ ssh admin@svn.exemple.com \
      "svnadmin create /var/svn/miroir-svn"
admin@svn.exemple.com's password: ********
$
</screen>
        </informalexample>

<!--
        <para>At this point, we have our repository, and due to our
          server's configuration, that repository is now
          <quote>live</quote> on the Internet.  Now, because we don't
          want anything modifying the repository except our replication
          process, we need a way to distinguish that process from other
          would-be committers.  To do so, we use a dedicated username
          for our process.  Only commits and revision property
          modifications performed by the special username
          <literal>syncuser</literal> will be allowed.</para>
-->
        <para>À ce stade, nous disposons d'un dépôt et, en raison de la
          configuration de notre serveur, ce dépôt est accessible
          directement depuis Internet. Maintenant, puisque nous ne
          voulons pas que quoi que ce soit modifie notre dépôt en dehors
          du processus de réplication, nous devons trouver un moyen de
          distinguer ce processus des autres prétendants aux
          propagations. Pour ce faire, nous utilisons un identifiant
          d'utilisateur dédié à notre processus. Seules les propagations
          et les modifications de propriétés de révisions effectuées par
          l'identifiant spécial <literal>id-sync</literal> sont
          autorisées.</para>

<!--
        <para>We'll use the repository's hook system both to allow the
          replication process to do what it needs to do and to enforce
          that only it is doing those things.  We accomplish this by
          implementing two of the repository event
          hooks&mdash;pre-revprop-change and start-commit.  Our
          pre-revprop-change hook script is found
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />, and basically verifies that the user attempting the
          property changes is our <literal>syncuser</literal> user.  If
          so, the change is allowed; otherwise, it is denied.</para>
-->
        <para>Nous allons utiliser le système de procédures automatiques
          du dépôt à la fois pour autoriser le processus de réplication
          à faire ce qu'il doit faire et pour garantir qu'il soit le
          seul à le faire. Nous implémentons donc deux des procédures
          automatiques du dépôt&nbsp;:
          <literal>pre-revprop-change</literal> et
          <literal>start-commit</literal>. Le script
          <literal>pre-revprop-change</literal> est présenté dans
          l'<xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          /> et, pour résumer, vérifie que l'utilisateur qui essaie de
          modifier les propriétés est bien notre utilisateur
          <literal>id-sync</literal>. Si c'est bien le cas, la
          modification est autorisée&nbsp;; sinon, elle est
          refusée.</para>

        <example id="svn.reposadmin.maint.replication.pre-revprop-change">
<!--
          <title>Mirror repository's pre-revprop-change hook script</title>
-->
          <title>Procédure automatique pre-revprop-change du dépôt
            miroir</title>
<!--
          <programlisting>
#!/bin/sh

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
-->
          <programlisting>
#!/bin/sh

USER="$3"

if [ "$USER" = "id-sync" ]; then exit 0; fi

echo "Seul l'utilisateur id-sync est autorisé à modifier les propriétés de révision." &gt;&amp;2
exit 1
</programlisting>
        </example>

<!--
        <para>That covers revision property changes.  Now we need to
          ensure that only the <literal>syncuser</literal> user is
          permitted to commit new revisions to the repository.  We do
          this using a start-commit hook script
          such as the one in <xref
          linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>
-->
        <para>Voilà pour les modifications des propriétés de révision.
          Maintenant nous devons nous assurer que seul l'utilisateur
          <literal>id-sync</literal> est autorisé à propager de
          nouvelles révisions dans le dépôt. Ce que nous allons faire en
          utilisant une procédure automatique
          <literal>start-commit</literal> telle que celle présentée dans
          l'<xref linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>

        <example id="svn.reposadmin.maint.replication.start-commit">
<!--
          <title>Mirror repository's start-commit hook script</title>
-->
          <title>Procédure automatique start-commit du dépôt
            miroir</title>

<!--
          <programlisting>
#!/bin/sh

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
-->
          <programlisting>
#!/bin/sh

USER="$2"

if [ "$USER" = "id-sync" ]; then exit 0; fi

echo "Seul l'utilisateur id-sync est autorisé à effectuer des propagations." &gt;&amp;2
exit 1
</programlisting>
        </example>

<!--
        <para>After installing our hook scripts and ensuring that they
          are executable by the Subversion server, we're finished with
          the setup of the mirror repository.  Now, we get to actually
          do the mirroring.</para>
-->
        <para>Après avoir installé nos procédures automatiques et s'être
          assuré qu'elles sont exécutables par le serveur Subversion,
          nous en avons terminé avec l'installation de notre dépôt
          miroir. Maintenant, nous allons effectivement lancer la
          réplication.</para>

<!--
        <para>The first thing we need to do with
          <command>svnsync</command> is to register in our target
          repository the fact that it will be a mirror of the source
          repository.  We do this using the <command>svnsync
          initialize</command> subcommand.  The URLs we provide point
          to the root directories of the target and source
          repositories, respectively.  In Subversion 1.4, this is
          required&mdash;only full mirroring of repositories is
          permitted.  Beginning with Subversion 1.5, though, you can
          use <command>svnsync</command> to mirror only some subtree
          of the repository, too.</para>
-->
        <para>La première chose à faire avec <command>svnsync</command>
          est d'enregistrer dans notre dépôt destination le fait qu'il
          sera un miroir du dépôt source. Nous utilisons donc la
          sous-commande <command>svnsync initialize</command>. Nous
          fournissons des URL qui pointent vers les répertoires racines
          des dépôts destination et source, respectivement. Dans
          Subversion 1.4, c'est obligatoire &mdash; seule la réplication
          de dépôts complets est permise. Depuis Subversion 1.5,
          cependant, vous pouvez aussi utiliser
          <command>svnsync</command> pour répliquer uniquement des
          sous-arborescences du dépôt.</para>

<!--
        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     https://svn.code.sf.net/p/svnbook/source \
                     - -sync-username syncuser - -sync-password syncpass
Copied properties for revision 0 (svn:sync-* properties skipped).
NOTE: Normalized svn:* properties to LF line endings (1 rev-props, 0 node-props).
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage : svnsync initialize DEST_URL SOURCE_URL

Initialise un dépôt destination pour être synchronisé à partir
d'un autre dépôt.
&hellip;
$ svnsync initialize http://svn.exemple.com/miroir-svn \
                     http://svn.code.sf.net/p/svnbook/source \
                     --sync-username id-sync --sync-password mdp-sync
Propriétés copiées pour la révision 0.
$
</screen>
        </informalexample>

<!--
        <para>Our target repository will now remember that it is a
          mirror of the public Subversion source code repository.
          Notice that we provided a username and password as arguments
          to <command>svnsync</command>&mdash;that was required by the
          pre-revprop-change hook on our mirror repository.</para>
-->
        <para>Notre dépôt destination se souviendra maintenant qu'il est
          un miroir du dépôt public du code source de ce livre. Notez
          que nous avons fourni un identifiant et un mot de passe en
          arguments à <command>svnsync</command> &mdash; c'était exigé
          par la procédure automatique
          <literal>pre-revprop-change</literal> de notre dépôt
          miroir.</para>

        <note>
<!--
          <para>In Subversion 1.4, the values given to
            <command>svnsync</command>'s <option>- -username</option> and
            <option>- -password</option> command-line options were used
            for authentication against both the source and destination
            repositories.  This caused problems when a user's
            credentials weren't exactly the same for both repositories,
            especially when running in noninteractive mode (with the
            <option>- -non-interactive</option> option).  This was
            fixed in Subversion 1.5 with the introduction of two new
            pairs of options.  Use
            <option>- -source-username</option> and
            <option>- -source-password</option> to provide authentication
            credentials for the source repository; use
            <option>- -sync-username</option> and
            <option>- -sync-password</option> to provide credentials for
            the destination repository.  (The old
            <option>- -username</option> and <option>- -password</option>
            options still exist for compatibility, but we advise against
            using them.)</para>
-->
          <para>Dans Subversion 1.4, les valeurs assignées aux options
            <option>--username</option> et <option>--password</option>
            de <command>svnsync</command> étaient utilisées pour
            l'authentification à la fois par le dépôt source et par le
            dépôt destination. Cela posait des problèmes quand ces
            l'utilisateur n'avait pas exactement les mêmes éléments pour
            les deux dépôts, particulièrement quand le mode
            non-interactif était utilisé (avec l'option
            <option>--non-interactive</option>).Ce problème a été résolu
            dans la version 1.5 de Subversion avec l'introduction de
            deux nouvelles paires d'options. Utilisez
            <option>--source-username</option> et
            <option>--source-password</option> pour vous authentifier
            auprès du dépôt source&nbsp;; utilisez
            <option>--sync-username</option> et
            <option>--sync-password</option> pour vous authentifier
            auprès du dépôt destination (les vieilles options
            <option>--username</option> et <option>--password</option>
            existent encore pour assurer la compatibilité mais nous en
            déconseillons l'usage).</para>

        </note>

<!--
        <para>And now comes the fun part.  With a single subcommand, we
          can tell <command>svnsync</command> to copy all the
          as-yet-unmirrored revisions from the source repository to the
          target.<footnote><para>Be forewarned that while it will take
          only a few seconds for the average reader to parse this
          paragraph and the sample output that follows it, the actual
          time required to complete such a mirroring operation is, shall
          we say, quite a bit longer.</para></footnote> The
          <command>svnsync synchronize</command> subcommand will peek
          into the special revision properties previously stored on the
          target repository and determine how much of the source
          repository has been previously mirrored&mdash;in this case,
          the most recently mirrored revision is r0.  Then it will query
          the source repository and determine what the latest revision
          in that repository is.  Finally, it asks the source
          repository's server to start replaying all the revisions
          between 0 and that latest revision.  As
          <command>svnsync</command> gets the resultant response from
          the source repository's server, it begins forwarding those
          revisions to the target repository's server as new
          commits.</para>
-->
        <para>Abordons maintenant la partie amusante. En une seule
          sous-commande, nous pouvons demander à
          <command>svnsync</command> de copier toutes les révisions qui
          n'ont pas encore été répliquées du dépôt source vers le dépôt
          destination<footnote>
          <para>Nous avertissons le lecteur que, bien qu'il lui suffise
            de quelques secondes pour lire ce paragraphe et l'exemple
            qui suit, le temps nécessaire pour réaliser une opération de
            réplication est, disons, un peu plus long.</para>
          </footnote>.
          La sous-commande <command>svnsync synchronize</command>
          fouille dans les propriétés de révision spéciales du dépôt
          destination pour déterminer la dernière révision qui a été
          répliquée, en l'occurrence la révision 0. Ensuite, elle
          interroge le dépôt source pour savoir quelle est la dernière
          révision propagée dans ce dépôt. Enfin, elle demande au dépôt
          source de commencer à envoyer toutes les révisions entre la
          révision 0 et la dernière révision. Au moment où
          <command>svnsync</command> reçoit la réponse du dépôt source,
          elle commence la retransmission des révisions vers le dépôt
          destination en tant que nouvelles propagations.</para>

<!--
        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL [SOURCE_URL]

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      https://svn.code.sf.net/p/svnbook/source
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data .
Committed revision 4063.
Copied properties for revision 4063.
Transmitting file data .
Committed revision 4064.
Copied properties for revision 4064.
Transmitting file data ....
Committed revision 4065.
Copied properties for revision 4065.
$
</screen>
        </informalexample>
-->
        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): Usage : svnsync synchronize URL_DEST [URL_SOURCE]

Tranfère toutes les révisions en attente vers la destination à partir
de la source avec laquelle elles ont été initialisées.
&hellip;
$ svnsync synchronize http://svn.exemple.com/miroir-svn \
                      http://svn.code.sf.net/p/svnbook/source
Transmission des données ........................................
Révision 1 propagée.
Propriétés copiées pour la révision 1.
Transmission des données ..
Révision 2 propagée.
Propriétés copiées pour la révision 2.
Transmission des données .....
Révision 3 propagée.
Propriétés copiées pour la révision 3.
&hellip;
Transmission des données ..
Révision 4063 propagée.
Propriétés copiées pour la révision 4063.
Transmission des données .
Révision 4064 propagée.
Propriétés copiées pour la révision 4064.
Transmission des données ....
Révision 4065 propagée.
Propriétés copiées pour la révision 4065.
$
</screen>
        </informalexample>

<!--
        <para>Of particular interest here is that for each mirrored
          revision, there is first a commit of that revision to the
          target repository, and then property changes follow.  This
          two-phase replication is required because the initial commit
          is performed by (and attributed to) the user
          <literal>syncuser</literal> and is datestamped with the time
          as of that revision's creation.  <command>svnsync</command>
          has to follow up with an immediate series of property
          modifications that copy into the target repository all the
          original revision properties found for that revision in the
          source repository, which also has the effect of fixing the
          author and datestamp of the revision to match that of the
          source repository.</para>
-->
        <para>Il est intéressant de noter ici que, pour chaque révision
          répliquée, il y a d'abord propagation de la révision dans le
          dépôt destination, puis des changements de propriétés ont
          lieu. C'est parce que la propagation initiale est effectuée
          par (et donc attribuée à) l'utilisateur
          <literal>id-sync</literal> et qu'elle est horodatée lors de la
          création de la nouvelle révision. Et aussi parce que les
          interfaces d'accès au dépôt Subversion n'autorisent pas la
          définition de propriétés de révision au sein d'une
          propagation. C'est pourquoi <command>svnsync</command> fait
          suivre la réplication par une série de modifications de
          propriétés qui copient dans le dépôt destination toutes les
          propriétés de révision trouvées dans le dépôt source pour
          cette révision. Cela a également pour effet de corriger
          l'auteur et l'horodatage de la révision pour être cohérent
          avec le dépôt source.</para>

<!--
        <para>Also noteworthy is that <command>svnsync</command>
          performs careful bookkeeping that allows it to be safely
          interrupted and restarted without ruining the integrity of the
          mirrored data.  If a network glitch occurs while mirroring a
          repository, simply repeat the <command>svnsync
          synchronize</command> command, and it will happily pick up
          right where it left off.  In fact, as new revisions appear in
          the source repository, this is exactly what you do
          to keep your mirror up to date.</para>
-->
        <para>Notez également que <command>svnsync</command>
          documente tout ce qu'il fait en détail, afin de pouvoir être
          interrompu ou redémarré sans remettre en cause l'intégrité des
          données répliquées. Si une panne réseau survient pendant la
          réplication d'un dépôt, relancez simplement la commande
          <command>svnsync synchronize</command> et elle reprendra
          tranquillement là où elle s'était arrêtée. En fait, au fur et
          à mesure que de nouvelles révisions apparaissent dans le dépôt
          source, c'est précisément ce qu'il faut faire pour conserver
          votre miroir à jour.</para>

        <warning>
<!--
          <para>As part of its bookkeeping, <command>svnsync</command>
            records in the mirror repository the URL with which the
            mirror was initialized.  Because of this, invocations of
            <command>svnsync</command> which follow the initialization
            step do not <emphasis>require</emphasis> that you provide
            the source URL on the command line again.  However, for
            security purposes, we recommend that you continue to do so.
            Depending on how it is deployed, it may not be safe for
            <command>svnsync</command> to trust the source URL which it
            retrieves from the mirror repository, and from which it
            pulls versioned data.</para>
-->

       <para>Parmi les informations stockées par le mirroir,
         <command>svnsync</command> enregistre l'URL source avec
         laquelle il a été initialisé. Ainsi, les appels suivants à
            <command>svnsync</command> <emphasis>ne requièrent
            pas</emphasis> de fournir l'URL source dans la ligne de
            commande. Cependant, pour plus de sécurité, nous
            recommandons que vous continuyez à le faire. En fonction de
            la manière dont il a été déployé, il peut s'avérer risqué
            pour <command>svnsync</command> de faire confiance à l'URL
            source qu'il récupère dépôt mirroir et depuis laquelle
            il récupère les données suivies en versions.</para>
        </warning>

        <sidebar>
<!--
          <title>svnsync Bookkeeping</title>
-->
          <title>Propriétés propres à svnsync</title>

<!--
          <para><command>svnsync</command> needs to be able to set and
            modify revision properties on the mirror repository because
            those properties are part of the data it is tasked with
            mirroring.  As those properties change in the source
            repository, those changes need to be reflected in the mirror
            repository, too.  But <command>svnsync</command> also uses a
            set of custom revision properties&mdash;stored in revision 0
            of the mirror repository&mdash;for its own internal
            bookkeeping.  These properties contain information such as
            the URL and UUID of the source repository, plus some
            additional state-tracking information.</para>
-->
          <para><command>svnsync</command> a besoin de pouvoir définir
            et modifier des propriétés de révision dans le dépôt miroir
            car ces propriétés font partie intégrante des données à
            répliquer. Au fur et à mesure que ces propriétés changent
            dans le dépôt source, ces changements doivent également être
            répliqués dans le dépôt miroir. Mais
            <command>svnsync</command> utilise aussi un ensemble de
            propriétés de révision qui lui sont propres (stockées
            dans la révision 0 du dépôt miroir) à fin de journalisation
            interne. Ces propriétés contiennent des
            informations telles que l'URL et l'UUID du dépôt source,
            ainsi que quelques informations supplémentaires sur l'état
            du miroir.</para>

<!--
          <para>One of those pieces of state-tracking information is a
            flag that essentially just means <quote>there's a
            synchronization in progress right now.</quote> This is used
            to prevent multiple <command>svnsync</command> processes
            from colliding with each other while trying to mirror data
            to the same destination repository.  Now, generally you
            won't need to pay any attention whatsoever to
            <emphasis>any</emphasis> of these special properties (all of
            which begin with the prefix <literal>svn:sync-</literal>).
            Occasionally, though, if a synchronization fails
            unexpectedly, Subversion never has a chance to remove this
            particular state flag.  This causes all future
            synchronization attempts to fail because it appears that a
            synchronization is still in progress when, in fact, none is.
            Fortunately, recovering from this situation is easy to do.
            In Subversion 1.7, you can use the newly introduced
            <option>- -steal-lock</option> option with
            <command>svnsync</command>'s commands.  In previous
            Subversion versions, you need only to remove the
            <literal>svn:sync-lock</literal> property which serves as
            this flag from revision 0 of the mirror repository:</para>
-->
          <para>Une de ces informations sur l'état du miroir est un
            drapeau indiquant qu'<quote>il y a une synchronisation en
            cours</quote>. Il est utilisé pour éviter que de multiples
            processus <command>svnsync</command> entrent en collision en
            essayant de répliquer les données vers le même dépôt
            destination. Quoi qu'il en soit, vous n'aurez généralement
            pas à vous soucier de ces propriétés spéciales (elles
            commencent toutes par le préfixe
            <literal>svn:sync-</literal>). Cependant, il peut arriver
            qu'une synchronisation échoue accidentellement et que
            Subversion n'ait pas l'occasion d'enlever ce drapeau
            indiquant l'état de la synchronisation. Cela fait échouer
            toute nouvelle tentative de synchronisation, puisque le
            drapeau indique qu'une synchronisation est en cours, alors
            que ce n'est pas le cas. Heureusement, il est facile de
            sortir de cette situation. Depuis Subversion 1.7, vous
            pouvez spécifier l'option <option>--steal-lock</option> avec
            la commande <command>svnsync</command>. Pour les versions
            précédentes il suffit de supprimer la propriété
            <literal>svn:sync-lock</literal> de la révision 0 du dépôt
            miroir (c'est le fameux drapeau)&nbsp;:</para>

<!--
          <informalexample>
            <screen>
$ svn propdel - -revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
</informalexample>
-->
          <informalexample>
            <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.exemple.com/miroir-svn
Propriété 'svn:sync-lock' supprimée de la révision 0 du dépôt
$
</screen>
          </informalexample>

<!--
          <para>Also, <command>svnsync</command> stores the source
            repository URL provided at mirror initialization time in a
            bookkeeping property on the mirror repository.  Future
            synchronization operations against that mirror which omit
            the source URL at the command line will consult the
            special <literal>svn:sync-from-url</literal> property
            stored on the mirror itself to know where to synchronize
            from.  This value is used literally by the synchronization
            process, though.  Be wary of using non-fully-qualified
            domain names (such as referring
            to <literal>svnbook.red-bean.com</literal> as
            simply <literal>svnbook</literal> because that happens to
            work when you are connected directly to
            the <literal>red-bean.com</literal> network), domain names
            which don't resolve or resolve differently depending on
            where you happen to be operating from, or IP addresses
            (which can change over time).  But here again, if you need
            an existing mirror to start referring to a different URL
            for the same source repository, you can change the
            bookkeeping property which houses that information.  Users
            of Subversion 1.7 or better can use <command>svnsync init
            - -allow-non-empty</command> to reinitialize their mirrors
            with new source URL:</para>
-->
          <para>Le fait que <command>svnsync</command> stocke l'URL du
            dépôt source dans une propriété qui lui est dédiée au sein
            du dépôt destination est la raison pour laquelle vous n'avez
            à renseigner cette URL qu'une seule fois, au moment de
            <command>svnsync init</command>. Les opérations suivantes de
            synchronisation de ce miroir se contentent de consulter la
            propriété <literal>svn:sync-from-url</literal> stockée dans
            le dépôt miroir lui-même pour déterminer la source de la
            synchronisation. Notez bien que cette valeur est utilisée
            telle quelle par le processus de synchronisation. Faites
            donc attention à ne pas utiliser de nom de domaine non
            complétement qualifié (tel que <literal>svnbook</literal>
            au lieu de <literal>svnbook.read-bean.com</literal>, qui
            fonctionne à l'intérieur du réseau
            <literal>red-bean.com</literal> mais pas à l'extérieur), de
            nom de domaine qui ne serait pas résolu ou résolu
            différemment en fonction de l'endroit où vous êtes connecté,
            ou une adresse IP (qui peut changer avec le temps).
            Là encore, si vous devez changer l'URL de la source (ayant
            le même contenu) d'un dépôt miroir existant, vous pouvez
            changer la propriété de journalisation qui stocke cette
            information. Les utilisateurs de Subversion 1.7 ou ultérieur
            peuvent utiliser <command>svnsync init
            --allow-non-empty</command> pour réinitialiser leurs
            mirroirs avec une nouvelle URL&nbsp;:</para>

          <informalexample>
            <screen><!--
$ svnsync initialize - -allow-non-empty http://svn.example.com/svn-mirror \
                                       <replaceable>NEW-SOURCE-URL</replaceable>
Copied properties for revision 4065.
-->
$ svn initialize --allow-non-empty http://svn.exemple.com/miroir-svn \
                                   <replaceable>NOUVELLE-URL-SOURCE</replaceable>
Propriétés copiées pour la révision 4065.
$
</screen>
          </informalexample>

<!--
          <para>If you are running an older version of Subversion,
            you'll need to manually tweak
            the <literal>svn:sync-from-url</literal> bookkeeping
            property:</para>
-->
          <para>Si vous disposez d'une version plus ancienne de
            Subversion, vous devrez ajuster manuellement la
            propriété de journalisation
            <literal>svn:sync-from-url</literal>&nbsp;:</para>

          <informalexample>
            <screen><!--
$ svn propset - -revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0-->
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NOUVELLE-URL-SOURCE</replaceable> \
      http://svn.exemple.com/miroir-svn
Propriété 'svn:sync-from-url' définie à la révision 0 du dépôt
$
</screen>
          </informalexample>

<!--
          <para>Another interesting thing about these special
            bookkeeping properties is that <command>svnsync</command>
            will not attempt to mirror any of those properties when they
            are found in the source repository.  The reason is probably
            obvious, but basically boils down to
            <command>svnsync</command> not being able to distinguish the
            special properties it has merely copied from the source
            repository from those it needs to consult and maintain for
            its own bookkeeping needs.  This situation could occur if,
            for example, you were maintaining a mirror of a mirror of a
            third repository.  When <command>svnsync</command> sees its
            own special properties in revision 0 of the source
            repository, it simply ignores them.</para>
-->
          <para>Un autre point intéressant concernant ces propriétés
            liées à la synchronisation est que
            <command>svnsync</command> n'essaie pas de répliquer ces
            propriétés s'il les trouve dans le dépôt source. La raison
            en est probablement évidente mais est due en résumé au fait
            que <command>svnsync</command> n'est pas capable de
            distinguer les propriétés spéciales qu'il n'a fait que
            copier à partir du dépôt source de celles qu'il doit
            consulter et tenir à jour pour ses propres besoins. Cette
            situation peut arriver si, par exemple, vous hébergez le
            miroir d'un miroir d'un dépôt. Quand
            <command>svnsync</command> voit ses propres propriétés de
            synchronisation dans la révision 0 du dépôt source, il les
            ignore purement et simplement.</para>

<!--
          <para>An <command>svnsync info</command> subcommand was
            added in Subversion 1.6 to easily display the special
            bookkeeping properties in the destination
            repository.</para>
-->
          <para>Une sous-commande <command>svnsync info</command> a été
            ajoutée dans Subversion 1.6 pour afficher facilement les
            propriétés spéciales de journalisation sur le dépôt
            destination.</para>

<!--
          <informalexample>
            <screen>
$ svnsync help info
info: usage: svnsync info DEST_URL

Print information about the synchronization destination repository
located at DEST_URL.
&hellip;
$ svnsync info http://svn.example.com/svn-mirror
Source URL: https://svn.code.sf.net/p/svnbook/source
Source Repository UUID: 931749d0-5854-0410-9456-f14be4d6b398
Last Merged Revision: 4065
$
</screen>
          </informalexample>
-->
          <informalexample>
            <screen>
$ svnsync help info
info: usage : svnsync info URL_DEST

Affiche les informations du dépôt destination d'une synchronisation
à URL_DEST.
&hellip;
$ svnsync info http://svn.exemple.com/mirroir-svn
URL source : https://svn.code.sf.net/p/svnbook/source
UUID du dépôt source : 931749d0-5854-0410-9456-f14be4d6b398
Dernière révision fusionnée : 4065
$
</screen>
          </informalexample>
        </sidebar>

<!--
        <para>There is, however, one bit of inelegance in the process.
          Because Subversion revision properties can be changed at any
          time throughout the lifetime of the repository, and because
          they don't leave an audit trail that indicates when they were
          changed, replication processes have to pay special attention
          to them.  If you've already mirrored the first 15 revisions of
          a repository and someone then changes a revision property on
          revision 12, <command>svnsync</command> won't know to go back
          and patch up its copy of revision 12.  You'll need to tell it
          to do so manually by using (or with some additional tooling
          around) the <command>svnsync copy-revprops</command>
          subcommand, which simply rereplicates all the revision
          properties for a particular revision or range thereof.</para>
-->
        <para>Le procédé est cependant peu élégant. Comme les propriétés
          des révisions Subversion peuvent être modifiées n'importe
          quand dans la vie du dépôt et comme elles ne conservent pas de
          trace des modifications effectuées, les processus de
          réplication doivent faire particulièrement attention à ces
          propriétés. Si vous avez déjà répliqué les quinze premières
          révisions d'un dépôt et que quelqu'un modifie une propriété de
          révision concernant la révision 12, <command>svnsync</command>
          ne sait pas qu'il faut revenir en arrière et modifier la copie
          de la révision 12. Vous devez le lui indiquer manuellement en
          utilisant la sous-commande <command>svnsync
          copy-revprops</command> (ou à l'aide d'autres outils), ce qui
          re-réplique toutes les propriétés de révision pour une
          révision particulière ou un ensemble de révisions.</para>

        <informalexample>
          <screen><!--
$ svnsync help copy-revprops
copy-revprops: usage:

    1. svnsync copy-revprops DEST_URL [SOURCE_URL]
    2. svnsync copy-revprops DEST_URL REV[:REV2]

&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
-->
copy-revprops: usage :

    1. svnsync copy-revprops URL_DEST [URL_SOURCE]
    2. svnsync copy-revprops URL_DEST REV[:REV2]

&hellip;
$ svnsync copy-revprops http://svn.exemple.com/mirroir-svn 12
Propriétés copiées pour la révision 12.
$
</screen>
        </informalexample>

<!--
        <para>That's repository replication
          via <command>svnsync</command> in a nutshell.  You'll likely
          want some automation around such a process.  For example,
          while our example was a pull-and-push setup, you might wish to
          have your primary repository push changes to one or more
          blessed mirrors as part of its post-commit and
          post-revprop-change hook implementations.  This would enable
          the mirror to be up to date in as near to real time as is
          likely possible.</para>
-->
        <para>C'en est fini pour la présentation rapide de la
          réplication de dépôt. Vous voudrez sûrement automatiser un
          certain nombre de choses autour de ce processus. Par exemple,
          alors que notre exemple présentait une mise en place
          <quote>tirer-et-pousser</quote>, vous êtes susceptible de
          vouloir que ce soit le dépôt source qui pousse les
          modifications vers un ou plusieurs miroirs prédéfinis lors de
          l'exécution des procédures automatiques
          <literal>post-commit</literal> et
          <literal>post-revprop-change</literal>. Ceci permettrait au
          miroir d'être à jour presque en temps réel.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-partial">
<!--
        <title>Partial replication with svnsync</title>
-->
        <title>Réplication partielle avec svnsync</title>

<!--
        <para><command>svnsync</command> isn't limited to full copies
          of everything which lives in a repository.  It can handle
          various shades of partial replication, too.  For example,
          while it isn't very commonplace to do so,
          <command>svnsync</command> does gracefully mirror repositories
          in which the user as whom it authenticates has only partial
          read access.  It simply copies only the bits of the repository
          that it is permitted to see.  Obviously, such a mirror is not
          useful as a backup solution.</para>
-->
        <para><command>svnsync</command> n'est pas limitée à la copie
          intégrale de tout ce qui se trouve dans le dépôt. Elle peut
          aussi prendre en compte toute une variation de réplications
          partielles. Par exemple, bien que ce ne soit pas une situation
          très courante, <command>svnsync</command> sait répliquer des
          dépôts pour lesquels l'identifiant qu'elle utilise pour
          s'authentifier n'a que des droits partiels en lecture. Elle
          copie simplement les parties du dépôt qu'elle est autorisée à
          voir. Un tel miroir n'est clairement pas une bonne solution de
          sauvegarde..</para>

<!--
        <para>As of Subversion 1.5, <command>svnsync</command> also
          has the ability to mirror a subset of a repository rather than
          the whole thing.  The process of setting up and maintaining
          such a mirror is exactly the same as when mirroring a whole
          repository, except that instead of specifying the source
          repository's root URL when running <command>svnsync
          init</command>, you specify the URL of some subdirectory
          within that repository.  Synchronization to that mirror will
          now copy only the bits that changed under that source
          repository subdirectory.  There are some limitations to this
          support, though.  First, you can't mirror multiple disjoint
          subdirectories of the source repository into a single mirror
          repository&mdash;you'd need to instead mirror some parent
          directory that is common to both.  Second, the filtering
          logic is entirely path-based, so if the subdirectory you are
          mirroring was renamed at some point in the past, your mirror
          would contain only the revisions since the directory appeared
          at the URL you specified.  And likewise, if the source
          subdirectory is renamed in the future, your synchronization
          processes will stop mirroring data at the point that the
          source URL you specified is no longer valid.</para>
-->
        <para>Avec Subversion 1.5, <command>svnsync</command> a acquis
          la capacité de répliquer uniquement un sous-ensemble d'un
          dépôt plutôt que le dépôt entier. La procédure pour configurer
          et assurer la maintenance d'un tel miroir est exactement la
          même que pour répliquer un dépôt entier, excepté lors du
          passage de l'URL du dépôt source à <command>svnsync
          init</command>&nbsp;: vous spécifiez l'URL d'un sous-dossier à
          l'intérieur du dépôt. La synchronisation du miroir ne copie
          que les modifications relatives à l'arborescence sous le
          répertoire indiqué. Notez quand même quelques restrictions sur
          cette fonction&nbsp;: premièrement, vous ne pouvez pas
          répliquer plusieurs sous-dossiers disjoints du dépôt source
          vers un unique dépôt miroir &mdash; vous devez dans ce cas
          répliquer un répertoire parent qui est commun à tous les
          répertoires que vous voulez répliquer&nbsp;; deuxièmement, la
          logique de filtrage est entièrement basée sur le chemin
          d'accès donc, si le sous-dossier que vous répliquez a été
          renommé par le passé, votre miroir ne contiendra que les
          révisions depuis lesquelles il a le nom indiqué dans l'URL que
          vous avez spécifiée. Et, de la même manière, si le
          sous-dossier source est renommé dans le futur, le processus de
          synchronisation ne répliquera plus les données à partir du
          moment où l'URL que vous avez spécifiée ne sera plus
          valide.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-init-nonempty">
<!--
        <title>A quick trick for mirror creation</title>
-->
        <title>Une astuce rapide pour la création de mirroirs</title>

<!--
        <para>We mentioned previously the cost of setting up an
          initial mirror of an existing repository.  For many folks,
          the sheer cost of transmitting thousands&mdash;or
          millions&mdash;of revisions of history to a new mirror
          repository via <command>svnsync</command> is a show-stopper.
          Fortunately, Subversion 1.7 provides a workaround by way of
          a new <option>- -allow-non-empty</option> option to
          <command>svnsync initialize</command>.  This option allows
          you to initialize one repository as a mirror of another
          while bypassing the verification that the to-be-initialized
          mirror has no version history present in it.  Per our
          previous warnings about the sensitivity of this whole
          replication process, you should rightly discern that this is
          an option to be used only with great caution.  But it's
          wonderfully handy when you have administrative access to the
          source repository, where you can simply make a physical copy
          of the repository and then initialize that copy as a new
          mirror:</para>
-->
        <para>Nous avons mentionné le coût de mise en place d'un mirroir
          pour un dépôt existant. Pour beaucoup, le coût apparent de
          transmettre des milliers (voire des millions) de révisions de
          l'historique vers un nouveau dépôt mirroir avec
          <command>svnsync</command> est le point d'arrêt final.
          Heureusement, Subversion 1.7 offre une porte de sortie avec la
          nouvelle option <option>--allow-non-empty</option> de
          <command>svnsync initialize</command>. Cette option vous
          permet d'initialiser un dépôt comme mirroir d'un autre en
          courtcircuitant la vérification que le dépôt à initialiser
          possède bien un historique vide. À la lecture de nos
          précédents avertissements sur la sensibilité du processus de
          réplication, vous devriez pressentir que cette option à
          n'utiliser qu'avec la plus grande prudence. Mais elle est
          terriblement efficace si vous avez les droits d'accès au dépôt
          source et que vous pouvez faire une copie physique du dépôt,
          puis initialiser cette copie en tant que nouveau
          mirroir&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svnadmin hotcopy /path/to/repos /path/to/mirror-repos
$ ### create /path/to/mirror-repos/hooks/pre-revprop-change
$ svnsync initialize file:///path/to/mirror-repos \
                     file:///path/to/repos
svnsync: E000022: Destination repository already contains revision history; co
nsider using - -allow-non-empty if the repository's revisions are known to mirr
or their respective revisions in the source repository
$ svnsync initialize - -allow-non-empty file:///path/to/mirror-repos \
                                       file:///path/to/repos
Copied properties for revision 32042.-->
$ svnadmin hotcopy /chemin/vers/depot /chemin/vers/depot-mirroir
$ ### créer le fichier /chemin/vers/depot-mirroir/hooks/pre-revprop-change
$ svnsync initialize file:///chemin/vers/depot-mirroir \
                     file:///chemin/vers/depot
svnsync: E000022: Le dépôt destination contient déjà des révisions ; utilisez
éventuellement l'option --allow-non-empty si ces révisions correspondent à
leurs contreparties dans le dépôt source
$ svnsync initialize --allow-non-empty file:///chemin/vers/depot-mirroir \
                                       file:///chemin/vers/depot
Propriétés copiées pour la révision 32042.
$
</screen>
        </informalexample>

<!--
        <para>Admins who are running a version of Subversion prior to
          1.7 (and thus do not have access to <command>svnsync
          initialize</command>'s <option>- -allow-non-empty</option>
          feature) can accomplish effectively the same thing that that
          feature does through <emphasis>careful</emphasis>
          manipulation of the r0 revision properties on the copy of
          the repository which is slated to become a mirror of the
          original.  Use <command>svnadmin setrevprop</command> to
          create the same bookkeeping properties
          that <command>svnsync</command> would have created
          there.</para>
-->
        <para>Les administrateurs qui utilisent une version antérieure
          à Subversion 1.7 (et qui n'ont donc pas accès à l'option
          <option>--allow-non-empty</option>de
          <command>svnsync initialize</command>) peuvent atteindre le
          même résultat en manipulant
          <emphasis>précautionneusement</emphasis> la propriété de la
          révision r0 sur la copie du dépôt qui a vocation à devenir un
          mirroir. Utilisez <command>svnadmin setrevprop</command> pour
          créer les mêmes propriétés de journalisation que
          <command>svnsync</command> aurait créées.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.wrapup">
<!--
        <title>Replication wrap-up</title>
-->
        <title>Autour des réplications</title>

<!--
        <para>We've discussed a couple of ways to replicate revision
          history from one repository to another.  So let's look now
          at the user end of these operations.  How does replication
          and the various situations which call for it affect
          Subversion clients?</para>
-->

        <para>Nous avons vu deux façons de répliquer l'historique des
          révisions d'un dépôt vers un autre. Regardons maintenant les
          choses du point de vue de l'utilisateur. Comment les
          réplications et les diverses situations qui y font appel
          affectent-elles les clients Subversion&nbsp;?</para>

<!--
        <para>As far as user interaction with repositories and mirrors
          goes, it <emphasis>is</emphasis> possible to have a single
          working copy that interacts with both, but you'll have to
          jump through some hoops to make it happen.  First, you need
          to ensure that both the primary and mirror repositories have
          the same repository UUID (which is not the case by default).
          See <xref linkend="svn.reposadmin.maint.uuids" /> later in
          this chapter for more about this.</para>
-->
        <para>Tant que l'on considère les interactions relatives aux
          dépôts et mirroirs, une copie de travail unique
          <emphasis>peut</emphasis> interagir avec les deux, mais vous
          devrez jongler un peu pour y arriver. D'abord, vous devez vous
          assurer que le dépôt primaire et le mirroir possèdent bien le
          même UUID (ce qui n'est pas le cas par défaut). Reportez-vous
          à <xref linkend="svn.reposadmin.maint.uuids" /> plus loin dans
          ce chapitre pour en savoir davantage.</para>

<!--
        <para>Once the two repositories have the same UUID, you can use
          <command>svn relocate</command> to point your working
          copy to whichever of the repositories you wish to operate
          against, a process that is described in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref"/>.  There is a possible danger here,
          though, in that if the primary and mirror repositories
          aren't in close synchronization, a working copy up to date
          with, and pointing to, the primary repository will, if
          relocated to point to an out-of-date mirror, become confused
          about the apparent sudden loss of revisions it fully expects
          to be present, and it will throw errors to that effect.  If
          this occurs, you can relocate your working copy back to the
          primary repository and then either wait until the mirror
          repository is up to date, or backdate your working copy to a
          revision you know is present in the sync repository, and
          then retry the relocation.</para>
-->
        <para>Une fois que les dépôts possèdent le même UUID, vous
          pouvez utiliser <command>svn relocate</command> pour faire
          pointer votre copie de travail vers le dépôt avec lequel vous
          souhaitez travailler&nbsp;; cette procédure est décrite dans
          <xref linkend="svn.ref.svn.c.relocate" /> dans
          <xref linkend="svn.ref"/>. Un danger vous guette ici
          cependant, car si les dépôts ne sont pas parfaitement
          synchrones, une copie de travail à jour et pointant vers le
          dépôt principal sera, si vous la faites pointer vers un
          mirroir obsolète, déboussolée par la perte apparente et
          soudaine des révisions qu'elle s'attend à trouver dans le
          dépôt. Elle renverra des erreurs pour vous le signaler. Si
          jamais cela survient, vous pouvez refaire pointer votre copie
          de travail vers le dépôt primaire et, soit attendre que le
          dépôt mirroir se mette à jour, soit remonter dans le temps
          votre copie de travail vers une révision dont vous savez
          qu'elle figure dans le dépôt mirroir, puis tenter à nouveau
          de faire pointer votre copie de travail vers ce
          mirroir.</para>

<!--
        <para>Finally, be aware that the revision-based replication
          provided by <command>svnsync</command> is only
          that&mdash;replication of revisions.  Only the kinds of
          information carried by the Subversion repository dump file
          format are available for replication.  As such, tools such
          as <command>svnsync</command>
          (and <command>svnrdump</command>, which we discuss in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />)
          are limited in ways similar to that of the repository dump
          stream.  They do not include in their replicated information
          such things as the hook implementations, repository or
          server configuration data, uncommitted transactions, or
          information about user locks on repository paths.</para>
-->
        <para>Enfin, soyez conscient que la réplication des révisions
          fournie par <command>svnsync</command> n'est que cela &nbsp;:
          une réplication de révisions. Seules les informations pouvant
          être contenues dans le format de fichier dump des dépôts
          Subversion peuvent être répliquées. Ainsi, les outils tels que
          <command>svnsync</command> (et <command>svnrdump</command> que
          nous avons vu dans <xref
          linkend="svn.reposadmin.maint.migrate.svnrdump" />) possèdent
          les mêmes limites intrinsèques aux fichiers dump. Ils ne
          répliquent pas les procédures automatiques, les transactions
          non propagées ou les verrous posés par les utilisateurs sur
          les chemins du dépôt.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
<!--
      <title>Repository Backup</title>
-->
      <title>Sauvegarde d'un dépôt</title>

<!--
      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>
-->
      <para>En dépit des nombreux progrès de la technologie depuis
        l'avènement de l'informatique moderne, une chose reste
        certaine&nbsp;: le pire n'est jamais très loin. L'alimentation
        électrique tombe en panne, les réseaux subissent des coupures,
        les mémoires vives crament, les disques durs flanchent, et ce
        même pour le plus consciencieux des administrateurs. Nous en
        venons donc maintenant à un sujet très important&nbsp;: comment
        réaliser des copies de sauvegarde des données de votre
        dépôt.</para>

<!--
      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>
-->
      <para>Les administrateurs de dépôts Subversion disposent de deux
        méthodes de sauvegarde&nbsp;: la complète et l'incrémentale. Une
        sauvegarde complète d'un dépôt implique de récupérer d'un seul
        coup toutes les informations nécessaires pour reconstruire
        complètement ce dépôt dans le cas d'une catastrophe.
        Habituellement, cela consiste à dupliquer, littéralement, la
        totalité du répertoire du dépôt (ce qui inclut l'environnement
        Berkeley DB ou FSFS). Les sauvegardes incrémentales sont plus
        restreintes&nbsp;: elles ne sauvegardent que les données du
        dépôt qui ont changé depuis la sauvegarde précédente.</para>

<!--
      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutiae involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>
-->
      <para>Pour ce qui concerne les sauvegardes complètes, l'approche
        naïve pourrait sembler satisfaisante. Mais à moins d'interdire
        temporairement tout accès au dépôt, une simple copie récursive
        du répertoire risque de créer une sauvegarde corrompue. Dans le
        cas d'une base de données Berkeley DB, la documentation décrit
        un certain ordre de copie des fichiers qui garantit une copie de
        sauvegarde valide. Un ordre similaire existe avec les données
        FSFS. Mais vous n'avez pas à implémenter ces algorithmes
        vous-même, puisque l'équipe de développement de Subversion l'a
        déjà fait pour vous. La commande <command>svnadmin
        hotcopy</command> prend soin de tout ça afin de réaliser une
        copie à chaud de votre dépôt. Et son invocation est aussi
        triviale que la commande Unix <command>cp</command> ou qu'une
        copie sous Windows&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup-->
$ svnadmin hotcopy /var/svn/depot /var/svn/depot-sauvegarde
</screen>
      </informalexample>

<!--
      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>
-->
      <para>La sauvegarde générée est un dépôt Subversion totalement
        fonctionnel, capable de prendre immédiatement la place de votre
        dépôt en production si les choses tournent au vinaigre.</para>

<!--
      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>
-->
      <para>Des outils additionnels existent également autour de cette
        commande. Le répertoire <filename>tools/backup</filename> du
        code source de Subversion contient le script
        <command>hot-backup.py</command>. Ce script ajoute de la gestion
        de sauvegardes par-dessus <command>svnadmin hotcopy</command>,
        permettant de ne garder que les dernières sauvegardes (le nombre
        de sauvegardes à conserver est configurable) de chaque dépôt. Il
        gère automatiquement les noms des répertoires sauvegardés pour
        éviter les collisions avec les précédentes sauvegardes et
        élimine par rotation les sauvegardes les plus anciennes. Même
        si vous réalisez aussi des sauvegardes incrémentales, cette
        commande vous servira peut-être régulièrement. Par exemple, vous
        pouvez utiliser <command>hot-backup.py</command> dans un outil
        permettant le lancement différé de commandes (tel que
        <command>cron</command> sur les systèmes Unix) afin de le lancer
        toutes les nuits (ou à tout autre intervalle de temps qui vous
        convient mieux).</para>

<!--
      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with
        the <option>- -incremental</option> option to perform an
        incremental backup of a given revision or range of revisions.
        And of course, you can achieve a full backup variation of this
        by omitting the <option>- -incremental</option> option to that
        command.  There is some value in these methods, in that the
        format of your backed-up information is flexible&mdash;it's
        not tied to a particular platform, versioned filesystem type,
        or release of Subversion or the libraries it uses.  But that
        flexibility comes at a cost, namely that restoring that data
        can take a long time&mdash;longer with each new revision
        committed to your repository.  Also, as is the case with so
        many of the various backup methods, revision property changes
        that are made to already backed-up revisions won't get picked
        up by a nonoverlapping, incremental dump generation.  For
        these reasons, we recommend against relying solely on
        dump-based backup approaches.</para>
-->
      <para>Quelques administrateurs utilisent un autre mécanisme de
        sauvegarde basé sur la génération et le stockage de flux dump
        des dépôts. Nous avons décrit dans <xref
        linkend="svn.reposadmin.maint.migrate" /> comment utiliser
        <command>svnadmin dump</command> avec l'option
        <option>--incremental</option> pour réaliser une sauvegarde
        incrémentale d'une révision ou d'un intervalle de révisions
        donné. Et bien sûr, vous pouvez réaliser une sauvegarde complète
        en omettant l'option <option>--incremental</option> dans la
        commande. Cette méthode comporte certains avantages, entre
        autres que le format de vos informations sauvegardées est
        flexible (il n'est pas lié à une plateforme, à un type de
        magasin de données ou à une version particulière de Subversion
        ou des bibliothèques qu'il utilise). Mais cette flexibilité a un
        coût, à savoir le temps de restauration des données, qui en plus
        augmente avec chaque nouvelle révision propagée dans le dépôt. Aussi,
        comme c'est le cas pour un tas d'autres méthodes de sauvegarde, les
        modifications sur les propriétés de révision qui sont effectuées
        après une sauvegarde de ladite révision ne sont pas prises en
        compte par l'utilisation de flux de dump incrémentaux ne se
        chevauchant pas. C'est pourquoi nous recommandons de ne pas se
        reposer uniquement sur le type de sauvegarde basé sur les
        fichiers dump.</para>

<!--
      <para>Beginning with Subversion 1.8, <command>svnadmin hotcopy</command>
        accepts <option>- -incremental</option> option and supports incremental
        hotcopy mode for FSFS repositories.  In incremental hotcopy mode,
        revision data which has already been copied from the source to the
        destination repository will not be copied again. When
        <option>- -incremental</option> option is used with
        <command>svnadmin hotcopy</command>, Subversion will only copy new
        revisions, and revisions which have changed in size or had their
        modification time stamp changed since the previous hotcopy
        operation.  Moreover, unlike with <command>svnsync</command> or
        <command>svnadmin dump - -incremental</command>, performance of
        <command>svnadmin hotcopy - -incremental</command> is only limited to
        disk I/O.  Therefore, incremental hotcopy can be a huge
        time saver when making a backup of a large repository.</para>
-->
      <para>À partir de Subversion 1.8, <command>svnadmin
        hotcopy</command> accepte l'option
        <option>--incremental</option> et gère la copie à chaud des
        dépôts FSFS. Dans le mode de copie à chaud incrémentale, les
        données des révisions qui ont déjà été copiées vers le dépôt de
        destination ne seront pas copiées à nouveau. Lorsque l'option
        <option>--incremental</option> est utilisée avec
        <command>svnadmin hotcopy</command>, Subversion ne copie que les
        nouvelles révisions, les révisions dont la taille a changé et
        celles dont l'horodatage a été modifié depuis la précédente
        opération de copie à chaud. De plus, les performances de
        <command>svnadmin hotcopy --incremental</command> ne sont
        limitées que par les entrées/sorties disques, au contraire de
        <command>svnsync</command> ou <command>svnadmin dump
        --incremental</command>. En conséquence, les copies à chaud
        incrémentales peuvent vous faire économiser beaucoup de temps
        lors de la sauvegarde d'un gros dépôt.</para>

<!--
      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>
-->
      <para>Comme vous pouvez le constater, chaque type de sauvegarde a
        ses avantages et ses inconvénients. La méthode la plus facile
        est de loin la sauvegarde à chaud complète, qui fournit
        toujours une copie conforme et fonctionnelle de votre dépôt. En
        cas d'accident sur votre dépôt de production, vous pouvez
        effectuer une restauration à partir de votre sauvegarde par une
        simple copie récursive de répertoire. Malheureusement, si vous
        maintenez plusieurs sauvegardes de votre dépôt, chaque
        sauvegarde consomme autant d'espace disque que votre dépôt en
        production. Les sauvegardes incrémentales, en revanche, sont
        plus rapides à réaliser et prennent moins de place. Mais le
        processus de restauration peut s'avérer pénible, avec souvent
        plusieurs sauvegardes incrémentales à appliquer. D'autres
        méthodes ont leurs propres bizarreries. Les administrateurs
        doivent trouver le juste milieu entre le coût des sauvegardes et
        le coût de la restauration.</para>

<!--
      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>
-->
      <para>Le programme <command>svnsync</command> (voir <xref
        linkend="svn.reposadmin.maint.replication" />) fournit en fait
        une approche médiane assez pratique. Si vous synchronisez
        régulièrement un miroir en lecture seule avec votre dépôt
        principal, ce miroir en lecture seule se révèle être un bon
        candidat pour prendre le relais du dépôt défaillant en cas de
        besoin. Le principal inconvénient de cette méthode est que
        seules les données suivies en versions sont synchronisées &mdash;
        les fichiers de configuration du dépôt, les verrous utilisateurs
        sur les chemins ou d'autres éléments stockés physiquement dans
        le répertoire du dépôt mais pas <emphasis>dans le système de
        fichiers virtuel du dépôt</emphasis> ne sont pas pris en charge
        par <command>svnsync</command>.</para>

<!--
      <para>In any backup scenario, repository administrators need to
        be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change
        hooks.<footnote><para><command>svnadmin setlog</command> can
        be called in a way that bypasses the hook interface
        altogether.</para></footnote>  And since you can change
        revision properties without respect to chronological
        order&mdash;you can change any revision's properties at any
        time&mdash;an incremental backup of the latest few revisions
        might not catch a property modification to a revision that was
        included as part of a previous backup.</para>
-->
      <para>Quelle que soit la méthode de sauvegarde utilisée, les
        administrateurs doivent savoir comment les modifications des
        propriétés non suivies en versions des révisions sont prises en
        compte (ou pas). Puisque ces modifications elles-mêmes ne créent
        pas de nouvelles révisions, elles n'activent pas les
        procédures automatiques <literal>post-commit</literal> ni même
        éventuellement les procédures automatiques
        <literal>pre-revprop-change</literal> et
        <literal>post-revprop-change</literal><footnote>
          <para>La commande <command>svnadmin setlog</command> peut être
            utilisée de manière à contourner les procédures
            automatiques.</para>
        </footnote>.
        Et puisque vous pouvez modifier les propriétés de révision sans
        respecter l'ordre chronologique (vous pouvez changer n'importe
        quelle propriété de révision à n'importe quel moment), une
        sauvegarde incrémentale des dernières révisions pourrait ne pas
        intégrer la modification d'une propriété de révision qui faisait
        partie d'une sauvegarde précédente.</para>

<!--
      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
-->
      <para>En règle générale, seuls les plus paranoïaques ont besoin de
        sauvegarder le dépôt entier, disons, à chaque propagation.
        Cependant, en considérant qu'un dépôt donné possède des
        mécanismes de redondance autres avec une certaine granularité
        (tels que des courriels envoyés à chaque propagation ou des
        fichiers dumps incrémentaux), réaliser une copie à chaud de la
        base de données, dans le cadre des sauvegardes nocturnes
        quotidiennes des systèmes, est une bonne pratique
        d'administration. Ce sont vos données, protégez-les autant que
        vous le voulez.</para>

<!--
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of
        Fate,<footnote><para>You know&mdash;the collective term for
        all of her <quote>fickle fingers.</quote></para></footnote> it
        should certainly help you recover from those trying
        times.</para>
-->
      <para>Bien souvent, la meilleure approche de sauvegarde d'un dépôt
        consiste à ne pas mettre tous ses œufs dans le même panier, en
        utilisant une combinaison des méthodes décrites ici. Les
        développeurs Subversion, par exemple, sauvegardent le code
        source de Subversion chaque nuit en utilisant
        <command>hot-backup.py</command> et effectuent une copie
        distante par <command>rsync</command> de ces sauvegardes
        complètes&nbsp;; ils conservent plusieurs archives de tous les
        emails de notification des propagations et des changements de
        propriétés&nbsp;; ils ont également des miroirs maintenus par
        divers volontaires qui utilisent <command>svnsync</command>.
        Votre solution peut ressembler à cela, mais elle doit être
        adaptée à vos besoins et maintenir l'équilibre entre commodité
        et paranoïa. Et quoi que vous fassiez, vérifiez la validité de
        vos sauvegardes de temps en temps (à quoi servirait une roue de
        secours crevée&nbsp;?). Bien que tout ceci n'empêche pas votre
        matériel de subir les affres du destin<footnote>
          <para>Vous savez, le fameux <quote>concours de
            circonstances</quote>, celui auquel vous êtes arrivé
            premier.</para>
        </footnote>,
        cela vous aidera certainement à vous sortir de ces situations
        délicates.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
<!--
      <title>Managing Repository UUIDs</title>
-->
      <title>Gestion des identifiants uniques (UUID) des dépôts</title>

<!--
      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>
-->
      <para>Chaque dépôt Subversion possède un identifiant unique
        (<foreignphrase>Universally Unique IDentifier</foreignphrase>
        en anglais ou <firstterm>UUID</firstterm>). Cet UUID est utilisé
        par les clients Subversion pour vérifier l'identité d'un dépôt
        quand les autres formes de vérification ne sont pas
        satisfaisantes (telles que l'URL du dépôt qui peut varier avec
        le temps). En général, les administrateurs de dépôts n'ont jamais
        (ou très rarement) à se préoccuper des UUID autrement que comme
        d'un détail d'implémentation bas niveau de Subversion. Parfois,
        cependant, il faut prêter attention à ce détail.</para>

<!--
      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>
-->
      <para>En règle générale, les UUID de vos dépôts de production
        doivent être uniques. C'est le but, après tout, des UUID. Mais
        il y a des cas où vous voulez que les UUID de deux dépôts
        soient identiques. Par exemple, quand vous faites une copie de
        sauvegarde d'un dépôt, vous voulez que cette sauvegarde soit une
        réplique exacte de l'original afin que, dans le cas où vous
        restaureriez la sauvegarde pour remplacer le dépôt de
        production, ceci soit transparent pour les utilisateurs. Quand
        vous déchargez et chargez l'historique d'un dépôt (comme décrit
        précédemment dans <xref
        linkend="svn.reposadmin.maint.migrate" />), vous devez décider
        si vous incluez l'UUID dans le flux de données déchargées (le
        fichier dump) qui va dans le nouveau dépôt. Les circonstances
        vous imposeront la marche à suivre.</para>

<!--
      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>
-->
      <para>Il y a plusieurs façons de faire pour attribuer (ou
        modifier) un UUID à un dépôt, le cas échéant. Depuis Subversion
        1.5, il suffit d'utiliser la commande <command>svnadmin
        setuuid</command>. Si vous fournissez un UUID explicite à cette
        sous-commande, elle valide le format de l'UUID et fixe
        l'identifiant unique du dépôt à cette valeur. Si vous omettez
        l'UUID, un nouvel UUID est généré automatiquement pour votre
        dépôt.</para>

      <informalexample>
        <screen><!--
$ svnlook uuid /var/svn/repos -->
$ svnlook uuid /var/svn/depot
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  <!--
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos -->
$ svnadmin setuuid /var/svn/depot   # créer un nouvel UUID
$ svnlook uuid /var/svn/depot
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c <!--
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos -->
$ svnadmin setuuid /var/svn/depot \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restaure l'ancien UUID
$ svnlook uuid /var/svn/depot
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

<!--
      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load - -force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>.</para>
-->
      <para>Pour ceux qui utilisent une version de Subversion antérieure
        à 1.5, ces tâches sont un peu plus compliquées. Vous pouvez
        attribuer explicitement un UUID en redirigeant le flux d'un
        fichier dump qui comporte le nouvel UUID avec la commande
        <userinput>svnadmin load --force-uuid
        <replaceable>CHEMIN-DU-DEPOT</replaceable></userinput>.</para>

      <informalexample>
        <screen> <!--
$ svnadmin load - -force-uuid /var/svn/repos &lt;&lt;EOF-->
$ svnadmin load --force-uuid /var/svn/depot &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF<!--
$ svnlook uuid /var/svn/repos-->
$ svnlook uuid /var/svn/depot
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

<!--
      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>
-->
      <para>Faire générer un nouvel UUID à une ancienne version de
        Subversion n'est pas aussi simple. La meilleure façon de faire
        est certainement de trouver un moyen de générer un UUID puis
        d'affecter explicitement cet UUID au dépôt.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
<!--
    <title>Moving and Removing Repositories</title>
-->
    <title>Déplacement et suppression d'un dépôt</title>

<!--
    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>
-->
    <para>Les données d'un dépôt Subversion sont toutes contenues dans
      l'arborescence du répertoire du dépôt. Ainsi, vous pouvez déplacer
      un dépôt Subversion vers un autre endroit du disque, renommer un
      dépôt, copier un dépôt ou effacer un dépôt entier en utilisant les
      outils de votre système d'exploitation pour manipuler les
      répertoires &mdash; <command>mv</command>, <command>cp -a</command>
      et <command>rm -r</command> pour les plateformes Unix&nbsp;;
      <command>copy</command>, <command>move</command> et
      <command>rmdir /s /q</command> sous Windows&nbsp;; cliquodrome
      avec de nombreux explorateurs graphiques,&nbsp;etc.</para>

<!--
    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>
-->
    <para>Bien sûr, il y a souvent d'autres choses à faire lors de ce
      genre de manipulations. Par exemple, vous voulez peut-être mettre
      à jour la configuration de votre serveur Subversion pour le faire
      pointer vers le nouveau chemin du dépôt déplacé ou pour supprimer
      les éléments de configuration relatifs à un dépôt ayant été
      effacé. Si vous avez des processus automatiques qui publient des
      informations à partir de vos dépôts, ou qui leur sont relatives,
      ils doivent sûrement être mis à jour. La configuration des
      procédures automatiques a peut-être besoin d'être modifiée. Les
      utilisateurs doivent être informés. La liste est longue, mais vous
      avez sûrement des procédures d'exploitation et des règles
      d'administration de votre dépôt Subversion qui vous indiquent ce
      qu'il faut faire.</para>

<!--
    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including
      their UUIDs.  In some circumstances, this might be desirable.
      But in the instances where it is not, you'll need to generate a
      new UUID for one of these identical repositories.  See
      <xref linkend="svn.reposadmin.maint.uuids" /> for more about
      managing repository UUIDs.</para>
-->
    <para>Dans le cas d'un dépôt copié, vous devez aussi prendre en
      compte le fait que Subversion utilise l'identifiant unique UUID
      pour distinguer les dépôts. Si vous copiez un dépôt en utilisant
      la commande typique de copie récursive de votre interpréteur de
      commande, vous vous retrouvez avec deux dépôts absolument
      identiques, y compris en ce qui concerne l'UUID. Dans certains
      cas, c'est ce que l'on cherche. Dans d'autres cas, non. Vous devez
      alors générer un nouvel UUID pour l'un des deux dépôts identiques.
      Lisez <xref linkend="svn.reposadmin.maint.uuids" /> pour plus
      d'informations sur la gestion des UUID.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
<!--
    <title>Summary</title>
-->
    <title>Résumé</title>

<!--
    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>
-->
    <para>À présent vous devez avoir une compréhension de base de la
      création, la configuration et l'administration des dépôts
      Subversion. Nous vous avons présenté les différents outils qui
      vous assistent dans ces tâches. Tout au long de ce chapitre, nous
      avons identifié quelques chausse-trappes d'administration et
      proposé des solutions pour les éviter.</para>

<!--
    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>
-->
    <para>Tout ce qui vous reste à faire est de décider quelles données
      passionnantes vous allez héberger dans votre dépôt et, finalement,
      comment les mettre à disposition sur un réseau. Le prochain
      chapitre est entièrement consacré au travail en réseau.</para>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
