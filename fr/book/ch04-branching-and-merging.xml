<!-- -*- sgml -*- -->

<chapter id="svn.branchmerge">
<!--
  <title>Branching and Merging</title>
-->
  <title>Gestion des branches</title>

  <blockquote>
<!--
    <attribution>Confucius</attribution>
    <para><quote>君子务本
      (It is upon the Trunk that a gentleman works.)</quote></para>
-->
    <attribution>Confucius</attribution>
    <para><quote>君子务本
      (C'est sur le Tronc qu'un gentleman travaille).</quote></para>
  </blockquote>

<!--
  <para>Branching and merging are fundamental aspects of version
    control, simple enough to explain conceptually but offering just
    enough complexity and nuance to merit their own chapter in this
    book.  Herein, we'll introduce you to the general ideas behind
    these operations as well as Subversion's somewhat unique approach
    to them.  If you've not familiarized yourself with Subversion's
    basic concepts (found in <xref linkend="svn.basic"/>), we
    recommend that you do so before reading this chapter.</para>
-->
  <para>La création et la fusion de branches sont des concepts
    fondamentaux des systèmes de gestion de versions, simples à
    expliquer d'un point de vue conceptuel mais offrant suffisamment de
    complexité et de nuances pour mériter un chapitre dans ce livre.
    Nous allons introduire le concept général de ces opérations ainsi
    que l'approche, quelque peu unique, adoptée par Subversion. Ce
    chapitre suppose que vous êtes déjà familier avec les notions de
    bases de Subversion (expliquées dans le
    <xref linkend="svn.basic"/>)</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
<!--
    <title>What's a Branch?</title>
-->
    <title>Définition d'une branche</title>

<!--
    <para>Suppose it's your job to maintain a document for a division
      in your company&mdash;a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>
-->
    <para>Supposons que votre travail soit de maintenir un document
      pour une division de votre entreprise, un manuel par exemple.
      Un beau jour, une autre division vous demande le même manuel,
      mais avec quelques parties <quote>modifiées</quote> spécialement
      pour elle, puisqu'elle fait les choses légèrement
      différemment.</para>

<!--
    <para>What do you do in this situation?  You do the obvious: make
      a second copy of your document and begin maintaining the two
      copies separately.  As each department asks you to make small
      changes, you incorporate them into one copy or the other.</para>
-->
    <para>Que faites-vous dans cette situation&nbsp;? Tout naturellement,
      vous créez une seconde copie du document et commencez à maintenir
      les deux copies séparément. Puis, quand chaque division vous
      demande de faire des petites modifications, vous les incorporez
      dans une copie ou dans l'autre.</para>

<!--
    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they differ only in
      small, specific ways.</para>
-->
    <para>Vous voulez souvent faire la même modification dans les deux
      copies. Par exemple, si vous découvrez une coquille dans la
      première copie, il est très probable que la même coquille existe
      dans la deuxième copie. Les deux documents sont presque
      identiques, après tout&nbsp;; ils ne diffèrent qu'en quelques
      points mineurs et spécifiques.</para>

<!--
    <para>
      <indexterm>
        <primary>branches</primary>
      </indexterm>This is the basic concept of a branch&mdash;namely,
      a line of development that exists independently of another line,
      yet still shares a common history if you look far enough back in
      time.  A branch always begins life as a copy of something, and
      moves on from there, generating its own history (see
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>
-->
    <para>
      <indexterm>
        <primary>branches</primary>
      </indexterm>Voilà le concept de <firstterm>branche</firstterm>,
      c'est-à-dire une ligne de développement qui existe
      indépendamment d'une autre ligne, mais partage cependant une
      histoire commune avec elle, si vous remontez suffisamment loin en
      arrière dans le temps. Une branche commence toujours sa vie en
      tant que copie de quelque chose, puis diffère à partir de là,
      selon une histoire qui lui est propre (voir la
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

    <figure id="svn.branchmerge.whatis.dia-1">
<!--
      <title>Branches of development</title>
-->
      <title>Branches de développement</title>
      <graphic fileref="images/ch04dia1.png"/>
    </figure>

<!--
    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>
-->
    <para>Subversion possède des commandes pour vous aider à maintenir
      des branches parallèles de vos fichiers et répertoires. Il vous
      permet de créer des branches en faisant des copies de vos
      données et se souvient que les copies sont liées les unes aux
      autres. Il vous aide aussi à dupliquer les modifications d'une
      branche vers une autre. Enfin, il permet que des portions de
      votre copie de travail correspondent à différentes branches,
      afin que vous puissiez <quote>mélanger</quote> différentes
      lignes de développement dans votre travail quotidien.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
<!--
    <title>Using Branches</title>
-->
    <title>Utilisation des branches</title>

<!--
    <para>At this point, you should understand how each commit creates
      a new state of the filesystem tree (called a <quote>revision</quote>)
      in the repository.  If you don't, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>
-->
    <para>Rendu à ce chapitre, vous devriez avoir compris que chaque
      propagation crée une arborescence de fichiers entièrement
      nouvelle (appelée <quote>révision</quote>) dans le dépôt. Si ce
      n'est pas le cas, retournez vous informer sur les révisions dans
      <xref linkend="svn.basic.in-action.revs"/>.</para>

<!--
    <para>Let's revisit the example from
      <xref linkend="svn.basic"/>.  Remember that you and your
      collaborator, Sally, are sharing a repository that contains two
      projects, <filename>paint</filename> and
      <filename>calc</filename>.  Notice that in <xref
      linkend="svn.branchmerge.using.dia-1"/>, however, each project
      directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>
-->
    <para>Pour ce chapitre, nous reprendrons le même exemple qu'au
      <xref linkend="svn.basic"/>. Souvenez-vous que votre
      collaboratrice Sally et vous partagez un dépôt qui contient
      deux projets, <filename>paint</filename> et
      <filename>calc</filename>. Notez cependant que dans la
       <xref linkend="svn.branchmerge.using.dia-1"/>, le dossier de
       chaque projet contient désormais des sous-dossiers nommés
       <filename>trunk</filename> et <filename>branches</filename>.
       Les raisons de cette arborescence apparaîtront bientôt
       clairement.</para>

    <figure id="svn.branchmerge.using.dia-1">
<!--
      <title>Starting repository layout</title>
-->
      <title>Structure initiale du dépôt</title>
      <graphic fileref="images/ch04dia2.png"/>
    </figure>

<!--
    <para>As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>
-->
    <para>Comme avant, supposons que Sally et vous avez tous deux une
      copie de travail du projet <quote>calc</quote>. Plus
      spécifiquement, vous avez chacun une copie de travail de
      <filename>/calc/trunk</filename>. Tous les fichiers du projet
      sont dans ce sous-dossier plutôt que dans
      <filename>/calc</filename> lui-même, parce que votre équipe a
      décidé que la <quote>ligne principale</quote> de développement
      du projet allait se situer
      dans <filename>/calc/trunk</filename>.</para>

<!--
    <para>Let's say that you've been given the task of implementing a
      large software feature.  It will take a long time to write, and
      will affect all the files in the project.  The immediate problem
      is that you don't want to interfere with Sally, who is in the
      process of fixing small bugs here and there.  She's depending on
      the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit by bit, you'll surely break
      things for Sally (and other team members as well).</para>
-->
    <para>Disons que l'on vous a attribué la tâche d'implémenter une
      fonctionnalité du logiciel qui prendra longtemps à écrire et
      touchera à tous les fichiers du projet. Le problème immédiat est
      que vous ne voulez pas déranger Sally, qui est en train de
      corriger des bogues mineurs ici et là. Elle a besoin que la
      dernière version du projet
      (dans <filename>/calc/trunk</filename>) demeure en permanence
      utilisable. Si vous commencez à propager des changements petit
      à petit, vous allez sûrement rendre les choses difficiles pour
      Sally (ainsi que pour d'autres membres de l'équipe).</para>

<!--
    <para>One strategy is to crawl into a hole: you can stop sharing
      information for a week or two, gutting and reorganizing all the
      files in your private working copy but not committing or
      updating until you're completely finished with your task.  There
      are a number of problems with this, though.  First, it's not
      very safe.  Should something bad happen to your working copy or
      computer, you risk losing all your changes.  Second, it's not
      very flexible.  Unless you manually replicate your changes
      across different working copies or computers, you're stuck trying
      to make your changes in a single working copy.  Similarly, it's
      difficult to share your work-in-progress with anyone else.  A
      common software development <quote>best practice</quote> is to
      allow your peers to review your work as you go.  If nobody sees
      your intermediate commits, you lose potential feedback and may
      end up going down the wrong path for weeks before another person
      on your team notices.  Finally, when you're finished with all
      your changes, you might find it very difficult to merge your
      completed work with the rest of the company's main body of code.
      Sally (or others) may have made many other changes in the
      repository that are difficult to incorporate into your working
      copy when you eventually run <command>svn update</command> after
      weeks of isolation.</para>
-->
    <para>Une stratégie possible est de vous isoler&nbsp;: vous pouvez
      arrêter de partager des informations avec Sally pendant une
      semaine ou deux. C'est-à-dire commencer à modifier et à
      réorganiser les fichiers dans votre copie de travail, mais
      sans effectuer de propagation ni de mise à jour avant que vous
      n'ayez complètement terminé la tâche. Cette stratégie comporte
      certains risques. Premièrement, ce n'est pas sans danger. La
      plupart des gens aiment propager leurs modifications fréquemment,
      au cas où leur copie de travail aurait un accident. Deuxièmement,
      ce n'est pas très flexible. Si vous travaillez sur différents
      ordinateurs (vous avez peut-être une copie de travail de
      <filename>/calc/trunk</filename> sur deux machines différentes),
      vous aurez besoin de transférer manuellement vos changements entre
      les deux, ou bien de travailler sur une seule machine. De la même
      façon, il est difficile de partager vos changements en cours avec
      quelqu'un d'autre. Une des <quote>bonnes pratiques</quote> du
      monde du développement logiciel est de permettre à vos pairs de
      passer votre travail en revue au fur et à mesure. Si personne n'a
      accès à vos propagations intermédiaires, vous vous coupez
      d'éventuelles critiques et risquez de partir dans une mauvaise
      direction pendant des semaines avant que quelqu'un ne s'en
      aperçoive. Enfin, quand vous en aurez fini avec tous vos
      changements, vous pourriez avoir du mal à fusionner votre travail
      avec le code du reste de l'équipe. Sally (et les autres) peuvent
      avoir apporté de nombreux autres changements au dépôt, changements
      qui seront difficiles à incorporer dans votre copie de travail,
      notamment si vous lancez <command>svn update</command> après des
      semaines d'isolation.</para>

<!--
    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      not-yet-completed work frequently without interfering with
      others' changes and while still selectively sharing information
      with your collaborators.  You'll see exactly how this works as
      we continue.</para>
-->
    <para>Une solution bien meilleure est de créer votre propre
      branche, ou ligne de développement, dans le dépôt. Ceci vous
      permettra de sauvegarder fréquemment votre travail un peu
      boiteux sans interférer avec vos collaborateurs&nbsp;; vous pourrez
      toutefois partager une sélection d'informations avec eux. Vous
      découvrirez comment tout cela fonctionne exactement au fur et à
      mesure de ce chapitre.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
<!--
      <title>Creating a Branch</title>
-->
      <title>Création d'une branche</title>

<!--
      <para>Creating a branch is very simple&mdash;you make a copy of
        your project tree in the repository using the <command>svn
        copy</command> command.  Since your project's source code is
        rooted in the <filename>/calc/trunk</filename> directory, it's
        that directory that you'll copy.  Where should the new
        copy live?  Wherever you wish.  The repository location in
        which branches are stashed is left by Subversion as a matter
        of project policy.  Finally, your branch will need a name to
        distinguish it from other branches.  Once again, the name you
        choose is unimportant to Subversion&mdash;you can use whatever
        name works best for you and your team.</para>
-->
      <para>Créer une branche est très simple&nbsp;: il s'agit juste de
        faire une copie du projet dans le dépôt avec la commande
        <command>svn copy</command>. Subversion est capable de copier
        non seulement de simples fichiers, mais aussi des dossiers
        entiers. Dans le cas présent, vous voulez faire une copie du
        dossier <filename>/calc/trunk</filename>. Où doit résider la
        nouvelle copie&nbsp;? Là où vous le désirez, cette décision
        faisant partie de la gestion du projet. Enfin, votre branche se
        doit de posséder un nom, pour la distinguer des autres branches.
        Là encore, le nom que vous choisissez importe peu à Subversion
        (vous pouvez utiliser le nom qui vous convient personnellement
        ou à votre équipe).</para>

<!--
      <para>Let's assume that your team (like most) has a policy of
        creating branches in the <filename>branches</filename>
        directory that is a sibling of the project's trunk
        (the <filename>/calc/branches</filename> directory in our
        scenario).  Lacking inspiration, you settle
        on <literal>my-calc-branch</literal> as the name you wish to
        give your branch.  This means that you'll create a new
        directory, <filename>/calc/branches/my-calc-branch</filename>,
        which begins its life as a copy
        of <filename>/calc/trunk</filename>.</para>

-->
      <para>Supposons que votre équipe (comme la plupart des équipes)
        ait pour convention de créer les branches dans le répertoire
        <filename>branches</filename> qui se trouve au même niveau que
        la branche principale de votre projet (le répertoire
        <filename>/calc/branches</filename> dans notre scénario). Comme
        vous manquez d'inspiration, vous vous décidez pour
        <literal>ma-branche-calc</literal> come nom pour votre branche.
        Cela veut dire que vous allez créer un nouveau dossier,
        <filename>/calc/branches/ma-branche-calc</filename>,
        qui commence ainsi sa vie en tant que copie de
        <filename>/calc/trunk</filename>.</para>
<!--
      <para>
        <indexterm>
          <primary>copying</primary>
          <secondary>remote copies</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
          <secondary>creating</secondary>
        </indexterm>You may already have seen <command>svn
        copy</command> used to copy one file to another within a
        working copy.  But it can also be used to do
        a <firstterm>remote copy</firstterm>&mdash;a copy that
        immediately results in a newly committed repository revision
        and for which no working copy is required at all.  Just copy
        one URL to another:</para>
-->
      <para>
        <indexterm>
          <primary>copier</primary>
          <secondary>copies distantes</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
          <secondary>création</secondary>
        </indexterm>Vous avez peut-être déjà utilisé
        <command>svn copy</command> pour copier un fichier vers un
        autre à l'intérieur d'une copie de travail. Mais il peut aussi
        être utilisé pour effectuer une <firstterm>copie
        distante</firstterm> (une copie qui propage immédiatement une
        nouvelle révision dans le dépôt et pour laquelle aucune copie
        de travail n'est nécessaire). Il suffit juste de copier une
        URL vers une autre&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn copy ^/calc/trunk ^/calc/branches/my-calc-branch \
           -m "Creating a private branch of /calc/trunk."

Committed revision 341.
-->
$ svn copy ^/calc/trunk ^/calc/branches/ma-branche-calc \
      -m "Création d'une branche privée à partir de /calc/trunk."

Révision 341 propagée.
$
</screen>
      </informalexample>

<!--
      <para>This command causes a near-instantaneous commit in the
        repository, creating a new directory in revision 341.  The new
        directory is a copy of <filename>/calc/trunk</filename>.  This
        is shown in <xref linkend="svn.branchmerge.using.create.dia-1"
        />.<footnote><para>Subversion does not support copying between
        different repositories.  When using URLs with <command>svn
        copy</command> or <command>svn move</command>, you can only
        copy items within the same repository.</para></footnote>  While
        it's also possible to create a branch by using <command>svn
        copy</command> to duplicate a directory within the working
        copy, this technique isn't recommended.  It can be quite slow,
        in fact!  Copying a directory on the client side is a
        linear-time operation, in that it actually has to duplicate
        every file and subdirectory within that working copy directory
        on the local disk.  Copying a directory on the server,
        however, is a constant-time operation, and it's the way most
        people create branches.  In addition, this practice raises the
        possibility of copying mixed-revision working copies.  This isn't
        inherently dangerous, but can cause unnecessary complications later
        during merging.  If you do choose to create a branch by copying a
        working copy path, you should be sure the source directory has no
        local modifications and is not at mixed-revisions.</para>
-->
      <para>Cette commande entraîne une opération quasi-instantanée
        dans le dépôt, créant un nouveau dossier à la révision 341.
        Ce nouveau dossier est une copie de
        <filename>/calc/trunk</filename>, comme l'illustre la
        <xref linkend="svn.branchmerge.using.create.dia-1"/>
        <footnote>
        <para>Subversion n'accepte pas les copies entre des dépôts
          distincts. Quand vous utilisez des URLs avec
          <command>svn copy</command> et <command>svn move</command>,
          vous ne pouvez copier que des éléments faisant partie du
          même dépôt.</para>
        </footnote>.
        Bien qu'il soit aussi possible de créer une branche en
        utilisant <command>svn copy</command> pour dupliquer un dossier
        à l'intérieur de la copie de travail, cette technique n'est
        pas recommandée. Elle peut s'avérer assez lente, en fait&nbsp;!
        Copier un dossier côté client est une opération linéaire en
        terme de durée, puisque chaque fichier et chaque dossier doit
        être dupliqué sur le disque local. Copier un dossier sur le
        serveur, par contre, est une opération dont la durée est
        constante et c'est ainsi que la plupart des gens créent
        des branches. En plus, cette façon de faire engendre le risque
        de copier des copies de travail à révisions mélangées. Ce n'est
        pas intrinsèquement dangereux, mais peut causer des
        complications inutiles plus tard lors des fusions. </para>

      <figure id="svn.branchmerge.using.create.dia-1">
<!--
        <title>Repository with new copy</title>
-->
        <title>Dépôt avec nouvelle copie</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
<!--
        <title>Cheap Copies</title>
-->
        <title>Des copies peu coûteuses</title>

<!--
        <para>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&mdash;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're an experienced Unix user, you'll recognize this as
          the same concept behind a hard link.  As further changes are
          made to files and directories beneath the copied directory,
          Subversion continues to employ this hard link concept where
          it can.  It duplicates data only when it is necessary to
          disambiguate different versions of objects.</para>
-->
        <para>Le dépôt Subversion a un design particulier. Quand vous
          copiez un dossier, il n'y a pas à s'en faire pour la taille
          du dépôt&nbsp;: en fait Subversion ne duplique aucune donnée.
          Au lieu de ça, il crée une nouvelle entrée de dossier qui
          pointe vers une arborescence <emphasis>existante</emphasis>.
          Si vous êtes un utilisateur expérimenté d'Unix, vous
          reconnaîtrez là le concept de lien matériel
          (<foreignphrase>hard link</foreignphrase> en anglais). Au fur
          et à mesure des modifications faites aux fichiers et dossiers
          sous le dossier copié, Subversion continue à employer ce
          concept de lien matériel quand il le peut. Il duplique les
          données seulement s'il est nécessaire de lever l'ambiguïté
          entre différentes versions d'objets.</para>

<!--
        <para>This is why you'll often hear Subversion users talk
          about <quote>cheap copies.</quote>  It doesn't matter how
          large the directory is&mdash;it takes a very tiny, constant
          amount of time and space to make a copy of it.  In fact,
          this feature is the basis of how commits work in Subversion:
          each revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's web site and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>
-->
        <para>C'est pourquoi vous entendrez souvent les utilisateurs
          de Subversion parler de <quote>copies peu coûteuses</quote>
          (<foreignphrase>cheap copies</foreignphrase> en anglais).
          Peu importe la taille du dossier, la durée de la copie
          est constante et très faible, tout comme l'espace disque
          nécessaire. En fait, cette fonctionnalité est à la base du
          fonctionnement des propagations dans Subversion&nbsp;: chaque
          révision est une <quote>copie peu coûteuse</quote> de la
          révision précédente, avec juste quelques éléments modifiés à
          l'intérieur (pour en savoir plus à ce sujet, visitez le site
          web de Subversion et lisez les paragraphes relatifs à la
          méthode <quote>bubble up</quote> dans les documents de
          conception de Subversion).</para>

<!--
        <para>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and in space.  If you create a branch
          entirely within the repository (by running <userinput>svn copy
          <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput>),
          it's a quick, constant-time operation.  Make branches as
          often as you want.</para>
-->
        <para>Bien sûr, cette mécanique interne de copie et de partage
          des données est transparente pour l'utilisateur, qui n'y
          voit que de simples copies d'arborescences. Le point
          essentiel ici est que les copies sont peu coûteuses, aussi
          bien en temps qu'en espace disque. Si vous créez une branche
          entièrement à l'intérieur du dépôt (en lançant
          <userinput>svn copy <replaceable>URL1</replaceable>
          <replaceable>URL2</replaceable></userinput>), c'est une
          opération rapide, à durée constante. Créez des branches
          aussi souvent que vous le souhaitez.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
<!--
      <title>Working with Your Branch</title>
-->
      <title>Travail sur votre branche</title>

<!--
      <para>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>
-->
      <para>Maintenant que vous avez créé votre branche du projet, vous
        pouvez extraire une nouvelle copie de travail et commencer à
        l'utiliser&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A    my-calc-branch/doc
A    my-calc-branch/src
A    my-calc-branch/doc/INSTALL
A    my-calc-branch/src/real.c
A    my-calc-branch/src/main.c
A    my-calc-branch/src/button.c
A    my-calc-branch/src/integer.c
A    my-calc-branch/Makefile
A    my-calc-branch/README
Checked out revision 341.
-->
$ svn checkout http://svn.exemple.com/depot/calc/branches/ma-branche-calc
A  ma-branche-calc/doc
A  ma-branche-calc/src
A  ma-branche-calc/doc/INSTALL
A  ma-branche-calc/src/reel.c
A  ma-branche-calc/src/main.c
A  ma-branche-calc/src/bouton.c
A  ma-branche-calc/src/entier.c
A  ma-branche-calc/Makefile
A  ma-branche-calc/LISEZMOI
Révision 341 extraite.
$
</screen>
      </informalexample>

<!--
      <para>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't see them when she
        updates, because her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternative way of
        creating a working copy of a branch.)</para>
-->
      <para>Cette copie de travail n'a rien de spéciale&nbsp;; elle
        correspond juste à un dossier différent du dépôt. Cependant,
        quand vous propagerez vos modifications, Sally ne les verra
        pas quand elle effectuera une mise à jour, car sa copie de
        travail correspond à <filename>calc/trunk</filename> (pensez
        bien à lire <xref linkend="svn.branchmerge.switchwc"/> plus
        loin dans ce chapitre&nbsp;: la commande
        <command>svn switch</command> est une méthode alternative
        pour créer une copie de travail d'une branche).</para>

<!--
      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>
-->
      <para>Imaginons qu'une semaine passe et que les propagations
        suivantes ont lieu&nbsp;:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>,
            which creates revision 342.</para>
-->
          <para>Vous modifiez
          <filename>/calc/branches/ma-branche-calc/src/bouton.c</filename>,
          ce qui crée la révision 342.</para>
        </listitem>

        <listitem>
<!--
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>,
            which creates revision 343.</para>
-->
          <para>Vous modifiez
          <filename>/calc/branches/ma-branche-calc/src/entier.c</filename>,
          ce qui crée la révision 343.</para>
        </listitem>

        <listitem>
<!--
          <para>Sally makes a change to
            <filename>/calc/trunk/src/integer.c</filename>, which creates
            revision 344.</para>
-->
          <para>Sally modifie
            <filename>/calc/trunk/src/entier.c</filename>, ce qui crée
            la révision 344.</para>
        </listitem>
      </itemizedlist>

<!--
      <para>Now two independent lines of development (shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>) are happening on
        <filename>integer.c</filename>.</para>
-->
      <para>À présent, deux lignes de développement indépendantes (voir
      la <xref linkend="svn.branchmerge.using.work.dia-1"/>) existent
      pour <filename>entier.c</filename>.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
<!--
        <title>The branching of one file's history</title>
-->
        <title>Historique des branches d'un fichier</title>
        <graphic width="4.81in" depth="2.18in" fileref="images/basic-branch.png" />
      </figure>

<!--
      <para>Things get interesting when you look at the history of
        changes made to your copy of <filename>integer.c</filename>:</para>
-->
      <para>Les choses deviennent intéressantes quand on regarde
        l'historique des modifications apportées à votre copie de
        <filename>entier.c</filename>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ pwd
/home/user/my-calc-branch

$ svn log -v src/integer.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r343 | user | 2013-02-15 14:11:09 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch/src/integer.c

* integer.c:  frozzled the wazjub.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&hellip;
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
$ pwd
/home/utilisateur/ma-branche-calc

$ svn log -v src/entier.c
------------------------------------------------------------------------
r343 | utilisateur | 2002-11-07 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
Chemins modifiés :
   M /calc/branches/ma-branche-calc/src/entier.c

* entier.c:  machiné le bidule.

------------------------------------------------------------------------
r341 | utilisateur | 2002-11-03 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
Chemins modifiés :
   A /calc/branches/ma-branche-calc (from /calc/trunk:340)

Création d'une branche privée à partir de /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (mar. 29 oct. 2002) | 2 lignes
Chemins modifiés :
   M /calc/trunk/src/entier.c

* entier.c:  modifié une docstring.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (ven. 22 fev. 2002) | 2 lignes
Chemins modifiés :
  A /calc/trunk/src/entier.c

* entier.c:  modifié l'API trucplusse.
------------------------------------------------------------------------
r8 | sally | 2002-01-17 16:55:36 -0500 (mar. 17 jan. 2002) | 1 ligne
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/LISEZMOI
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/bouton.c
   A /calc/trunk/src/entier.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/reel.c

Import initial du code dans trunk pour le projet calc.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look at what happens when Sally runs the same
        command on her copy of the file:</para>
-->

      <para>Notez bien que Subversion reprend tout l'historique du
        <filename>entier.c</filename> de votre branche à travers le
        temps, remontant même au delà du point où il a été copié. Il
        liste la création d'une branche en tant qu'élément de
        l'historique, parce qu'<filename>entier.c</filename> a été
        copié implicitement lorsque <filename>calc/trunk</filename>
        tout entier a été copié. Maintenant regardez ce qui se passe
        quand Sally lance la même commande sur sa copie du
        fichier&nbsp;:</para>

<!--
      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/integer.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Refactor the bazzle functions.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&hellip;
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/entier.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
 Chemins modifiés :
    M /calc/trunk/src/entier.c

 * entier.c:  réusinage des fonctions trucmuches.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (mar. 29 oct. 2002) | 2 lignes
 Chemins modifiés :
    M /calc/trunk/entier.c

 * entier.c:  modifié une docstring.

------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (ven. 22 fev. 2002) | 2 lignes
Chemins modifiés :
  A /calc/trunk/src/entier.c

* entier.c:  modifié l'API trucplusse.
------------------------------------------------------------------------
r8 | sally | 2002-01-17 16:55:36 -0500 (mar. 17 jan. 2002) | 1 ligne
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/LISEZMOI
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/bouton.c
   A /calc/trunk/src/entier.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/reel.c

Import initial du code dans trunk pour le projet calc.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch copy was made in revision
        341, the files used to be the same file.  That's why you and
        Sally both see the changes made between revisions 8 and
        154.</para>
-->
      <para>Sally voit la modification due à sa propre révision 344,
        mais pas le changement que vous avez effectué dans la révision
        343. Pour Subversion, ces deux propagations ont touché des
        fichiers différents dans des dossiers distincts. Néanmoins,
        Subversion <emphasis>indique bien</emphasis> que les deux
        fichiers partagent une histoire commune. Avant que la copie de
        branche n'ait été faite en révision 341, les fichiers ne
        faisaient qu'un. C'est pourquoi Sally et vous voyez tous les
        deux les modifications apportées entre les révisions 8 et
        303.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
<!--
      <title>The Key Concepts Behind Branching</title>
-->
      <title>Gestion des branches par Subversion&nbsp;: notions clés</title>

<!--
      <para>You should remember two important lessons
        from this section.  First, Subversion has no internal concept
        of a branch&mdash;it knows only how to make copies.  When you
        copy a directory, the resultant directory is only
        a <quote>branch</quote> because <emphasis>you</emphasis>
        attach that meaning to it.  You may think of the directory
        differently, or treat it differently, but to Subversion it's
        just an ordinary directory that happens to carry some extra
        historical information.</para>
-->
      <para>Il y a deux leçons importantes à retenir de ce paragraphe.
        Premièrement, Subversion n'a pas de notion interne de
        branche &mdash; il sait seulement faire des copies. Quand
        vous copiez un dossier, le dossier qui en résulte n'est une
        <quote>branche</quote> que parce que <emphasis>vous</emphasis>
        le considérez comme tel. Vous aurez beau envisager ce dossier
        différemment ou le traiter différemment, pour Subversion c'est
        juste un dossier ordinaire auquel sont associées des
        informations extérieures relatives à son historique.</para>

<!--
      <para>Second, because of this copy mechanism, Subversion's
        branches exist as <emphasis>normal filesystem
        directories</emphasis> in the repository.  This is different
        from other version control systems, where branches are
        typically defined by adding
        extra-dimensional <quote>labels</quote> to collections of
        files.  The location of your branch directory doesn't matter
        to Subversion.  Most teams follow a convention of putting all
        branches into a <filename>/branches</filename> directory, but
        you're free to invent any policy you wish.</para>
-->
      <para>Deuxièmement, en raison de ce mécanisme de copie, les
        branches de Subversion existent en tant que
        <emphasis>dossiers classiques du système de fichiers</emphasis>
        du dépôt. En cela, Subversion diffère des autres systèmes
        de gestion de versions, où les branches sont définies par
        l'ajout d'<quote>étiquettes</quote>
        (<foreignphrase>labels</foreignphrase> en anglais)
        extra-dimensionnelles à des groupes de fichiers. L'emplacement
        du dossier de votre branche importe peu à Subversion. La plupart
        des équipes ont pour convention de placer toutes les branches
        dans un dossier <filename>/branches</filename>, mais vous êtes
        libre d'inventer la convention qui vous plaît.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.basicmerging">
<!--
    <title>Basic Merging</title>
-->
    <title>Fusions&nbsp;: pratiques de base</title>

<!--
    <para>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the trunk, or main line of development.</para>
-->
    <para>Désormais, Sally et vous travaillez sur des branches
      parallèles du projet&nbsp;: vous travaillez sur une branche
      privée et Sally travaille sur le <firstterm>tronc</firstterm>
      (<foreignphrase>trunk</foreignphrase> en anglais), la branche de
      développement principale.</para>

<!--
    <para>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>
-->
    <para>Pour les projets qui ont un grand nombre de contributeurs,
      il est d'usage que la plupart des gens ait des copies
      de travail du tronc. Dès que quelqu'un doit faire des
      modifications de longue haleine, susceptibles de perturber
      le tronc, une procédure standard est qu'il crée une branche
      privée et qu'il y propage les modifications jusqu'à ce que tout
      le travail soit terminé.</para>

<!--
    <para>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>
-->
    <para>Bref, la bonne nouvelle est que Sally et vous n'empiétez
      pas l'un sur l'autre. La mauvaise nouvelle est qu'il est très
      facile de <emphasis>dériver</emphasis> chacun de son côté.
      Rappelez-vous qu'un des problèmes lié à la stratégie
      d'<quote>isolement</quote> est que lorsque vous en aurez fini
      avec votre branche, il risque d'être quasi impossible de
      refusionner vos modifications dans le tronc sans avoir à faire
      face à un grand nombre de conflits.</para>

<!--
    <para>
      <indexterm>
        <primary>merging</primary>
      </indexterm>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <firstterm>merging</firstterm>, and
      it is performed using various invocations of the <command>svn
      merge</command> subcommand.</para>
-->
    <para>
      <indexterm>
        <primary>fusions</primary>
      </indexterm>
      <indexterm>
        <primary>merging</primary>
        <see>fusions</see>
      </indexterm>À la place, Sally et vous pourriez continuer de
      partager vos changements au fur et à mesure de votre travail.
      C'est à vous de décider quelles modifications valent la peine
      d'être partagées&nbsp;; Subversion vous offre la possibilité de
      <quote>copier</quote> sélectivement des modifications entre
      les branches. Et quand vous aurez tout fini dans votre branche,
      l'ensemble de vos modifications pourra être recopié en entier
      vers le tronc. Dans la terminologie Subversion, l'action
      générale de réplication des modifications d'une branche vers
      une autre s'appelle la <firstterm>fusion</firstterm> et elle
      s'effectue à l'aide de plusieurs exécutions de la sous-commande
      <command>svn merge</command>.</para>

<!--
    <para>In the examples that follow, we're assuming that both your
      Subversion client and server are running Subversion 1.8 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won't track changes
      automatically, forcing you to use painful manual methods to
      achieve similar results.  That is, you'll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/> later
      in this chapter), and take special care to keep track of what's
      already been merged and what hasn't.  For this reason,
      we <emphasis>strongly</emphasis> recommend that you make sure your
      client and server are at least at version 1.5.</para>
-->
    <para>Dans les exemples qui suivent, nous supposons que le
      client et le serveur Subversion sont tous deux en version 1.8
      (ou plus récente). Si l'un ou l'autre sont en version plus
      ancienne que la 1.5, les choses sont plus compliquées&nbsp;: le
      système ne gére pas les changements de façon automatique et vous
      devrez utiliser des méthodes manuelles pénibles pour obtenir
      des résultats similaires. Vous devrez en effet toujours utiliser
      la syntaxe détaillée de la fusion spécifiant l'éventail des
      révisions à répliquer
      (voir <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>
      plus loin dans ce chapitre) et penser à garder trace de ce qui a
      déjà été fusionné et de ce qui ne l'a pas encore été. Pour cette
      raison, nous recommandons <emphasis>fortement</emphasis> de vous
      assurer que client et serveur sont au moins en version 1.5.</para>

    <sidebar id="svn.branchmerge.basicmerging.mergetracking">
<!--
      <title>Merge Tracking</title>
      <para>
        <indexterm>
          <primary>merge tracking</primary>
        </indexterm>Subversion 1.5 introduced the
        <firstterm>merge tracking</firstterm> feature to Subversion.
        Prior to this feature keeping track of merges required cumbersome
        manual procedures or the use of external tools. Subsequent
        releases of Subversion introduced many enhancements and bug
        fixes to merge tracking, which is why we recommend using the
        most recent versions for both your server and client.  Keep in
        mind that even if your server is running 1.5-1.7, you can still
        use a 1.8 client.  This is particularly important with regard to merge
        tracking, because the overwhelming majority of fixes and enhancements
        to it are on the client side.</para>
-->
      <title>Suivi de fusions</title>
      <para>
        <indexterm>
          <primary>fusions</primary>
          <secondary>suivi des fusions</secondary>
        </indexterm>
        <indexterm>
          <primary>merge tracking</primary>
          <see>fusions, suivi</see>
        </indexterm>Subversion 1.5 a introduit la fonction de
        <firstterm>suivi des fusions</firstterm>
        (<foreignphrase>merge tracking</foreignphrase> en anglais).
        Auparavant, garder la trace de toutes les fusions nécessitait
        de lourdes actions manuelles  ou l'utilisation d'outils
        externes. Les versions suivantes de Subversion ont apporté
        beaucoup d'améliorations et de corrections au suivi des fusions,
        c'est pourquoi nous recommandons d'utiliser les versions les
        plus récentes pour le serveur et le client. Gardez à l'esprit
        que, même si votre serveur est sous les versions 1.5-1.7, vous
        pouvez utiliser un client 1.8. C'est particulièrement important
        pour ce qui concerne le suivi des fusions, car la grande
        majorité des corrections et améliorations sont relatives au
        client.</para>
    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.changesets">
<!--
      <title>Changesets</title>
-->
      <title>Ensembles de modifications</title>

<!--
      <para>
        <indexterm>
          <primary>changesets</primary>
        </indexterm>Before we proceed further, we should warn you that there's
        a lot of discussion of <quote>changes</quote> in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms <quote>change</quote>
        and <quote>changeset</quote> interchangeably, and we should
        clarify what Subversion understands as
        a <firstterm>changeset</firstterm>.</para>
-->
      <para>
        <indexterm>
          <primary>ensembles de modifications</primary>
        </indexterm>
        <indexterm>
          <primary>changesets</primary>
          <see>ensembles de modifications</see>
        </indexterm>Avant que nous n'allions plus loin, nous devons vous
        avertir que les pages suivantes contiennent de nombreuses
        discussions portant sur les <quote>modifications</quote>.
        Beaucoup de gens ayant de l'expérience dans les systèmes de
        gestion de versions utilisent le terme
        <quote>modifications</quote> et le terme <quote>ensemble de
        modifications</quote> de façon interchangeable et nous allons
        donc clarifier ce que Subversion entend par
        <firstterm>ensemble de modifications</firstterm>
        (<foreignphrase>changeset</foreignphrase> en anglais).</para>

<!--
      <para>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let's say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</para>
-->
      <para>Chacun semble avoir sa propre définition, variant
        légèrement, d'un ensemble de modifications, ou tout du moins
        a une attente différente quant à leur traitement par le système
        de gestion de versions. En ce qui nous concerne, disons
        qu'un ensemble de modifications n'est qu'un simple regroupement
        de modifications identifié par un nom unique. Les modifications
        peuvent inclure des changements textuels du contenu des
        fichiers, des modifications de l'arborescence ou des
        ajustements portant sur les méta-données. En langage plus
        courant, un ensemble de modifications n'est qu'un correctif
        avec un nom auquel vous pouvez vous référer.</para>

<!--
      <para>In Subversion, a global revision
        number <replaceable>N</replaceable> names a tree in the
        repository: it's the way the repository looked after the
        <replaceable>N</replaceable>th commit.  It's also the name of
        an implicit changeset: if you compare
        tree <replaceable>N</replaceable> with
        tree <replaceable>N</replaceable>-1, you can derive the exact
        patch that was committed.  For this reason, it's easy to think
        of revision <replaceable>N</replaceable> as not just a tree,
        but a changeset as well.  If you use an issue tracker to
        manage bugs, you can use the revision numbers to refer to
        particular patches that fix bugs&mdash;for example,
        <quote>this issue was fixed by r9238.</quote> Somebody
        can then run <userinput>svn log -r 9238</userinput> to read about
        the exact changeset that fixed the bug, and run
        <userinput>svn diff -c 9238</userinput> to see the patch itself.
        And (as you'll see shortly)
        Subversion's <command>svn merge</command> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <userinput>-c 9238</userinput>
        to <command>svn merge</command> would merge changeset r9238
        into your working copy.</para>
-->
      <para>Dans Subversion, un numéro de révision globale
        <replaceable>N</replaceable> désigne une arborescence dans le
        dépôt&nbsp;: c'est ce à quoi le dépôt ressemblait après la
        <replaceable>N</replaceable>-ième propagation. C'est aussi le
        nom implicite d'un ensemble de modifications&nbsp;: si vous
        comparez l'arborescence <replaceable>N</replaceable> avec
        l'arborescence <replaceable>N</replaceable>-1, vous pouvez en
        déduire exactement le correctif qui a été propagé. Pour cette
        raison, il est facile de se représenter une révision
        <replaceable>N</replaceable> non seulement comme une
        arborescence, mais aussi comme un ensemble de modifications. Si
        vous utilisez un système de gestion des incidents pour gérer vos
        bogues, vous pouvez utiliser les numéros de révision pour vous
        référer à des correctifs particuliers permettant de résoudre des
        bogues &mdash; par exemple, <quote>cet incident a été corrigé
        par r9238</quote>. Quelqu'un peut alors lancer <userinput>svn
        log -r 9238</userinput> pour obtenir le détail des modifications
        qui ont corrigé le bogue et lancer <userinput>svn diff -c
        9238</userinput> pour voir le correctif lui-même. De plus (comme
        nous le verrons bientôt), la commande <command>svn
        merge</command> de Subversion est capable d'utiliser les numéros
        de révision. Vous pouvez fusionner des listes de modifications
        spécifiques d'une branche à une autre en les nommant dans les
        paramètres de la fusion&nbsp;: donner comme argument
        <userinput>-c 9238</userinput> à <command>svn merge</command>
        fusionne la liste de modifications r9238 avec votre copie de
        travail.</para>

    </sect2>
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync">
<!--
      <title>Keeping a Branch in Sync</title>
-->
      <title>Garder une branche synchronisée</title>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>sync merges</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>merge</tertiary>
        </indexterm>Continuing with our running example, let's suppose
        that a week has passed since you started working on your
        private branch.  Your new feature isn't finished yet, but at
        the same time you know that other people on your team continue
        to make important changes in the
        project's <filename>/trunk</filename>.  It's in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  This is done
        by performing an <firstterm>automatic sync merge</firstterm>&mdash;a
        merge operation designed to bring your branch up to date with
        any changes made to its ancestral parent branch since your
        branch was created.
        <indexterm>
          <primary>merging</primary>
          <secondary>automatic</secondary>
        </indexterm> An <quote>automatic</quote> merge is simply
        one in which you provide the bare minimum of information required
        for a merge (i.e. a single merge source and a working copy target)
        and let Subversion determine which changes need merging&mdash;no
        changesets are passed to <command>svn merge</command> via the
        <option>-r</option> or <option>-c</option> options in an automatic
        merge.</para>
-->
      <para>
        <indexterm>
          <primary>fusions</primary>
          <secondary>synchronisation de branches</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>sous-commandes</secondary>
          <tertiary>merge</tertiary>
        </indexterm>Continuons avec notre exemple précédent et imaginons
        qu'une semaine a passé depuis que vous avez commencé à
        travailler sur votre branche privée. Votre nouvelle
        fonctionnalité n'est pas encore terminée, mais en même temps
        vous savez que d'autres personnes de votre équipe ont continué
        à faire des modifications importantes sur l'arborescence
        <filename>/trunk</filename> du projet. Vous avez intérêt à
        recopier ces modifications dans votre propre branche, juste
        pour vous assurer qu'elles se combinent bien avec vos propres
        modifications. Cette opération s'effectue par <firstterm>fusion
        automatique  de synchronisation</firstterm> (une opération de
        fusion destinée à garder votre branche synchronisée avec les
        modifications faites dans l'arborescence
        <quote>ancestrale</quote> de création de ladite branche).
        <indexterm>
            <primary>fusions</primary>
            <secondary>automatiques</secondary>
        </indexterm>Une fusion automatique est simplement une fusion
        pour laquelle vous ne fournissez que le minimum d'informations
        requis (c'est-à-dire une seule source et une copie de travail
        pour destination) et que vous laissez Subversion déterminer
        quels modifications doivent être fusionnées &mdash; dans une
        fusion automatique, aucun  ensemble de modifications n'est passé
        à la commande <command>svn merge</command> par l'option
        <option>-r</option> ou <option>-c</option>.</para>

<!--
      <tip>
        <para>Frequently keeping your branch in sync with the main
          development line helps prevent <quote>surprise</quote>
          conflicts when the time comes for you to fold your changes
          back into the trunk.</para>
      </tip>
-->
      <tip>
        <para>En fait, c'est là une bonne pratique&nbsp;: synchroniser
          fréquemment votre branche avec la ligne de développement
          principale permet d'éviter les conflits
          <quote>surprises</quote> le jour où vous reversez vos
          modifications dans le tronc.</para>
      </tip>

<!--
      <para>Subversion is aware of the history of your branch and
        knows when it split away from the trunk.  To perform a sync
        merge, first make sure your working copy of the branch
        is <quote>clean</quote>&mdash;that it has no local
        modifications reported by <command>svn status</command>.  Then
        simply run:</para>
-->
      <para>Subversion connaît l'historique de votre branche et sait à
        quel moment elle s'est séparée du tronc. Afin de récupérer les
        modifications du tronc les plus récentes et les plus
        importantes, assurez-vous en premier lieu que votre copie de
        travail est <quote>propre</quote>, c'est-à-dire que
        <command>svn status</command> ne liste aucune modification
        locale. Puis lancez juste&nbsp;:</para>

      <informalexample>
        <screen><!--
$ pwd
/home/user/my-calc-branch

$ svn merge ^/calc/trunk
- - Merging r341 through r351 into '.':
- - Recording mergeinfo for merge of r345 through r356 into '.':
-->
$ pwd
/home/user/ma-branche-calc

$ svn merge ^/calc/trunk
--- Fusion de r341 à r351 dans '.':
--- Stockage des informations de fusion (mergeinfo) de r345 à r356 dans '.' :
U    bouton.c
U    entier.c
$
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>properties</primary>
          <secondary>svn:mergeinfo</secondary>
        </indexterm>This basic syntax&mdash;<userinput>svn merge
        <replaceable>URL</replaceable></userinput>&mdash;tells
        Subversion to merge all changes which have not been previously
        merged from the URL to the current working directory (which is
        typically the root of your working copy).  Notice that we're
        using the caret (<literal>^</literal>)
        syntax<footnote><para>This was introduced in svn
        1.6.</para></footnote> to avoid having to type out the
        entire <filename>/trunk</filename> URL.  Also note
        the <quote>Recording mergeinfo for merge&hellip;</quote>
        notification.  This tells you that the merge is updating
        the <literal>svn:mergeinfo</literal> property. We'll discuss
        both this property and these notifications later in this
        chapter, in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>
-->
      <para>
        <indexterm>
          <primary>propriétés</primary>
          <secondary>svn:mergeinfo</secondary>
        </indexterm>La syntaxe de base, <userinput>svn merge
        <replaceable>URL</replaceable></userinput>, indique à Subversion
        qu'il doit fusionner toutes les modifications récentes depuis
        l'URL vers le répertoire de travail actuel (qui est bien souvent
        la racine de votre copie de travail). Remarquez que nous
        utilisons la syntaxe circonflexe
        (<literal>^</literal>)<footnote><para>Cette notation a été
        introduite par Subversion 1.6</para></footnote> afin d'éviter
        d'avoir à taper l'URL complète jusqu'au
        <filename>trunk</filename>. Remarquez également la notification
        de Subversion <quote>Recording mergeinfo for merge
        &hellip;</quote>. Ceci vous indique que la fusion met à jour la
        propriété <literal>svn:mergeinfo</literal>. Nous aborderons
        cette propriété et les notifications plus loin dans ce chapitre,
        dans
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>

<!--
      <tip>
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
          </indexterm>In this book and elsewhere (Subversion mailing
          lists, articles on merge tracking, etc.) you will frequently
          come across the term <firstterm>mergeinfo</firstterm>. This
          is simply shorthand for the <literal>svn:mergeinfo</literal>
          property.</para>
      </tip>
-->
      <tip>
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
          </indexterm>
          <indexterm>
            <primary>informations de fusion</primary>
            <see>mergeinfo</see>
          </indexterm>Dans ce chapitre et en général (listes de
          diffusion de Subversion, articles sur le suivi de fusions,
          etc.), vous rencontrerez souvent le terme
          <firstterm>mergeinfo</firstterm> (<firstterm>informations de
          fusion</firstterm> en français). C'est simplement un
          raccourci pour désigner la propriété
          <literal>svn:mergeinfo</literal></para>
      </tip>

      <sidebar>
<!--
        <title>Keeping a Branch in Sync Without Merge Tracking</title>
-->
        <title>Garder une branche synchronisée sans le suivi de
          fusions</title>

<!--
        <para>You may not always be able to use Subversion's merge
          tracking feature, perhaps because your server is running
          Subversion 1.4 or earlier or you must use an older client.
          In such a scenario, you can of course still perform merges,
          but Subversion will need you to manually do many of the historical
          calculations that it automatically does on your behalf when the
          merge tracking feature is available.</para>
-->
        <para>vous ne serez pas toujours en mesure d'utilliser le suivi
          de fusions réalisé par Subversion, soit parce que votre
          serveur fait tourner Subversion 1.4 ou antérieur, soit parce
          que vous utilisez un vieux client. Dans ce cas, vous
          pouvez toujours effectuer des fusions mais Subversion aura
          besoin de vous pour effectuer manuellement les calculs
          d'historique qu'il effectue automatiquement pour votre
          compte lorsque la fonctionnalité est disponible.</para>

<!--
        <para>To replicate the most recent trunk changes you need to
          perform sync merges the <quote>old-fashioned</quote>
          way&mdash;by specifying ranges of revisions you wish to
          merge.</para>
-->
        <para>Pour répliquer les modifications les plus récentes du
          tronc, vous devez effectuer des fusions de synchronisation
          <quote>à l'ancienne</quote>&nbsp;: en spécifiant les
          intervalles de révisions que vous souhaitez fusionner.</para>

<!--
        <para>Using the ongoing example, you know that you branched
          <filename>/calc/trunk</filename> to
          <filename>/calc/branches/my-calc-branch</filename> in revision
          341:</para>
-->
        <para>Avec notre exemple, vous savez que vous avez créé votre
          branche <filename>/calc/branches/ma-branche-calc</filename> à
          la révision 341 à partir de
          <filename>/calc/trunk</filename>&nbsp;:</para>

        <informalexample>
          <screen>
$ svn log -v -r341
------------------------------------------------------------------------ <!--
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 fév. 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)-->
r341 | utilisateur | 2002-11-03 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
Chemins modifiés :
   A /calc/branches/ma-branche-calc (from /calc/trunk:340)

Création d'une branche privée à partir de /calc/trunk.
------------------------------------------------------------------------
</screen>
        </informalexample>

<!--
        <para>When you are ready to synchronize your branch with the
          ongoing changes from trunk, you specify the starting
          revision as the revision of <filename>/calc/trunk</filename>
          which the branch was copied from and the ending revision as
          the youngest change on <filename>/calc/trunk</filename>.  You
          can find the latter with the <command>svn log</command> command
          with the <option>-r</option> set to <literal>HEAD</literal>:</para>
-->
        <para>Quand vous êtes prêt à synchroniser votre branche avec les
          modifications en cours du tronc, vous spécifiez la révision de
          départ comme la valeur de révision où
          <filename>/calc/trunk</filename> a été copié, et la révision
          de fin comme le changement le plus récent dans
          <filename>/calc/trunk</filename>. Vous obtenez ce numéro avec
          la commande <command>svn log</command> et l'option
          <option>-r</option> positionnée à la valeur
          <literal>HEAD</literal>&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk-->
$ svn log -q -rHEAD http://svn.exemple.com/depot/calc/trunk
------------------------------------------------------------------------<!--
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013)-->
r351 | sally | 2013-02-16 08:04:22 -0500 (Sam. 16. fev. 2013)
------------------------------------------------------------------------
<!--
$ svn merge http://svn.example.com/repos/calc/trunk -r340:351
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile-->
$ svn merge http://svn.exemple.com/depot/calc/trunk -r340:351
U    doc/INSTALL
U    src/reel.c
U    src/bouton.c
U    Makefile
</screen>
        </informalexample>

<!--
        <para>After any conflicts have been resolved, you can commit
          the merged changes to your branch.  Now, to avoid
          accidentally trying to merge these same changes into your
          branch again in the future, you'll need to record the fact
          that you've already merged them.  But where should that
          record be kept?  One of the simplest places to record this
          information is in the log message for the commit of the
          merge:</para>
-->
        <para>Après avoir résolu les conflits éventuels, vous pouvez
          propager les éléments fusionnés de votre branche. Maintenant,
          pour éviter d'essayer accidentellement de fusionner de nouveau
          les mêmes modifications plus tard dans votre branche, vous
          devrez garder une trace de cette opération. Mais où donc en
          garder une trace&nbsp;? L'un des endroits les plus simples est
          de placer cette information dans le commentaire de propagation de
          la fusion&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn ci -m "Sync the my-calc-branch with ^/calc/trunk through r351."-->
$ svn ci -m "Synchronisation de ma-branche-calc avec ^/calc/trunk jusqu'à r351."
&hellip;
</screen>
        </informalexample>

<!--
        <para>The next time you sync
          <filename>/calc/branches/my-calc-branch</filename>  with
          <filename>/calc/trunk</filename> you repeat this process, except
          that the starting revision is the <emphasis>youngest</emphasis>
          revision that's already been merged in from the trunk.
          If you've been keeping good records of your merges in the
          commit log messages, you should be able to determine what
          that youngest revision was by reading the revision logs
          associated with your branch.  Once you know your starting
          revision, you can perform another sync merge:</para>
-->
        <para>La prochaine fois que vous voulez synchroniser
          <filename>/calc/branches/ma-branche-calc</filename> avec
          <filename>/calc/trunk</filename>, vous suivez la même
          procédure, sauf que la révision de départ devient le numéro
          de la révision la plus récente qui a déjà été fusionnée à
          partir du tronc. Si vous annotez correctement vos commentaires de
          propagation avec les informations de fusions, vous devriez
          être capable de déterminer la révision la plus récente en
          lisant les commentaires de propagation relatifs à votre branche.
          Une fois le numéro de départ connu, vous pouvez effectuer une
          autre fusion de synchronisation&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk-->
$ svn log -q -rHEAD http://svn.exemple.com/depot/calc/trunk
------------------------------------------------------------------------<!--
r959 | sally | 2013-03-5 7:30:21 -0500 (Tue, 05 Mar 2013)-->
r959 | sally | 2013-03-5 7:30:21 -0500 (dim. 05. mar 2013)
------------------------------------------------------------------------

<!--
$ svn merge http://svn.example.com/repos/calc/trunk -r351:959-->
$ svn merge http://svn.exemple.com/depot/calc/trunk -r351:959
&hellip;
</screen>
        </informalexample>

      </sidebar>

<!--
      <para>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</para>
-->
      <para>À la fin de cet exemple, votre copie de travail de la
        branche contient de nouvelles modifications locales qui
        correspondent à toutes les modifications qui ont eu lieu sur le
        tronc depuis la création de votre branche&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status
 M      .
M       Makefile
M       doc/INSTALL<!--
M       src/button.c
M       src/real.c-->
M       src/bouton.c
M       src/reel.c
</screen>
      </informalexample>

<!--
      <para>At this point, the wise thing to do is look at the changes
        carefully with <command>svn diff</command>, and then build and
        test your branch.  Notice that the current working directory
        (<quote><filename>.</filename></quote>) has also been
        modified; <command>svn diff</command> shows that
        its <literal>svn:mergeinfo</literal> property has been created.
     </para>
-->
      <para>Maintenant, le plus sage consiste à examiner attentivement
        chaque modification avec <command>svn diff</command>, puis à
        compiler et tester votre branche. Notez que le répertoire
        de travail actuel (<quote><filename>.</filename></quote>) a
        aussi été modifié.
        La commande <command>svn diff</command> indique que sa propriété
        <literal>svn:mergeinfo</literal> a été créée.</para>

      <informalexample>
        <screen>
$ svn diff --depth empty .
Index: .
===================================================================<!--
- - .   (revision 351)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /calc/trunk:r341-351-->
--- .   (révision 351)
+++ .   (copie de travail)

Modification de propriétés sur .
___________________________________________________________________
Ajouté : svn:mergeinfo
   Fusionné /calc/trunk:r341-351
</screen>
      </informalexample>

<!--
      <para>
        This new property is important merge-related metadata
        that you should <emphasis>not</emphasis> touch, since it is
        needed by future <command>svn merge</command> commands.
        (We'll learn more about this metadata later in the
        chapter.)</para>
-->
      <para>Cette nouvelle propriété contient d'importantes métadonnées
        relatives à la fusion que <emphasis>vous ne devez pas</emphasis>
        modifier, car elles sont nécessaires aux futures commandes
        <command>svn merge</command> (nous en apprendrons plus sur ces
        métadonnées plus loin dans ce chapitre).</para>

<!--
      <para>After performing the merge, you might also need to resolve
        some conflicts&mdash;just as you do with <command>svn
        update</command>&mdash;or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <emphasis>syntactic</emphasis> conflicts doesn't mean there
        aren't any <emphasis>semantic</emphasis> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <userinput>svn revert . -R</userinput> (which
        will undo all local modifications) and starting a
        long <quote>what's going on?</quote> discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</para>
-->
      <para>Après cette fusion, vous êtes susceptible de devoir résoudre
        quelques conflits (de même que lorsque vous effectuez une mise à
        jour avec <command>svn update</command>) ou d'effectuer des
        corrections à la main pour que les choses fonctionnent
        correctement&nbsp;: rappelez-vous que l'absence de conflits
        <emphasis>syntaxiques</emphasis> ne veut pas dire l'absence de
        conflits <emphasis>sémantiques</emphasis>&nbsp;! Si vous
        rencontrez de sérieux problèmes, vous pouvez toujours abandonner
        vos modifications locales en lançant la commande <userinput>svn
        revert . -R</userinput> et ouvrir une conversation qui promet
        d'être longue avec vos collaborateurs sur le thème <quote>c'est
        quoi ce truc&nbsp;?</quote>. Mais si les choses se passent bien,
        vous pouvez propager les modifications dans le
        dépôt&nbsp;:</para>

      <informalexample>
        <screen>
<!--
$ svn commit -m "Sync latest trunk changes to my-calc-branch."
Sending        .
Sending        Makefile
Sending        doc/INSTALL
Sending        src/button.c
Sending        src/real.c
Transmitting file data ....
Committed revision 352.
-->
$ svn commit -m "Synchronisation des dernières modifications du tronc avec ma-branche-calc."
Envoi              .
Envoi              Makefile
Envoi              doc/INSTALL
Envoi              src/bouton.c
Envoi              src/reel.c
Transmission des données .
Révision 352 propagée.
</screen>
      </informalexample>

<!--
      <para>At this point, your private branch is now <quote>in
        sync</quote> with the trunk, so you can rest easier knowing
        that as you continue to work in isolation, you're not drifting
        too far away from what everyone else is doing.</para>
-->
      <para>À ce stade, votre branche privée est <quote>en phase</quote>
        avec le tronc et vous pouvez dormir tranquille car vous savez
        que vous pouvez continuer à travailler dans votre coin tout en
        ne dérivant pas trop par rapport au reste de l'équipe.</para>

      <sidebar>
<!--
        <title>Why Not Use Patches Instead?</title>
-->
        <title>Mieux que les correctifs de type patch</title>

<!--
        <para>A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use <command>svn patch</command> or the
          operating system's <command>patch</command> command to
          accomplish the same job?  For example:</para>
-->
        <para>Une question vous trotte peut-être dans la tête, surtout
          si vous êtes un utilisateur d'Unix&nbsp;: pourquoi s'embêter à
          utiliser <command>svn merge</command>&nbsp;? Pourquoi ne pas
          tout simplement utiliser la commande <command>patch</command>
          du système d'exploitation pour accomplir la même tâche&nbsp;?
          Par exemple&nbsp;:</para>

        <informalexample>
          <screen><!--
$ cd my-calc-branch

$ svn diff -r 341:351 ^/calc/trunk > my-patch-file

$ svn patch my-patch-file
U         doc/INSTALL
U         src/real.c
U         src/button.c
U         Makefile-->
$ cd ma-branche-calc

$ svn diff -r 341:351 ^/calc/tronc &gt; fichier_correctif

$ svn patch fichier_correctif
U         doc/INSTALL
U         src/reel.c
U         src/bouton.c
U         Makefile
</screen>
        </informalexample>

<!--
        <para>In this particular example, there really isn't much
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's able to tweak file contents only.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <command>patch</command> program
          notice changes to properties.  If Sally's change had,
          say, added a new directory, the output of <command>svn
          diff</command> wouldn't have mentioned it at
          all.  <command>svn diff</command> outputs only the limited
          patch format, so there are some ideas it simply can't
          express.  Even Subversion's own <command>svn patch</command>
	  subcommand, while more flexible than the <command>patch</command>
	  program, still has
          similar limitations.</para>
-->
        <para>Dans cet exemple, il n'y a pas vraiment de grande
          différence. Mais <command>svn merge</command> possède des
          fonctionnalités spécifiques qui surpassent le programme
          <command>patch</command>. Le format de fichier utilisé par
          <command>patch</command> est assez limité&nbsp;; il ne sait
          manipuler que les contenus de fichier. Il n'y a pas moyen de
          représenter des changements dans
          <emphasis>l'arborescence</emphasis>, tels que l'ajout,
          la suppression ou le renommage de fichiers ou de dossiers.
          Le programme <command>patch</command> n'est pas non plus
          capable de prendre en compte des modifications de propriétés.
          Si Sally avait, par exemple, ajouté un nouveau dossier,
          <command>svn diff</command> ne l'aurait pas mentionné du
          tout en sortie. Le résultat de <command>svn diff</command>
          n'est qu'au format <quote>patch</quote>, il y a donc des
          concepts qu'il ne peut tout simplement pas exprimer. Même la
          sous-commande <command>svn patch</command> de Subversion,
          bien que plus flexible que le programme
          <command>patch</command>, possède aussi
          des limitations comparables.</para>

<!--
        <para>The <command>svn merge</command> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven't been merged
          yet.</para>
-->
        <para>La commande <command>svn merge</command>, en revanche,
          peut gérer des modifications dans l'arborescence et dans
          les propriétés en les appliquant directement à votre copie
          de travail. Et, ce qui est encore plus important, cette
          commande enregistre les modifications qui ont été
          dupliquées vers votre branche de telle sorte que Subversion
          sait exactement quelles modifications existent dans chaque
          endroit (voir <xref
          linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          C'est une fonctionnalité cruciale qui rend la gestion des
          branches utilisable&nbsp;; sans elle, les utilisateurs
          seraient forcés de conserver des notes manuelles relatant
          quelles listes de modifications ont été fusionnées
          (et lesquelles ne l'ont pas été).</para>
      </sidebar>

<!--
      <para>Suppose that another week has passed.  You've committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you want to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</para>
-->
      <para>Supposons qu'une autre semaine s'est écoulée. Vous avez
        propagé des modifications supplémentaires dans votre branche
        et vos camarades ont également continué à améliorer le
        tronc. Une fois encore, vous aimeriez répercuter les dernières
        modifications du tronc vers votre branche et ainsi être en
        phase. Lancez juste la même commande <command>svn
        merge</command> à nouveau&nbsp;!</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk <!--
svn: E195020: Cannot merge into mixed-revision working copy [352:357]; try up\
dating first-->
svn: E195020: Cannot merge into mixed-revision working copy [352:357]; try updating first
$
</screen>
      </informalexample>

<!--
      <para>Well that was unexpected!  After making changes to your
        branch over the past week you now find yourself with a working
        copy that contains a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs"/>).  With Subversion
        1.7 and later, the <command>svn merge</command>
        subcommand disables merges into mixed-revision working copies
        by default.  Without going into too much detail, this is
        because of limitations in the way merges are tracked by the
        <literal>svn:mergeinfo</literal> property (see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details).  These limitations mean that merges into
        mixed-revision working copies can result in unexpected text
        and tree conflicts.<footnote><para>The <command>svn
        merge</command> subcommand
        option <option>- -allow-mixed-revisions</option> allows you to
        override this prohibition, but you should only do so if you
        understand the ramifications and have a good reason for
        it.</para></footnote>  We don't want any needless conflicts, so
        we update the working copy and then reattempt the
        merge.</para>
-->
      <para>Ça par exemple, nous ne attendions pas à ça&nbsp;! Après
        avoir fait des modifications dans votre branche cette semaine,
        vous vous retrouvez avec une copie de travail à révisions
        mélangées (voir
        <xref linkend="svn.basic.in-action.mixedrevs"/>). Avec
        Subversion 1.7 ou plus récent, la sous-commande <command>svn
        merge</command> interdit par défaut les fusions dans les copies
        de travail à révisions mélangées. Sans rentrer dans les détails,
        cela résulte de la façon dont la trace des fusions est conservée
        dans la propriété <literal>svn:mergeinfo</literal> (lisez
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> pour
        les détails). Des fusions dans les copies de travail à révisions
        mélangées peuvent créer des conflits textuels ou
        d'arborescence<footnote><para>L'option
        <option>--allow-mixed-revisions</option> de la sous-commande
        <command>svn merge</command> vous permet de lever cette
        interdiction, mais vous ne devriez le faire que si vous
        comprenez les implications et que vous avez une bonne raison de
        le faire.</para></footnote>. Nous ne voulons pas conflit
        inutile, c'est pourquoi nous mettons à jour la copie de travail
        et nous réessayons la fusion.</para>

      <informalexample>
        <screen>
$ svn up<!--
Updating '.':
At revision 361.-->
Mise à jour de '.' :
Actualisé à la révision 361.

$ svn merge ^/calc/trunk<!--
- - Merging r352 through r361 into '.':
-->
--- Fusion de r352 à r361 dans '.':<!--
U    src/real.c
U    src/main.c
- - Recording mergeinfo for merge of r352 through r361 into '.':
-->
U    src/reel.c
U    src/main.c
-- Stockage des informations de fusion (mergeinfo) de r352 à r361 dans '.' :
 U   .
</screen>
      </informalexample>

<!--
      <para>Subversion knows which trunk changes you previously
        replicated to your branch, so it carefully replicates only
        those changes you don't yet have.  And once again, you build,
        test, and <command>svn commit</command> the local modifications
        to your branch.</para>
-->
      <para>Subversion sait quelles sont les modifications du tronc
        que vous avez déjà répercutées vers votre branche, il ne
        répercute donc que les modifications que vous n'avez pas
        encore. Une fois de plus, vous devrez compiler, tester et
        propager avec <command>svn commit</command> les modifications
        locales à votre branche.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync.subtree">
<!--
      <title>Subtree Merges and Subtree Mergeinfo</title>
-->
      <title>Fusions de sous-arborescences et mergeinfo</title>
<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>subtree merge</secondary>
        </indexterm>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>subtree mergeinfo</secondary>
        </indexterm>In most of the examples in this chapter the
        merge target is the root directory of a branch (see
        <xref linkend="svn.branchmerge.whatis"/>). While this is a
        best practice, you may occasionally need to merge directly
        to some child of the branch root. This type of merge is
        called a <firstterm>subtree merge</firstterm> and the
        mergeinfo recorded to describe it is called
        <firstterm>subtree mergeinfo</firstterm>. There is nothing
        special about subtree merges or subtree mergeinfo.  In fact
        there is really only one important point to keep in mind
        about these concepts: the complete record of merges to a
        branch may not be contained solely in the mergeinfo on the
        branch root.  You may have to consider subtree mergeinfo
        to get a full accounting.  Fortunately Subversion does this
        for you and rarely will you need to concern yourself with
        it.  A brief example will help explain:</para>
-->
      <para>
        <indexterm>
          <primary>fusions</primary>
          <secondary>fusions de sous-arborescences</secondary>
        </indexterm>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>informations de fusion de sous-arborescences</secondary>
        </indexterm>Dans la plupart des exemples de ce chapitre, la
        cible de la fusion est le répertoire racine d'une branche
        (voir <xref linkend="svn.branchmerge.whatis"/>).
        Bien que ce soit une bonne pratique, vous aurez peut-être
        l'occasion de devoir fusionner avec un enfant de la racine de
        votre branche. Ce type de fusion est appelé une
        <firstterm>fusion de sous-arborescence</firstterm> et les
        informations de fusions (<quote>mergeinfo</quote>) stockées
        pour décrire cela s'appellent les
        <firstterm>informations de fusion de
        sous-arborescence</firstterm> ou mergeinfo de
        sous-arborecences. Il n'y a rien de particulier à signaler
        pour les fusions de sous-arborescences et les mergeinfo de
        sous-arborescences. En fait, il n'y a vraiment qu'un seul
        point à retenir pour ces concepts&nbsp;: l'enregistrement
        complet des fusions pour une branche peut ne pas être contenu
        uniquement dans le mergeinfo de la racine de la branche. Vous
        pouvez avoir à prendre en compte les mergeinfos des
        sous-arborescences pour obtenir le décompte total.
        Heureusement, Subversion le fait pour vous et vous n'aurez que
        rarement l'occasion de vous en préoccuper personnellement. Un
        court exemple vaut mieux qu'un long discours&nbsp;:</para>

      <informalexample>
        <screen><!--
# We need to merge r958 from trunk to branches/proj-X/doc/INSTALL,
# but that revision also affects main.c, which we don't want to merge:
$ svn log - -verbose - -quiet -r 958 ^/
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r958 | bruce | 2011-10-20 13:28:11 -0400 (Thu, 20 Oct 2011)
Changed paths:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# No problem, we'll do a subtree merge targeting the INSTALL file
# directly, but first take a note of what mergeinfo exists on the
# root of the branch:
$ cd branches/proj-X

$ svn propget svn:mergeinfo - -recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652

# Now we perform the subtree merge, note that merge source
# and target both point to INSTALL:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
- - Merging r958 into 'doc/INSTALL':
U    doc/INSTALL
- - Recording mergeinfo for merge of r958 into 'doc/INSTALL':
 G   doc/INSTALL

# Once the merge is complete there is now subtree mergeinfo on INSTALL:
$ svn propget svn:mergeinfo - -recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652
Properties on 'doc/INSTALL':
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# What if we then decide we do want all of r958? Easy, all we need do is
# repeat the merge of that revision, but this time to the root of the
# branch, Subversion notices the subtree mergeinfo on INSTALL and doesn't
# try to merge any changes to it, only the changes to main.c are merged:
$ svn merge ^/subversion/trunk . -c 958
- - Merging r958 into '.':
U    src/main.c
- - Recording mergeinfo for merge of r958 into '.':
 U   .
- - Eliding mergeinfo from 'doc/INSTALL':
 U   doc/INSTALL
-->
# We devons fusionner r958 depuis le tronc vers branches/proj-X/doc/INSTALL,
# mais cette révision touche aussi main.c, que nous ne voulons pas fusionner :
$ svn log --verbose --quiet -r 958 ^/
------------------------------------------------------------------------
r958 | bruce | 2011-10-20 13:28:11 -0400 (jeu. 20 oct 2011)
Chemins modifiés :
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
------------------------------------------------------------------------

# Pas de problème, nous allons effectuer une fusion d'arborescence
# directement sur le fichier INSTALL, mais d'abord notons les
# informations de mergeinfo relatives à la racine de la branche :
$ cd branches/proj-X

$ svn propget svn:mergeinfo --recursive
Propriétés sur '.'
  svn:mergeinfo
    /trunk:651-652

# Maintenant nous effectuons la fusion d'arborescence.
# Remarquez que la source et la destination de la fusion pointent sur INSTALL :
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
-- Fusion de r958 dans 'doc/INSTALL':
U    doc/INSTALL
-- Stockage des informations de fusion (mergeinfo) de r958 dans 'doc/INSTALL' :
 G   doc/INSTALL

# Une fois la fusion effectuée, l'information de fusion de l'arboresence
# est disponible dans INSTALL :
$ svn propget svn:mergeinfo --recursive
Propriétés sur '.' :
  svn:mergeinfo
    /trunk:651-652
Propriétés sur 'doc/INSTALL' :
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# Que se passe-t-il si nous décidons maintenant d'avoir l'intégralité de
# r958 ? Facile, nous avons seulement à répéter l'opération de fusion
# de cette révision, mais cette fois à la racine de la branche.
# Subversion prend en compte les informations de fusion sur INSTALL et
# n'essaie pas de fusionner quoi ce soit sur ce fichier ; seuls les
# changements sur main.c sont fusionnés.
$ svn merge ^/subversion/trunk . -c 958
-- Fusion de r958 dans '.':
U    src/main.c
-- Stockage des informations de fusion (mergeinfo) de r958 dans '.' :
 U   .
-- Nettoyage des informations de fusion (mergeinfo) de 'doc/INSTALL' :
 U   doc/INSTALL
</screen>
      </informalexample>

<!--
      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>elision</secondary>
        </indexterm>You might be wondering
        why <filename>INSTALL</filename> in the above example has
        mergeinfo for r651-652, when we only merged r958. This is
        due to mergeinfo inheritance, which we'll cover in the
        sidebar
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
        />.  Also note that the subtree mergeinfo on
        <filename>doc/INSTALL</filename> was removed, or
        <quote>elided</quote>.  This is called
        <firstterm>mergeinfo elision</firstterm> and it occurs
        whenever Subversion detects redundant subtree mergeinfo.</para>
-->
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>nettoyage</secondary>
          </indexterm>Vous devez vous demander pourquoi
          <filename>INSTALL</filename> dans l'exemple ci-dessus possède
          des informations de fusion pour r651-652 alors que nous
          n'avons fusionné que r958. C'est en raison de l'héritage des
          informations de fusion, que nous abordons dans l'encart particulier
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
          />. Notez aussi que les informations de fusion de
          l'arborescence ont été supprimées (ou <quote>nettoyées</quote>)
          de <filename>doc/INSTALL</filename>. Ce
          <firstterm>nettoyage des informations de fusion</firstterm> a
          lieu quand Subversion détecte des informations
          redondantes.</para>

      <tip>
<!--
        <para>Prior to Subversion 1.7, merges unconditionally updated
          <emphasis>all</emphasis> of the subtree mergeinfo under the
          target to describe the merge. For users with a lot of subtree
          mergeinfo this meant that relatively <quote>simple</quote>
          merges (e.g. one which applied a diff to only a single file)
          resulted in changes to every subtree with mergeinfo, even
          those that were not parents of the affected path(s). This
          caused some level of confusion and frustration. Subversion 1.7
          and later addresses this problem by only updating the mergeinfo
          on subtrees which are parents of the paths modified by the merge
          (i.e. paths changed, added, or deleted by application of the
          difference, see
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          The one exception to this behavior regards the actual merge
          target; the merge target's mergeinfo is always updated to
          describe the merge, even if the applied difference made no
          changes.</para>
-->
        <para>Avant Subversion 1.7, les fusions mettaient à jour de
          manière inconditionnelle les informations de fusion sous la
          destination pour décrire la fusion. Pour les utilisateurs qui
          ont beaucoup d'informations de fusion sur leurs arborescences,
          cela voulait dire que même des fusions relativement
          <quote>simles</quote> (par exemple une fusion qui ne concerne
          qu'un seul fichier) impliquaient des modifications de
          mergeinfo dans toutes les sous-arborescences, y compris celles
          qui n'avaient pas de lien de parenté avec le(s) chemin(s)
          concerné(s). Cela engendrait de la confusion et de la
          frustration. Subversion 1.7 et suivants répondent à ce
          problème en ne mettant à jour que les informations de fusion
          des arborescences qui ont des liens de parenté avec les
          chemins modifiés par la fusion (c'est-à-dire les chemins
          modifiés, ajoutés ou supprimés par application d'un
          changement, voir
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          La cible de la fusion fait exception à ce comportement&nbsp;;
          les informations de fusion de la cible de fusion sont toujours
          mises à jour décrire la fusion, même si l'application de la
          fusion ne produit aucun changement.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.reintegrate">
<!--
      <title>Reintegrating a Branch</title>
-->
      <title>Réintegration d'une branche</title>

<!--
      <para>What happens when you finally finish your work, though?
        Your new feature is done, and you're ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch into sync with the trunk again, just as you've been
        doing all along<footnote><para>Since Subversion 1.7 you don't
        absolutely have to do all your sync merges to the root of your
        branch as we do in this example.  <emphasis>If</emphasis> your
        branch is effectively synced via a series of subtree
        merges then the reintegrate will work, but ask yourself, if the
        branch is effectively synced, then why are you doing subtree
        merges? Doing so is almost always needlessly
        complex.</para></footnote>:</para>
-->
      <para>Que se passe-t-il quand vous finissez enfin votre
        travail&nbsp;? Votre nouvelle fonctionnalité est
        terminée et vous êtes prêt à fusionner les changements de
        votre branche avec le tronc (pour que votre équipe puisse
        bénéficier du fruit de votre travail). La procédure est
        simple. Premièrement, synchronisez à nouveau votre branche
        avec le tronc, comme vous le faites depuis le
        début <footnote><para>Depuis Subversion 1.7 vous n'avez pas
        absolument besoin de resynchroniser complètement votre branche
        avec le tronc comme nous le faisons dans cet exemple.
        <emphasis>Si</emphasis> votre branche est effectivement
        synchronisée par une série de fusions d'arborescences alors
        la réintégration fonctionnera, mais demandez-vous, si la branche
        est effectivement synchronisée, pourquoi effectuez-vous des
        fusions d'arborescences&nbsp;? Le faire est pratiquement
        toujours inutilement complexe.</para></footnote></para>

      <informalexample>
        <screen>
<!--
$ svn up # (make sure the working copy is up to date)
Updating '.':
At revision 378.

$ svn merge ^/calc/trunk
- - Merging r362 through r378 into '.':
U    src/main.c
- - Recording mergeinfo for merge of r362 through r378 into '.':
 U   .

$ # build, test, ...

$ svn commit -m "Final merge of trunk changes to my-calc-branch."
Sending        .
Sending        src/main.c
Transmitting file data .
Committed revision 379.
-->
$ svn up # (pour être sûr que la copie de travail est à jour)
Mise à jour de '.' :
À la révision 378.

$ svn merge ^/calc/trunk
--- Fusion de r362 à r378 dans '.':
U    src/main.c
--- Stockage des informations de fusion (mergeinfo) de r381 à r385 dans '.' :
 U   .

$ # compiler, tester, ...

$ svn commit -m "Fusion finale des modifications du tronc dans ma-branche-calc."
Envoi              .
Envoi              src/main.c
Transmission des données .
Révision 379 propagée.
</screen>
      </informalexample>

<!--
      <para>Now, use <command>svn merge</command> subcommand to automatically
        replicate your branch changes back into the trunk.  This type of
        merge is called an
        <indexterm>
          <primary>merging</primary>
          <secondary>reintegrate merges</secondary>
        </indexterm> <quote>automatic reintegrate</quote> merge.  You'll need
        a working copy of <filename>/calc/trunk</filename>.  You can get one
        by doing an <command>svn checkout</command>, dredging up an old trunk
        working copy from somewhere on your disk, or
        using <command>svn switch</command> (see
        <xref linkend="svn.branchmerge.switchwc" />).</para>
-->
      <para>À présent, utilisez la sous-commande
        <command>svn merge</command> pour répercuter automatiquement les
        modifications de votre branche sur le tronc. Ce type de fusion
        est appelée
        <indexterm>
          <primary>fusions</primary>
          <secondary>fusion de réintégration</secondary>
        </indexterm>une fusion de <quote>réintégration
        automatique</quote>. Vous aurez besoin d'une copie de travail de
        <filename>/calc/trunk</filename>. Vous pouvez vous la procurer
        soit en effectuant un <command>svn checkout</command>, soit en
        reprenant une vieille copie de travail du tronc, soit en
        utilisant <command>svn switch</command> (voir
        <xref linkend="svn.branchmerge.switchwc" />).</para>

      <tip>
<!--
        <para>The term <quote>reintegrating</quote> comes from the
          <command>merge</command> option <option>- -reintegrate</option>.
          This option is deprecated in Subversion 1.8 (which automatically
          detects when a reintegrate merge is needed), but is required
          for Subversion 1.5 through 1.7 clients when performing reintegrate
          merges.</para>
-->
        <para>Le terme <quote>réintégration</quote> provient de l'option
          <option>--reintegrate</option> de la sous-commande
          <command>merge</command>. Cette option est obsolète dans
          Subversion 1.8 (qui détecte automatiquement quand une fusion
          de réintégration est nécessaire), mais elle est demandée par
          les clients des versions 1.5 à 1.7 de Subversion lorsque vous
          effectuez des fusions de réintégration.</para>
      </tip>

<!--
      <para>Your trunk working copy cannot have any local edits, switched
        paths, or contain a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs" />).  While
        these are typically best practices for merging anyway, they
        are <emphasis>required</emphasis> for automatic reintegrate
        merges.</para>
-->

      <para>Votre copie de travail du tronc ne doit avoir aucune
        modification locale, aucun chemin qui ne pointe vers une autre
        branche et ne pas comporter de mélange de révisions (voir
        <xref linkend="svn.basic.in-action.mixedrevs" />). Bien que ce
        soient de bonnes pratiques pour les fusions de toute façon,
        c'est particulièrement <emphasis>obligatoire</emphasis> pour une
        fusion de réintégration automatique.</para>

<!--
      <para>Once you have a clean working copy of the trunk, you're
        ready to merge your branch back into it:</para>
-->
      <para>Une fois que vous avez une copie de travail propre du tronc,
        vous êtes prêt pour y fusionner votre branche&nbsp;:</para>

      <informalexample>
        <screen>
$ pwd<!--
/home/user/calc-trunk-->
/home/utilisateur/calc-trunk

$ svn update<!--
Updating '.':
At revision 379.
-->
Mise à jour '.' :
À la révision 390.

<!--
$ svn merge ^/calc/branches/my-calc-branch
- - Merging differences between repository URLs into '.':
U    src/real.c
-->
$ svn merge ^/calc/branches/ma-branche-calc
--- Fusion des différences des URLs du dépôt vers '.' :
U    src/reel.c
U    src/main.c
U    Makefile <!--
- - Recording mergeinfo for merge between repository URLs into '.':
-->
-- Stockage des informations de fusion (mergeinfo) des URLs du dépôt vers '.' :
 U   .
<!--
$ # build, test, verify, ...
-->
$ # compiler, tester, vérifier, ...
<!--
$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        Makefile
Sending        src/main.c
Sending        src/real.c
Transmitting file data ...
Committed revision 380.
-->
$ svn commit -m "ma-branche-calc réintégrée dans le tronc !"
Envoi          .
Envoi          Makefile
Envoi          src/main.c
Envoi          src/reel.c
Transmission des données ...
Révision 380 propagée.
</screen>
      </informalexample>

<!--
      <para>Congratulations, your branch-specific changes have now
        been merged back into the main line of development.  Notice that
        the automatic reintegrate merge did a different sort of work than
        what you've done up until now.  Previously, we were
        asking <command>svn merge</command> to grab the <quote>next
        set</quote> of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 341:351 from
        <filename>/calc/trunk</filename> to
        <filename>/calc/branches/my-calc-branch</filename>;
        later on, it continues by merging the next contiguously
        available range, 351:361.  When doing the final sync, it
        merges the range 361:378.</para>
-->
      <para>Félicitations, votre branche a maintenant réintégré la
        ligne de développement principale. Notez que la fusion de
        réintégration automatique a effectué un travail différent de ce
        que vous avez fait jusqu'à maintenant. Auparavant, nous
        demandions à <command>svn merge</command> de récupérer le
        <quote>prochain lot de modifications</quote> d'une ligne de
        développement (le tronc en l'occurence) et de l'appliquer à une
        autre (votre branche). C'est assez simple à réaliser et à chaque
        fois Subversion sait reprendre là où il s'était arrêté. Dans
        nos exemples précédents, vous pouvez constater qu'il fusionne en
        premier les modifications 341:351 de
        <filename>/calc/trunk</filename> vers
        <filename>/calc/branches/ma-branche-calc</filename>&nbsp;;
        ensuite il continue en fusionnant l'intervalle
        immédiatement suivant, 351:361. Quand il effectue la
        synchronisation finale, il fusionne l'intervalle 361:378.</para>

<!--
      <para>When merging <filename>/calc/branches/my-calc-branch</filename>
        back to the <filename>/calc/trunk</filename>, however, the
        underlying mathematics are quite different.  Your feature
        branch is now a mishmash of both duplicated trunk changes and
        private branch changes, so there's no simple contiguous range
        of revisions to copy over.  By using an automatic merge, you're
        asking Subversion to carefully replicate <emphasis>only</emphasis>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</para>
-->
      <para>Cependant, quand il fusionne
        <filename>/calc/branches/ma-branche-calc</filename>
        vers <filename>/calc/trunk</filename>, la logique sous-jacente
        est assez différente. Votre branche dédiée est à présent un
        amoncellement de modifications provenant à la fois du tronc
        et de votre branche privée et il n'y a donc pas d'intervalle
        de révisions contigues à recopier. En utilisant la fusion
        automatique, vous demandez à Subversion de ne recopier
        <emphasis>que</emphasis> les modifications spécifiques à votre
        branche (et en fait il le fait en comparant la version la plus
        récente de l'arborescence du tronc avec la version la plus
        récente de l'arborescence de la branche&nbsp;:
        la différence qui en résulte constitue exactement les
        modifications de votre branche&nbsp;!).</para>

<!--
      <para>Keep in mind that the automatic reintegrate merges only support
        the use case described above.  Because of this narrow focus, in
        addition to the requirements previously mentioned (up-to-date working
        copy <footnote><para>Automatic reintegrate merges are allowed if the
        target is a shallow checkout
        (see <xref linkend="svn.advanced.sparsedirs"/>) but any paths
        affected by the diff which are <quote>missing</quote> due to the
        sparse working copy will be skipped&mdash;this is probably
        <emphasis>not</emphasis> what you intended!</para></footnote>
        with no mixed-revisions, switched paths or local changes) it will not
        function in combination with most of the other
        <command>svn merge</command> options. You'll get an error if you
        use any non-global options but these: <option>- -accept</option>,
        <option>- -dry-run</option>, <option>- -diff3-cmd</option>,
        <option>- -extensions</option>, or <option>- -quiet</option>.
        </para>
-->
      <para>Gardez à l'esprit que les fusions de réintégration
        automatiques ne fonctionnent que dans le cas cité ci-dessus. En
        raison de cette configuration particulière et des autres
        prérequis annoncés précédemment (une copie de travail à
        jour<footnote><para>les fusions de réintégration
        automatiques sont autorisées si la cible est une extraction
        partielle (voir <xref linkend="svn.advanced.sparsedirs"/>), mais
        alors chaque chemin concerné par le calcul de différence et qui
        est <quote>absent</quote> en raison de l'extraction partielle
        sera ignoré, ce qui n'est <emphasis>probablement pas</emphasis>
        ce que vous recherchez&nbsp;!</para></footnote> sans révisions
        mélangées, sans chemins qui pointent vers d'autres branches ou
        modifications locales), elles ne fonctionneront pas en
        combinaison avec la plupart des autres options de la
        sous-commande <command>svn merge</command>. Vous obtiendrez une
        erreur si vous utilisez n'importe laquelle des options
        non-globales autres que celles-ci&nbsp;:
        <option>--accept</option>, <option>--dry-run</option>,
        <option>--diff3-cmd</option>, <option>--extensions</option>
        ou <option>--quiet</option>.</para>

<!--
      <para>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</para>
-->
      <para>Maintenant que votre branche privée a réintégré le tronc,
        vous voudrez peut-être la supprimer du dépôt&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn delete ^/calc/branches/my-calc-branch \
      -m "Remove my-calc-branch, reintegrated with trunk in r391."
-->
$ svn delete ^/calc/branches/ma-branche-calc \
      -m "Supprime ma-branche-calc, réintégrée dans le tronc à r391."
&hellip;
</screen>
      </informalexample>

<!--
      <para>But wait!  Isn't the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <filename>/calc/branches</filename> directory, its
        existence is still an immutable part of the repository's
        history.  A simple <command>svn log</command> command on
        the <filename>/calc/branches</filename> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>
-->
      <para>Mais attendez&nbsp;! L'historique de votre branche ne
        possède-t-il pas une certaine valeur&nbsp;? Et si un beau
        jour quelqu'un voulait auditer l'évolution de votre
        fonctionnalité et examiner toutes les modifications de
        votre branche&nbsp;? Pas la peine de s'inquiéter.
        Souvenez-vous que, même si votre branche n'est plus visible
        dans le dossier <filename>/calc/branches</filename>, son
        existence demeure une partie immuable de l'historique du dépôt.
        Une simple commande <command>svn log</command> appliquée à l'URL
        <filename>/calc/branches</filename> vous renverra l'historique
        complet de votre branche. Votre branche pourrait même
        ressusciter un jour ou l'autre, si vous le désirez (voir
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>

<!--
      <para>If you choose not to delete your branch after reintegrating
        it to the trunk you may continue to perform sync merges from the
        trunk and then reintegrate the branch again<footnote><para>Only
        Subversion 1.8 supports this reuse of a feature branch.  Earlier
        versions require some special handling before a feature branch
        can be reintegrated more than once.  See the earlier version of
        this chapter for more information: <ulink
        url="http://svnbook.red-bean.com/en/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. If you do this, only the changes made on your
        branch after the first reintegrate are merged to the trunk.</para>
-->
      <para>Si vous décidez de ne pas détruire votre branche après
        réintégration dans le tronc, vous pouvez continuer à effectuer
        des fusions de synchronisation depuis le tronc puis réintégrer
        la branche à nouveau <footnote><para>Seul Subversion 1.8
        autorise cette réutilisation d'une branche. Les précédentes
        versions demandaient quelques manipulations préalables afin de
        pouvoir réintegrer à nouveau une branche. Consultez les versions
        antérieures de ce chapitre pour plus d'informations&nbsp;: <ulink
        url="http://svnbook.red-bean.com/fr/1.5/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. Si vous adoptez ce comportement, seules
        les modifications effectuées sur votre branche après la
        réintégration seront fusionnées vers le tronc.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.mergeinfo">
<!--
      <title>Mergeinfo and Previews</title>
-->
      <title>Mergeinfo et aperçus</title>

<!--
      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>property</secondary>
        </indexterm>The basic mechanism Subversion uses to track
        changesets&mdash;that is, which changes have been merged to
        which branches&mdash;is by recording data in versioned
        properties.  Specifically, merge data is tracked in
        the <literal>svn:mergeinfo</literal> property attached to
        files and directories.  (If you're not familiar with
        Subversion properties, see <xref linkend="svn.advanced.props"
        />.)</para>
-->
      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>property</secondary>
        </indexterm>Le mécanisme de base que Subversion utilise pour gérer
        les ensembles de modifications, c'est-à-dire quelles
        modifications ont été fusionnées dans quelles branches, est
        l'enregistrement de données dans des propriétés suivies en
        versions. Plus précisément, les informations de fusion sont
        conservées dans la propriété <literal>svn:mergeinfo</literal>
        qui est associée aux fichiers et aux dossiers (si les propriétés
        de Subversion ne vous sont pas familières, c'est le moment de
        lire <xref linkend="svn.advanced.props"/>).</para>

<!--
      <para>You can examine the mergeinfo property, just like any other
        versioned property:</para>
-->
      <para>Vous pouvez examiner cette propriété comme n'importe
        quelle autre propriété suivie en versions&nbsp;:</para>

      <informalexample>
        <screen><!--
$ cd my-calc-branch

$ svn pg svn:mergeinfo -v
Properties on '.':-->
$ cd ma-branche-calc

$ svn pg svn:mergeinfo -v
Propriétés sur '.'
  svn:mergeinfo
    /calc/trunk:341-378
</screen>
      </informalexample>

<!--
      <warning>
        <para>While it is possible to
          modify <literal>svn:mergeinfo</literal> just as you might
          any other versioned property, we strongly discourage doing
          so unless you <emphasis>really</emphasis> know what you're
          doing.</para>
      </warning>
-->
      <warning>
        <para>Bien qu'il soit possible de modifier soi-même
          <literal>svn:mergeinfo</literal> comme n'importe qu'elle autre
          propriété suivie en versions, nous déconseillons vivement de
          le faire à moins de <emphasis>réellement</emphasis> savoir ce
          que vous faites.</para>
      </warning>

      <tip>
<!--
        <para>The amount of <literal>svn:mergeinfo</literal> on a single
          path can get quite large, as can the output of a
          <command>svn propget - -recursive</command> or
          <command>svn proplist - -recursive</command> when dealing with
          large amounts of subtree mergeinfo, see
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>
          . The formatted output produced by the
          <option>- -verbose</option> option with either of these
          subcommands is often very helpful in these cases.</para>
-->
        <para>La quantité de <literal>svn:mergeinfo</literal> sur un
          simple chemin peut être assez grande, de même que la sortie
          produite par <command>svn propget --recursive</command>
          ou <command>svn proplist --recursive</command> lorsque vous
          ciblez de grosses quantités d'arborescences, comme l'indique
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>.
          Dans ces cas, le formatage de la sortie produit par l'option
          <option>--verbose</option> avec ces deux commandes est
          souvent bien utile.</para>
      </tip>

<!--
      <para>The <literal>svn:mergeinfo</literal> property is
        automatically maintained by Subversion whenever you
        run <command>svn merge</command>.  Its value indicates which
        changes made to a given path have been replicated into the
        directory in question.  In our previous example, the path
        which is the source of the merged changes is
        <filename>/calc/trunk</filename> and the directory which has
        received the changes is
        <filename>/calc/branches/my-calc-branch</filename>.
        Earlier versions of Subversion maintained the
        <literal>svn:mergeinfo</literal> property silently. You could
        still detect the changes, after a merge completed, with the
        <command>svn diff</command> or <command>svn status</command>
        subcommands, but the merge itself gave no indication when it
        changed the <literal>svn:mergeinfo</literal> property. In
        Subversion 1.7 and later this is no longer true as there are
        several notifications to alert you when a merge updates the
        <literal>svn:mergeinfo</literal> property. These notifications
        all begin with <quote>- - Recording mergeinfo for</quote>
        and appear at the end of the merge.  Unlike other merge
        notifications, these don't describe the application of a
        difference to a working copy
        (see <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        but instead describe "housekeeping" changes made to keep
        track of what was merged.</para>
-->

      <para>La propriété <literal>svn:mergeinfo</literal> est manipulée
        automatiquement par Subversion à chaque fois que vous lancez
        <command>svn merge</command>. Sa valeur indique quelles
        modifications (pour un chemin donné) ont été recopiées dans
        le dossier en question. Dans le cas présent, le chemin d'origine
        de la fusion des modifications est
        <filename>/calc/trunk</filename> et le dossier qui a reçu les
        modifications spécifiées est
        <filename>/calc/branches/ma-branche-calc</filename>. Les
        vieilles versions de Subversion tenaient à jour la propriété
        <literal>svn:mergeinfo</literal> silencieusement. Vous en
        détectiez quand même les modifications, après une fusion, lors
        de l'utilisation des sous-commandes <command>svn diff</command>
        ou <command>svn status</command>, mais la fusion en elle-même
        n'indiquait rien de la modification de la propriété
        <literal>svn:mergeinfo</literal>. Dans les versions 1.7 et
        ultérieures de Subversion, ce n'est plus le cas puisque
        plusieurs notifications vous avertissent de la mise à jour de
        la propriété <literal>svn:mergeinfo</literal> par une opération
        de fusion. Ces notifications commencent toutes par
        <quote>--- Stockage des informations de fusion
        (mergeinfo)</quote> et sont indiquées à la fin de l'opération
        de fusion. Contrairement aux autres notifications de la fusion,
        elles ne décrivent pas les modifications apportées à la copie
        de travail (voir
        <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        mais plutôt la conservation des modifications effectuées
        pour garder la trace de ce qui a été fusionné.</para>

<!--
      <para>Subversion also provides a subcommand, <command>svn
        mergeinfo</command>, which is helpful in seeing the merge
        relationships between two branches; specifically which changesets
        a directory has absorbed or which changesets it's still eligible
        to receive.  The latter gives a sort of preview of which changes a
        subsequent <command>svn merge</command> operation would replicate
        to your branch.  By default, <command>svn mergeinfo</command> gives
        an graphical overview of the relationship between to branches.
        Returning to our earlier example, we use the subcommand to analyze
        the relationship between <filename>/calc/trunk</filename> and
        <filename>/calc/branches/my-calc-branch</filename>:</para>
-->
      <para>Il existe également une sous-commande,
        <command>svn mergeinfo</command>, qui peut être utile pour
        voir les relations de fusions entre deux branches&nbsp;;
        particulièrement, quels ensembles de modifications un
        dossier a absorbés, mais aussi quels ensembles de modifications
        il est encore susceptible de recevoir. Ceci donne une sorte
        d'aperçu du prochain ensemble de modifications que
        <command>svn merge</command> recopiera vers
        votre branche. Par défaut, <command>svn mergeinfo</command>
        donne un aperçu graphique de la relation entre les branches.
        Pour en revenir à notre exemple précédent, nous utilisons la
        sous-commande pour analyser la relation entre
        <filename>/calc/trunk</filename> et
        <filename>/calc/branches/ma-branche-calc</filename> &nbsp;:</para>

      <informalexample>
        <screen><!--
$ cd my-calc-branch

$ svn mergeinfo ^/calc/trunk
    youngest common ancestor
    |         last full merge
    |         |        tip of branch
    |         |        |         repository path
-->
$ cd ma-branche-calc

$svn mergeinfo ^/calc/trunk
    youngest common ancestor
    |         last full merge
    |         |        tip of branch
    |         |        |         repository path
    340                382
    |                  |
  -------| |------------         calc/trunk
     \          /
      \        /<!--
       - | |- - - - - -          calc/branches/my-calc-branch-->
       --| |------------         calc/branches/ma-branche-calc
              |        |
              379      382
</screen>
      </informalexample>

<!--
      <para>The diagram shows that <filename>/calc/branches/my-calc-branch
      </filename> was copied from <filename>/calc/trunk@340</filename> and
      that most recent automatic merge was the reintegrate merge we made
      from the branch to the trunk in r380.  Notice that the diagram does
      <emphasis>not</emphasis> show the four automatic sync merges we made
      in revisions 352, 362, 372, and 379.  Only the most recent automatic
      merge, in either direction<footnote><para>By <quote>direction</quote>
      we mean either trunk-to-branch (automatic sync) or branch-to-trunk
      (automatic reintegrate) merges.</para></footnote>, is shown.  This
      default output is useful for obtaining an overview of the merges
      between two branches, but to see the specific revisions which were
      merged we use the <option>- -show-revs=merged</option> option:</para>
-->
      <para>Le diagramme indique que
        <filename>/calc/branches/ma-branche-calc</filename> a été copié
        à partir de <filename>/calc/trunk@340</filename> et que la
        fusion automatique la plus récente était la fusion de
        réintégration que nous avons faite depuis la branche vers le
        tronc à r380. Notez que le diagramme <emphasis>n'indique
        pas</emphasis> les quatre fusions de synchronisation que nous
        avons effectuées aux révisions 352, 362, 372 et 379. Seule la
        fusion automatique la plus récente est indiquée, quelle que soit
        sa direction <footnote><para>Par <quote>direction</quote>,
        nous entendons les fusions soit du tronc vers la branche
        (synchronisation automatique), soit de la branche vers le tronc
        (réintégration automatique).</para></footnote>. Cet affichage
        par défaut est utile pour obtenir un aperçu des fusions entre
        deux branches, mais pour voir les révisions spécifiques qui ont
        fait l'objet d'une fusion, nous utilisons l'option
        <option>--show-revs=merged</option>&nbsp;:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs merged
r344
r345
r346
&hellip;
r366
r367
r368
</screen>
      </informalexample>

<!--
      <para>Likewise, to see which changes are eligible to merge from the
        trunk to the branch we can use the <option>- -show-revs=eligible
        </option> option:</para>
-->
      <para>De la même manière, pour voir quelles modifications sont
        éligibles pour une fusion depuis le tronc vers la branche, nous
        pouvons utiliser l'option
        <option>--show-revs=eligible</option>&nbsp;:</para>
      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r380
r381
r382
</screen>
      </informalexample>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.operativerevs">
<!--
        <title>Operative and Inoperative Merge Revisions</title>
-->
        <title>Révisions effectives et non-effectives pour la
          fusion</title>

<!--
        <para>The revision lists produced by the <option>- -show-revs
          </option> option include only revisions which made (or would make)
          changes when merged.  So while we have merged a contiguous range of
          revisions (i.e. r341-378) from <filename>/calc/trunk</filename> to
          <filename>/calc/branches/my-calc-branch</filename>, only the
          revisions listed with the <option>- -show-revs=merged</option> option
          actually represent changes made on <filename>/calc/trunk</filename>.
          These revisions are described as <quote>operative</quote>
          revisions as regards merging, not to be confused with the
          operative revision used with the <option>-r</option> option, see
          <xref linkend="svn.advanced.pegrevs"/>.  Not suprisingly, the
          revisions in the range r341-378 that are <emphasis>not</emphasis>
          listed as merged are termed <quote>inoperative</quote> revisions.
        </para>
-->
        <para>La liste des révisions donnée par l'option
          <option>--show-revs </option> ne comporte que les révisions
          qui ont produit (ou produiraient) des modifications lors d'une
          fusion. Ainsi, alors que nous avons fusionné un intervalle
          contigu de révisions (par exemple r341-378) depuis
          <filename>/calc/trunk</filename> vers
          <filename>/calc/branches/ma-branche-calc</filename>, seules
          les révisions listées par l'option
          <option>--show-revs=merged</option> comportent des
          modifications sur <filename>/calc/trunk</filename>. Ces
          révisions sont appelées <quote>effectives</quote>
          (<foreignphrase>operative</foreignphrase> en anglais) quant à
          l'opération de fusion, et ne doivent pas être confondues avec
          les révisions opérationnelles utilisées par l'option
          <option>-r</option> (voir <xref linkend="svn.advanced.pegrevs"
          />. Sans surprise, les révisions dans l'intervalle r341-378,
          qui ne sont pas listées comme fusionnées sont appelées
          révisions <quote>non-effectives</quote>
          (<foreignphrase>inoperative</foreignphrase> en anglais).
      </para>
    </sidebar>

<!--
      <para>The <command>svn mergeinfo</command> command requires
        a <quote>source</quote> URL (where the changes come
        from), and takes an optional <quote>target</quote> URL (where
        the changes merge to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we're querying our
        branch working copy, the command assumes we're interested in
        receiving changes to <filename>/calc/branches/my-calc-branch
        </filename> from the specified trunk URL.</para>
-->
      <para>La sous-commande <command>svn mergeinfo</command> requiert
        une URL <quote>source</quote> (d'où proviennent les
        modifications) et prend optionnellement une URL
        <quote>cible</quote> (où les modifications sont fusionnées). Si
        aucune URL cible n'est fournie, Subversion suppose que le
        répertoire courant est la cible. Dans l'exemple précédent, comme
        nous interrogeons notre copie de travail de la branche, la
        commande suppose que nous nous intéressons aux modifications
        que nous souhaitons apporter à
        <filename>/calc/branches/ma-branche-calc</filename> depuis l'URL
        du tronc telle que spécifiée.</para>

<!--
      <para>Since Subversion 1.7, the
        <command>svn mergeinfo</command> subcommand can also account for
        subtree mergeinfo and non-inheritable mergeinfo.  It accounts for
        subtree mergeinfo by use of the <option>- -recursive</option> or
        <option>- -depth</option> options, while non-inheritable mergeinfo
        is considered by default.</para>
-->
      <para>Depuis Subversion 1.7, la sous-commande <command>svn
        mergeinfo</command> peut également traiter les informations de
        fusion de la sous-arborescence et les informations de fusion non
        héritables. Elle traite les informations de fusion de
        sous-arborescence avec les options <option>--recursive</option>
        ou <option>--depth</option>, et les informations de fusion non
        héritables sont traitées par défaut.</para>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.inheritance">
<!--
        <title>Mergeinfo Inheritance</title>
-->
        <title>Héritages des informations de fusion</title>

<!--
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>inheritance</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>explicit</secondary>
          </indexterm>When a path has
          the <literal>svn:mergeinfo</literal> property set on it we
          say it has <firstterm>explicit mergeinfo</firstterm>.  This
          explicit mergeinfo describes not only what changes were
          merged into that particular directory, but also all the
          children of that directory (because those children inherit
          the mergeinfo of their parent path).  For example:</para>
-->
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>héritage</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>explicite</secondary>
          </indexterm>Quand un chemin possède la propriété
          <literal>svn:mergeinfo</literal>, il est réputé avoir un
          <firstterm>mergeinfo explicite</firstterm>. Ces informations
          de fusion décrivent non seulement les modifications qui ont
          été fusionnées dans ce dossier particulier mais aussi dans
          tous les enfants de ce dossier (parce que ces enfants héritent
          du mergeinfo de leur chemin parent). Par exemple&nbsp;:</para>

        <informalexample>
          <screen> <!--
# What explicit mergeinfo exists on a branch?
-->
# Quelles informations de fusion explicites existent sur cette branche ?
$ svn propget svn:mergeinfo ^/branches/proj-X --recursive
/trunk:651-652
<!--
# What children does proj-X have?
-->
# Quels sont les enfants de proj-X ?
$ svn list --recursive ^/branches/proj-X
doc/
doc/INSTALL<!--
README-->
LISEZMOI
src/main.c
<!--
# Ask what revs were merged to a file with no explicit mergeinfo
-->
# Quelles sont les révisions qui ont été fusionnées dans ce fichier
# sans informations de fusion explicites
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

<!--
        <para>Notice from our first subcommand that only the root of
          <filename>/branches/proj-X</filename> has any explicit
          mergeinfo.  However, when we use
          <command>svn mergeinfo</command> to ask what was merged to
          <filename>/branches/proj-X/src/main.c</filename> it reports
          that the two revisions described in the explicit mergeinfo
          on <filename>/branches/proj-X</filename> were merged.  This is
          because <filename>/branches/proj-X/src/main.c</filename>, having
          no explicit mergeinfo of its own, inherits the mergeinfo from
          its nearest parent with explicit mergeinfo,
          <filename>/branches/proj-X</filename>.</para>
-->
        <para>Notez que dans notre première sous-commande, seule la
          racine de <filename>/branches/proj-X</filename> possède des
          informations de fusion explicites. Toutefois, quand nous
          utilisons <command>svn mergeinfo</command> pour demander ce
          qui a été fusionné vers
          <filename>/branches/proj-X/src/main.c</filename>, elle indique
          que les deux révisions décrites dans les informations de
          fusion explicites de <filename>/branches/proj-X</filename>
          ont été fusionnées. C'est parce que
          <filename>/branches/proj-X/src/main.c</filename>,  qui ne
          possède pas d'informations de fusion explicites, hérite des
          informations de fusion de son parent le plus proche avec des
          informations de fusion explicites,
          <filename>/branches/proj-X</filename>.</para>

<!--
        <para>There are two cases in which mergeinfo is not inherited.
          First, if a path has explicit mergeinfo, then it never inherits
          mergeinfo. Another way to think of this is that explicit
          mergeinfo is always a complete record of the merges to a given
          path, once it exists it overrides any mergeinfo that path might
          otherwise inherit. The second way is when dealing with
          non-inheritable mergeinfo, a special type of explicit mergeinfo
          that applies <emphasis>only</emphasis> to the directory on which
          the <literal>svn:mergeinfo</literal> property is set (and it's
          only directories, non-inheritable mergeinfo is never set on
          files). For example:</para>
-->
        <para>Il existe deux cas dans lesquelles les informations de
          fusion ne sont pas héritées. Premièrement, si un chemin
          possède des informations de fusion explicites, alors il
          n'hérite jamais des informations de fusion. Une autre façon de
          se représenter ceci est que les informations de fusion
          explicites sont toujours un enregistrement complet des fusions
          pour un chemin donné&nbsp;; si elles existent, elles prennent
          le pas sur les informations de fusion du chemin pour lequel
          elles auraient hérité autrement. Deuxièmement, lorsque les
          informations de fusion ne sont pas héritables, un type
          particulier d'informations de fusion explicites s'applique
          alors <emphasis>uniquement</emphasis> au dossier sur lequel la
          propriété <literal>svn:mergeinfo</literal> est définie (et
          seulement ces dossiers, les informations de fusion non
          héritables ne sont jamais définies sur des fichiers). Par
          exemple&nbsp;:</para>

        <informalexample>
          <screen> <!--
# The '*' decorator indicates non-inheritable mergeinfo
-->
# la marque '*' indique des informations de fusion non héritables
$ svn propget svn:mergeinfo ^/branches/proj-X
/trunk:651-652,758*
<!--
# Revision 758 is non-inheritable, but still applies to the path it is
# set on. Here the '*' decorator signals that r758 is only partially
# merged from trunk.
-->
# La révision 758 n'est pas héritable, mais elle s'applique quand même
# sur le chemin sur lequel elle est définie. Ici, la marque '*' signale
# que r758 est seulement partiellement fusionnée depuis le tronc
$ svn mergeinfo ^/trunk ^/branches/proj-X --show-revs merged
651
652
758*
<!--
# Revision 758 is not reported as merged because it is non-inheritable
# and applies only to ^/trunk
-->
# La révision 758 n'est pas marquée comme fusionnée parce qu'elle n'est
# pas héritable et s'applique uniquement à ^/trunk
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

<!--
        <para>You might never have to think about mergeinfo inheritance
          or encounter non-inheritable mergeinfo in your own repository.
          A discussion of the full ramifications of mergeinfo inheritance
          are beyond the scope of this book.  If you have more questions
          check out some of the references mentioned in
          <xref linkend="svn.branchmerge.advanced.finalword"/></para>
-->
        <para>Il est possible que vous n'ayez jamais besoin de vous
          soucier de l'héritage des informations de fusion ou que vous
          ne rencontriez jamais d'informations de fusion non héritables
          dans votre propre dépôt. Une discussion sur toutes les
          ramifications de l'héritage des informations de fusion dépasse
          le cadre de ce livre. Si vous avez des questions
          complémentaires, regardez du côté des références mentionnées
          dans
          <xref linkend="svn.branchmerge.advanced.finalword"/>.</para>
      </sidebar>

<!--
      <para>Let's say we have a branch with both subtree and
        non-inheritable mergeinfo:</para>
-->
      <para>Considérons que nous avons une branche avec à la fois une
        sous-arborescence et des informations de fusion non
        héritables&nbsp;:</para>

        <informalexample>
          <screen>
$ svn pg svn:mergeinfo -vR <!--
# Non-inheritable mergeinfo
Properties on '.':
-->
# informations de fusion non héritables
Propriétés sur '.'
  svn:mergeinfo
    /calc/trunk:354,385-388* <!--
# Subtree mergeinfo
Properties on 'Makefile':
-->
# sous-arborescence d'informations de fusion
Propriétés sur 'doc/INSTALL'
  svn:mergeinfo
    /calc/trunk/Makefile:354,380
</screen>
        </informalexample>

<!--
      <para>From the above mergeinfo we see that r385-388 has only been
        merged into the root of the branch, but not any of the root's
        children.  We also see that r380 has only been merged to
        <filename>Makefile</filename>.
        When we use <command>svn mergeinfo</command> with the
        <option>- -recursive</option> option to see what has been merged
        from <filename>/calc/trunk</filename> to this branch, we see three
        revisions are flagged with the <literal>*</literal> marker:</para>
-->
      <para>Dans les informations de fusion ci-dessus, nous voyons que
        r385-388 a été fusionnée seulement à la racine de la branche
        et dans aucun des enfants de la racine. Nous voyons aussi que
        r380 a été fusionnée seulement dans
        <filename>Makefile</filename>. Quand nous utilisons
        <command>svn mergeinfo</command> avec l'option
        <option>--recursive</option> pour voir ce qui a été fusionné
        depuis <filename>/calc/trunk</filename> vers cette branche, nous
        voyons trois révisions qui sont marquées avec
        <literal>*</literal>&nbsp;:</para>

        <informalexample>
          <screen>
$ svn mergeinfo -R --show-revs=merged ^/calc/trunk .
r354
r380*
r385
r386
r387*
r388*
</screen>
        </informalexample>

<!--
      <para>The <literal>*</literal> indicates revisions that are only
        <emphasis>partially</emphasis> merged to the target in question
        (the meaning is the same if we are checking for eligible
        revisions).  What this means in this example is that if we tried
        to merge r380, r387, or r388 from <filename>^/trunk</filename> then
        more changes would result. Likewise, because r354, r385 and r386 are
        <emphasis>not</emphasis> flagged with a <literal>*</literal>,
        we know that re-merging those revisions would have no result.
        <footnote><para>This is a good example of inoperative merge
        revisions.</para></footnote></para>
-->
      <para>Cette marque <literal>*</literal> indique des révisions qui
        ont fait l'objet de fusions <emphasis>partielles</emphasis> vers
        la cible en question (la signification est la même que lorsque
        nous cherchons des révisions éligibles). Dans cet exemple, cela
        signifie que si nous essayons de fusionner r380, r387 ou r388
        depuis <filename>^/trunk</filename> alors des modifications
        seront apportées. De la même manière, puisque r354, r385 et r386
        <emphasis>ne sont pas</emphasis> marquées avec
        <literal>*</literal>, nous savons que fusionner à nouveau ces
        révisions ne produira aucun changement.<footnote><para>C'est un
        bon exemple de révisions non-effectives pour la
        fusion.</para></footnote></para>

<!--
      <para>Another way to get a more precise preview of a merge
        operation is to use the <option>- -dry-run</option>
        option:</para>
-->
      <para>Une autre manière d'obtenir un aperçu plus précis d'une
        opération de fusion est d'utiliser l'option
        <option>--dry-run</option>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn merge ^/paint/trunk paint-feature-branch - -dry-run
- - Merging r290 through r383 into 'paint-feature-branch':
U    paint-feature-branch/src/palettes.c
U    paint-feature-branch/src/brushes.c
U    paint-feature-branch/Makefile
-->
$ svn merge ^/paint/trunk ma-branche-peinture --dry-run
--- Fusion de r290 à r383 dans 'ma-branche-peinture':
U    ma-branche-peinture/src/palettes.c
U    ma-branche-peinture/src/brosses.c
U    ma-branche-peinture/Makefile

$ svn status <!--
#  nothing printed, working copy is still unchanged.
-->
#  rien ne s'affiche, la copie de travail n'a pas changé.
</screen>
      </informalexample>

<!--
      <para>The <option>- -dry-run</option> option doesn't actually
        apply any local changes to the working copy.  It shows only
        status codes that <emphasis>would</emphasis> be printed in a
        real merge.  It's useful for getting a <quote>high-level</quote>
        preview of the potential merge, for those times
        when running <command>svn diff</command> gives too much
        detail.</para>
-->
        <para>L'option <option>--dry-run</option> n'effectue en fait
        pas de modification locale sur la copie de travail. Elle ne
        fait qu'indiquer les codes d'état qui
        <emphasis>seraient</emphasis> affichés par une vraie fusion.
        Ceci permet d'obtenir un <quote>aperçu général</quote>
        d'une fusion potentielle, pour les fois où
        <command>svn diff</command> renvoie trop de détails.</para>

      <tip>
<!--
        <para>After performing a merge operation, but before
          committing the results of the merge, you can use
          <userinput>svn diff - -depth=empty <replaceable>
          /path/to/merge/target</replaceable></userinput> to see only the
          changes to the immediate target of your merge.  If your merge
          target was a directory, only property differences are displayed.
          This is a handy way to see the changes to the
          <literal>svn:mergeinfo</literal> property recorded by the
          merge operation, which will remind you about what you've
          just merged.</para>
-->
        <para>Après avoir effectué une opération de fusion, mais avant
          d'en avoir propagé les résultats, vous pouvez utiliser
          <userinput>svn diff --depth=empty
          <replaceable>/chemin/vers/la/cible/de/la/fusion</replaceable>
          </userinput> pour visualiser uniquement les modifications
          apportées à la cible immédiate de votre fusion. Si la cible
          de la fusion est un dossier, seules les différences de
          propriétés sont alors affichées. C'est un moyen très pratique
          pour voir les modifications de la propriété
          <literal>svn:mergeinfo</literal> enregistrées par l'opération
          de fusion, qui vous rappellera ce que vous venez juste de
          fusionner.</para>
      </tip>

<!--
      <para>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <command>svn merge</command>
        isn't an inherently risky thing (unless you've made local
        modifications to your working copy&mdash;but we already
        stressed that you shouldn't merge into such an
        environment).  If you don't like the results of the merge,
        simply run <userinput>svn revert . -R</userinput> to revert
        the changes from your working copy and retry the command with
        different options.  The merge isn't final until you
        actually <command>svn commit</command> the results.</para>
-->
      <para>Bien sûr, la meilleure façon d'avoir un aperçu d'une
        opération de fusion est tout simplement de la réaliser&nbsp;!
        Souvenez-vous que lancer <command>svn merge</command> n'est
        pas une opération risquée en soi (à moins que vous ayez
        effectué des modifications locales dans votre copie de
        travail, mais nous avons déjà souligné que vous ne devriez
        pas faire de fusion dans de telles circonstances). Si les
        résultats de la fusion ne vous plaisent pas, lancez juste
        <userinput>svn revert . -R</userinput> pour ôter les
        modifications de votre copie de travail et réessayez la
        commande avec des options différentes. La fusion n'est
        définitive qu'une fois que vous en avez propagé
        les résultats par <command>svn commit</command>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.undo">
<!--
      <title>Undoing Changes</title>
-->
      <title>Retour en arrière sur des modifications</title>

<!--
      <para>An extremely common use for <command>svn merge</command>
        is to roll back a change that has already been committed.
        Suppose you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made back in revision 392, which changed
        several code files, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference.  (You can do this by
        specifying <option>- -revision 392:391</option>, or by an
        equivalent <option>- -change -392</option>.)</para>
-->
      <para>Un usage très répandu de <command>svn merge</command>
        est le retour en arrière sur une modification qui a déjà
        été propagée. Supposons que vous travaillez tranquillement
        sur une copie de travail de <filename>/calc/trunk</filename>
        et que vous découvrez tout à coup que la modification faite
        il y a longtemps lors de la révision 392, qui affectait
        plusieurs fichier sources, est complètement incorrecte.
        Elle n'aurait jamais du être propagée. Vous pouvez utiliser
        <command>svn merge</command> pour <quote>revenir en
        arrière</quote> sur ces modifications dans votre copie de
        travail, puis propager les modifications locales au dépôt. Il
        vous suffit juste de spécifier une différence
        <emphasis>inversée</emphasis> (en indiquant soit
        <option>--revision 392:391</option>, soit
        <option>--change -392</option>, les deux se valent).</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk . -c-392 <!--
- - - Reverse-merging r392 into '.':
U    src/real.c
U    src/main.c
U    src/button.c
U    src/integer.c
- - - Recording mergeinfo for reverse merge of r392 into '.':-->
-- Fusion inverse de r392 dans '.' :
U    src/reel.c
U    src/main.c
U    src/bouton.c
U    src/entier.c
-- Stockage des informations de fusion (mergeinfo) inverse de r392 vers '.' :
 U   .

$ svn st<!--
M       src/button.c
M       src/integer.c
M       src/main.c
M       src/real.c-->
M       src/bouton.c
M       src/entier.c
M       src/main.c
M       src/reel.c
$ svn diff
&hellip; <!--
# verify that the change is removed
-->
# vérifions que les modifications ont été annulées
&hellip;
<!--
$ svn commit -m "Undoing erroneous change committed in r392."
Sending        src/button.c
Sending        src/integer.c
Sending        src/main.c
Sending        src/real.c
Transmitting file data ....
Committed revision 399.
-->
$ svn commit -m "Retour en arrière sur les modifications propagées en r392."
Envoi          src/bouton.c
Envoi          src/entier.c
Envoi          src/main.c
Envoi          src/reel.c
Envoi          entier.c
Transmission des données ....
Révision 399 propagée.
</screen>
      </informalexample>

<!--
      <para>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <option>-r</option> option, you can ask <command>svn
        merge</command> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset r392 to our working copy
        <emphasis>backward</emphasis>.</para>
-->
      <para>Comme nous l'avons signalé précédemment, une façon de se
        représenter une révision du dépôt est de la considérer comme
        un ensemble de modifications spécifique. En utilisant l'option
        <option>-r</option>, vous pouvez demander à
        <command>svn merge</command> d'appliquer un ensemble de
        modifications, ou tout un groupe d'ensembles de modifications,
        à votre copie de travail. Dans le cas présent, pour revenir
        en arrière, nous demandons à <command>svn merge</command>
        d'appliquer <emphasis>dans le sens inverse</emphasis>
        l'ensemble de modifications r392 à notre copie de
        travail.</para>

<!--
      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>
-->
      <para>Gardez à l'esprit que revenir en arrière sur une
        modification de cette façon est similaire à toute autre
        opération <command>svn merge</command>, vous devez donc ensuite
        utiliser <command>svn status</command> et <command>svn
        diff</command> pour vous assurer que votre travail est dans
        l'état que vous voulez, puis utiliser <command>svn
        commit</command> pour propager la version finale au dépôt. Après
        la propagation, cet ensemble de modifications particulier n'est
        plus présent dans la révision <literal>HEAD</literal>.</para>

<!--
      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 392.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 392 and
        398, she'll still see the bad change, right?</para>
-->
      <para>À nouveau vous vous dites&nbsp;: bon, ceci n'a pas vraiment
        annulé la propagation, n'est-ce pas&nbsp;? La modification
        existe toujours en révision 392. Si quelqu'un extrait une
        version du projet calc entre les révisions 392 et 398, il verra
        toujours la mauvaise modification, non&nbsp;?</para>
<!--
      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from the <literal>HEAD</literal> revision.  The
        original change still exists in the repository's history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.<footnote><para>The
        Subversion project has plans, however, to someday implement a
        command that would accomplish the task of permanently deleting
        information.  In the meantime, see
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a
        possible workaround.</para></footnote></para>
-->
      <para>Oui, c'est vrai. Quand nous parlons de
        <quote>supprimer</quote> une modification, il s'agit de la
        supprimer de la révision <literal>HEAD</literal>. La
        modification originale existe toujours dans l'historique du
        dépôt. Dans la plupart des situations, c'est suffisant. La
        plupart des gens ne s'intéressent d'ailleurs qu'à la révision
        <literal>HEAD</literal> du projet. Il y a des cas particuliers,
        cependant, où l'on voudra vraiment détruire toute preuve de
        la propagation (quelqu'un a peut-être accidentellement propagé
        un document confidentiel). Cela ne s'avère pas si facile, parce
        que Subversion a été conçu délibérément pour ne jamais perdre
        d'information. Les révisions sont des arborescences immuables
        qui sont empilées les unes par dessus les autres. Supprimer
        une révision de l'historique créerait un effet domino,
        engendrant le chaos dans les révisions ultérieures et
        invalidant potentiellement toutes les copies de
        travail <footnote>
          <para>Le projet Subversion prévoit néanmoins d'implémenter, un
            jour, une commande qui accomplirait la tâche de supprimer
            des informations de façon permanente. En attendant, en guise
            de palliatif, voir <xref
            linkend="svn.reposadmin.maint.tk.svndumpfilter"/>.</para>
        </footnote>.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.resurrect">
<!--
      <title>Resurrecting Deleted Items</title>
-->
      <title>Résurrection des éléments effacés</title>

<!--
      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote></para>
-->
      <para>Ce qu'il y a de formidable dans les systèmes de gestion
        de versions, c'est que les informations ne sont jamais
        perdues. Même si vous effacez un fichier ou un dossier, s'il
        disparaît bien de la révision <literal>HEAD</literal>, l'objet
        existe toujours dans les révisions précédentes. Une des
        questions les plus courantes que posent les nouveaux
        utilisateurs est&nbsp;: <quote>Comment est-ce que je récupère
        mon ancien fichier ou dossier&nbsp;?</quote></para>

<!--
      <para>The first step is to define
        exactly <emphasis>which</emphasis> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        is defined by a specific coordinate pair.  (Remember the
        <quote>peg revision</quote>
        syntax&mdash;foo.c@224&mdash;mentioned back in
        <xref linkend="svn.advanced.pegrevs"/>.)</para>
-->
      <para>La première étape est de définir exactement
        <emphasis>quel</emphasis> élément vous essayez de ressusciter.
        Voici une métaphore utile&nbsp;: vous pouvez imaginer votre
        objet dans le dépôt comme existant dans une sorte de système
        à deux dimensions. La première coordonnée est une révision
        correspondant à une arborescence particulière&nbsp;; la
        deuxième coordonnée est un chemin à l'intérieur de cette
        arborescence. Ainsi, toute version d'un fichier ou d'un
        dossier peut être définie par une paire de coordonnées
        qui lui est propre (souvenez-vous de la syntaxe des
        <quote>révisions pivots</quote>&nbsp;: machin.c@224,
        mentionnée dans <xref linkend="svn.advanced.pegrevs"/>).</para>

<!--
      <para>First, you might need to use <command>svn log</command> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <userinput>svn log - -verbose</userinput>
        in a directory that used to contain your deleted item.  The
        <option>- -verbose</option> (<option>-v</option>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).  If you know that
        the item in question was recently deleted you might also use
        the <option>- -limit</option> option to keep the log output brief
        enough to examine manually.</para>
-->
      <para>Tout d'abord, vous allez peut-être avoir besoin de
        <command>svn log</command> pour identifier précisément les
        coordonnées du fichier ou dossier que vous voulez ressusciter.
        À cette fin, une bonne stratégie est de lancer
        <userinput>svn log --verbose</userinput> dans un dossier qui
        contenait votre élément effacé. L'option
        <option>--verbose</option> (<option>-v</option>) renvoie la
        liste de tous les éléments modifiés par chaque révision&nbsp;;
        il vous suffit alors de trouver la révision dans laquelle
        vous avez effacé le fichier ou le dossier en question.
        Vous pouvez accomplir cette recherche soit visuellement
        soit en utilisant un autre outil pour examiner
        le résultat de la commande <command>svn log</command>
        (<foreignphrase>via</foreignphrase> <command>grep</command> ou
        peut-être <foreignphrase>via</foreignphrase> une recherche
        incrémentale dans un éditeur). Si vous savez que l'élément en
        question a été effacé recemment, vous pouvez utiliser l'option
        <option>--limit</option> pour conserver un affichage de
        l'historique suffisamment bref afin d'être exploité
        manuellement.</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn log -v --limit 3
------------------------------------------------------------------------ <!--
r401 | sally | 2013-02-19 23:15:44 -0500 (Tue, 19 fév. 2013) | 1 line
Changed paths:
-->
r401 | sally | 2013-02-18 23:15:44 -0500 (mar. 19 fév. 2013) | 1 ligne
Chemins modifiés :
   M /calc/trunk/src/main.c
<!--
Follow-up to r400: Fix typos in help text.
-->
Suite à r400 : corrections de coquilles dans le texte d'aide.
------------------------------------------------------------------------<!--
r400 | bill | 2013-02-19 20:55:08 -0500 (Tue, 19 fév. 2013) | 4 lines
Changed paths:
   M /calc/trunk/src/main.c
   D /calc/trunk/src/real.c-->
r400 | bill | 2013-02-19 20:55:08 -0500 (mar. 19 fév. 2013) | 4 lignes
Chemins modifiés :
   M /calc/trunk/src/main.c
   D /calc/trunk/src/reel.c

<!--
* calc/trunk/src/main.c: Update help text.

* calc/trunk/src/real.c: Remove this file, none of the APIs
  implemented here are used anymore.
-->
* calc/trunk/src/main.c: mise à jour du texte d'aide.

* calc/trunk/src/reel.c: fichier supprimé, aucune API de ce fichier
  n'est encore utilisée.
------------------------------------------------------------------------<!--
r399 | sally | 2013-02-19 20:05:14 -0500 (Tue, 19 fév. 2013) | 1 line
Changed paths:
   M /calc/trunk/src/button.c
   M /calc/trunk/src/integer.c
   M /calc/trunk/src/main.c
   M /calc/trunk/src/real.c
-->
r399 | sally | 2013-02-19 20:05:14 -0500 (mar. 19 fév. 2013) | 1 ligne
Chemins modifiés :
   M /calc/trunk/src/bouton.c
   M /calc/trunk/src/entier.c
   M /calc/trunk/src/main.c
   M /calc/trunk/src/reel.c
<!--
Undoing erroneous change committed in r392.-->
Retour en arrière sur les modifications propagées en r392.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 400.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        399.</para>
-->
      <para>Dans l'exemple ci-dessus, nous supposons que vous
        recherchez un fichier effacé nommé <filename>reel.c</filename>.
        En examinant le journal du dossier parent, vous avez découvert
        que ce fichier a été effacé en révision 400. La dernière
        version du fichier à avoir existé était donc dans la révision
        précédant celle-ci. Conclusion&nbsp;: vous voulez ressusciter
        le chemin <filename>/calc/trunk/reel.c</filename> tel qu'il
        était en révision 399.</para>

<!--
      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>
-->
      <para>Voilà, c'était la partie difficile&nbsp;: la recherche.
        Maintenant que vous savez ce que vous voulez récupérer,
        deux options s'offrent à vous.</para>

<!--
      <para>One option is to use <command>svn merge</command> to apply
        revision 400 <quote>in reverse.</quote> (We already
        discussed how to undo changes in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.)  This
        would have the effect of re-adding <filename>real.c</filename>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <literal>HEAD</literal>.</para>
-->
      <para>Une possibilité serait d'utiliser
        <command>svn merge</command> pour appliquer la révision 400
        <quote>à l'envers</quote> (nous avons déjà parlé de comment
        revenir sur des modifications dans <xref
        linkend="svn.branchmerge.basicmerging.undo"/>). Ceci aurait
        pour effet de ré-ajouter <filename>reel.c</filename> en tant
        que modification locale. Le fichier serait alors programmé
        pour être ajouté et après la propagation le fichier existerait
        à nouveau dans <literal>HEAD</literal>.</para>

<!--
      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 400 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>main.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 400 and
        then <command>svn revert</command> the local modifications to
        <filename>main.c</filename>, but this technique doesn't
        scale well.  What if 90 files were changed in revision
        400?</para>
-->
      <para>Cependant, dans cet exemple particulier, ce n'est
        probablement pas la meilleure stratégie. Appliquer la
        révision 400 à l'envers programmerait non seulement l'ajout
        de <filename>reel.c</filename>, mais le commentaire de propagation
        indique qu'il reviendrait aussi sur certaines modifications
        de <filename>main.c</filename>, ce que vous ne voulez pas.
        Vous pourriez certainement fusionner à l'envers la révision
        808 et ensuite revenir sur les modifications locales faites
        dans <filename>main.c</filename>, mais cette technique
        fonctionne mal à plus grande échelle. Que dire si 90 fichiers
        avaient été modifiés en révision 400&nbsp;?</para>

<!--
      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather to use the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>
-->
      <para>Une seconde stratégie, plus ciblée, est de ne pas utiliser
        <command>svn merge</command> du tout, mais plutôt d'utiliser
        la commande <command>svn copy</command>. Copiez juste la
        révision et le chemin exacts (vos deux
        <quote>coordonnées</quote>) du dépôt vers votre copie de
        travail&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn copy ^/calc/trunk/src/real.c@399 ./real.c
A         real.c-->
$ svn copy ^/calc/trunk/src/reel.c@399 ./reel.c
A         reel.c
$ svn st<!--
A  +    real.c
# Commit the resurrection.-->
A  +    reel.c
# Propager la résurrection
&hellip;
</screen>
      </informalexample>

<!--
      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history.</quote>  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 399.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <emphasis>without</emphasis>
        maintaining a historical link to the old file, this technique
        works just as well:</para>
-->
      <para>Le symbole plus dans le résultat de la commande
        <command>svn status</command> indique que l'élément n'est
        pas simplement programmé pour ajout, mais programmé pour ajout
        <quote>avec son historique</quote>. Subversion se souviendra
        d'où il a été copié. Dans le futur, lancer
        <command>svn log</command> sur ce fichier parcourra tout son
        historique en passant par la résurrection du fichier ainsi que
        tout ce qui précédait la révision 399. En d'autres termes,
        ce nouveau <filename>reel.c</filename> n'est pas vraiment
        nouveau&nbsp;; c'est un descendant direct du fichier original
        qui avait été effacé. En général c'est une bonne chose, dont
        l'utilité est avérée. Si cependant vous vouliez récupérer
        le fichier <emphasis>sans</emphasis> conserver de lien
        historique avec l'ancien fichier, la technique suivante
        fonctionnerait tout aussi bien&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn cat ^/calc/trunk/src/real.c@399 &gt; ./real.c

$ svn add real.c
A         real.c

# Commit the resurrection.
-->
$ svn cat ^/calc/trunk/reel.c@399 &gt; ./reel.c

$ svn add reel.c
A         reel.c

# Propager la résurrection
&hellip;
</screen>
      </informalexample>

<!--
      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn't
        have to happen in your working copy&mdash;it can happen
        entirely in the repository:</para>
-->
      <para>Bien que notre exemple ne porte que sur la résurrection
        d'un fichier, remarquez que ces mêmes techniques fonctionnent
        tout aussi bien pour ressusciter des dossiers effacés.
        Remarquez aussi que cette résurrection ne doit pas forcément
        avoir lieu dans votre copie de travail&nbsp;; elle peut avoir
        lieu entièrement dans le dépôt&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn copy ^/calc/trunk/src/real.c@399 ^/calc/trunk/src/real.c \
           -m "Resurrect real.c from revision 399."
Committed revision 402.
-->
$ svn copy ^/calc/trunk/src/reel.c@399 ^/calc/trunk/src/reel.c \
           -m "Ressuscite reel.c depuis la révision 399."
Révision 402 propagée.

$ svn up<!--
Updating '.':
A    real.c
Updated to revision 402.
-->
Mise à jour de '.' :
A    reel.c
À la révision 402.
</screen>
      </informalexample>

  </sect2>

</sect1>

<!-- ================================================================= -->
<!-- ================================================================= -->
<!-- ================================================================= -->
  <sect1 id="svn.branchmerge.advanced">
<!--
    <title>Advanced Merging</title>
-->
    <title>Fusions&nbsp;: pratiques avancées</title>

<!--
    <para>Here ends the automated magic.  Sooner or later, once you
      get the hang of branching and merging, you're going to have to
      ask Subversion to merge <emphasis>specific</emphasis> changes
      from one place to another.  To do this, you're going to
      have to start passing more complicated arguments to <command>svn
      merge</command>.  The next section describes the fully expanded
      syntax of the command and discusses a number of common
      scenarios that require it.</para>
-->
    <para>Ici finit la magie automatisée. Tôt ou tard, une fois que
      vous maîtrisez bien la gestion des branches et les fusions,
      vous allez vous retrouver à demander à Subversion de fusionner
      des modifications <emphasis>spécifiques</emphasis> d'un endroit à
      un autre. Pour faire cela, vous allez devoir commencer à passer
      des paramètres plus compliqués à <command>svn merge</command>. Le
      paragraphe suivant décrit la syntaxe complète de la commande et
      aborde un certain nombre de scénarios d'utilisation courants qui
      exploitent la commande.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.cherrypicking">
<!--
      <title>Cherrypicking</title>
-->
      <title>Sélection à la main</title>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>cherrypicking</secondary>
        </indexterm>Just as the term <quote>changeset</quote> is often used in
        version control systems, so is the term
        <firstterm>cherrypicking</firstterm>.  This word refers to
        the act of choosing <emphasis>one</emphasis> specific
        changeset from a branch and replicating it to another.
        Cherrypicking may also refer to the act of duplicating a
        particular set of (not necessarily contiguous!) changesets
        from one branch to another.  This is in contrast to more
        typical merging scenarios, where the <quote>next</quote>
        contiguous range of revisions is duplicated
        automatically.</para>
-->
      <para>
        <indexterm>
          <primary>fusions</primary>
          <secondary>sélectionner à la main</secondary>
          </indexterm>De la même façon que le terme <quote>ensemble
        de modifications</quote> est utilisé couramment dans les
        systèmes de gestion de versions, le terme <quote>sélectionner
        à la main</quote> l'est aussi. Il désigne l'action
        de choisir <emphasis>une</emphasis> liste de modifications
        particulière au sein d'une branche et de la recopier dans une
        autre. Sélectionner à la main peut aussi faire référence à
        l'action de dupliquer un ensemble de modifications
        (pas nécessairement contiguës&nbsp;!) d'une branche vers une
        autre. Ceci est en opposition avec des scénarios de fusion
        plus courants, où l'ensemble de révisions contiguës
        <quote>suivant</quote> est dupliqué automatiquement.</para>

<!--
      <para>Why would people want to replicate just a single change?
        It comes up more often than you'd think.  For example, let's
        assume you've created a new feature branch <filename>
        /calc/branches/my-calc-feature-branch</filename> copied from
        <filename>/calc/trunk</filename>:</para>
-->
      <para>Pourquoi voudrait-on ne recopier qu'une modification
        unique&nbsp;? Cela arrive plus souvent qu'on ne croit. Par
        exemple, imaginons que vous ayez créé une branche pour une
        nouvelle fonctionnalité
        <filename>/calc/branches/ma-branche-nouvelle-calc</filename> copiée à
        partir de <filename>/calc/trunk</filename>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn log ^/calc/branches/new-calc-feature-branch -v -r403-->
$ svn log ^/calc/branches/ma-branche-nouvelle-calc -v -r403
------------------------------------------------------------------------<!--
r403 | user | 2013-02-20 03:26:12 -0500 (Wed, 20 fév. 2013) | 1 line
Changed paths:-->
r403 | user | 2013-02-20 03:26:12 -0500 (mer. 20 fév. 2013) | 1 ligne
Chemins modifiés :
   A /calc/branches/ma-branche-nouvelle-calc (de /calc/trunk:402)
<!--
Create a new calc branch for Feature 'X'.
-->
Création d'une nouvelle branche calc pour la fonctionnalité 'X'.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>At the water cooler, you get word that Sally made an interesting
        change to <filename>main.c</filename> on the trunk.
        Looking over the history of commits to the trunk, you see that
        in revision 413 she fixed a critical bug that directly
        impacts the feature you're working on.  You might not be ready
        to merge all the trunk changes to your branch just yet, but
        you certainly need that particular bug fix in order to continue
        your work.</para>
-->
      <para>À la machine à café, vous apprenez par hasard que Sally a
        apporté une modification intéressante à
        <filename>main.c</filename> dans le tronc. Vous reportant à
        l'historique des propagations du tronc, vous vous apercevez
        qu'elle a corrigé un bogue crucial en révision 413, qui
        impacte directement la fonctionnalité sur laquelle vous êtes
        en train de travailler. Vous n'êtes peut-être pas encore prêt
        à fusionner toutes les modifications du tronc dans votre
        branche, mais vous avez certainement besoin de ce correctif
        pour continuer votre travail.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/trunk -r413 -v
------------------------------------------------------------------------<!--
r413 | sally | 2013-02-21 01:57:51 -0500 (Thu, 21 fév. 2013) | 3 lines
Changed paths:-->
r413 | sally | 2013-02-21 01:57:51 -0500 (jeu. 21 fév. 2013) | 3 lignes
Chemins modifiés :
   M /calc/trunk/src/main.c
<!--
Fix issue #22 'Passing a null value in the foo argument
of bar() should be a tolerated, but causes a segfault'.
-->
Corrige le problème #22 'Passer une valeur null dans l'argument truc
de machin() devrait être toléré, mais cela produit un plantage'.
------------------------------------------------------------------------

$ svn diff ^/calc/trunk -c413
Index: src/main.c
===================================================================
--- src/main.c  (revision 412)
+++ src/main.c  (revision 413)
@@ -34,6 +34,7 @@
&hellip;<!--
Details of the fix-->
Détails de la correction
&hellip;
</screen>
      </informalexample>

<!--
      <para>Just as you used <command>svn diff</command> in the prior
        example to examine revision 413, you can pass the same option
        to <command>svn merge</command>:</para>
-->
      <para>De la même façon que vous avez utilisé <command>svn
        diff</command> dans l'exemple précédent pour examiner la
        révision 413, vous pouvez passer le même paramètre à
        <command>svn merge</command>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ cd new-calc-feature-branch

$ svn merge ^/calc/trunk -c413
- - - Merging r413 into '.':
-->
$ cd ma-branche-nouvelle-calc

$ svn merge ^/calc/trunk -c413
--- Fusion de r413 dans '.':
U    src/main.c<!--
- - Recording mergeinfo for merge of r413 into '.':
-->
-- Stockage des informations de fusion (mergeinfo) de r413 dans '.' :
 U   .

$ svn st
 M      .
M       src/main.c
</screen>
      </informalexample>

<!--
      <para>You can now go through the usual testing procedures before
        committing this change to your branch.  After the commit,
        Subversion updates the <literal>svn:mergeinfo</literal> on your
        branch to reflect that r413 was been merged to the branch.  This
        prevents future automatic sync merges from attempting to merge
        r413 again.  (Merging the same change to the same branch almost
        always results in a conflict!) Notice also the mergeinfo <literal>
        /calc/branches/my-calc-branch:341-379</literal>.  This was
        recorded during the earlier reintegrate merge to <filename>
        /calc/trunk</filename> from the <filename>
        /calc/branches/my-calc-branch</filename> branch which we made in
        r380.  When we created the <filename>my-calc-branch</filename>
        branch in r403, this mergeinfo was carried along with the copy.
        </para>
-->
      <para>Vous pouvez à présent lancer les procédures habituelles
        de tests, avant de propager cette modification à votre branche.
        Après la propagation, Subversion met à jour la propriété
        <literal>svn:mergeinfo</literal> de votre branche pour indiquer
        que r413 a été fusionnée dans la branche. Cela empêche qu'une
        future fusion automatique de synchronisation ne tente
        d'appliquer une nouvelle fois r413 (fusionner une même
        modification dans une même branche aboutit presque toujours
        à un conflit&nbsp;!). Notez aussi les informations de fusion
        <literal>/calc/branches/my-calc-branch:341-379</literal>. Cela
        a été enregistré lors de la précédente fusion de réintégration
        vers <filename>/calc/trunk</filename> depuis la branche
        <filename>/calc/branches/ma-branche-calc</filename> que nous
        avons effectué en r380. Quand nous avons créé la branche
        <filename>ma-branche-nouvelle-calc</filename> en r403, les
        informations de fusion sont venues avec le reste de la
        copie.</para>

      <informalexample>
        <screen>
$ svn pg svn:mergeinfo -v<!--
Properties on '.':-->
Propriétés sur '.' :
  svn:mergeinfo<!--
    /calc/branches/my-calc-branch:341-379-->
    /calc/branches/ma-branche-calc:341-379
    /calc/trunk:413
</screen>
      </informalexample>

<!--
      <para>Notice too that the <command>mergeinfo</command> doesn't list r413
        as "eligible" to merge, because it's already been merged:</para>
-->
      <para>Vous pouvez remarquer que <command>mergeinfo</command> ne
        marque pas r413 comme <quote>éligible</quote> pour une fusion
        puisqu'elle a été déjà fusionnée&nbsp;:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r404
r405
r406
r407
r409
r410
r411
r412
r414
r415
r416
&hellip;
r455
r456
r457
</screen>
      </informalexample>

<!--
      <para>The preceding means that when the time finally comes to do an
        automatic sync merge, Subversion breaks the merge into two parts.
        First it merges all eligible merges up to revision 412.  Then it
        merges all eligible revisions from revisions 414 to the <literal>HEAD
        </literal> revision.  Because we already cherrypicked r413, that
        change is skipped:</para>
-->
      <para>Ce qui précède signifie que, quand le temps sera venu de
        faire une fusion de synchronisation automatique, Subversion
        séparera la fusion en deux parties&nbsp;: d'abord il fusionnera
        toutes les révisions éligibles jusqu'à r412, puis il fusionnera
        toutes les révisions éligibles depuis r414 jusqu'à la révision
        <literal>HEAD</literal>. Comme nous avons déjà sélectionné à la
        main r413, cette modification est sautée&nbsp;:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk <!--
- - Merging r403 through r412 into '.':
-->
--- Fusion de r403 à r412 dans '.':
U    doc/INSTALL
U    src/main.c<!--
U    src/button.c
U    src/integer.c
U    Makefile
U    README
- - Merging r414 through r458 into '.':-->
U    src/bouton.c
U    src/entier.c
U    Makefile
U    LISEZMOI
--- Fusion de r414 à r458 dans '.':
G    doc/INSTALL
G    src/main.c<!--
G    src/integer.c-->
G    src/entier.c
G    Makefile<!--
- - Recording mergeinfo for merge of r403 through r458 into '.':-->
--- Stockage des informations de fusion (mergeinfo) de r403 à r458  dans '.' :
 U   .
</screen>
      </informalexample>

<!--
      <para> <indexterm> <primary>merging</primary>
      <secondary>backporting</secondary> </indexterm>This use case of
      replicating (or <firstterm>backporting</firstterm>) bug fixes
      from one branch to another is perhaps the most popular reason
      for cherrypicking changes; it comes up all the time, for
        example, when a team is maintaining a <quote>release
        branch</quote> of software.  (We discuss this pattern in <xref
        linkend="svn.branchmerge.commonpatterns.release"/>.)</para>
-->
      <para> <indexterm> <primary>fusions</primary>
        <secondary>retroportage</secondary> </indexterm>Ce type
        d'utilisation de la copie (ou
        <firstterm>rétroportage</firstterm>) de correctifs d'une branche
        à une autre est peut-être la raison la plus répandue pour
        sélectionner à la main des modifications&nbsp;; le cas se
        présente très souvent, par exemple lorsqu'une équipe gère une
        <quote>branche de production</quote> du logiciel (ce thème est
        développé dans <xref
        linkend="svn.branchmerge.commonpatterns.release"/>).</para>

      <warning>
<!--
        <para>Did you notice how, in the last example, the merge
          invocation merged two distinct ranges?
          The <command>svn merge</command> command applied
          two independent patches to your working copy to skip over
          changeset 413, which your branch already contained.  There's
          nothing inherently wrong with this, except that it has the
          potential to make conflict resolution trickier.  If the
          first range of changes creates conflicts,
          you <emphasis>must</emphasis> resolve them interactively for
          the merge process to continue and apply the second range of
          changes.  If you postpone a conflict from the first wave of
          changes, the whole merge command will bail out with an error
          message and you must resolve the conflict before running the
          merge a second time to get the remainder of the changes.</para>
-->
        <para>Avez-vous remarqué la façon dont, dans le dernier
          exemple, le lancement de la fusion a eu pour effet
          l'application de deux ensembles distincts de fusions&nbsp;?
          La commande <command>svn merge</command> a appliqué deux
          correctifs indépendants à votre copie de travail, afin de
          sauter l'ensemble de modifications 413, que votre branche
          contenait déjà. Il n'y a rien de mal en soi là-dedans, sauf
          que ça risque de rendre plus délicate la résolution des
          conflits. Si le premier groupe de modifications engendre des
          conflits, vous <emphasis>devrez</emphasis> les résoudre de
          façon interactive pour que la procédure de fusion puisse
          continuer et appliquer le deuxième groupe de modifications.
          Si vous remettez à plus tard un conflit lié à la première
          vague de modifications, la commande de fusion renverra au
          final un message d'erreur et vous devrez résoudre le conflit
          avant de lancer la fusion une deuxième fois pour récupérer
          le reste des modifications.</para>
      </warning>

<!--
      <para>A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in <xref linkend="svn.ref.svn"/> for details, or ask
        <command>svn help</command>.  For example, <command>svn
        merge</command> requires a working copy path as a target, that is,
        a place where it should apply the generated patch.  If the
        target isn't specified, it assumes you are trying to perform
        one of the following common operations:</para>
-->
      <para>Avertissement&nbsp;: bien que <command>svn diff</command>
        et <command>svn merge</command> soient conceptuellement très
        similaires, leur syntaxe est différente dans de nombreux cas.
        Pour plus de détails, reportez-vous au <xref
        linkend="svn.ref.svn"/> ou consultez <command>svn
        help</command>. Par exemple, <command>svn merge</command>
        demande en entrée, en tant que cible, le chemin d'une copie de
        travail, c'est-à-dire un emplacement où il va appliquer le
        correctif généré. Si la cible n'est pas spécifiée, elle suppose
        que vous essayez d'exécuter l'une des opérations
        suivantes&nbsp;:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>You want to merge directory changes into your current
            working directory.</para>
-->
          <para>Vous voulez fusionner les modifications du dossier dans
            votre dossier de travail en cours.</para>
        </listitem>
        <listitem>
<!--
          <para>You want to merge the changes in a specific file into
            a file by the same name that exists in your current working
            directory.</para>
-->
          <para>Vous voulez fusionner les modifications d'un fichier
            donné dans un fichier du même nom existant dans votre
            dossier de travail en cours.</para>
        </listitem>
      </itemizedlist>

<!--
      <para>If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first
        case and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a
        file by the same name) exists in your current working
        directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>
-->
      <para>Si vous fusionnez un dossier et que vous n'avez pas encore
        spécifié de cible, <command>svn merge</command> suppose qu'il
        est dans la première situation et essaie d'appliquer les
        modifications dans votre dossier en cours. Si vous fusionnez un
        fichier et que ce fichier (ou un fichier du même nom) existe
        dans votre dossier de travail en cours, <command>svn
        merge</command> suppose qu'il est dans la seconde situation et
        essaie d'appliquer les modifications au fichier local du même
        nom.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.advancedsyntax">
<!--
      <title>Merge Syntax: Full Disclosure</title>
-->
      <title>Syntaxe de la fusion&nbsp;: pour tout vous dire</title>

<!--
      <para>You've now seen some examples of the <command>svn
        merge</command> command, and you're about to see several more.
        If you're feeling confused about exactly how merging works,
        you're not alone.  Many users (especially those new to version
        control) are initially perplexed about the proper syntax of
        the command and about how and when the feature should be
        used.  But fear not, this command is actually much simpler
        than you think!  There's a very easy technique for
        understanding exactly how <command>svn merge</command>
        behaves.</para>
-->
      <para>Nous venons de voir des exemples d'utilisation de la
        commande <command>svn merge</command> et nous allons bientôt
        en voir plusieurs autres. Si vous n'avez pas bien assimilé le
        le fonctionnement des fusions, rassurez-vous, vous n'êtes pas un
        cas isolé. De nombreux utilisateurs (en particulier ceux qui
        découvrent la gestion de versions) commencent par une phase de
        perplexité au sujet de la syntaxe de la commande, ainsi que
        quand et comment utiliser cette fonctionnalité. Mais, en fait,
        cette commande est bien plus simple que vous ne le pensez&nbsp;!
        Il y a une technique très simple pour comprendre comment
        <command>svn merge</command> agit.</para>

<!--
      <para>The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that some sort of mysterious
        blending of data is going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>
-->
      <para>La raison principale de la confusion est le nom de la
        commande. Le terme <foreignphrase>merge</foreignphrase>
        (<quote>fusionner</quote> en anglais) indique en quelque
        sorte que les branches vont être combinées, ou qu'un
        mystérieux mélange des données va avoir lieu. Ce n'est pas
        le cas. Un nom plus approprié pour cette commande aurait pu
        être <quote>comparer-et-appliquer</quote>, car c'est là tout
        ce qui se passe&nbsp;: deux arborescences sont comparées et
        les différences sont appliquées à une copie de travail.</para>

<!--
      <para>If you're using <command>svn merge</command> to do basic
        copying of changes between branches, an automatic merge will
        generally do the right thing.  For example, a command such as the
        following,</para>
-->
      <para>Si vous utilisez svn merge pour effectuer de simples copies
        de modifications entre branches, elle fait généralement ce qu'il
        faut automatiquement. Par exemple, une commande telle
        que&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn merge ^/calc/branches/some-branch-->
$ svn merge ^/calc/branches/une-branche
</screen>
      </informalexample>

<!--
      <para>will attempt to duplicate any changes made
        on <filename>some-branch</filename> into your current working
        directory, which is presumably a working copy that shares some
        historical connection to the branch.  The command is smart
        enough to only duplicate changes that your working copy
        doesn't yet have.  If you repeat this command once a week, it
        will only duplicate the <quote>newest</quote> branch changes
        that happened since you last merged.</para>
-->
      <para>tente de dupliquer toutes les modifications faites
        dans <filename>une-branche</filename> vers votre répertoire
        de travail actuel, qui est sans doute une copie de travail
        partageant des liens historiques avec la branche. La commande
        est suffisamment intelligente pour ne copier que les
        modifications que votre copie de travail ne possède pas
        encore. Si vous répétez cette commande une fois par semaine,
        elle ne copie que les modifications <quote>les plus
        récentes</quote> qui ont eu lieu depuis la dernière
        fusion.</para>

<!--
      <para>If you choose to use the <command>svn merge</command>
        command in all its full glory by giving it specific revision
        ranges to duplicate, the command takes three main
        arguments:</para>
-->
      <para>Si vous choisissez d'utiliser la commande <command>svn
        merge</command> dans sa version intégrale en lui fournissant les
        groupes de révisions spécifiques à copier, la commande prend
        trois paramètres&nbsp;:</para>

      <orderedlist>
        <indexterm>
<!--
          <primary>merging</primary>
          <secondary>left side</secondary>
-->
          <primary>fusions</primary>
          <secondary>côté gauche</secondary>
        </indexterm>
        <indexterm>
<!--
          <primary>merging</primary>
          <secondary>right side</secondary>
-->
          <primary>fusions</primary>
          <secondary>côté droit</secondary>
        </indexterm>
        <indexterm>
<!--
          <primary>merging</primary>
          <secondary>target</secondary>
-->
          <primary>fusions</primary>
          <secondary>cible</secondary>
        </indexterm>

        <listitem>
<!--
          <para>An initial repository tree (often called the
            <firstterm>left side</firstterm> of the comparison)</para>
-->
          <para>une arborescence initiale (souvent appelée
            <firstterm>côté gauche</firstterm> de la
            comparaison)&nbsp;;</para>
        </listitem>
        <listitem>
<!--
          <para>A final repository tree (often called the
            <firstterm>right side</firstterm> of the
            comparison)</para>
-->
          <para>une arborescence finale (souvent appelée
            <firstterm>côté droit</firstterm> de la
            comparaison)&nbsp;;</para>
        </listitem>
        <listitem>
<!--
          <para>A working copy to accept the differences as local
            changes (often called the <firstterm>target</firstterm> of
            the merge)</para>
-->
          <para>une copie de travail qui reçoit les différences en tant
            que modifications locales (souvent appelée
            <firstterm>cible</firstterm> de la fusion).</para>
        </listitem>
      </orderedlist>

<!--
      <para>Once these three arguments are specified, then the two trees
        are compared and the differences applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>
-->
      <para>Une fois ces trois paramètres fournis, les deux
        arborescences sont comparées et les différences sont appliquées
        à la copie de travail cible en tant que modifications locales.
        Une fois que la commande s'est terminée, le résultat est le même
        que si vous aviez édité les fichiers à la main ou lancé diverses
        commandes <command>svn add</command> ou <command>svn
        delete</command> vous-même. Si le résultat vous plaît, vous
        pouvez le propager. S'il ne vous plaît pas, vous pouvez toujours
        lancer <command>svn revert</command> pour revenir en arrière sur
        toutes les modifications.</para>

<!--
      <para>The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>
-->
      <para>La syntaxe de <command>svn merge</command> est assez
        flexible quant à la façon de spécifier les trois paramètres.
        Voici quelques exemples&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk-->
$ svn merge http://svn.exemple.com/depot/branche1@150 \
             http://svn.exemple.com/depot/branche2@212 \
             ma-copie-de-travail

$ svn merge -r 100:200 http://svn.exemple.com/depot/trunk ma-copie-de-travail

$ svn merge -r 100:200 http://svn.exemple.com/depot/trunk
</screen>
      </informalexample>

<!--
      <para>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax is used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.
        <indexterm>
          <primary>merging</primary>
          <secondary>2-URL</secondary>
        </indexterm> This type of merge is referred to (for obvious
        reasons) as a <quote>2-URL</quote> merge.  The last syntax shows
        how the working copy argument is optional; if omitted, it
        defaults to the current directory.</para>
-->
      <para>La première syntaxe liste les trois arguments de façon
        explicite, spécifiant chaque arborescence sous la forme
        <emphasis>URL@REV</emphasis> et incluant la copie de travail
        cible. La deuxième syntaxe peut être utilisée comme raccourci
        pour les cas où vous comparez des révisions différentes de la
        même URL.
        <indexterm>
          <primary>fusions</primary>
          <secondary>2-URL</secondary>
        </indexterm> Ce type de fusion est appelée (pour des raisons
        évidentes) une fusion <quote>à 2-URL</quote>. La dernière
        syntaxe indique que le paramètre copie de travail est
        optionnel&nbsp;; s'il est omis, elle utilise par défaut le
        répertoire en cours.</para>

<!--
      <para>While the first example shows the <quote>full</quote>
        syntax of <command>svn merge</command>, use it
        very carefully;  it can result in merges which do not record
        any <literal>svn:mergeinfo</literal> metadata at all.  The
        next section talks a bit more about this.</para>
-->
      <para>Si le premier exemple donne la syntaxe
          <quote>complète</quote> de <command>svn merge</command>,
          celle-ci doit être utilisée avec grande prudence&nbsp;; elle
          peut en effet aboutir à des fusions qui n'enregistrent pas la
          moindre méta-donnée <literal>svn:mergeinfo</literal>. Le
          paragraphe suivant évoque ceci plus en détail.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.nomergedata">
<!--
      <title>Merges Without Mergeinfo</title>
-->
      <title>Fusions sans mergeinfo</title>

<!--
      <para>Subversion tries to generate merge metadata whenever it
        can, to make future invocations of <command>svn
        merge</command> smarter.  There are still situations, however,
        where <literal>svn:mergeinfo</literal> data is not created or
        changed.  Remember to be a bit wary of these scenarios:</para>
-->
      <para>Subversion essaie de générer des métadonnées de fusion
        dès qu'il le peut, afin de rendre plus intelligentes les
        invocations suivantes de <command>svn merge</command>.
        Néanmoins, il reste des situations où les données
        <literal>svn:mergeinfo</literal> ne sont ni créées ni modifiées.
        Pensez à être prudent avec les scénarios suivants&nbsp;:</para>

      <variablelist>
        <varlistentry>
<!--
          <term>Merging unrelated sources</term>
-->
          <term>Fusionner des sources sans lien de parenté</term>
          <listitem>
<!--
            <para>If you ask <command>svn merge</command> to compare
              two URLs that aren't related to each other, a patch is
              still generated and applied to your working copy, but
              no merging metadata is created.  There's no common
              history between the two sources, and
              future <quote>smart</quote> merges depend on that common
              history.</para>
-->
            <para>Si vous demandez à <command>svn merge</command>
              de comparer deux URLs qui n'ont pas de lien entre elles,
              un correctif est quand même généré et appliqué à votre
              copie de travail, mais aucune métadonnée de fusion n'est
              créée. Il n'y a pas d'historique commun aux deux
              sources et les futures fusions
              <quote>intelligentes</quote> dépendent de cet historique
              commun.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term>Merging from foreign repositories</term>
-->
          <term>Fusionner avec des dépôts extérieurs</term>
          <listitem>
<!--
            <para>While it's possible to run a command such
              as <userinput>svn merge -r 100:200
              <replaceable>http://svn.foreignproject.com/repos/trunk</replaceable></userinput>,
              the resultant patch also lacks any historical merge
              metadata.  At the time of this writing, Subversion has no
              way of representing different repository URLs within
              the <literal>svn:mergeinfo</literal> property.</para>
-->
            <para>Bien qu'il soit possible de lancer une commande telle
            que <userinput>svn merge -r 100:200
            <replaceable>http://svn.projetexterieur.com/depot/trunk</replaceable></userinput>,
            le correctif résultant ne comporte aucune métadonnée
            historique de fusion. À la date d'aujourd'hui, Subversion
            n'est pas capable de représenter des URL de dépôts
            différents au sein de la propriété
            <literal>svn:mergeinfo</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term>Using <option>- -ignore-ancestry</option></term>
-->
          <term>Utiliser <option>--ignore-ancestry</option></term>
          <listitem>
<!--
            <para>If this option is passed to <command>svn
              merge</command>, it causes the merging logic to
              mindlessly generate differences the same way
              that <command>svn diff</command> does, ignoring any
              historical relationships.  We discuss this later in this
              chapter in
              <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
-->
          <para>Si ce paramètre est passé à <command>svn
            merge</command>, il force la logique de fusion à générer les
            différences sans réfléchir, de la même façon que
            <command>svn diff</command> les génère, en ignorant toute
            considération historique. Nous traitons ce point plus loin
            dans ce chapitre dans <xref
            linkend="svn.branchmerge.advanced.ancestry"/>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term>Applying reverse merges from a target's natural history</term>
-->
          <term>Appliquer des fusions inversées à l'historique naturel
            de la cible</term>
          <listitem>
<!--
            <para>Earlier in this chapter
              (<xref linkend="svn.branchmerge.basicmerging.undo"/>) we
              discussed how to use <command>svn merge</command> to
              apply a <quote>reverse patch</quote> as a way of rolling
              back changes.  If this technique is used to undo a
              change to an object's personal history (e.g., commit r5
              to the trunk, then immediately roll back r5
              using <userinput>svn merge . -c -5</userinput>), this
              sort of merge doesn't affect the recorded
              mergeinfo.<footnote><para>Interestingly, after rolling
              back a revision like this, we wouldn't be able to
              reapply the revision using <userinput>svn merge . -c
              5</userinput>, since the mergeinfo would already list r5
              as being applied.  We would have to use
              the <option>- -ignore-ancestry</option> option to make
              the merge command ignore the existing
              mergeinfo!</para></footnote></para>
-->
            <para>Précédemment dans ce chapitre (dans
              <xref linkend="svn.branchmerge.basicmerging.undo"/>),
              nous avons vu comment utiliser <command>svn
              merge</command> pour appliquer un <quote>correctif
              inversé</quote>, comme moyen de revenir en arrière sur des
              modifications. Si cette technique est utilisée pour
              revenir sur une modification faite à l'historique propre
              d'un objet (par exemple, propager r5 au tronc, puis
              revenir immédiatement en arrière sur r5 en utilisant
              <userinput>svn merge . -c -5</userinput>), ce type de
              fusion ne touche pas aux informations de fusion
              (<literal>mergeinfo</literal>) enregistrées
            <footnote>
              <para>À noter qu'après être revenu en arrière sur une
                révision de cette manière, nous ne serions plus
                capables de ré-appliquer cette révision avec
                <userinput>svn merge . -c 5</userinput>, puisque
                les informations de fusion marqueraient déjà r5 comme
                ayant été appliquée. Nous serions alors obligés
                d'utiliser l'option <option>--ignore-ancestry</option>
                pour forcer la commande de fusion à ignorer le contenu
                de mergeinfo&nbsp;!</para>
            </footnote>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <!-- TODO: We might need to introduce a glossary of merge
                 tracking terms into this chapter.  Here we use
                 "mergeinfo" to help defined "natural history", but
                 we've not really defined "mergeinfo" either.  -->

      <sidebar id="svn.branchmerge.nomergedata.impicit.mergeinfo">
<!--
        <title>Natural History and Implicit Mergeinfo</title>
-->
        <title>Historique naturel et informations de fusion
          implicites</title>

<!--
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>implicit</secondary>
          </indexterm>
          <indexterm>
            <primary>natural history</primary>
            <see>mergeinfo, implicit</see>
          </indexterm>As we mentioned earlier when discussing
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>,
          a path that has the
          <literal>svn:mergeinfo</literal> property set on it is said to
          have <quote>explicit</quote> mergeinfo.  Yes, this implies a
          path can have <quote>implicit</quote> mergeinfo, too!  Implicit
          mergeinfo, or <firstterm>natural history</firstterm>, is
          simply a path's own history (see
          <xref linkend="svn.tour.history" />) interpreted as mergeinfo.
          While implicit mergeinfo is largely
          an implementation detail, it can be a useful abstraction for
          understanding merge tracking behavior.</para>
-->
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>implicite</secondary>
          </indexterm>
          <indexterm>
            <primary>historique naturel</primary>
            <see>mergeinfo, implicite</see>
          </indexterm>Comme nous l'avons indiqué dans
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>,
          un chemin qui possède une propriété
          <literal>svn:mergeinfo</literal> définie est réputé avoir des
          informations de fusion (mergeinfo)
          <quote>explicites</quote>. Le lecteur attentif en déduit
          rapidement qu'un chemin peut avoir des mergeinfo
          <quote>implicites</quote>. Ces informations de fusion
          implicites, ou <firstterm>historique naturel</firstterm>,
          correspondent simplement au propre historique (voir
          <xref linkend="svn.tour.history" />) du chemin, du point de
          vue des fusions. Bien que n'étant que des détails
          d'implémentation, ces mergeinfos implicites peuvent s'avérer
          très utiles pour se représenter la façon dont ont lieu les
          fusions.</para>

<!--
        <para>Let's say you created <filename>^/trunk</filename> in
          revision 100 and then later, in revision 201,
          created <filename>^/branches/feature-branch</filename> as
          a copy of <filename>^/trunk@200</filename>.  The natural
          history of <filename>^/branches/feature-branch</filename>
          contains all the repository paths and revision ranges
          through which the history of the new branch has ever
          passed:</para>
-->
        <para>Supposons que vous avez créé à la révision 100 le fichier
          <filename>^/trunk</filename> et que, plus tard, à la révision
          201 vous avez créé
          <filename>^/branches/nouvelle-branche</filename> en tant que
          copie de <filename>^/trunk@200</filename>. L'historique
          naturel de <filename>^/branches/nouvelle-branche</filename>
          contient tous les chemins et les intervalles de révisions du
          dépôt par lesquels l'historique de la nouvelle branche est
          passé.</para>

        <informalexample>
          <literallayout>
/trunk:100-200<!--
/branches/feature-branch:201-->
/branches/nouvelle-branche:201
</literallayout>
        </informalexample>

<!--
        <para>With each new revision added to the repository, the
          natural history&mdash;and thus, implicit mergeinfo&mdash;of
          the branch continues to expand to include those revisions
          until the day the branch is deleted.  Here's what the
          implicit mergeinfo of our branch would look like when
          the <literal>HEAD</literal> revision of the repository had
          grown to 234:</para>
-->
        <para>À chaque nouvelle révision ajoutée au dépôt, l'historique
          naturel (et donc les informations de fusion implicites) de la
          branche continue de grandir pour inclure ces révisions
          jusqu'au jour où la révision est supprimée. Voici ce à quoi
          ressemblent les informations de fusion implicites de notre
          branche quand la révision <literal>HEAD</literal> du dépôt
          vaut 234&nbsp;:</para>

        <informalexample>
          <literallayout>
/trunk:100-200<!--
/branches/feature-branch:201-234-->
/branches/nouvelle-branche:201-234
</literallayout>
        </informalexample>

<!--
        <para>Implicit mergeinfo does not actually show up in the
          <literal>svn:mergeinfo</literal> property, but Subversion
          acts as if it does.  This is why if you check out
          <filename>^/branches/feature-branch</filename> and then
          run <userinput>svn merge ^/trunk -c 58</userinput> in the
          resulting working copy, nothing happens.  Subversion knows
          that the changes committed to <filename>^/trunk</filename>
          in revision 58 are already present in the target's natural
          history, so there's no need to try to merge them again.
          After all, avoiding repeated merges of
          changes <emphasis>is</emphasis> the primary goal of
          Subversion's merge tracking feature!</para>
-->
        <para>Les informations de fusion implicites ne sont pas
          concrètement contenues dans la propriété
          <literal>svn:mergeinfo</literal>, mais Subversion se comporte
          comme si elles l'étaient. C'est pourquoi lorsque vous faites
          une extraction de
          <filename>^/branches/nouvelle-branche</filename> et que vous
          lancez <userinput>svn merge ^/trunk -c 58</userinput> dans la
          copie de travail correspondante, rien ne se passe. Subversion
          sait que les changements propagés dans la révision 58 sont
          déjà présents dans l'historique naturel de la cible, il n'y a
          donc aucune raison d'essayer de les fusionner à nouveau. Après
          tout, éviter de fusionner plusieurs fois les modifications
          <emphasis>est</emphasis>, pour Subversion, le but premier de
          l'existence  de la fonctionnalité de traçage des
          fusions&nbsp;!</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.mergeconflicts">
<!--
      <title>More on Merge Conflicts</title>
-->
      <title>Plus de détails sur les conflits liés aux fusions</title>

<!--
      <para>Just like the <command>svn update</command> command,
        <command>svn merge</command> applies changes to your working
        copy.  And therefore it's also capable of creating
        conflicts.  The conflicts produced by <command>svn
          merge</command>, however, are sometimes different, and this
        section explains those differences.</para>
-->
      <para>Tout comme la commande <command>svn update</command>,
        <command>svn merge</command> applique les modifications à votre
        copie de travail. Elle est donc aussi susceptible de créer des
        conflits. Cependant, les conflits engendrés par <command>svn
        merge</command> sont parfois différents et ce paragraphe va
        expliquer ces différences.</para>

<!--
      <para>To begin with, assume that your working copy has no
        local edits.  When you <command>svn update</command> to a
        particular revision, the changes sent by the server
        always apply <quote>cleanly</quote> to your working copy.
        The server produces the delta by comparing two trees: a
        virtual snapshot of your working copy, and the revision tree
        you're interested in.  Because the left hand side of the
        comparison is exactly equal to what you already have, the
        delta is guaranteed to correctly convert your working copy
        into the right hand tree.</para>
-->
      <para>Pour commencer, supposons que votre copie de travail n'a
        pas de modification locale en cours. Quand vous lancez
        <command>svn update</command> pour la mettre à jour à une
        révision particulière, les modifications envoyées par le
        serveur s'appliquent toujours <quote>proprement</quote>
        à votre copie de travail. Le serveur génère le delta en
        comparant deux arborescences&nbsp;: d'une part un
        instantané virtuel de votre copie de travail, d'autre part
        l'arborescence de la révision qui vous intéresse. Parce que
        la partie gauche de la comparaison est parfaitement égale à
        ce que vous avez déjà, il est garanti que le delta va
        convertir correctement votre copie de travail en
        l'arborescence de droite.</para>

<!--
      <para>But <command>svn merge</command> has no such guarantees
        and can be much more chaotic: the advanced user can ask the
        server to compare <emphasis>any</emphasis> two trees at all,
        even ones that are unrelated to the working copy!  This means
        there's large potential for human error.  Users will sometimes
        compare the wrong two trees, creating a delta that doesn't
        apply cleanly. The <command>svn merge</command> subcommand does
        its best to apply as much of the delta as possible, but some
        parts may be impossible. A common sign that you merged the wrong
        delta is unexpected tree conflicts:</para>
-->
      <para>Mais <command>svn merge</command> ne dispose pas de telles
        garanties et peut être bien plus chaotique&nbsp;: l'utilisateur
        avancé peut demander au serveur de comparer <emphasis>n'importe
        quelle</emphasis> paire d'arborescences, même des arborescences
        n'ayant aucun rapport avec la copie de travail&nbsp;! Cela
        laisse potentiellement beaucoup de place à l'erreur humaine. Les
        utilisateurs vont parfois comparer deux arborescences qui ne
        sont pas les bonnes, créant ainsi un delta qui ne s'appliquera
        pas proprement. La sous-commande <command>svn merge</command>
        fera de son mieux pour appliquer la plus grande partie possible
        du delta, mais ça risque d'être impossible pour certains
        morceaux. Un conflit d'arborescences inattendu est un bon indice
        pour détecter que vous avez fusionné un  mauvais
        delta&nbsp;</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk -r104:115<!--
- - Merging r105 through r115 into '.':
-->
--- Fusion de r105 à r115 dans '.' :
   C doc<!--
   C src/button.c
   C src/integer.c
   C src/real.c
   C src/main.c
- - Recording mergeinfo for merge of r105 through r115 into '.':-->
   C src/bouton.c
   C src/entier.c
   C src/reel.c
   C src/main.c
-- Stockage des informations de fusion (mergeinfo) de r105 à r115 dans '.' :
 U   .  <!--
Summary of conflicts:
  Tree conflicts: 3
-->
Résumé des conflits :
  Arborescences en conflit : 3

$ svn st
 M      .
!     C doc<!--
      >   local dir missing, incoming dir edit upon merge
!     C src/button.c
      >   local file missing, incoming file edit upon merge
!     C src/integer.c
      >   local file missing, incoming file edit upon merge
!     C src/main.c
      >   local file missing, incoming file edit upon merge
!     C src/real.c
      >   local file missing, incoming file edit upon merge
Summary of conflicts:
  Tree conflicts: 5-->
      >   local dir missing, incoming dir edit upon merge
!     C src/button.c
      >   local file missing, incoming file edit upon merge
!     C src/integer.c
      >   local file missing, incoming file edit upon merge
!     C src/main.c
      >   local file missing, incoming file edit upon merge
!     C src/real.c
      >   local file missing, incoming file edit upon merge
Résumé des conflits :
  Arborescences en conflit : 5
</screen>
      </informalexample>

<!--
      <para>In the previous example, it might be the case that
        <filename>doc</filename> and the four <filename>*.c</filename>
        files all exist in both snapshots of the
        branch being compared.  The resultant delta wants to change
        the contents of the corresponding paths in your working copy,
        but those paths don't exist in the working copy.  Whatever the
        case, the preponderance of tree conflicts most likely means that
        the user compared the wrong two trees or that you are merging to
        the wrong working copy target; both are classic signs of user
        error.  When this happens, it's easy to recursively revert all
        the changes created by the merge
        (<userinput>svn revert . - -recursive</userinput>), delete any
        unversioned files or directories left behind after the
        revert, and rerun <command>svn merge</command> with the
        correct arguments.</para>
-->
      <para>Dans l'exemple précédent, il est possible que
        <filename>doc</filename> et les quatre fichiers
        <filename>*.c</filename> existent dans les deux instantanés
        de la branche en question. Le delta résultant tente de modifier
        le contenu des fichiers dans votre copie de travail mais ces
        fichiers n'existent pas dans la copie de travail. Quoi qu'il en
        soit, un nombre élevé de conflits d'arborescences signifie
        généralement que l'utilisateur compare les mauvaises
        arborescences ou qu'il essaie de fusionner vers une mauvaise
        copie de travail&nbsp;; c'est le signe classique d'une erreur
        de l'utilisateur. Quand ça arrive, il est facile de revenir
        en arrière de manière récursive sur toutes les modifications
        créées par la fusion
        (<userinput>svn revert . --recursive</userinput>), d'effacer
        tout fichier ou dossier non suivi en versions restant après le
        retour en arrière et de relancer <command>svn merge</command>
        avec des paramètres différents.</para>

<!--
      <para>Also keep in mind that a merge into a working copy with no
        local edits can still produce text conflicts.</para>
-->
      <para>Soyez aussi conscient qu'une fusion dans une copie de
        travail sans modification locale peut produire également des
        conflits textuels.</para>

      <informalexample>
        <screen>
$ svn st

$ svn merge ^/paint/trunk -r289:291<!--
- - Merging r290 through r291 into '.':
-->
--- Fusion de r290 à r291 dans '.' :
C    Makefile<!--
- - Recording mergeinfo for merge of r290 through r291 into '.':
-->
-- Stockage des informations de fusion (mergeinfo) de r290 à r291 dans '.' :
 U   .  <!--
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'Makefile'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: p
-->
Résumé des conflits :
  Text conflicts: 1
Conflit découvert dans le fichier 'Makefile'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: p
$ svn st
 M      .
C       Makefile
?       Makefile.merge-left.r289
?       Makefile.merge-right.r291
?       Makefile.working<!--
Summary of conflicts:
  Text conflicts: 2
-->
Résumé des conflits :
  Text conflicts: 2
</screen>
      </informalexample>

<!--
      <para>How can a conflict possibly happen?  Again, because the user
        can request <command>svn merge</command> to define and apply any
        old delta to the working copy, that delta may contain textual
        changes that don't cleanly apply to a working file, even if
        the file has no local modifications.</para>
-->
      <para>Comment un conflit peut-il se produire&nbsp;? Encore une
        fois, parce que l'utilisateur peut demander à <command>svn
        merge</command> de calculer et appliquer n'importe quel vieux
        delta sur la copie de travail, ce delta pouvant contenir des
        modifications textuelles qui ne s'appliquent pas proprement à
        un fichier de la copie de travail, même si ce fichier ne
        comporte aucune modification locale.</para>

<!--
      <para>Another small difference between <command>svn
        update</command> and <command>svn merge</command> is the names
        of the full-text files created when a conflict happens.  In
        <xref linkend="svn.tour.cycle.resolve"/>, we saw that an
        update produces files named
        <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename>, and
        <filename>filename.rNEWREV</filename>.  When <command>svn
        merge</command> produces a conflict, though, it creates three
        files named <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename>, and
        <filename>filename.merge-right.rNEWREV</filename>.  In this case,
        the terms <quote>merge-left</quote> and <quote>merge-right</quote>
        are describing which side of the double-tree comparison the file
        came from, <quote>rOLDREV</quote> describes the revision of the
        left side, and <quote>rNEWREV</quote> the revision of the right
        side. In any case, these differing names help you distinguish
        between conflicts that happened as a result of an  update and
        ones that happened as a result of a merge.</para>
-->
      <para>Une autre petite différence entre <command>svn
        update</command> et <command>svn merge</command> réside dans le
        nom des fichiers textuels créés lorsqu'un conflit survient. Dans
        <xref linkend="svn.tour.cycle.resolve"/>, nous avons vu qu'une
        mise à jour produit des fichiers nommés
        <filename>nom_du_fichier.mine</filename>,
        <filename>nom_du_fichier.rANCIENNE_REV</filename> et
        <filename>nom_du_fichier.rNOUVELLE_REV</filename>. Quand
        <command>svn merge</command> génère un conflit,
        elle crée trois fichiers dont les noms sont
        <filename>nom_du_fichier.working</filename>,
        <filename>nom_du_fichier.merge-left.rANCIENNE_REV</filename> et
        <filename>nom_du_fichier.merge-right.rNOUVELLE_REV</filename>.
        Dans ce cas, les termes  <quote>merge-left</quote>
        (fusion-gauche en anglais) et <quote>merge-right</quote>
        (fusion-droite en anglais) indiquent de quel côté de la
        comparaison d'arborescences provient le fichier en
        question&nbsp;;
        <quote>rANCIENNE_REV</quote> indique la révision du côté gauche
        et <quote>rNOUVELLE_REV</quote> indique la révision du côté
        droit. Dans tous les cas, ces noms différenciés vous aident à
        distinguer les conflits qui résultent d'une mise à jour de ceux
        qui résultent d'une fusion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.blockchanges">
<!--
      <title>Blocking Changes</title>
-->
      <title>Blocage de modifications</title>

<!--
      <para>Sometimes there's a particular changeset that you don't
        want automatically merged.  For example, perhaps your
        team's policy is to do new development work on
        <filename>/trunk</filename>, but is more conservative about
        backporting changes to a stable branch you use for releasing
        to the public.  On one extreme, you can manually cherrypick
        single changesets from the trunk to the branch&mdash;just the
        changes that are stable enough to pass muster.  Maybe things
        aren't quite that strict, though; perhaps most of the time
        you just let <command>svn merge</command>
        automatically merge most changes from trunk to branch.  In
        this case, you want a way to mask a few specific changes
        out, that is, prevent them from ever being automatically
        merged.</para>
-->
      <para>Il peut parfois y avoir un ensemble de modifications
        particulier dont vous ne voulez pas qu'il soit fusionné
        automatiquement. Par exemple, peut–être que l'habitude dans
        votre équipe est d'effectuer tout nouveau travail de
        développement dans <filename>/trunk</filename>, mais d'être
        plus conservateur en ce qui concerne le rétroportage des
        modifications vers une branche stable que vous utilisez
        pour la publication. À l'extrême, vous pouvez sélectionner
        à la main des ensembles de modifications individuels du tronc
        à porter vers la branche&nbsp;: juste les changements qui
        sont suffisamment stables pour être acceptables. Peut-être
        que les choses ne sont pas aussi strictes après tout&nbsp;;
        peut-être que la plupart du temps vous aimeriez juste laisser
        <command>svn merge</command> fusionner automatiquement la
        plupart des modifications du tronc vers la branche. Dans ce
        cas, il vous faudrait une façon de masquer quelques
        modifications particulières, c'est-à-dire d'empêcher qu'elles
        ne soient fusionnées automatiquement.</para>

<!--
      <para>To block a changeset you must make Subversion believe that the
        change has <emphasis>already</emphasis> been merged.  To do this,
        invoke the merge subcommand with the <option>- -record-only</option>
        option.  The option makes Subversion record mergeinfo as if it had
        actually performed the merge, but no difference is actually
        applied:</para>
-->
      <para>Pour bloquer une liste de modifications, vous devez faire
        croire à Subversion que la modification a déjà été fusionnée.
        Pour cela, il est possible de lancer la sous-commande de fusion
        avec l'option <option>--record-only</option>. Cette option
        demande à Subversion d'enregistrer les informations de fusion
        comme s'il avait réellement effectué la fusion, mais aucun
        changement n'est effectivement appliqué&nbsp;:</para>

      <informalexample>
        <screen><!--
$ cd my-calc-branch-->
$ cd ma-branche-calc

$ svn merge ^/calc/trunk -r386:388 --record-only <!--
- - Recording mergeinfo for merge of r387 through r388 into '.':
-->
--- Stockage des informations de fusion (mergeinfo) de r387 à r388 dans '.' :
 U   .
 <!--
Only the mergeinfo is changed-->
# Seules les informations de fusion sont modifiées.
$ svn st
 M      .

$ svn pg svn:mergeinfo -vR<!--
Properties on '.':-->
Propriétés sur '.' :
  svn:mergeinfo
    /calc/trunk:341-378,387-388

<!--
$ svn commit -m "Block r387-388 from being merged to my-calc-branch."
Sending        .

Committed revision 461.-->
$ svn commit -m "Bloque r387-388 vis-à-vis d'une fusion vers ma-branche-calc."
Envoi              .

Révision 461 propagée.
</screen>
      </informalexample>

<!--
      <para>Since Subversion 1.7, <option>- -record-only</option>
        merges are transitive.  This means that, in addition to recording
        mergeinfo describing the blocked revision(s), any
        <literal>svn:mergeinfo</literal> property differences in the
        merge source are also applied.  For example, let's say we want to
        block the 'paint-python-wrapper' feature from ever being merged from
        <filename>^/paint/trunk</filename> to the
        <filename>^/paint/branches/paint-1.0.x</filename> branch.  We know
        the work on this feature was done on its own branch, which was
        reintegrated to <filename>/paint/trunk</filename> in revision
        465:</para>
-->
      <para>Depuis Subversion 1.7, les fusions avec
        <option>--record-only</option> sont transitives. Cela veut dire
        que, en plus d'enregistrer les informations de fusion décrivant
        la ou les révisions bloquées, toute modification de la
        propriété <literal>svn:mergeinfo</literal> dans la source de la
        fusion est aussi appliquée. Par exemple, supposons que nous
        voulions bloquer la fonctionnalité "paint-python-wrapper" d'être
        fusionnée depuis <filename>^/paint/trunk</filename> vers la
        branche <filename>^/paint/branches/paint-1.0.x</filename>. Nous
        savons que le travail sur cette fonctionnalité a été effectué
        dans sa propre branche, qui a été réintégrée dans
        <filename>/paint/trunk</filename> au moment de la révision
        465&nbsp;:</para>

      <informalexample>
        <screen>
$ svn log -v -r465 ^/paint/trunk
------------------------------------------------------------------------<!--
r465 | joe | 2013-02-25 14:05:12 -0500 (Mon, 25 fév. 2013) | 1 line
Changed paths:
   M /paint/trunk
   A /paint/trunk/python (from /paint/branches/paint-python-wrapper/python:464)

Reintegrate Paint Python wrapper.
-->
r465 | joe | 2013-02-25 14:05:12 -0500 (lun. 25 fév. 2013) | 1 ligne
Chemins modifiés :
   M /paint/trunk
   A /paint/trunk/python (de /paint/branches/paint-python-wrapper/python:464)

Réintégration de Paint Python Wrapper.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Because revision 465 was a reintegrate merge we know
        that mergeinfo was recorded describing the merge:</para>
-->
      <para>Comme la révision 465 était une fusion de réintégration,
        nous savons que les informations de fusion ont été enregistrées
        pour décrire cette fusion&nbsp;:</para>

      <informalexample>
        <screen>
$ svn diff ^/paint/trunk --depth empty -c465
Index: .
===================================================================
--- .   (revision 464)
+++ .   (revision 465)
<!--
Property changes on: .
-->
Modification de propriétés sur .
___________________________________________________________________ <!--
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
-->
Added: svn:mergeinfo
   Fusionné /paint/branches/paint-python-wrapper:r463-464
</screen>
      </informalexample>

<!--
      <para>Now simply blocking merges of revision 465 from
        <filename>/paint/trunk</filename> isn't foolproof since someone could
        merge r462:464 directly from
        <filename>/paint/branches/paint-python-wrapper</filename>.
        Fortunately the transitive nature
        of <option>- -record-only</option> merges prevents this; the
        <option>- -record-only</option> merge
        applies the <literal>svn:mergeinfo</literal> diff from
        revision 465, thus blocking merges of that change directly from
        <filename>/paint/trunk</filename> <emphasis>and</emphasis> indirectly
        from <filename>/paint/branches/paint-python-wrapper</filename>:
        </para>
-->
      <para>Maintenant, simplement bloquer les fusions de la révision
        465 de <filename>/paint/trunk</filename> n'est pas suffisant car
        quelqu'un pourrait fusionner r462:464 directement depuis
        <filename>/paint/branches/paint-python-wrapper</filename>.
        Heureusement, grace à la transitivité de
        <option>--record-only</option>, les fusions seront interdites.
        La fusion <option>--record-only</option> applique le delta
        calculé à partir de <literal>svn:mergeinfo</literal> à la
        révision 465, bloquant par conséquent les fusions de cette
        modification directement depuis
        <filename>/paint/trunk</filename>  <emphasis>et</emphasis>
        indirectement depuis
        <filename>/paint/branches/paint-python-wrapper</filename>&nbsp;:
        </para>

      <informalexample>
        <screen>
$ cd paint/branches/paint-1.0.x

$ svn merge ^/paint/trunk --record-only -c465<!--
- - Merging r465 into '.':
-->
--- Fusion de r465 dans '.' :
 U   .  <!--
- - Recording mergeinfo for merge of r465 into '.':
-->
--- Stockage des informations de fusion (mergeinfo) de r465 dans '.' :
 G   .

$ svn diff --depth empty
Index: .
===================================================================<!--
- - .   (revision 462)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
   Merged /paint/trunk:r465
-->
--- .   (révision 462)
+++ .   (copie de travail)

Modification de propriétés sur  .
___________________________________________________________________
Added: svn:mergeinfo
   Fusionné /paint/branches/paint-python-wrapper:r463-464
   Fusionné /paint/trunk:r465
<!--
$ svn ci -m "Block the Python wrappers from the first release of paint."
Sending        .

Committed revision 466.
-->
$ svn ci -m "Blocage du wrapper Python dans la version 1.0 de paint."
Envoi           .

Révision 466 propagée.
</screen>
      </informalexample>

<!--
      <para>Now any subsequent attempts to merge the feature to <filename>
        /paint/trunk</filename> are inoperative:</para>
-->
      <para>Maintenant, toute tentative de fusionner la fonctionnalité
        vers <filename>/paint/trunk</filename> est
        inopérante&nbsp;:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465<!--
- - Recording mergeinfo for merge of r465 into '.':-->
--- Stockage des informations de fusion (mergeinfo) de r456 dans '.' :
 U   .
<!--
$ svn st # No change!
-->
$ svn st # Rien n'a changé !

$ svn merge ^/paint/branches/paint-python-wrapper -r462:464<!--
- - Recording mergeinfo for merge of r463 through r464 into '.':-->
---  Stockage des informations de fusion (mergeinfo) de r463 bis r464 in '.' :
 U   .
<!--
$ svn st  # No change!
-->
$ svn st # Rien n'a changé !
$
</screen>
      </informalexample>

<!--
      <para>If at a later time you realize that you actually <emphasis>do
        </emphasis> need the blocked feature merged to <filename>/paint/trunk
        </filename> you have a couple of choices.  You can reverse merge r466,
        (the revision you blocked the feature), as we discussed in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.  Once you commit
        that change you can repeat the merge of r465 from <filename>
        /paint/trunk</filename>.  Alternatively, you can simply repeat the
        merge of r465 from <filename>/paint/trunk</filename> using the
        <option>- -ignore-ancestry</option> option, which will cause the merge
        to disregard any mergeinfo and simply apply the requested diff, see
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
-->
      <para>Si, plus tard, vous vous rendez compte que vous avez besoin
        de fusionner la fonctionnalité bloquée vers
        <filename>/paint/trunk </filename>, vous avez deux possibilités.
        Vous pouvez rejouer à l'envers la fusion r466 (la révision dans
        laquelle vous avez bloqué la fonctionnalité), comme cela a été
        montré dans <xref linkend="svn.branchmerge.basicmerging.undo"/>.
        Une fois que vous avez propagé cette modification, vous pouvez
        recommencer la fusion de r465 de
        <filename>/paint/trunk</filename>. L'autre façon, vous pouvez
        simplement rejouer la fusion de r465 depuis
        <filename>/paint/trunk</filename> avec l'option
        <option>--ignore-ancestry</option>. Cela forcera la fusion à
        ignorer les informations contenues dans mergeinfo et appliquera
        simplement les changements demandés, comme indiqué dans
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465 --ignore-ancestry<!--
- - Merging r465 into '.':-->
--- Fusion de r465 in '.' :
A    python
A    python/paint.py
 G   .
</screen>
      </informalexample>

<!--
      <para>Blocking changes with <option>- -record-only</option>
        works, but it's also a little bit
        dangerous.  The main problem is that we're not clearly
        differentiating between the ideas of <quote>I already have
        this change</quote> and <quote>I don't have this change, but
        don't currently want it.</quote> We're effectively lying to
        the system, making it think that the change was previously
        merged.  This puts the responsibility on you&mdash;the
        user&mdash;to remember that the change wasn't actually merged,
        it just wasn't wanted.  There's no way to ask Subversion for a
        list of <quote>blocked changelists.</quote> If you want to
        track them (so that you can unblock them someday) you'll need
        to record them in a text file somewhere, or perhaps in an
        invented property.</para>
-->
      <para>Bloquer des modifications avec l'option
        <option>--record-only</option> fonctionne, mais cela peut
        s'avérer dangereux.Le problème principal est que nous ne faisons
        pas clairement la différence entre
        <quote>J'ai déjà cette modification</quote> et
        <quote>Je n'ai pas cette modification, mais je n'en veux pas
        pour le moment.</quote>. En fait, nous mentons au système, en
        lui faisant croire que la modification a déjà été fusionnée. Ce
        qui transfère vers vous, l'utilisateur, la responsabilité de
        vous rappeler que la modification n'a en fait pas été fusionnée,
        qu'elle n'était tout simplement pas voulue. Il n'y a pas moyen
        de demander à Subversion la liste des <quote>listes des
        modifications bloquées</quote>. Si vous voulez en conserver la
        trace (afin de pouvoir les débloquer un jour), vous devrez les
        consigner dans un fichier texte quelque part, ou peut-être
        dans une propriété inventée de toutes pièces pour
        l'occasion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.logblame">
<!--
      <title>Merge-Sensitive Logs and Annotations</title>
-->
      <title>Historiques et annotations tenant compte des fusions
        passées</title>

<!--
      <para>One of the main features of any version control system is
        to keep track of who changed what, and when they did it.
        The <command>svn log</command> and <command>svn
        blame</command> subcommands are just the tools for this: when
        invoked on individual files, they show not only the history of
        changesets that affected the file, but also exactly which user
        wrote which line of code, and when she did it.</para>
-->
      <para>Une des fonctionnalités principales de tout système de
        gestion de versions est de conserver la trace de qui a modifié
        quoi et quand ils l'ont fait. Les sous-commandes <command>svn
        log</command> et <command>svn blame</command> sont les outils
        adaptés pour cela&nbsp;: quand on les applique à des fichiers
        individuels, ils renvoient non seulement l'historique des
        ensembles de modifications qui ont touché le fichier, mais aussi
        exactement quel utilisateur a écrit quelle ligne de code et
        quand il l'a fait.</para>

<!--
      <para>When changes start getting replicated between branches,
        however, things start to get complicated.  For example, if you
        were to ask <command>svn log</command> about the history of
        your feature branch, it would show exactly every revision that ever
        affected the branch:</para>
-->
      <para>Cependant, quand des modifications commencent à être
        copiées entre des branches, les choses se compliquent. Par
        exemple, si vous interrogiez <command>svn log</command> sur
        l'historique de votre branche fonctionnelle, elle renverrait
        exactement toutes les révisions qui ont touché cette
        branche&nbsp;:</para>

<!--
      <informalexample>
        <screen>
$ cd my-calc-branch
$ svn log -q
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r461 | user | 2013-02-25 05:57:48 -0500 (Mon, 25 fév. 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r379 | user | 2013-02-18 10:56:35 -0500 (Mon, 18 fév. 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r378 | user | 2013-02-18 09:48:28 -0500 (Mon, 18 fév. 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&hellip;
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r7 | bill | 2013-01-17 16:49:36 -0500 (Thu, 17 Jan 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r3 | bill | 2013-01-17 09:07:04 -0500 (Thu, 17 Jan 2013)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</screen>
      </informalexample>
-->
      <informalexample>
        <screen>
$ cd ma-branche-calc

$ svn log -q
------------------------------------------------------------------------
r461 | utilisateur | 2013-02-25 05:57:48 -0500 (lun. 25 fév. 2013)
------------------------------------------------------------------------
r379 | utilisateur | 2013-02-18 10:56:35 -0500 (lun. 18 fév. 2013)
------------------------------------------------------------------------
r378 | utilisateur | 2013-02-18 09:48:28 -0500 (lun. 18 fév. 2013)
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (jeu. 17 janv. 2013)
------------------------------------------------------------------------
r7 | bill | 2013-01-17 16:49:36 -0500 (jeu. 17 janv. 2013)
------------------------------------------------------------------------
r3 | bill | 2013-01-17 09:07:04 -0500 (jeu. 17 janv. 2013)
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>But is this really an accurate picture of all the changes
        that happened on the branch?  What's left out here is
        the fact that revisions 352, 362, 372 and 379 were actually the
        results of merging changes from the trunk.  If you look at one
        of these logs in detail, the multiple trunk changesets that
        comprised the branch change are nowhere to be seen:</para>
-->
      <para>Mais est-ce bien là une description adéquate de tous les
        changements qui ont eu lieu sur cette branche&nbsp;? Ce qui
        manque ici, c'est le fait que les révisions 352, 362, 372 et 379
        résultaient en fait de fusions en provenance du tronc. Si vous
        regardez plus en détail l'historique d'une de ces révisions,
        vous ne verrez nulle part les multiples ensembles de
        modifications du tronc qui ont été reportés sur la
        branche&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn log ^/calc/branches/my-calc-branch -r352 -v-->
$ svn log ^/calc/branches/ma-branche-calc -r352 -v
------------------------------------------------------------------------ <!--
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 fév. 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
-->
r352 | utilisateur | 2013-02-16 09:35:18 -0500 (sam. 16 fév. 2013) | 1 ligne
Chemins modifiés :
   M /calc/branches/ma-branche-calc
   M /calc/branches/ma-branche-calc/Makefile
   M /calc/branches/ma-branche-calc/doc/INSTALL
   M /calc/branches/ma-branche-calc/src/bouton.c
   M /calc/branches/ma-branche-calc/src/reel.c

Synchronisation des dernières modifications du tronc dans ma-branche-calc.
</screen>
      </informalexample>

<!--
      <para>We happen to know that this merge to the branch was
        nothing but a merge of trunk changes.  How can we see those
        trunk changes as well?  The answer is to use the
        <option>- -use-merge-history</option> (<option>-g</option>)
        option.  This option expands those <quote>child</quote>
        changes that were part of the merge.</para>
-->
      <para>Il se trouve que nous savons que cette fusion vers la
        branche n'était qu'une fusion de modifications du tronc.
        Comment pouvons-nous également voir ces modifications du
        tronc&nbsp;? La réponse est d'utiliser l'option
        <option>--use-merge-history</option> (<option>-g</option>).
        Cette option donne le détail des modifications
        <quote>filles</quote> qui faisaient partie de la fusion.</para>

      <informalexample>
        <screen><!--
$ svn log ^/calc/branches/my-calc-branch -r352 -v -g-->
$ svn log ^/calc/branches/my-calc-branch -r352 -v -g
------------------------------------------------------------------------ <!--
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 fév. 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
-->
r352 | utilisateur | 2013-02-16 09:35:18 -0500 (sam. 16 fév. 2013) | 1 ligne
Chemins modifiés :
   M /calc/branches/ma-branche-calc
   M /calc/branches/ma-branche-calc/Makefile
   M /calc/branches/ma-branche-calc/doc/INSTALL
   M /calc/branches/ma-branche-calc/src/bouton.c
   M /calc/branches/ma-branche-calc/src/reel.c

Synchronisation des dernières modifications du tronc dans ma-branche-calc.
------------------------------------------------------------------------ <!--
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 fév. 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/real.c
Merged via: r352

Trunk work on calc project.
-->
r351 | sally | 2013-02-16 08:04:22 -0500 (sam. 16 fév. 2013) | 2 lignes
Chemins modifiés :
   M /calc/trunk/src/real.c
Fusion via : r352

Travail sur le tronc du projet calc.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------ <!--
r345 | sally | 2013-02-15 16:51:17 -0500 (Fri, 15 fév. 2013) | 2 lines
Changed paths:
   M /calc/trunk/Makefile
   M /calc/trunk/src/integer.c
Merged via: r352

Trunk work on calc project.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 fév. 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c
Merged via: r352

Refactor the bazzle functions.-->
r345 | sally | 2013-02-15 16:51:17 -0500 (ven. 15 fév. 2013) | 2 lignes
Chemins modifiés :
   M /calc/trunk/Makefile
   M /calc/trunk/src/entier.c
Fusion via : r352

Travail sur le tronc du projet calc.
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (ven. 15 fév. 2013) | 1 ligne
Chemins modifiés :
   M /calc/trunk/src/entier.c
Fusion via : r352

Réusinage des fonctions trucmuches.
</screen>
      </informalexample>

<!--
      <para>By making the log operation use merge history, we see not
        just the revision we queried (r352), but also the other revisions
        that came along on the ride with it&mdash;Sally's work on trunk.
        This is a much more complete picture of history!</para>
-->
      <para>En forçant l'opération <command>svn log</command> à
        utiliser l'historique des fusions, nous obtenons non seulement
        la révision que nous avions demandé (r352), mais aussi les deux
        révisions qui l'accompagnaient &mdash; deux modifications du
        tronc faites par Sally. C'est une image bien plus complète
        de l'historique&nbsp;!</para>

<!--
      <para>The <command>svn blame</command> command also takes the
        <option>- -use-merge-history</option> (<option>-g</option>)
        option.  If this option is neglected, somebody looking at
        a line-by-line annotation of <filename>src/button.c</filename> may
        get the mistaken impression that you were responsible for a
        particular change:</para>
-->
      <para>La commande <command>svn blame</command> accepte également
        l'option <option>--use-merge-history</option>
        (<option>-g</option>). Si cette option est omise, quelqu'un
        qui regarderait un relevé annoté ligne par ligne pour
        <filename>bouton.c</filename> risquerait d'avoir l'impression
        erronée que vous êtes responsable des lignes qui ont corrigé
        une certaine erreur&nbsp;:</para>

      <informalexample>
        <screen>
$ svn blame src/button.c
&hellip;<!--
   352    user    retval = inverse_func(button, path);
   352    user    return retval;
   352    user    }-->
   352    utilisateur  retval = inverse_func(button, path);
   352    utilisateur  return retval;
   352    utilisateur  }
&hellip;
</screen>
      </informalexample>

<!--
      <para>And while it's true that you did actually commit those
        three lines in revision 352, two of them were actually written
        by Sally back in revision 348 and were brought into your branch
        via a sync merge:</para>
-->
      <para>Et bien qu'il soit vrai que vous avez propagé ces trois
        lignes lors de la révision 352, deux d'entre elles ont en fait
        été écrites par Sally auparavant, en révision 348, et ont été
        injectées dans votre branche lors d'une fusion de
        synchronisation&nbsp;:</para>

      <informalexample>
        <screen>
$ svn blame button.c -g
&hellip;<!--
G    348    sally   retval = inverse_func(button, path);
G    348    sally   return retval;
     352    user    }-->
G    348    sally        retval = inverse_func(button, path);
G    348    sally        return retval;
     352    utilisateur  }
&hellip;
</screen>
      </informalexample>

<!--
      <para>Now we know who to <emphasis>really</emphasis> blame for
        those two lines of code!</para>
-->
      <para>À présent, nous savons qui doit
        <emphasis>réellement</emphasis> être tenu responsable pour ces
        deux lignes de code&nbsp;!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.ancestry">
<!--
      <title>Noticing or Ignoring Ancestry</title>
-->
      <title>Prise en compte ou non de l'ascendance</title>

<!--
      <para>
        <indexterm>
          <primary>ancestry</primary>
        </indexterm>When conversing with a Subversion developer, you
        might very likely hear reference to the term
        <firstterm>ancestry</firstterm>.  This word is used to
        describe the relationship between two objects in a
        repository: if they're related to each other, one
        object is said to be an ancestor of the other.</para>
-->
      <para>
        <indexterm>
          <primary>ascendance</primary>
        </indexterm>Si vous discutez avec un développeur Subversion, il
        est probable qu'il fasse référence au terme
        d'<firstterm>ascendance</firstterm>. Ce mot est utilisé pour
        décrire la relation entre deux objets dans un dépôt&nbsp;:
        s'ils sont liés l'un à l'autre, un des objets est alors
        qualifié d'ancêtre de l'autre.</para>

<!--
      <para>For example, suppose you commit revision 100, which
        includes a change to a file <filename>foo.c</filename>.
        Then <filename>foo.c@99</filename> is an
        <quote>ancestor</quote> of <filename>foo.c@100</filename>.
        On the other hand, suppose you commit the deletion of
        <filename>foo.c</filename> in revision 101, and then add a
        new file by the same name in revision 102.  In this case,
        <filename>foo.c@99</filename> and
        <filename>foo.c@102</filename> may appear to be related
        (they have the same path), but in fact are completely
        different objects in the repository.  They share no history
        or <quote>ancestry.</quote></para>
-->
      <para>Par exemple, supposons que vous propagiez la révision 100
        qui contient une modification d'un fichier
        <filename>truc.c</filename>. Dès lors,
        <filename>truc.c@99</filename> est un <quote>ancêtre</quote>
        de <filename>truc.c@100</filename>. En revanche, supposons
        que vous propagiez la suppression de
        <filename>truc.c</filename> en révision 101 et ensuite
        l'ajout d'un nouveau fichier du même nom en révision 102.
        Dans ce cas, <filename>truc.c@99</filename> et
        <filename>truc.c@102</filename> pourraient sembler
        apparentés (ils ont le même chemin), mais en fait ce sont
        des objets complètement différents au sein du dépôt. Ils ne
        partagent aucun historique ou <quote>ascendance</quote>.</para>

<!--
      <para>The reason for bringing this up is to point out an
        important difference between <command>svn diff</command> and
        <command>svn merge</command>.  The former command ignores
        ancestry, while the latter command is quite sensitive to it.
        For example, if you asked <command>svn diff</command> to
        compare revisions 99 and 102 of <filename>foo.c</filename>,
        you would see line-based diffs; the <command>diff</command>
        command is blindly comparing two paths.  But if you asked
        <command>svn merge</command> to compare the same two objects,
        it would notice that they're unrelated and first attempt to
        delete the old file, then add the new file;  the output would
        indicate a deletion followed by an add:</para>
-->
      <para>Nous abordons ce point pour mettre en évidence une
        différence importante entre <command>svn diff</command> et
        <command>svn merge</command>. La première commande ignore
        toute ascendance, tandis que la seconde y est particulièrement
        sensible. Par exemple, si vous demandez à <command>svn
        diff</command> de comparer les révisions 99 et 102 de
        <filename>truc.c</filename>, vous obtenez des différences basées
        sur les lignes&nbsp;; la commande <command>svn diff</command>
        compare deux chemins à l'aveugle. Mais si vous demandez à
        <command>svn merge</command> de comparer les deux mêmes objets,
        elle remarque qu'ils ne sont pas liés et essaie d'abord de
        supprimer l'ancien fichier, puis d'ajouter le nouveau
        fichier&nbsp;; le résultat indique une suppression puis un
        ajout&nbsp;:</para>

      <informalexample>
        <screen><!--
D    foo.c
A    foo.c-->
D    truc.c
A    truc.c
</screen>
      </informalexample>

<!--
      <para>Most merges involve comparing trees that are ancestrally
        related to one another; therefore, <command>svn
        merge</command> defaults to this behavior.  Occasionally,
        however, you may want the <command>merge</command> command to
        compare two unrelated trees.  For example, you may have
        imported two source-code trees representing different vendor
        releases of a software project (see
        <xref linkend="svn.advanced.vendorbr"/>).  If you ask
        <command>svn merge</command> to compare the two trees, you'd
        see the entire first tree being deleted, followed by an add
        of the entire second tree!  In these situations, you'll want
        <command>svn merge</command> to do a path-based comparison
        only, ignoring any relations between files and directories.
        Add the <option>- -ignore-ancestry</option> option to your
        <command>merge</command> command, and it will behave just
        like <command>svn diff</command>.  (And conversely, the
        <option>- -notice-ancestry</option> option will cause
        <command>svn diff</command> to behave like the
        <command>svn merge</command> command.)</para>
-->
      <para>La plupart des fusions impliquent de comparer des
        arborescences qui ont une relation d'ascendance de l'une à
        l'autre&nbsp;; c'est pourquoi <command>svn merge</command> a ce
        comportement par défaut. Cependant, à l'occasion, vous pourriez
        vouloir que la commande <command>svn merge</command> compare
        deux arborescences sans relation d'ascendance entre elles. Par
        exemple, vous avez peut-être importé deux arborescences de code
        source représentant des publications différentes de deux
        fournisseurs d'un projet logiciel (voir <xref
        linkend="svn.advanced.vendorbr"/>). Si vous demandez à
        <command>svn merge</command> de comparer les deux arborescences,
        vous verrez la première arborescence complètement supprimée,
        puis l'ajout de la seconde arborescence toute entière&nbsp;!
        Dans ce genre de situations, vous attendez de <command>svn
        merge</command> qu'il effectue une comparaison basée sur les
        chemins uniquement, en ignorant toute relation entre les
        fichiers et les dossiers. Ajoutez l'option
        <option>--ignore-ancestry</option> à votre commande
        <command>svn merge</command> et elle se comportera comme
        <command>svn diff</command> (et inversement, l'option
        <option>--notice-ancestry</option> fera se comporter
        <command>svn diff</command> comme la commande
        <command>svn merge</command>).</para>

<!--
      <tip>
        <para>
        <indexterm>
          <primary>merge tracking</primary>
          <secondary>disabling</secondary>
        </indexterm>
        The <option>- -ignore-ancestry</option> option also disables
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This means that <literal>svn:mergeinfo</literal> is not considered
        when <command>svn merge</command> is determining what revisions
        to merge, nor is <literal>svn:mergeinfo</literal> recorded to
        describe the merge.</para>
      </tip>
-->
      <tip>
        <para>
        <indexterm>
          <primary>fusions</primary>
          <secondary>suivi</secondary>
          <tertiary>désactivation</tertiary>
        </indexterm>
          L'option <option>--ignore-ancestry</option> désactive le suivi
          des fusions (voir <xref
          linkend="svn.branchmerge.basicmerging.mergetracking"/>).
          Das bedeutet, dass weder <literal>svn:mergeinfo</literal>
          berücksichtigt wird, wenn <command>svn merge</command>
          ermittelt, welche Revisionen zusammengeführt werden sollen,
          noch <literal>svn:mergeinfo</literal> aufgezeichnet wird, um
          die Zusammenführung zu beschreiben.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.moves">
<!--
      <title>Merges and Moves</title>
-->
      <title>Fusions, copies et renommages</title>

<!--
      <para>A common desire is to refactor source code, especially
        in Java-based software projects.  Files and directories are
        shuffled around and renamed, often causing great disruption
        to everyone working on the project.  Sounds like a perfect
        case to use a branch, doesn't it?  Just create a branch,
        shuffle things around, and then merge the branch back to the
        trunk, right?</para>
-->
      <para>Il arrive souvent qu'on veuille réorganiser le code source,
        en particulier dans les projets logiciels en Java. Les fichiers
        et les répertoires sont déplacés et renommés, causant souvent
        de grandes perturbations pour tous ceux qui travaillent sur le
        projet. Ceci semble être le cas idéal où utiliser une branche,
        n'est-ce pas&nbsp;? Créer une branche, réorganiser les choses,
        et ensuite fusionner la branche vers le tronc, non&nbsp;?</para>

<!--
      <para>Alas, this scenario doesn't work so well right now and
        is considered one of Subversion's current weak spots.  The
        problem is that Subversion's <command>svn merge</command>
        command isn't as robust as it should be, particularly when
        dealing with copy and move operations.</para>
-->
      <para>Hélas, ce scénario ne fonctionne pas si bien pour le
        moment et est même considéré comme l'une des faiblesses de
        Subversion. Le problème est que la commande
        <command>svn update</command> de Subversion n'est pas aussi
        robuste qu'elle le devrait, en particulier en ce qui
        concerne les opérations de copies et de déplacements.</para>

<!--
      <para>When you use <command>svn copy</command> to duplicate a
        file, the repository remembers where the new file came from,
        but it fails to transmit that information to the client which
        is running <command>svn update</command> or <command>svn
        merge</command>.  Instead of telling the client, <quote>Copy
        that file you already have to this new location,</quote> it
        sends down an entirely new file.  This can lead to
        problems, particularly tree conflicts in the case of renames,
        which involve not only the new copy, but a deletion of the old
        path&mdash;a lesser-known fact about Subversion is that
        it lacks <quote>true renames</quote>&mdash;the <command>svn
        move</command> command is nothing more than an aggregation
        of <command>svn copy</command> and <command>svn
        delete</command>.</para>
-->
      <para>Quand vous utilisez <command>svn copy</command> pour
        dupliquer un fichier, le dépôt se souvient d'où venait le
        nouveau fichier, mais il ne transmet pas cette information
        au client qui lance <command>svn update</command> ou
        <command>svn merge</command>. Au lieu de dire au client
        <quote>Copie ce fichier que tu as déjà vers ce nouvel
        emplacement</quote>, il envoie un fichier entièrement nouveau.
        Ceci peut engendrer des problèmes, notamment des conflits
        d'arborescences dans le cas de renommage de fichiers, pour ce
        qui concerne la nouvelle copie et la suppression de l'ancien
        emplacement. Un fait peu connu à propos de Subversion est qu'il
        lui manque de <quote>vrais renommages</quote> &mdash; la
        commande <command>svn move</command> n'est rien de plus que
        l'agrégation de <command>svn copy</command> et
        <command>svn delete</command>.</para>

<!--
      <para>For example, suppose that you want to make some changes on
        your private branch <filename>/calc/branch/my-calc-branch
        </filename>.  First you perform an automatic sync merge with
        <filename>/calc/trunk</filename> and commit that in r470:</para>
-->
      <para>Par exemple, supposons que vous travaillez sur votre branche
        privée <filename>/calc/branches/ma-branche-calc</filename>.
        D'abord, vous effectuez une fusion automatique de
        synchronisation avec <filename>/calc/trunk</filename> et vous la
        propagez dans r470&nbsp;:</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn merge ^/calc/trunk <!--
- - - Merging differences between repository URLs into '.':
-->
--- Fusion des différences des URLs du dépôt vers '.' :
U    doc/INSTALL
A    FAQ
U    src/main.c<!--
U    src/button.c
U    src/integer.c
U    Makefile
U    README
 U   .
- - - Recording mergeinfo for merge between repository URLs into '.':
-->
U    src/bouton.c
U    src/entier.c
U    Makefile
U    LISEZMOI
 U   .
-- Stockage des informations de fusion (mergeinfo) des URLs du dépôt dans '.' :
 U   .
<!--
$ svn ci -m "Sync all changes from ^/calc/trunk through r469."
Sending        .
Sending        Makefile
Sending        README
Sending        FAQ
Sending        doc/INSTALL
Sending        src/main.c
Sending        src/button.c
Sending        src/integer.c
Transmitting file data ....
Committed revision 470.
-->
$ svn ci -m "Synchronisation des changements de ^/calc/trunk jusqu'à r469."
Envoi         .
Envoi         Makefile
Envoi         LISEZMOI
Envoi         FAQ
Envoi         doc/INSTALL
Envoi         src/main.c
Envoi         src/bouton.c
Envoi         src/entier.c
Transmission des données ....
Révision 470 propagée.
</screen>
      </informalexample>
<!--
      <para>Then you rename <filename>integer.c</filename> to <filename>
        whole.c</filename> in r471 and then make some edits to the same
        file in r473.  Effectively you've created a new file in your branch
        (that is a copy of the original file plus some edits) and deleted
        the original file.  Meanwhile, back on <filename>/calc/trunk
        </filename>, Sally has committed some improvements of her own to
        <filename>integer.c</filename> in r472:</para>
-->
      <para>Puis vous renommez <filename>entier.c</filename>
        en <filename>tout.c</filename> dans r471 et vous effectuez des
        modifications dans ce même fichier dans r473. Concrètement, vous
        avez créé un nouveau fichier dans votre branche (c'est une copie
        du fichier original avec quelques modifications) et vous avez
        effacé le fichier original. Pendant ce temps, sur
        <filename>/calc/trunk</filename>, Sally a propagé des
        améliorations de son cru au fichier
        <filename>entier.c</filename> lors de la r472&nbsp;:</para>

      <informalexample>
        <screen>
$ svn log -v -r472 ^/calc/trunk
------------------------------------------------------------------------<!--
r472 | sally | 2013-02-26 07:05:18 -0500 (Tue, 26 fév. 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Trunk work on integer.c.-->
r472 | sally | 2013-02-26 07:05:18 -0500 (dim. 26 fév. 2013) | 1 ligne
Chemins modifiés :
   M /calc/trunk/src/entier.c

Travail d'amélioration de entier.c sur le tronc.
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Now you decide to merge your branch back to the trunk.
        How will Subversion combine the rename and edits you made
        with Sally's edits?</para>
-->
      <para>C'est alors que vous décidez de fusionner votre branche vers
        le tronc. Comment Subversion combine-t-il le renommage et les
        modifications que vous avez faits avec les modifications de
        Sally&nbsp;?</para>

      <informalexample>
        <screen><!--
$ svn merge ^/calc/branches/my-calc-branch
- - Merging differences between repository URLs into '.':
   C src/integer.c
 U   src/real.c
A    src/whole.c
- - Recording mergeinfo for merge between repository URLs into '.':-->
$ svn merge ^/calc/branches/ma-branche-calc
--- Fusion des différences des URLs du dépôt dans '.' :
   C src/entier.c
 U   src/reel.c
A    src/tout.c
--- Stockage des informations de fusion (mergeinfo) des URLs du dépôt dans '.' :
 U   .<!--
Summary of conflicts:
  Tree conflicts: 1-->
Résumé des conflits:
  conflits d'arborescences : 1

$ svn st
 M      .<!--
      C src/integer.c
      >   local file edit, incoming file delete upon merge
M      src/real.c
A  +    src/whole.c-->
      C src/entier.c
      >   local file edit, incoming file delete upon merge
 M      src/reel.c
A  +    src/tout.c<!--
Summary of conflicts:
  Tree conflicts: 1-->
Résumé des conflits:
  conflits d'arborescences : 1
</screen>
      </informalexample>

<!--
      <para>The answer is that Subversion <emphasis>won't</emphasis>
        combine those changes, but rather raises a tree conflict<footnote>
        <para>If Sally hadn't made her change in r472, then Subversion would
        notice that <filename>integer.c</filename> in the
        target working copy is identical to <filename>integer.c</filename>
        in the left-side of the merge and would allow your rename to
        succeed without a tree conflict:</para>-->
      <para>La réponse est que Subversion <emphasis>ne combinera
        pas</emphasis> les modifications, mais générera un conflit
        d'arborescences<footnote><para>Si Sally n'avait pas propagé ses
        modifications dans r472, alors Subversion aurait remarqué que
        <filename>entier.c</filename> dans la copie de travail cible
        était identique à <filename>entier.c</filename> du côté gauche
        de la fusion et aurait permis le succès de votre renommage sans
        conflit d'arborescence&nbsp;:</para>
        <informalexample>
          <screen><!--
$ svn merge ^/calc/branches/my-calc-branch
- - Merging differences between repository URLs into '.':
 U   src/real.c
A    src/whole.c
D    src/integer.c
- - Recording mergeinfo for merge between repository URLs into '.':-->
$ svn merge ^/calc/branches/ma-branche-calc
--- Fusion des différences entre les URLs du dépôt dans '.' :
 U   src/reel.c
A    src/tout.c
D    src/entier.c
--- Stockage des informations de fusion (mergeinfo) des URLs du dépôt dans '.' :
 U   .
</screen><!--
      </informalexample></footnote>because it needs your help
        to figure out what part of your changes and what part of Sally's
        changes should ultimately end up in <filename>whole.c</filename>
        or even if the rename should take place at all!</para>-->
        </informalexample></footnote>parce qu'il a besoin de votre aide
        pour déterminer quelle part de vos modifications et quelle part
        des modifications de Sally doivent finalement se retrouver dans
        <filename>tout.c</filename>,ou même si le renommage a tout
        simplement lieu d'être&nbsp;!</para>

<!--
      <para>You will need to resolve this tree conflict before committing
        the merge and this may require some manual intervention on your
        part, see <xref linkend="svn.tour.treeconflicts"/>.  The moral of
        this story is that until Subversion improves, be careful about
        merging copies and renames from one branch to another and when you
        do, be prepared for some manual resolution.</para>
-->
      <para>Vous devrez résoudre le conflit d'arborescences avant de
        pouvoir propager la fusion, ce qui requiert un minimum
        d'intervention manuelle de votre part, voir <xref
        linkend="svn.tour.treeconflicts"/>. La morale de cette histoire,
        c'est que tant que Subversion ne se sera pas amélioré, soyez
        vigilant lors des fusions avec copies et renommages d'une
        branche vers une autre et, lorsque vous le faites, préparez-vous
        à effectuer des résolutions manuelles.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.pre1.5clients">
<!--
      <title>Preventing Naïve Clients from Committing Merges</title>
-->
      <title>Blocage des clients qui ne prennent pas en compte les
        fusions</title>

<!--
      <para>If you've just upgraded your server to Subversion 1.5 or
        later, there's a risk that pre-1.5 Subversion
        clients can cause problems with
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This is because pre-1.5 clients don't support this feature;
        when one of these older clients performs <command>svn
        merge</command>, it doesn't modify the value of
        the <literal>svn:mergeinfo</literal> property at all.  So the
        subsequent commit, despite being the result of a merge,
        doesn't tell the repository about the duplicated
        changes&mdash;that information is lost.  Later on,
        when <quote>merge-aware</quote> clients attempt automatic
        merging, they're likely to run into all sorts of conflicts
        resulting from repeated merges.</para>
-->
      <para>Si vous venez juste de mettre à niveau votre serveur Subversion
        à la version 1.5 ou plus, il existe un risque significatif que
        les clients Subversion pré-1.5 sèment la pagaille dans votre
        suivi automatique des fusions. Pourquoi&nbsp;? Quand un client
        Subversion pré-1.5 exécute <command>svn merge</command>, il ne
        modifie pas du tout la valeur de la propriété
        <literal>svn:mergeinfo</literal>. La propagation qui s'ensuit,
        bien qu'elle soit le résultat d'une fusion, n'envoie donc
        aucune indication au dépôt au sujet des modifications
        dupliquées &mdash; ces informations sont perdues. Par la
        suite, lorsque des clients <quote>qui prennent en compte les
        fusions</quote> tentent d'effectuer une fusion automatique,
        ils rencontreront probablement toutes sortes de conflits
        résultant des fusions répétées.</para>

<!--
      <para>If you and your team are relying on the merge-tracking
        features of Subversion, you may want to configure your
        repository to prevent older clients from committing changes.
        The easy way to do this is by inspecting
        the <quote>capabilities</quote> parameter in
        the start-commit hook script.  If the
        client reports itself as having <literal>mergeinfo</literal>
        capabilities, the hook script can allow the commit to start.
        If the client doesn't report that capability, have the hook
        deny the commit.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> gives an
        example of such a hook script:</para>
-->
      <para>Si votre équipe et vous dépendez des fonctionnalités de
        suivi des fusions de Subversion, vous voudrez peut-être
        configurer votre dépôt pour qu'il empêche les anciens clients
        de propager des modifications. La méthode la plus simple est
        d'examiner le paramètre <quote>capabilities</quote> dans la
        procédure automatique de début de propagation
        (<literal>start-commit</literal>). Si le client
        indique être capable de gérer les <literal>mergeinfo</literal>,
        la procédure automatique peut l'autoriser à commencer la
        propagation. Si le client n'indique pas en être capable, la
        procédure automatique doit lui refuser la propagation.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> donne un
        exemple d'une telle procédure automatique.</para>

      <example id="svn.branchmerge.advanced.hook-ex1">
<!--
        <title>Merge-tracking gatekeeper start-commit hook script</title>
-->
        <title>Procédure automatique de vérification des capacités de
          suivi des fusions avant une propagation</title>

        <programlisting><!--
#!/usr/bin/env python
import sys

# The start-commit hook is invoked immediately after a Subversion txn is
# created and populated with initial revprops in the process of doing a
# commit. Subversion runs this hook by invoking a program (script,
# executable, binary, etc.) named 'start-commit' (for which this file
# is a template) with the following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] USER         (the authenticated user attempting to commit)
#   [3] CAPABILITIES (a colon-separated list of capabilities reported
#                     by the client; see note below)
#   [4] TXN-NAME     (the name of the commit txn just created)

capabilities = sys.argv[3].split(':')
if "mergeinfo" not in capabilities:
  sys.stderr.write("Commits from merge-tracking-unaware clients are "
                   "not permitted.  Please upgrade to Subversion 1.5 "
                   "or newer.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>
-->
# -*- coding: utf-8 -*-
#!/usr/bin/env python
import sys

# La procédure automatique start-commit est appelée après la création
# de la transaction Subversion et peuplée avec propriétés de révision
#
#
# [1] CHEMIN-DEPOT  (le chemin du dépôt)
# [2] UTILISATEUR   (l'utilisateur authentifié qui tente la propagation)
# [3] CAPACITES     (liste des capacités qu'annonce le client,
#                    les éléments sont séparés par des ':'
#                    voir ci-dessous)
# [4] NOM-TRANSACTION  (nom de la transaction qui vient d'être créée)

capacites = sys.argv[3].split(':')
if "mergeinfo" not in capacites:
  sys.stderr.write("Les propagations depuis un client non capable de"
                   "suivre les fusions sont interdites. "
                   "Veuillez mettre à niveau votre client  à "
                   "Subversion 1.5 ou plus récent.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>

<!--
      <para>For more information about hook scripts, see
        <xref linkend="svn.reposadmin.hooks" />.</para>
-->
      <para>Pour plus d'informations sur les procédures automatiques,
        reportez-vous au <xref linkend="svn.reposadmin.hooks"/>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.finalword">
<!--
      <title>The Final Word on Merge Tracking</title>
-->
      <title>Recommandations finales sur le suivi des fusions</title>

<!--
      <para>The bottom line is that Subversion's merge-tracking
        feature has a complex internal implementation, and
        the <literal>svn:mergeinfo</literal> property is the only
        window the user has into the machinery.</para>
-->
      <para>En fin de compte, la fonctionnalité de suivi des fusions
        de Subversion possède une mécanique interne extrêmement
        complexe et la propriété <literal>svn:mergeinfo</literal>
        est la seule lorgnette dont l'utilisateur dispose pour
        observer cette mécanique.</para>

<!--
      <para>How and when mergeinfo is recorded by a merge can sometimes
        be difficult to understand.  Furthermore, the management of
        mergeinfo metadata has a whole set of taxonomies and behaviors
        around it, such as <quote>explicit</quote> versus <quote>implicit
        </quote> mergeinfo, <quote>operative</quote>
        versus <quote>inoperative</quote> revisions, specific
        mechanisms of mergeinfo <quote>elision,</quote> and
        even <quote>inheritance</quote> from parent to child
        directories.</para>
-->
      <para>Quand et pourquoi les informations de fusions sont
        enregistrées par une fusion peut parfois être difficile à
        comprendre. De plus, la gestion des informations de fusions
        comporte tout un ensemble de taxonomies et de règles, telles
        que les informations <quote>explicites</quote> et celles
        <quote>implicites</quote>, les révisions
        <quote>effectives</quote> et les <quote>non-effectives</quote>,
        le <quote>nettoyage</quote> et <quote>l'héritage</quote> d'un
        dossier parent vers les dossiers enfants.</para>

<!--
      <para>We've chosen to only briefly cover, if at all, these detailed
        topics for a couple of reasons.  First, the level of detail is
        overwhelming for a typical user.  Second, and more
        importantly, the typical user <emphasis>doesn't</emphasis> need
        to understand these concepts; typically they remain in the
        background as implementation details.  All that said, if you
        enjoy this sort of thing, you can get a fantastic overview in a
        paper posted at CollabNet's website: <ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>
-->
      <para>Nous avons choisi de ne pas couvrir en détail ces sujets
        dans ce livre pour plusieurs raisons. Premièrement,
        l'utilisateur moyen serait totalement submergé par le niveau
        de détail disponible. Deuxièmement, et c'est le plus important,
        nous estimons que l'utilisateur moyen <emphasis>ne doit
        pas</emphasis> avoir à comprendre ces concepts&nbsp;; en tant
        que détails d'implémentation, ils restent à l'arrière-plan.
        Malgré tout, si vous appréciez ce genre de choses, vous en
        trouverez une formidable vue d'ensemble dans un article posté
        sur le site internet de Collabnet&nbsp;: <ulink
        url="http://www.collab.net/community/subversion/articles/merge-info.html"
        />.</para>

<!--
      <para>For now, if you want to steer clear of the complexities of
        merge tracking, we recommend that you follow these simple best
        practices:</para>
-->
      <para>Pour le moment, si vous voulez rester à l'écart de la
        complexité du suivi de fusions, nous vous recommandons de vous
        en tenir simplement aux bonnes pratiques suivantes&nbsp;:</para>

      <itemizedlist>
        <listitem>
<!--
          <para>For short-term feature branches, follow the simple
            procedure described throughout
            <xref linkend="svn.branchmerge.basicmerging"/>.</para>
-->
          <para>Pour les branches fonctionnelles à courte durée de vie,
            suivez la procédure simple décrite dans <xref
            linkend="svn.branchmerge.basicmerging"/>.</para>
        </listitem>
        <listitem>
<!--
          <para>Avoid subtree merges and subtree mergeinfo. Perform
            merges only on the root of your branches, not on
            subdirectories or files (see <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>)
            .</para>
-->
          <para>Evitez les fusions sous les sous-arborescences et de
            générer des informations de fusions sur les sous-dossiers.
            Ne pratiquez de fusions que sur la racine de la branche, pas
            sur des sous-répertoires. <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>).
          </para>
        </listitem>
        <listitem>
<!--
          <para>Don't ever edit the <literal>svn:mergeinfo</literal>
            property directly; use <command>svn
            merge</command> with the <option>- -record-only</option> option
            to effect a desired change to the metadata (as demonstrated in
            <xref linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
-->
          <para>Ne modifiez jamais la propriété
            <literal>svn:mergeinfo</literal> directement&nbsp;;
            utilisez <command>svn merge</command> avec l'option
            <option>--record-only</option> pour appliquer une
            modification désirée à cette métadonnée (comme expliqué
            dans <xref
            linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
        </listitem>
        <listitem>
<!--
          <para>Your merge target should be a working copy which
            represents the root of a <emphasis>complete</emphasis> tree
            representing a <emphasis>single</emphasis> location in the
            repository at a single point in time:
-->
          <para>Votre cible de fusion devrait toujours être une copie
            de travail qui est la racine d'une arborescence
            <emphasis>complète</emphasis> représentant une
            <emphasis>seule</emphasis> position dans le dépôt à un
            moment bien précis dans le temps&nbsp;:
            <itemizedlist>
              <listitem>
<!--
                <para>Update before you merge!  Don't use the <option>
                - -allow-mixed-revisions</option> option to merge into
                mixed-revision working copies.</para>
-->
                <para>mettez à jour avant de fusionner&nbsp;! N'utilisez
                  pas l'option <option>--allow-mixed-revisions</option>
                  pour fusionner vers des copies de travail à révisions
                  mélangées.</para>
              </listitem>
              <listitem>
<!--
                <para>Don't merge to targets with <quote>switched</quote>
                subdirectories (as described next in
                <xref linkend="svn.branchmerge.switchwc"/>).</para>
-->
                <para>ne fusionnez pas vers des cibles dont des dossiers
                  ont pointent vers d'autres branches (tels que décrits
                  dans <xref linkend="svn.branchmerge.switchwc"/>).</para>
              </listitem>
              <listitem>
<!--
                <para>Avoid merges to targets with sparse directories.
                  Likewise, don't merge to depths other than
                  <option>- -depth=infinity</option></para>
-->
                <para>évitez les fusions vers des cibles avec des
                  répertoires clairsemés. De la même manières, ne
                  fusionnez pas pour des profondeurs autres que
                  <option>--depth=infinity</option></para>
              </listitem>
              <listitem>
<!--
                <para>Be sure you have read access to all of the merge
                  source and read/write access to all of the merge
                  target.</para>
-->
                <para>Assurez-vous de toujours avoir l'accès complet en
                  lecture à toutes vos sources de fusion et l'accès en
                  lecture/écriture à l'ensemble de la cible de la
                  fusion.</para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>

<!--
      <para>Of course sometimes you may need to violate some of these
        best practices.  Don't worry if you need to, just be sure you
        understand the ramifications of doing so.</para>
-->
      <para>Bien sûr, vous pouvez être amené parfois à devoir violer
        certaines bonnes pratiques. Dans ce cas, ne vous inquietez pas,
        soyez seulement conscient des conséquences que cela
        engendre.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
<!--
    <title>Traversing Branches</title>
-->
    <title>Parcours des branches</title>

<!--
    <para>The <command>svn switch</command> command transforms an
      existing working copy to reflect a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut.  In one of our earlier examples,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>
-->
    <para>La commande <command>svn switch</command> transforme une
      copie de travail existante de telle sorte qu'elle pointe vers
      une branche différente. Bien que la connaissance de cette
      commande ne soit pas absolument nécessaire pour travailler avec
      des branches, elle fournit un raccourci utile. Dans l'un de nos
      exemples précédents, après avoir créé votre branche privée, vous
      avez extrait une toute nouvelle copie de travail du nouveau
      répertoire du dépôt. À la place, vous pouvez simplement
      demander à Subversion de modifier votre copie de travail de
      <filename>/calc/trunk</filename> pour qu'elle pointe vers
      l'emplacement de la nouvelle branche&nbsp;:</para>

    <informalexample>
      <screen>
$ cd calc

$ svn info | grep URL<!--
URL: http://svn.example.com/repos/calc/trunk

$ svn switch ^/calc/branches/my-calc-branch
U    integer.c
U    button.c
U    Makefile
Updated to revision 341.
-->
URL: http://svn.exemple.com/depot/calc/trunk

$ svn switch ^/calc/branches/ma-branche-calc
U   entier.c
U   bouton.c
U   Makefile
Actualisé à la révision 341.

$ svn info | grep URL<!--
URL: http://svn.example.com/repos/calc/branches/my-calc-branch-->
URL: http://svn.exemple.com/depot/calc/branches/ma-branche-calc
</screen>
    </informalexample>

<!--
    <para><quote>Switching</quote> a working copy that has no local
      modifications to a different branch results in the working copy
      looking just as it would if you'd done a fresh checkout of the
      directory.  It's usually more efficient to
      use this command, because often branches differ by only a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>
-->
    <para><quote>Faire pointer</quote> (ou <quote>déporter</quote>)
      une copie de travail qui n'a pas de modifications locales vers
      une branche différente a pour résultat que la copie de travail
      a exactement le même aspect que si vous aviez effectué une
      extraction brute du répertoire. C'est en général plus efficace
      d'utiliser cette commande, car les différences entre les
      branches sont souvent minimes. Le serveur n'envoie que le
      minimum de modifications nécessaire pour faire pointer votre
      copie de travail vers le répertoire de la branche.</para>

<!--
    <para>The <command>svn switch</command> command also takes a
      <option>- -revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the
      <literal>HEAD</literal> of the branch.</para>
-->
    <para>La commande <command>svn switch</command> accepte également
      l'option <option>--revision</option> (<option>-r</option>), pour
      que que vous ne soyez pas obligé de faire pointer votre copie de
      travail vers la révision <literal>HEAD</literal> de la
      branche.</para>

<!--
    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, and contain multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>
-->
    <para>Bien sûr, beaucoup de projets sont plus compliqués que
      notre exemple <filename>calc</filename> et contiennent de
      multiples sous-dossiers. Les utilisateurs de Subversion suivent
      souvent un algorithme précis quand ils utilisent des
      branches&nbsp;:</para>

    <orderedlist>
      <listitem>
<!--
        <para>Copy the project's entire <quote>trunk</quote> to a new
          branch directory.</para>
-->
        <para>Copier le <quote>tronc</quote> entier du projet vers
            une nouvelle branche&nbsp;;</para>
        </listitem>
        <listitem>
<!--
        <para>Switch only <emphasis>part</emphasis> of the trunk
          working copy to mirror the branch.</para>
-->
        <para>Ne déporter qu'<emphasis>une partie</emphasis> de la copie
          de travail du tronc pour qu'elle pointe sur la branche.</para>
        </listitem>
      </orderedlist>

<!--
    <para>In other words, if a user knows that the branch work needs
      to happen on only a specific subdirectory, she uses
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, the user can continue to
      receive normal <quote>trunk</quote> updates to most of her
      working copy, but the switched portions will remain immune
      (unless someone commits a change to her branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote>&mdash;not only can working copies contain a
      mixture of working revisions, but they can also contain a
      mixture of repository locations as well.</para>
-->
    <para>En d'autres termes, si un utilisateur sait que le travail sur
      la branche ne doit avoir lieu que sur un sous-dossier donné, il
      utilise <command>svn switch</command> pour ne faire pointer que ce
      sous-dossier vers la branche (ou parfois des utilisateurs ne vont
      faire pointer qu'un unique fichier de travail vers la
      branche&nbsp;!). De cette façon, l'utilisateur peut continuer à
      recevoir les mises à jour normales du <quote>tronc</quote> vers la
      plus grande partie de sa copie de travail, mais les portions
      déportées ne seront pas touchées (à moins que quelqu'un ne propage
      une modification à sa branche). Cette fonctionnalité ajoute une
      dimension complètement nouvelle au concept de <quote>copie de
      travail mixte</quote>&nbsp;: les copies de travail peuvent non
      seulement contenir un mélange de révisions de travail, mais elles
      peuvent également contenir un mélange d'emplacements du
      dépôt.</para>

    <tip>
<!--
      <para>Typically switched subdirectories share common ancestry with
        the location which is switched <quote>away</quote> from.  However
        <command>svn switch</command> can switch a subdirectory to mirror
        a repository location which it shares no common ancestry with.
        To do this you need to use the
        <option>- -ignore-ancestry</option> option.
    </para>
-->
      <para>Typiquement, les sous-dossiers déportés partagent un ancêtre
        commun avec l'emplacement d'où ils ont été déportés. Cependant,
        <command>svn switch</command> peut déporter un sous-dossier pour
        refléter un emplacement du dépôt qui ne partage aucun ancêtre
        avec ce sous-dossier. Pour ce faire, vous devez utiliser
        l'option <option>--ignore-ancestry</option>.</para>
    </tip>

<!--
    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes are still
      applied as a single, atomic change to the repository.</para>
-->
    <para>Si votre copie de travail contient un certain nombre de
      sous-arborescences pointant vers des emplacements variés du dépôt,
      elle continue à fonctionner normalement. Quand vous la mettez à
      jour, vous recevez comme il se doit les correctifs pour chaque
      sous-arborescence. Quand vous effectuez une propagation, vos
      modifications locales s'appliquent toujours au dépôt en tant
      qu'une unique modification atomique.</para>

<!--
    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that feature is planned for the
      future.<footnote><para>You <emphasis>can</emphasis>, however,
      use <command>svn relocate</command> if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See <xref linkend="svn.ref.svn.c.relocate"/> in
      <xref linkend="svn.ref.svn"/> for more information and an
      example.</para></footnote></para>
-->
    <para>Remarquez que, bien qu'il soit possible pour votre copie de
      travail de pointer vers une variété d'emplacements du dépôt,
      ces emplacements doivent tous faire partie du
      <emphasis>même</emphasis> dépôt. Les dépôts Subversion ne sont
      pas encore capables de communiquer entre eux&nbsp;; cette
      fonctionnalité est prévue à l'avenir
      <footnote>
        <para>Vous <emphasis>pouvez</emphasis> cependant utiliser
          <command>svn relocate</command> si l'URL de votre serveur
          change et si vous ne voulez pas abandonner votre copie de
          travail existante. Reportez-vous à
          <xref linkend="svn.ref.svn.c.relocate"/> dans
          <xref linkend="svn.ref.svn"/> pour des détails et des
          exemples.</para>
      </footnote>.
    </para>

    <tip>
<!--
      <para>Administrators who need to change the URL of a repository
        which is accessed via HTTP are encouraged to add to
        their <filename>httpd.conf</filename> configuration file a
        permanent redirect from the old URL location to the new one
        (via the <literal>RedirectPermanent</literal> directive).
        Subversion clients will generally display the new repository
        URL in error messages generated when the user attempts to use
        working copies which still reflect the old URL location.  Since
        Subversion 1.7 clients will go a step further,
        automatically relocating the working copy to the new
        URL.</para>
-->
      <para>Les administrateurs qui doivent modifier l'URL d'un dépôt
        accessible <foreignphrase>via</foreignphrase> HTTP sont
        encouragés à ajouter à leur fichier de configuration
        <filename>httpd.conf</filename> une redirection permanente de
        l'ancienne URL vers la nouvelle (à l'aide de la directive
        <literal>RedirectPermanent</literal>). Les clients Subversion
        affichent généralement la nouvelle URL du dépôt dans les
        messages d'erreur produits lorsque l'utilisateur essaye de
        travailler avec une copie de travail qui pointe vers l'ancienne
        URL. Depuis Subversion 1.7, les clients font un pas
        supplémentaire en faisant pointer automatiquement la copie de
        travail vers la nouvelle URL.</para>
    </tip>

    <sidebar>
<!--
      <title>Switches and Updates</title>
-->
      <title>Déports et mises à jour</title>

<!--
      <para>Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> looks the
        same?  The switch command is actually a superset of the update
        command.</para>
-->
      <para>Avez-vous remarqué que les sorties des commandes
        <command>svn switch</command> et <command>svn update</command>
        se ressemblent&nbsp;? La commande <command>svn switch</command>
        est en fait une généralisation de la commande
        <command>svn update</command>.</para>

<!--
      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        latter command always compares two identical repository
        paths.</para>
-->
      <para>Quand vous lancez <command>svn update</command>, vous
        demandez au dépôt de comparer deux arborescences. C'est ce qu'il
        fait, puis il renvoie au client le détail des différences entre
        les deux. La seule différence entre <command>svn
        switch</command> et <command>svn update</command> est que cette
        dernière commande compare toujours deux chemins identiques du
        dépôt.</para>

<!--
      <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch directory in the
        <literal>HEAD</literal> revision.</para>
-->
      <para>C'est-à-dire que si votre copie de travail pointe vers
        <filename>/calc/trunk</filename>, <command>svn update</command>
        compare automatiquement votre copie de travail de
        <filename>/calc/trunk</filename> au
        <filename>/calc/trunk</filename> de la révision
        <literal>HEAD</literal>. Si vous faites pointer votre copie de
        travail vers une branche, <command>svn switch</command>
        comparera votre copie de travail de
        <filename>/calc/trunk</filename> au répertoire d'une
        <emphasis>autre</emphasis> branche de la révision
        <literal>HEAD</literal>.</para>

<!--
      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
-->
      <para>En d'autres termes, <command>svn update</command> déplace
        votre copie de travail à travers le temps.
        <command>svn switch</command> déplace votre copie de travail
        à travers le temps <emphasis>et</emphasis> l'espace.</para>
    </sidebar>

<!--
    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.</para>
-->
    <para>Parce que <command>svn switch</command> est essentiellement
      une variante de <command>svn update</command>, elle se comporte
      de la même manière&nbsp;; toute modification locale présente
      dans votre copie de travail est préservée lorsque de nouvelles
      données arrivent en provenance du dépôt.</para>

    <tip>
<!--
      <para>Have you ever found yourself making some complex edits (in
        your <filename>/trunk</filename> working copy) and suddenly
        realized, <quote>Hey, these changes ought to be in their own
        branch?</quote> There is a great two step technique to do
        this:</para>
-->
        <para>Vous-êtes vous déjà trouvés dans une situation où vous
          effectuez des modifications complexes (dans votre copie de
          travail de <filename>/trunk</filename>) et réalisez
          soudainement&nbsp;:<quote>Mais, ces modifications ne
          devraient-elles pas être dans leur propre
          branche&nbsp;?</quote> Une excellente technique pour accomplir
          ceci peut être résumée en deux étapes&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \
           -m "Create branch 'newbranch'."
Committed revision 353.
$ svn switch ^/calc/branches/newbranch
At revision 353.
-->
$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/branches/nouvelle-branche \
      -m "Création de la branche 'nouvelle-branche'."
Révision 353 propagée.
$ svn switch http://svn.exemple.com/depot/calc/branches/nouvelle-branche
À la révision 353.
</screen>
      </informalexample>

<!--
      <para>The <command>svn switch</command> command, like
        <command>svn update</command>, preserves your local edits.  At
        this point, your working copy is now a reflection of the newly
        created branch, and your next <command>svn commit</command>
        invocation will send your changes there.</para>
    </tip>
-->
    <para>La commande <command>svn switch</command>, à l'instar de
      <command>svn update</command>, préserve vos modifications locales.
      Désormais, votre copie de travail pointe vers la branche
      nouvellement créée et la prochaine fois que vous lancerez
      <command>svn commit</command> vos modifications y seront
      envoyées.</para>
    </tip>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
<!--
    <title>Tags</title>
-->
    <title>Étiquettes</title>

    <para>
      <indexterm>
<!--
        <primary>tags</primary>
-->
        <primary>étiquettes</primary>
      </indexterm>
<!--
      Another common version control concept is a tag.  A tag is
      just a <quote>snapshot</quote> of a project in time.  In
      Subversion, this idea already seems to be everywhere.  Each
      repository revision is exactly that&mdash;a snapshot of the
      filesystem after each commit.</para>
-->
      Un autre concept courant en gestion de versions est
      l'<firstterm>étiquette</firstterm> (parfois appelée
      <foreignphrase>tag</foreignphrase>).
      Une étiquette n'est qu'un <quote>instantané</quote> d'un
      projet à un moment donné. Dans Subversion, cette idée semble
      être présente partout. Chaque révision du dépôt est exactement
      cela&nbsp;: un instantané du système de fichiers pris après
      chaque propagation.</para>

<!--
    <para>However, people often want to give more human-friendly names
      to tags, such as <literal>release-1.0</literal>.  And they want
      to make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release 1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>
-->
    <para>Cependant les gens veulent souvent donner des noms plus
      conviviaux aux étiquettes, tel que
      <literal>version-1.0</literal>. Et ils veulent prendre des
      instantanés de sous-sections plus restreintes du système de
      fichiers. Après tout, ce n'est pas si facile de se rappeler
      que la version 1.0 d'un logiciel donné correspond à un
      sous-dossier particulier de la révision 4822.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
<!--
      <title>Creating a Simple Tag</title>
-->
      <title>Création d'une étiquette simple</title>

<!--
      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, make a copy of it:</para>
-->
      <para>Une fois encore, <command>svn copy</command> vient à la
        rescousse. Si vous voulez créer un instantané de
        <filename>/calc/trunk</filename> identique à ce qu'il est
        dans la révision <literal>HEAD</literal>, faites-en
        une copie&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
           -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 902.
-->
$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/tags/version-1.0 \
      -m "Étiquetage de la version 1.0 du projet 'calc'."

Révision 902 propagée.
</screen>
      </informalexample>

<!--
      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If
        it doesn't, you can create it using <command>svn
        mkdir</command>.)  After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the <filename>/trunk</filename> directory
        looked in the <literal>HEAD</literal> revision at the time you
        made the copy.  Of course, you might want to be more precise
        about exactly which revision you copy, in case somebody else
        may have committed changes to the project when you weren't
        looking.  So if you know that revision 901 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 901</option> to
        the <command>svn copy</command> command.</para>
-->
      <para>Cet exemple présuppose qu'un répertoire
        <filename>/calc/tags</filename> existe déjà (s'il n'existe
        pas, vous pouvez le créer en utilisant
        <command>svn mkdir</command>). Une fois la copie terminée,
        le nouveau dossier <filename>version-1.0</filename> sera pour
        toujours un instantané du dossier <filename>/trunk</filename>
        tel qu'il était en révision <literal>HEAD</literal> au moment
        où vous avez effectué la copie. Bien sûr, vous voudriez
        peut-être être plus précis quant à quelle révision vous copiez,
        au cas où quelqu'un d'autre aurait propagé des modifications
        au projet pendant que vous regardiez ailleurs. Donc si vous
        savez que la révision 901 de <filename>/calc/trunk</filename>
        est exactement l'instantané que vous voulez, vous pouvez le
        spécifier en passant <option>-r 901</option> à la commande
        <command>svn copy</command>.</para>

<!--
      <para>But wait a moment: isn't this tag creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>
-->
      <para>Mais attendez un moment&nbsp;: cette procédure de création
        d'étiquette, n'est-ce pas la même procédure que nous avons
        utilisé pour créer une branche&nbsp;? En fait, oui. Dans
        Subversion, il n'y pas de différence entre une étiquette et
        une branche. Toutes deux ne sont que des répertoires
        ordinaires qui sont créés par copie. Comme pour les branches,
        la seule raison qui fasse qu'un répertoire copié soit une
        <quote>étiquette</quote> est que les
        <emphasis>humains</emphasis> ont décidé de le traiter
        de cette façon&nbsp;: aussi longtemps que personne
        ne propage de modification à ce répertoire, il reste un
        instantané. Si les gens commencent à y propager des choses,
        il devient une branche.</para>

<!--
      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy.  (That is, make sure
        they know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags area (see
        <xref linkend="svn.serverconfig"/>).  The paranoid approach,
        however, isn't usually necessary.  If a user accidentally
        commits a change to a tag directory, you can simply undo the
        change as discussed in the previous section.  This is version
        control, after all!</para>
-->
      <para>Si vous administrez un dépôt, il y a deux approches
        possibles pour gérer les étiquettes. La première approche
        est une politique de <quote>non-intervention</quote>&nbsp;:
        en tant que convention définie pour le projet, vous décidez
        où vos étiquettes sont placées et vous vous assurez que tous
        les utilisateurs savent comment traiter les répertoires qu'ils
        copient (c'est-à-dire que vous vous assurez qu'ils savent
        qu'ils ne doivent rien y propager). La seconde approche est
        plus paranoïaque&nbsp;: vous pouvez utiliser un des contrôles
        d'accès fournis avec Subversion pour empêcher que quiconque ne
        puisse faire autre chose dans la zone des étiquettes que d'y
        créer de nouvelles copies (voir le <xref
        linkend="svn.serverconfig"/>). L'approche paranoïaque n'est
        cependant pas nécessaire, en général. Si un utilisateur propage
        accidentellement une modification à un répertoire d'étiquettes,
        vous pouvez simplement revenir en arrière sur cette modification
        comme expliqué dans le paragraphe précédent. C'est ça la gestion
        de versions, après tout&nbsp;!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
<!--
      <title>Creating a Complex Tag</title>
-->
      <title>Création d'une étiquette complexe</title>

<!--
      <para>Sometimes you may want a <quote>snapshot</quote> that is
        more complicated than a single directory at a single
        revision.</para>
-->
      <para>Il vous arrivera sûrement de vouloir que votre
        <quote>instantané</quote> soit plus compliqué qu'un simple
        répertoire à une unique révision donnée.</para>

<!--
      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn
        update</command> with the <option>-r</option> option
        liberally), by switching files and directories to particular
        branches (making use of <command>svn switch</command>), or
        even just by making a bunch of local changes.  When you're
        done, your working copy is a hodgepodge of repository
        locations from different revisions.  But after testing, you
        know it's the precise combination of data you need to
        tag.</para>
-->
      <para>Par exemple, imaginons que votre projet est bien plus
        vaste que notre exemple <filename>calc</filename>&nbsp;:
        supposons qu'il contient un bon nombre de sous-dossiers et bien
        plus de fichiers encore. Au cours de votre travail, vous pouvez
        très bien décider que vous avez besoin de créer une copie de
        travail destinée à des fonctionnalités particulières et à des
        corrections de bogues. Pour cela vous pouvez antidater de
        manière sélective des fichiers ou dossiers à des révisions
        données (en utilisant généreusement <command>svn
        update</command> avec l'option <option>-r</option>), déporter
        des fichiers et des dossiers vers des branches particulières (au
        moyen de <command>svn switch</command>) ou même effectuer
        manuellement un tas de modifications locales. Quand vous en avez
        terminé, votre copie de travail est un vrai bazar, fait
        d'emplacements du dépôt à des révisions différentes. Mais après
        l'avoir testée, vous êtes alors certain que c'est l'exacte
        combinaison de données que vous vouliez étiqueter.</para>

<!--
      <para>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (see <xref linkend="svn.ref.svn.c.copy"/> in <xref
        linkend="svn.ref.svn"/>), including the ability to copy a
        working copy tree to the repository:</para>
-->
      <para>C'est alors le moment de prendre un cliché. Copier une URL
        vers une autre ne fonctionnera pas cette fois. Dans le cas
        présent, vous voulez prendre un cliché de l'arrangement exact
        de votre copie de travail et le placer dans le dépôt. Par
        chance, <command>svn copy</command> possède en fait quatre
        utilisations différentes (au sujet desquelles vous pouvez
        obtenir des informations au <xref linkend="svn.ref"/>), dont la
        possibilité de copier une arborescence de travail vers le
        dépôt&nbsp;:</para>

      <informalexample>
        <screen>
$ ls<!--
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \
           -m "Tag my existing working copy state."

Committed revision 940.
-->
ma-copie-de-travail/

$ svn copy ma-copie-de-travail \
           http://svn.exemple.com/depot/calc/tags/mon-etiquette \
           -m "Étiquette l'état de ma copie de travail existante."

Révision 940 propagée.
</screen>
      </informalexample>

<!--
      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, URLs,
        local changes, and all.</para>
-->
      <para>Désormais il y a un nouveau répertoire dans le dépôt,
        <filename>/calc/tags/mon-etiquette</filename>, qui est un
        instantané exact de votre copie de travail&nbsp;: révisions
        mixtes, URL, modifications locales et tout et
        tout&hellip;</para>

<!--
      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        directory or symlink changes), you can
        use <command>svn copy</command> to <quote>upload</quote> your
        working copy to a private area of the repository.  Your
        collaborator can then either check out a verbatim copy of your
        working copy or use <command>svn merge</command> to receive
        your exact changes.</para>
-->
      <para>D'autres utilisateurs ont trouvé des usages intéressants
        pour cette fonctionnalité. Il y a parfois des situations où
        votre copie de travail contient un paquet de modifications
        locales que vous aimeriez montrer à un collaborateur. Au lieu
        de lancer <command>svn diff</command> et d'envoyer un fichier
        patch (qui ne listera pas les modifications de répertoires,
        de liens symboliques ou de propriétés), vous pouvez utiliser
        <command>svn copy</command> pour <quote>envoyer</quote> votre
        copie de travail vers une zone privée du dépôt. Votre
        collaborateur peut ensuite soit extraire une copie carbone
        de votre copie de travail, soit utiliser <command>svn
        merge</command> pour recevoir exactement vos
        modifications.</para>

<!--
      <para>While this is a nice method for uploading a quick snapshot
        of your working copy, note that this is <emphasis>not</emphasis>
        a good way to initially create a branch.  Branch creation should
        be an event unto itself, and this method conflates the creation
        of a branch with extra changes to files, all within a single revision.
        This makes it very difficult (later on) to identify a single
        revision number as a branch point.</para>
-->
      <para>Bien que ce soit une méthode élégante pour mettre à
        disposition un instantané rapide de votre copie de travail,
        remarquez que <emphasis>ce n'est pas</emphasis> une bonne
        manière de créer une branche initialement. La création de
        branche devrait être un évènement en soi, tandis que cette
        méthode combine la création d'une branche avec des
        modifications supplémentaires apportées aux fichiers, le tout
        au sein d'une seule révision. Ceci rend très difficile
        (à terme) d'identifier un unique numéro de révision en tant
        que point de création de la branche.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
<!--
    <title>Branch Maintenance</title>
-->
    <title>Maintenance des branches</title>

<!--
    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>
-->
    <para>À ce stade, vous vous êtes certainement rendu compte que
      Subversion est extrêmement flexible. Parce qu'il implémente les
      branches et les étiquettes avec le même mécanisme sous-jacent
      (des copies de répertoires) et parce que les branches et les
      étiquettes apparaissent au sein de l'espace standard du système
      de fichiers, beaucoup de gens sont intimidés par Subversion. Il
      est presque <emphasis>trop</emphasis> flexible. Dans ce paragraphe,
      nous proposons des suggestions pour organiser et gérer vos données
      au fil du temps.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
<!--
      <title>Repository Layout</title>
-->
      <title>Agencement du dépôt</title>

<!--
      <para>There are some standard, recommended ways to organize the
        contents of a repository.  Most people create a
        <filename>trunk</filename> directory to hold the <quote>main
        line</quote> of development, a <filename>branches</filename>
        directory to contain branch copies, and
        a <filename>tags</filename> directory to contain tag copies.
        If a repository holds only one project, often people create
        these top-level directories:</para>
-->
      <para>Il existe des méthodes standard recommandées pour
        structurer un dépôt. La plupart des gens créent un répertoire
        <filename>trunk</filename> pour la <quote>ligne de développement
        principale</quote> (le tronc), un répertoire
        <filename>branches</filename> qui contiendra les copies de
        branches et un répertoire <filename>tags</filename> qui
        contiendra les copies étiquetées. Si un dépôt ne comprend qu'un
        seul projet, les gens créent souvent les dossiers suivants
        à la racine&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   trunk/
   branches/
   tags/
</literallayout>
      </informalexample>

<!--
      <para>If a repository contains multiple projects, admins
        typically index their layout by project.  See <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>, but here's an example of such a
        layout:</para>
-->
      <para>Si un dépôt contient plusieurs projets, les administrateurs
        indexent généralement la structure du dépôt par projet (voir
        <xref linkend="svn.reposadmin.projects.chooselayout"/> pour en
        savoir plus sur les <quote>dossiers racine d'un
        projet</quote>), mais en voici directement un
        exemple&nbsp;:</para>

      <informalexample>
        <literallayout>
/
   paint/
      trunk/
      branches/
      tags/
   calc/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

<!--
      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>
-->
      <para>Bien sûr, vous restez libre d'ignorer ces agencements
        courants. Vous pouvez créer toutes sortes de variantes, selon
        ce qui fonctionne le mieux pour vous ou pour votre équipe.
        Souvenez-vous que quel que soit votre choix, ce n'est pas un
        engagement définitif. Vous pouvez réorganiser votre dépôt à
        tout moment. Parce que les branches et les étiquettes sont des
        répertoires ordinaires, la commande <command>svn move</command>
        peut les déplacer ou les renommer selon vos désirs. Passer
        d'un agencement à un autre consiste juste à lancer une série
        d'opérations de déplacement côté serveur&nbsp;; si vous n'aimez
        pas la façon dont les choses sont organisées dans le dépôt,
        modifiez juste leur agencement.</para>

<!--
      <para>Remember, though, that while moving directories is
        easy to do, you need to be considerate of other users as well.
        Your juggling can disorient users with existing
        working copies.  If a user has a working copy of a particular
        repository directory and your <command>svn move</command>
        subcommand removes the path from the latest revision, then
        when the user next runs <command>svn update</command>, she is
        told that her working copy represents a path that no
        longer exists.  She is then forced to <command>svn
        switch</command> to the new location.</para>
-->
      <para>Souvenez-vous néanmoins que bien qu'il soit facile de
        déplacer des dossiers, vous devez aussi rester attentif à vos
        utilisateurs. Vos modifications sont susceptibles de déboussoler
        ceux qui ont des copies de travail existantes. Si un utilisateur
        a une copie de travail d'un répertoire donné du dépôt, votre
        opération <command>svn move</command> risque de supprimer ce
        chemin de la révision la plus récente. Lorsque par la suite
        l'utilisateur lancera <command>svn update</command>, il se verra
        annoncer que sa copie de travail pointe vers un chemin qui
        n'existe plus et sera contraint d'effectuer un <command>svn
        switch</command> vers le nouvel emplacement.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
<!--
      <title>Data Lifetimes</title>
-->
      <title>Durée de vie des données</title>

<!--
      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>
-->
      <para>Une autre fonctionnalité intéressante liée aux principes
        de fonctionnement de Subversion est que les branches et les
        étiquettes peuvent avoir des durées de vie limitées, tout
        comme n'importe quel autre élément suivi en versions. Par
        exemple, supposons que vous avez enfin terminé votre travail
        sur votre branche personnelle du projet
        <filename>calc</filename>. Après avoir fusionné toutes vos
        modifications vers <filename>/calc/trunk</filename>, le
        répertoire contenant votre branche privée n'a plus de raison
        d'exister&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 474.
-->
$ svn delete http://svn.exemple.com/depot/calc/branches/ma-branche-calc \
             -m "Suppression d'une branche obsolète du projet calc."

Révision 474 propagée.
</screen>
      </informalexample>

      <tip>
<!--
        <para>Recall from the previous section that if the repository
          location your working copy refers to is deleted, then when
          you try to update you will receive an error:</para>
-->
        <para>Rappelez-vous que, comme indiqué dans la section
          précédente, si votre copie de travail pointe vers un chemin
          du dépôt qui a été supprimé, une erreur apparaitra à la
          prochaine mise à jour&nbsp;:</para>
        <informalexample>
          <screen>
$ svn up<!--
Updating '.':
svn: E160005: Target path '/calc/branches/my-calc-branch' does not exist-->
Actualise '.' :
svn: E160005: chemin '/calc/branches/my-calc-branch' n'existe pas
</screen>
        </informalexample>

<!--
        <para>All you need to do in this situation is switch your working
          copy to a location that still exits:</para>
-->
        <para>Vous n'avez qu'à basculer votre copie de travail vers un
          chemin qui existe encore&nbsp;:</para>

        <informalexample>
          <screen>
$ svn sw ^/calc/trunk <!--
D    src/whole.c
 U   src/real.c
A    src/integer.c
 U   .
Updated to revision 474.-->
D    src/tout.c
 U   src/reel.c
A    src/entier.c
 U   .
Actualisé à la révision 474.
</screen>
        </informalexample>
      </tip>

<!--
      <para>And now your branch is gone.  Of course, it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you can still see
        your old branch.</para>
-->
      <para>Et maintenant votre branche a disparu. Bien sûr, elle n'a
        pas vraiment disparu&nbsp;: le répertoire est juste absent de
        la révision <literal>HEAD</literal>, ne gênant plus personne.
        Si vous utilisez <command>svn checkout</command>,
        <command>svn switch</command> ou <command>svn list</command>
        pour examiner une révision plus ancienne, vous pourrez toujours
        voir votre vieille branche.</para>

<!--
      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy</command> to copy it from the old
        revision:</para>
-->
      <para>Si la navigation dans votre dossier supprimé ne vous suffit
        pas, vous pouvez toujours le récupérer. Ressusciter des données
        est très facile dans Subversion. S'il y a un  dossier (ou un
        fichier) supprimé que vous aimeriez faire réapparaître dans
        <literal>HEAD</literal>, utilisez simplement <command>svn
        copy</command> pour le copier depuis l'ancienne
        révision&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn copy ^/calc/branches/my-calc-branch@473 \
           ^/calc/branches/my-calc-branch \
           -m "Restore my-calc-branch."

Committed revision 475.
-->
$ svn copy ^/calc/branches/ma-branche-calc@473 \
           ^/calc/branches/ma-branche-calc \
           -m "Restaure ma-branche-calc."

Révision 475 propagée.
</screen>
      </informalexample>

<!--
      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side by side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>
-->
      <para>Dans notre exemple, votre branche personnelle a eu une durée
        de vie relativement limitée&nbsp;: vous l'aviez peut-être créée
        pour corriger un bogue ou implémenter une nouvelle
        fonctionnalité. Quand votre tâche est finie, il en va de même
        pour la branche. Cependant, en développement logiciel, il est
        aussi courant d'avoir deux branches <quote>principales</quote>
        côte à côte pour de très longues périodes. Par exemple,
        supposons que le moment est venu de publier une version stable
        du projet <filename>calc</filename> pour le public. Vous savez
        qu'il faudra quelques mois pour éliminer les bogues du logiciel.
        Vous ne voulez pas que les gens ajoutent de nouvelles
        fonctionnalités au projet, mais vous ne voulez pas non plus dire
        à tous les développeurs d'arrêter de programmer. Donc à la
        place, vous créez une branche <quote>stable</quote> du logiciel
        qui ne changera pas beaucoup&nbsp;:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/stable-1.0 \ <!--
           -m "Creating stable branch of calc project."

Committed revision 476.
-->
           -m "Création de la branche stable du projet calc."

Révision 476 propagée.
</screen>
      </informalexample>

<!--
      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        cherrypicks bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.  We'll
        discuss this more in the next section.</para>
-->
      <para>Dès lors les développeurs sont libres de continuer à ajouter
        des fonctionnalités de pointe (ou expérimentales) à
        <filename>/calc/trunk</filename> et vous pouvez poser comme
        convention pour le projet que seules les corrections de bogues
        seront propagées dans
        <filename>/calc/branches/stable-1.0</filename>. C'est-à-dire
        qu'au fur et à mesure que les gens continuent de travailler
        sur le tronc, quelqu'un reporte de façon sélective les
        corrections de bogues vers la branche stable. Même après que la
        branche stable aura été publiée, vous continuerez probablement à
        maintenir la branche pendant longtemps, c'est-à-dire pour aussi
        longtemps que vous continuerez à fournir aux clients un support
        sur cette version. Nous évoquons ceci plus en détails dans le
        prochain paragraphe.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonpatterns">
<!--
    <title>Common Branching Patterns</title>
-->
    <title>Modèles courants de gestion des branches</title>

<!--
    <para>There are many different uses for branching and <command>svn
        merge</command>, and this section describes the most
        common.</para>
-->
    <para>Il existe de nombreux usages pour la création et la fusion
      des branches&nbsp;; ce paragraphe décrit les plus courants.</para>

<!--
    <para>Version control is most often used for software
      development, so here's a quick peek at two of the most common
      branching/merging patterns used by teams of programmers.  If
      you're not using Subversion for software development, feel
      free to skip this section.  If you're a software developer
      using version control for the first time, pay close attention,
      as these patterns are often considered best practices by
      experienced folk.  These processes aren't specific to
      Subversion; they're applicable to any version control system.
      Still, it may help to see them described in Subversion
      terms.</para>
-->
    <para>Le plus souvent, la gestion de versions est utilisée pour le
      développement de logiciels, voici donc un coup d'œil rapide à deux
      des modèles les plus courants de création et de fusion de branches
      utilisés par les équipes de programmeurs. Si vous ne vous servez
      pas de Subversion pour développer des logiciels, n'hésitez pas à
      sauter ce paragraphe. Si vous êtes un développeur de logiciels qui
      utilise la gestion de versions pour la première fois, soyez très
      attentifs, car ces modèles sont souvent considérés comme des
      bonnes pratiques par les développeurs plus expérimentés. Ces
      procédures ne sont pas spécifiques à Subversion&nbsp;; elles sont
      applicables à tout système de gestion de versions. Néanmoins, les
      voir explicitées en termes Subversion peut aider.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.release">
<!--
      <title>Release Branches</title>
-->
      <title>Branches de publication</title>

<!--
      <para>Most software has a typical life cycle: code, test,
        release, repeat.  There are two problems with this process.
        First, developers need to keep writing new features while
        quality assurance teams take time to test supposedly stable
        versions of the software.  New work cannot halt while the
        software is tested.  Second, the team almost always needs to
        support older, released versions of software; if a bug is
        discovered in the latest code, it most likely exists in
        released versions as well, and customers will want to get
        that bug fix without having to wait for a major new
        release.</para>
-->
      <para>En général un logiciel suit un cycle de vie classique,
        répétant les trois étapes suivantes en boucle&nbsp;: code, test,
        publication. Il y a deux problèmes avec ce processus.
        Premièrement, les développeurs doivent continuer à écrire de
        nouvelles fonctionnalités pendant que les équipes d'assurance
        qualité prennent le temps de tester des versions supposées
        stables du logiciel. Les nouveaux développements ne peuvent pas
        s'arrêter pendant que le logiciel est en cours de test.
        Deuxièmement, l'équipe doit presque toujours effectuer le
        support des versions anciennes et publiées du logiciel&nbsp;;
        si un bogue est découvert dans le code le plus récent, il existe
        probablement aussi dans les versions qui ont été publiées et les
        clients voudront obtenir le correctif pour ce bogue sans avoir à
        attendre la publication d'une nouvelle version majeure.</para>

<!--
      <para>Here's where version control can help.  The typical
        procedure looks like this:</para>
-->
      <para>C'est là où la gestion de versions peut s'avérer utile.
        La procédure standard ressemble à ceci&nbsp;:</para>

      <orderedlist>

        <listitem>
<!--
          <para><emphasis>Developers commit all new work to the
            trunk.</emphasis>  Day-to-day changes are committed to
            <filename>/trunk</filename>: new features, bug fixes, and
            so on.</para>
-->
          <para><emphasis>Les développeurs propagent tout nouveau
            travail vers le tronc.</emphasis> Les modifications
            quotidiennes sont propagées vers
            <filename>/trunk</filename>&nbsp;: nouvelles
            fonctionnalités, corrections de bogues,&nbsp;etc.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>The trunk is copied to a
            <quote>release</quote> branch.</emphasis>  When the team
            thinks the software is ready for release (say, a 1.0
            release), <filename>/trunk</filename> might be copied to
            <filename>/branches/1.0</filename>.</para>
-->
          <para><emphasis>Le tronc est copié vers une branche <quote>de
            publication</quote>.</emphasis> Lorsque l'équipe estime que
            le logiciel est prêt à être publié (disons en version 1.0),
            <filename>/trunk</filename> peut être copié vers
            <filename>/branches/1.0</filename>.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>Teams continue to work in
            parallel.</emphasis>  One team begins rigorous testing of
            the release branch, while another team continues new work
            (say, for version 2.0) on <filename>/trunk</filename>.  If
            bugs are discovered in either location, fixes are cherrypicked
            back and forth as necessary.  At some point, however, even
            that process stops.  The branch is <quote>frozen</quote>
            for final testing right before a release.</para>
-->
          <para><emphasis>Les équipes continuent à travailler en
            parallèle.</emphasis> Une équipe commence à tester
            rigoureusement la branche de publication, pendant qu'une
            autre équipe continue avec les nouvelles tâches (disons pour
            la version 2.0) sur <filename>/trunk</filename>. Si des
            bogues sont découverts dans l'un ou l'autre des
            emplacements, les correctifs sont reportés de l'un à l'autre
            selon les besoins. Il arrive cependant un moment où même ce
            processus s'arrête. La branche est <quote>gelée</quote> pour
            les tous derniers tests juste avant publication.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>The branch is tagged and
            released.</emphasis>  When testing is complete,
            <filename>/branches/1.0</filename> is copied to
            <filename>/tags/1.0.0</filename> as a reference
            snapshot.  The tag is packaged and released to
            customers.</para>
-->
          <para><emphasis>La branche est étiquetée et
            publiée.</emphasis> Quand les tests sont terminés,
            <filename>/branches/1.0</filename> est copiée vers
            <filename>/tags/1.0.0</filename> en tant que cliché de
            référence. L'étiquette est exportée et livrée aux
            clients.</para>
        </listitem>

        <listitem>
<!--
          <para><emphasis>The branch is maintained over
            time.</emphasis>  While work continues
            on <filename>/trunk</filename> for version 2.0, bug fixes
            continue to be ported from <filename>/trunk</filename> to
            <filename>/branches/1.0</filename>.  When enough
            bug fixes have accumulated, management may decide to do a
            1.0.1 release: <filename>/branches/1.0</filename> is
            copied to <filename>/tags/1.0.1</filename>, and the tag
            is packaged and released.</para>
-->
          <para><emphasis>La branche est gérée au fil du
            temps.</emphasis> Pendant que le travail continue sur
            <filename>/trunk</filename> en vue de la version 2.0, les
            correctifs de bogues continuent à être reportés de
            <filename>/trunk</filename> à
            <filename>/branches/1.0</filename>. Lorsque suffisamment de
            correctifs se sont accumulés, les responsables peuvent
            décider de publier une version 1.0.1&nbsp;:
            <filename>/branches/1.0</filename> est copiée vers
            <filename>/tags/1.0.1</filename> et cette étiquette est
            exportée et publiée.</para>
        </listitem>

      </orderedlist>

<!--
      <para>This entire process repeats as the software matures:
        when the 2.0 work is complete, a new 2.0 release branch is
        created, tested, tagged, and eventually released.  After
        some years, the repository ends up with a number of release
        branches in <quote>maintenance</quote> mode, and a number
        of tags representing final shipped versions.</para>
-->
      <para>Ce processus entier se répète au fur et à mesure que le
        logiciel gagne en maturité&nbsp;: quand le travail pour la
        version 2.0 est terminé, une nouvelle branche de publication
        2.0 est créée, testée, étiquetée et finalement publiée. Au
        bout de quelques années, le dépôt finit par avoir un certain
        nombre de branches de publication en mode
        <quote>maintenance</quote> et un certain nombre d'étiquettes
        représentant les versions finales publiées.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.feature">
<!--
      <title>Feature Branches</title>
-->
      <title>Branches fonctionnelles</title>

<!--
      <para>
        <indexterm>
          <primary>branches</primary>
          <secondary>feature branches</secondary>
        </indexterm>A <firstterm>feature branch</firstterm> is the sort of
        branch that's been the dominant example in this chapter (the
        one you've been working on while Sally continues to work on
        <filename>/trunk</filename>).  It's a temporary branch created
        to work on a complex change without interfering with the
        stability of <filename>/trunk</filename>.  Unlike release
        branches (which may need to be supported forever), feature
        branches are born, used for a while, merged back to the trunk,
        and then ultimately deleted.  They have a finite span of
        usefulness.</para>
-->
      <para>
        <indexterm>
          <primary>branches</primary>
          <secondary>branches fonctionnelles</secondary>
        </indexterm>Une <firstterm>branche fonctionnelle</firstterm> est
        la sorte de branche qui est l'exemple dominant dans ce chapitre
        (celle sur laquelle vous travailliez pendant que Sally
        continuait à travailler sur <filename>/trunk</filename>). C'est
        une branche temporaire créée pour travailler sur un changement
        complexe sans interférer avec la stabilité de
        <filename>/trunk</filename>. À la différence des branches de
        publication (dont le support doit parfois être prolongé très
        longtemps), les branches fonctionnelles naissent, sont utilisées
        pendant un temps, sont fusionnées vers le tronc et sont
        finalement supprimées. Elles ont une utilité limitée dans le
        temps.</para>

<!--
      <para>Again, project policies vary widely concerning exactly
        when it's appropriate to create a feature branch.  Some
        projects never use feature branches at all: commits to
        <filename>/trunk</filename> are a free-for-all.  The
        advantage to this system is that it's simple&mdash;nobody
        needs to learn about branching or merging.  The disadvantage
        is that the trunk code is often unstable or unusable.  Other
        projects use branches to an extreme: no change is
        <emphasis>ever</emphasis> committed to the trunk directly.
        Even the most trivial changes are created on a short-lived
        branch, carefully reviewed, and merged to the trunk.  Then
        the branch is deleted.  This system guarantees an
        exceptionally stable and usable trunk at all times, but at
        the cost of tremendous process overhead.</para>
-->
      <para>Encore une fois, les stratégies varient énormément au
        sujet du moment approprié pour créer une branche fonctionnelle.
        Certains projets n'utilisent jamais de branche
        fonctionnelle&nbsp;: n'importe qui peut propager des
        modifications à <filename>/trunk</filename>. L'avantage de ce
        système est qu'il est simple&nbsp;: personne n'a besoin d'être
        formé aux branches ou aux fusions. L'inconvénient est que le
        code du tronc est souvent instable ou inutilisable. D'autres
        projets utilisent les branches à l'extrême&nbsp;: une
        modification n'est <emphasis>jamais</emphasis> propagée
        directement dans le tronc. Même les modifications les plus
        triviales sont faites au sein d'une branche à courte durée de
        vie, vérifiées attentivement, puis fusionnées vers le tronc.
        La branche est ensuite supprimée. Ce système garantit que le
        tronc restera exceptionnellement stable et utilisable à tout
        moment, mais aux dépens des coûts de gestion liés à cette
        procédure très lourde.</para>

<!--
      <para>Most projects take a middle-of-the-road approach.  They
        commonly insist that <filename>/trunk</filename> compile and
        pass regression tests at all times.  A feature branch is
        required only when a change requires a large number of
        destabilizing commits.  A good rule of thumb is to ask this
        question: if the developer worked for days in isolation and
        then committed the large change all at once (so that
        <filename>/trunk</filename> were never destabilized), would it
        be too large a change to review?  If the answer to that
        question is <quote>yes,</quote> the change should be
        developed on a feature branch.  As the developer commits
        incremental changes to the branch, they can be easily reviewed
        by peers.</para>
-->
      <para>En général, les projets choisissent une approche à mi-chemin
        entre les deux. Ils insistent généralement pour qu'à tout
        moment <filename>/trunk</filename> puisse être compilé et
        passe avec succès les tests de régression. Une branche
        fonctionnelle n'est nécessaire que quand une modification
        nécessite un grand nombre de propagations susceptibles de
        déstabiliser le tronc. Une bonne méthode empirique est de se
        poser la question suivante&nbsp;: si le développeur
        travaillait pendant plusieurs jours en isolation et ensuite
        propageait cette grosse modification en une seule fois
        (afin que <filename>/trunk</filename> ne soit jamais
        déstabilisé), est-ce que ce serait une modification trop
        grosse à vérifier&nbsp;? Si la réponse à cette question est
        <quote>oui</quote>, alors la modification devrait être
        développée sur une branche fonctionnelle. Au fur et à mesure
        que le développeur propage ses modifications incrémentales dans
        la branche, elles peuvent facilement être vérifiées par ses
        pairs.</para>

<!--
      <para>Finally, there's the issue of how to best keep a feature
        branch in <quote>sync</quote> with the trunk as work
        progresses.  As we mentioned earlier, there's a great risk to
        working on a branch for weeks or months; trunk changes may
        continue to pour in, to the point where the two lines of
        development differ so greatly that it may become a nightmare
        trying to merge the branch back to the trunk.</para>
-->
      <para>Finalement, il reste la question de savoir quelle est la
        meilleure méthode pour garder une branche synchronisée avec le
        tronc au fur et à mesure que le travail avance. Comme nous
        l'avons mentionné précédemment, il est très risqué de
        travailler sur une branche pendant des semaines ou
        des mois&nbsp;; le tronc continuera sûrement à recevoir des
        modifications, au point que les deux lignes de développement
        risquent de s'éloigner tellement l'une de l'autre qu'essayer
        de fusionner la branche vers le tronc devienne un
        cauchemar.</para>

<!--
      <para>This situation is best avoided by regularly running an
        automatic merge from trunk to the branch.  Make up a policy:
        once a week, merge the last week's worth of trunk changes to
        the branch.</para>
-->
      <para>Le mieux pour éviter une telle situation est de fusionner
        régulièrement les modifications du tronc vers la branche.
        Faites-en une habitude&nbsp;: une fois par semaine, fusionnez
        les modifications du tronc de la semaine précédente vers la
        branche.</para>

<!--
      <para>When you are eventually ready to merge the
        <quote>synchronized</quote> feature branch back to the trunk,
        begin by doing a final automatic merge of the latest trunk
        changes to the branch.  When that's done, the latest versions
        of branch and trunk are absolutely identical except for
        your branch changes.  You can then run an automatic reintegrate
        merge from the branch back to the trunk:</para>
-->
      <para>Le moment arrivera où vous serez prêt à fusionner la branche
        fonctionnelle <quote>synchronisée</quote> vers le tronc.
        Commencez donc par effectuer une dernière fusion des
        modifications les plus récentes du tronc vers la branche. Une
        fois que c'est fait, les dernières versions de la branche et du
        tronc sont absolument identiques, mises à part vos propres
        modifications sur la branche. Vous êtes alors en mesure de
        lancer une fusion automatique de réintégration de la branche
        vers le tronc&nbsp;:</para>

      <informalexample>
        <screen><!--
$ cd trunk-working-copy

$ svn update
Updating '.':
At revision 1910.

$ svn merge ^/calc/branches/mybranch
- - Merging differences between repository URLs into '.':
-->
$ cd copie-de-travail-du-tronc

$ svn update
À la révision 1910.

$ svn merge ^/calc/branches/ma-branche
--- Fusion des différences des URLs du dépôt vers '.':
U    reel.c
U    entier.c
A    nouveau-dossier
A    nouveau-dossier/nouveau-fichier
 U   .
&hellip;
</screen>
      </informalexample>

<!--
      <para>Another way of thinking about this pattern is that your
        weekly sync of trunk to branch is analogous to running
        <command>svn update</command> in a working copy, while the
        final merge step is analogous to running <command>svn
        commit</command> from a working copy.  After all, what else
        <emphasis>is</emphasis> a working copy but a very shallow
        private branch?  It's a branch that's capable of
        storing only one change at a time.</para>
-->
      <para>Une autre façon de concevoir ce modèle est d'imaginer que
        votre synchronisation hebdomadaire du tronc vers la branche
        est analogue au lancement de <command>svn update</command>
        dans une copie de travail, tandis que l'étape finale de fusion
        est analogue au lancement de <command>svn commit</command>
        depuis une copie de travail. Après tout, une copie de travail
        n'est rien d'autre qu'une branche privée très
        superficielle&nbsp;: c'est une branche qui n'est capable de ne
        contenir qu'une seule modification à la fois.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
<!--
    <title>Vendor Branches</title>
-->
    <title>Branches fournisseurs</title>

<!--
    <para>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&mdash;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</para>
-->
    <para>
      <indexterm>
        <primary>branches</primary>
        <secondary>branches fournisseurs</secondary>
      </indexterm>Comme c'est particulièrement le cas en développement
      logiciel, les données que vous gérez dans votre système de
      gestion de versions ont souvent un lien étroit avec les données
      de quelqu'un d'autre, ou en sont peut-être dépendantes.
      Généralement, les besoins de votre projet vous obligent à rester
      aussi à jour que possible avec les données fournies par cette
      entité externe, sans sacrifier la stabilité de votre propre
      projet. Ce scénario arrive très souvent, partout où les
      informations générées par un groupe de personnes ont un effet
      direct sur celles qui sont générées par un autre groupe de
      personnes.</para>

<!--
    <para>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see <xref linkend="svn.developer.usingapi.apr" />).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <quote>bleeding edge</quote> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</para>
-->
    <para>Par exemple, il arrive que des développeurs de logiciel
      travaillent sur une application qui utilise une bibliothèque
      tierce. Subversion a justement une relation de ce type avec la
      bibliothèque Apache Portable Runtime (APR) (voir
      <xref linkend="svn.developer.usingapi.apr" />). Le code source
      de Subversion dépend de la bibliothèque APR pour tous ses
      besoins de portabilité. Durant les étapes initiales de
      développement de Subversion, le projet suivait les changements
      de l'interface de programmation d'APR de près, restant toujours
      <quote>à la pointe</quote> des évolutions du code de la
      bibliothèque. Maintenant que APR et Subversion ont tous deux
      gagné en maturité, Subversion n'essaie de se synchroniser avec
      l'interface de programmation de l'APR qu'à des étapes de
      publication stables et bien testées.</para>

<!--
    <para>Now, if your project depends on someone else's information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions of
      that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <quote>pin down</quote> specific
      versions of that information to some location in your own
      working copy (see <xref linkend="svn.advanced.externals"
      />).</para>
-->
    <para>Donc, si votre projet dépend des informations de quelqu'un
      d'autre, vous pourriez tenter de synchroniser ces informations
      avec les vôtres de plusieurs manières. La plus pénible serait de
      donner des instructions orales ou écrites à tous les
      contributeurs de votre projet, leur demandant de s'assurer
      qu'ils disposent des bonnes versions de ces informations tierces
      dont votre projet a besoin. Si les informations tierces sont
      gérées dans un dépôt Subversion, vous pourriez aussi utiliser
      les définitions externes de Subversion pour en fait
      <quote>agrafer</quote> des versions spécifiques de ces
      informations à un endroit quelconque dans le dossier de votre
      copie de travail (voir <xref
      linkend="svn.advanced.externals"/>).</para>

<!--
    <para>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</para>
-->
    <para>Mais parfois vous voulez gérer des modifications
      personnalisées de ce code tierce à l'intérieur de votre propre
      système de gestion de versions. En reprenant l'exemple du
      développement logiciel, les programmeurs peuvent vouloir
      apporter des modifications à cette bibliothèque tierce pour
      leurs propres besoins. Ces modifications incluent peut-être
      de nouvelles fonctionnalités ou des corrections de bogues,
      gérées en interne seulement jusqu'à ce qu'elles soient incluses
      dans une version officielle de la bibliothèque tierce. Ou alors
      ces changements ne seront peut-être jamais remontés vers ceux qui
      gèrent cette bibliothèque, existant seulement en tant
      qu'optimisations <quote>maison</quote> permettant de mieux adapter
      la bibliothèque aux besoin des développeurs du logiciel.</para>

<!--
    <para>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</para>
-->
    <para>À présent vous êtes face à une situation intéressante. Votre
      projet pourrait héberger ses modifications maison des données
      tierces de manière désordonnée, par exemple en utilisant
      des correctifs de type patch ou des versions alternatives complètes des
      fichiers et dossiers. Mais ces méthodes deviennent rapidement de
      vrais casse-tête à gérer, nécessitant des mécanismes pour reporter
      vos modifications maison au code tierce et nécessitant le report
      de ces modifications à chaque version successive du code tierce
      dont vous dépendez.</para>

<!--
    <para>
      <indexterm>
        <primary>vendor drop</primary>
      </indexterm>The solution to this problem is to
      use <firstterm>vendor branches</firstterm>.  A vendor branch is
      a directory tree in your own version control system that
      contains information provided by a third-party entity, or
      vendor.  Each version of the vendor's data that you decide to
      absorb into your project is called a <firstterm>vendor
      drop</firstterm>.</para>
-->
    <para>
      <indexterm>
        <primary>livraisons fournisseurs</primary>
      </indexterm>La solution de ce problème est d'utiliser des
      <firstterm>branches fournisseurs</firstterm>. Une branche
      fournisseur est une arborescence au sein de votre propre système
      de gestion de versions qui contient des informations fournies par
      une entité tierce, ou fournisseur. Chaque version des données du
      fournisseur que vous décidez d'incorporer dans votre projet est
      appelée une <firstterm>livraison fournisseur</firstterm>.</para>

<!--
    <para>Vendor branches provide two benefits.  First, by storing the
      currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need
      to question whether they have the right version of the vendor's
      data.  They simply receive that correct version as part of their
      regular working copy updates.  Second, because the data lives in
      your own Subversion repository, you can store your custom
      changes to it in-place&mdash;you have no more need of an
      automated (or worse, manual) method for swapping in your
      customizations.</para>
-->
    <para>Les branches fournisseur présentent deux avantages.
      Premièrement, en incluant la livraison fournisseur actuellement
      supportée dans votre propre système de gestion de versions, vous
      avez la garantie que les membres de votre projet n'auront jamais
      besoin de se demander s'ils ont la bonne version des données du
      fournisseur. Ils reçoivent simplement la bonne version pendant
      les mises à jour usuelles de leur copie de travail. Deuxièmement,
      parce que ces données font partie de votre propre dépôt
      Subversion, vous pouvez y conserver vos modifications
      maison&nbsp;: vous n'avez plus besoin d'une méthode automatisée
      (ou pire, manuelle) pour reporter vos propres changements.</para>

<!--
    <para>Unfortunately, there is no single best way to manage vendor
      branches in Subversion.  The flexibility of the system offers
      several different approaches, each of which has its advantages
      and disadvantages, and none of which can be clearly considered
      a <quote>silver bullet</quote> for the problem.  We'll cover a
      few of these approaches at a high level in the following
      sections, using the common example of a software project which
      depends on a third-party library.</para>
-->
    <para>Malheureusement, il n'existe pas de <quote>meilleure</quote>
      façon pour gérer les branches fournisseurs dans Subversion. La
      flexibilité offerte par le système permet plusieurs approches
      différentes, chacune ayant ses avantages et ses inconvénients, et
      aucune ne peut être considérée comme <quote>la méthode qui
      tue</quote> pour ce problème. Nous allons décrire quelques unes
      des approches sans rentrer dans les détails dans les paragraphes
      qui suivent, en prenant comme exemple un projet logiciel qui
      dépend d'une bibliothèque tierce. </para>

<!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
<!--
      <title>General Vendor Branch Management Procedure</title>
-->
      <title>Procédure générale de gestion des branches
        fournisseurs</title>

<!--
      <para>Maintaining customizations to a third-party library
        involves three data sources: the version of the third-party
        library upon which your modifications were last based, the
        customized version (that is, the actual vendor branch) of that
        library which is used by your project, and any new version of
        the vendor's library to which you may be hoping to upgrade.
        Managing the vendor branch (which should live within your
        source code repository per our definition of the thing), then,
        essentially boils down to performing merge operations (in the
        general sense).  But different teams take different approaches
        to the other data sources&mdash;the pristine versions of the
        third-party library code.  Thus, there are likewise different
        specific ways to perform the requisite merges.</para>
-->
      <para>Gérer des modifications personnalisées d'une bibliothèque
        tierce met en jeu trois sources de données&nbsp;: la version de
        la bibliothèque tierce sur laquelle vos modifications ont porté
        la dernière fois, la version personnalisée (c'est-à-dire la
        branche fournisseur actuelle) de cette bibliothèque qui est
        utilisée par votre projet et toute nouvelle version de la
        bibliothèque externe dont vous espérez sûrement effectuer la
        mise à niveau. Gérer la branche fournisseur (qui doit résider
        dans le dépôt de votre code source, par définition) consiste
        alors essentiellement à effectuer des fusions (au sens général
        du terme). Mais chaque équipe peut choisir sa méthode pour ce
        qui concerne les autres sources de données&nbsp;: les versions
        originales du code source de la bibliothèque tierce. Donc, nous
        avons plusieurs façons pour effectuer les fusions
        requises.</para>

<!--
      <para>Strictly speaking, there are a couple of different ways
        that those merges can be performed in the general sense.  For
        the sake of simplicity and with the goal of at least providing
        <emphasis>something</emphasis> concrete in this section of the
        book, we'll assume that there is but a single vendor branch
        which is upgraded to each successive new release of the
        third-party library by receiving updates that describe the
        differences between the current and new pristine versions of
        that library.</para>
-->
      <para><foreignphrase>Stricto sensu</foreignphrase>, il existe
        deux façons de faire ces fusions. Afin de simplifier et de
        rester concret dans ce paragraphe, nous supposons qu'il n'y a
        qu'une seule branche fournisseur qui est mise à niveau lors de
        chaque mise à jour des bibliothèques tierces (qui décrivent les
        différences entre les versions courantes et les nouvelles
        versions des sources de la bibliothèque).</para>

<!--
      <note>
        <para>Another approach is to create new vendor branches for
          each successive pristine library version, applying the
          differences between the current pristine library and the
          customized version thereof (from the current vendor branch)
          to the new branch.  There's nothing wrong with that
          approach&mdash;we just don't feel compelled to document
          every legitimate possibility in this space.</para>
      </note>
-->
      <note>
        <para>Une autre approche est de créer une nouvelle branche
         fournisseur pour chaque version de la bibliothèque, en
         appliquant les différences entre la bibliothèque originale
         courante et la version personnalisée vers la nouvelle branche.
         Cette approche n'est pas mauvaise, nous ne nous sentons juste
         pas obligés de documenter ici toutes les façons de
         faire.</para>
      </note>

<!--
      <para>The following sections examine how to create and manage a
        vendor branch in a few different scenarios.  In the examples
        which follow, we'll assume that the third-party library is
        called libcomplex, and that we will be implementing a vendor
        branch based on libcomplex 1.0.0 which lives in our repository
        at <filename>^/vendor/libcomplex-custom</filename>.  We'll
        then look at how we can upgrade to libcomplex 1.0.1 while
        still preserving our customizations to the library.</para>
-->
      <para>Les paragraphes suivants décrivent comment créer et gérer
        une branche fournisseur suivant quelques scénarios différents.
        Dans les exemples qui suivent, nous supposons que la
        bibliothèque tierce s'appelle libcomplex et que nous allons
        implémenter une branche fournisseur basée sur libcomplex 1.0.0
        qui est stockée dans notre dépôt à l'emplacement
        <filename>^/vendor/libcomplex-perso</filename>. Nous allons voir
        comment nous pouvons mettre à niveau vers libcomplex 1.0.1 tout
        en préservant nos personnalisations de cette
        bibliothèque.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.foreign-repos">
<!--
      <title>Vendor Branches from Foreign Repositories</title>
-->
      <title>Branches fournisseurs depuis des dépôts externes</title>

<!--
      <para>Let's look first at a vendor branch management approach
        that is possible when the original third-party library is
        itself Subversion-accessible.  For the sake of the example,
        we'll assume that the libcomplex library we previously
        discussed is developed in a publicly accessible Subversion
        repository, and that its developers use sane release
        procedures which include the creation of tags for each stable
        release version.</para>
-->
      <para>Dans un premier temps, regardons comment gérer une branche
        fournisseur lorsque la bibliothèque originale est accessible par
        Subversion. Pour les besoins de cet exemple, nous allons
        considérer que la bibliothèque libcomplex dont nous avons parlé
        est développée dans un dépôt Subversion librement accessible et
        que les développeurs utilisent une procédure de publication de
        bon aloi qui comporte la création d'une étiquette pour chaque
        version stable publiée.</para>

<!--
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>foreign repository merges</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository merges</primary>
          <see>merging, foreign repository merges</see>
        </indexterm>
        <indexterm>
          <primary>copying</primary>
          <secondary>foreign repository copies</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository copies</primary>
          <see>copying, foreign repository copies</see>
        </indexterm>Since Subversion 1.5, <command>svn merge</command>
        has been able to perform so-called <firstterm>foreign
        repository merges</firstterm>, where the sources of the merge
        live in a different repository than the repository from which
        the merge target working copy was checked out.  And in
        Subversion 1.8, the behavior of <command>svn copy</command>
        was changed so that when you perform a copy from a foreign
        repository into an existing working copy, the resulting tree
        is incorporated into that working copy and scheduled for
        addition.  It's this <firstterm>foreign repository
        copy</firstterm> functionality that we'll use to bootstrap our
        vendor branch.</para>
-->
      <para>
        <indexterm>
          <primary>fusions</primary>
          <secondary>fusions avec un dépôt externe</secondary>
        </indexterm>
        <indexterm>
          <primary>fusions avec un dépôt externe</primary>
          <see>fusions, fusions avec un dépôt externe</see>
        </indexterm>
        <indexterm>
          <primary>copie</primary>
          <secondary>copie à partir d'un dépôt externe</secondary>
        </indexterm>
        <indexterm>
          <primary>copie à partir d'un dépôt externe</primary>
          <see>copie, copie à partir d'un dépôt externe</see>
        </indexterm>Depuis Subversion 1.5, la sous-commande <command>svn
        merge</command> est capable d'effectuer ce que l'on appelle des
        <firstterm>fusions avec un dépôt externe</firstterm>, où les
        sources de la fusion sont stockées dans un dépôt différent du
        dépôt dont la copie de travail, cible de la fusion, a été
        extraite. Et dans Subversion 1.8, le comportement de
        <command>svn copy</command> a été modifié de manière à ce que
        l'arborescence résultante d'une copie depuis un dépôt externe
        vers une copie de travail existante soit incorporée dans cette
        copie de travail et placée pour ajout lors de la prochaine
        propagation. C'est cette fonctionnalité de  <firstterm>copie à
        partir d'un dépôt externe</firstterm> que nous allons utiliser
        pour initier notre branche fournisseur.</para>

<!--
      <para>So let's create our vendor branch.  We'll begin by
        creating a placeholder directory for all such vendor branches
        in our repository, and then checking out a working copy of
        that location.</para>
-->
      <para>Créons donc notre branche fournisseur. Nous commençons par
        créer un dossier d'accueil pour toutes les branches fournisseurs
        dans notre dépôt puis nous extrayons une copie de travail à cet
        emplacement.</para>

      <informalexample>
        <screen><!--
$ svn mkdir http://svn.example.com/projects/vendor \
            -m "Create a container for vendor branches."
Committed revision 1160.-->
$ svn mkdir http://svn.exemple.com/projets/vendor \
            -m "Création d'un conteneur pour les branches fournisseurs."
Révision 1160 propagée.<!--
$ svn checkout http://svn.example.com/projects/vendor \
               /path/to/vendor
Checked out revision 1160.-->
$ svn checkout http://svn.exemple.com/projets/vendor \
               /chemin/vers/fournisseur
Révision 1160 extraite.
$
</screen>
      </informalexample>

<!--
      <para>Now, we'll take advantage of Subversion's foreign
        repository copy support to get an exact copy of libcomplex
        1.0.0&mdash;including any Subversion properties stored on its
        files and directories&mdash;from the vendor repository.</para>
-->
      <para>Maintenant nous allons profiter de la capacité de Subversion
        à copier un dépôt externe pour obtenir une copie exacte de
        libcomplex 1.0.0 (y compris les propriétés Subversion stockées
        dans ces fichiers et dossiers) à partir du dépôt du
        fournisseur.</para>

      <informalexample>
        <screen><!--
$ cd /path/to/vendor
$ svn copy http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
           libcomplex-custom
- - Copying from foreign repository URL 'http://svn.othervendor.com/repos/lib\
complex/tags/1.0.0':-->
$ cd /chemin/vers/fournisseur
$ svn copy http://svn.monfournisseur.fr/depot/libcomplex/tags/1.0.0 \
           libcomplex-perso
--- Copying from foreign repository URL 'http://svn.monfournisseur.fr/depot/libcomplex/tags/1.0.0' :
A    libcomplex-perso
A    libcomplex-perso/README
A    libcomplex-perso/LICENSE
&hellip;
A    libcomplex-perso/src/code.c
A    libcomplex-perso/tests
A    libcomplex-perso/tests/TODO<!--
$ svn commit -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1161.-->
$ svn commit -m "Initialisation de la branche fournisseur libcomplex avec libcomplex 1.0.0."
Ajout         libcomplex-custom
Ajout         libcomplex-custom/README
Ajout         libcomplex-custom/LICENSE
&hellip;
Ajout         libcomplex-custom/src
Ajout         libcomplex-custom/src/code.h
Ajout         libcomplex-custom/src/code.c
Transmission des données .......................................
Révision 1161 propagée.
$
</screen>
      </informalexample>

      <note>
<!--
        <para>If you happen to be using an older version of
          Subversion, the closest available approximation of the new
          foreign repository copy support in <command>svn
          copy</command> is to instead import (via <command>svn
          import</command>) a working copy of the vendor's tag,
          including the <option>- -no-auto-props</option>
          and <option>- -no-ignore</option> options so that the
          complete tree and any of its versioned properties are
          accurately replicated in your own repository.</para>
-->
        <para>Si vous êtes amené à utiliser une vieille version de
          Subversion, la meilleure façon d'approcher cette nouvelle
          fonctionnalité de <command>svn copy</command> est d'importer
          une copie de travail (avec <command>svn import</command>) de
          la version étiquetée du fournisseur, en spécifiant bien les
          options <option>--no-auto-props</option> et
          <option>--no-ignore</option> pour que l'arborescence complète
          et les propriétés suivies en versions soient correctement
          répliquées dans votre propre dépôt.</para>
      </note>

<!--
      <para>Now that we have a vendor branch based on libcomplex 1.0.0,
        we can begin making the customizations to libcomplex required
        for our purposes, committing them directly to the vendor
        branch we've created.  And of course, we can begin using
        libcomplex in our own application.</para>
-->
      <para>Maintenant que nous avons la branche fournisseur basée sur
        libcomplex 1.0.0, nous pouvons commencer à personnaliser
        libcomplex pour satisfaire nos besoins, en propageant les
        modifications directement vers la branche fournisseur que nous
        avons créée. Et bien sûr, nous pouvons commencer à utiliser
        libcomplex dans notre propre application.</para>

<!--
      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  Here is where Subversion's
        foreign repository merge operation is useful.  We have in our
        vendor branch the original libcomplex 1.0.0 plus our
        customizations to it.  What we need now is to get the set of
        changes the vendor has made between 1.0.0 and 1.0.1 into our
        vendor branch, ideally without clobbering our own
        customizations.  This is precisely what the 2-URL form of
        the <command>svn merge</command> command is for.</para>
-->
      <para>Quelques temps plus tard, les développeurs de
        libcomplex publient une nouvelle version de leur bibliothèque,
        la version 1.0.1. Après avoir passé en revue les modifications,
        nous décidons de mettre à niveau notre branche fournisseur vers
        cette nouvelle version. Et c'est ici que l'opération de fusion
        à partir d'un dépôt externe de Subversion est utile. Nous avons
        dans notre branche fournisseur la libcomplex 1.0.0 originale
        plus nos personnalisations. Nous avons besoin maintenant
        d'y insérer l'ensemble des modifications que le fournisseur a
        effectué entre 1.0.0 et 1.0.1, idéalement sans fracasser nos
        personnalisations. C'est précisément ce que la forme de
        <command>svn merge</command> à 2-URL sait faire.</para>

      <informalexample>
        <screen><!--
$ cd /path/to/vendor
$ svn merge http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
            http://svn.othervendor.com/repos/libcomplex/tags/1.0.1 \
            libcomplex-custom
- - Merging differences between foreign repository URLs into '.':
U    libcomplex-custom/src/code.h
C    libcomplex-custom/src/code.c
U    libcomplex-custom/README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'libcomplex-custom/src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: -->
$ cd /chemin/vers/fournisseur
$ svn merge http://svn.autrefournisseur.com/depot/libcomplex/tags/1.0.0 \
            http://svn.autrefournisseur.com/depot/libcomplex/tags/1.0.1 \
            libcomplex-perso
-- Fusion des différences des URLs du dépôt externe dans '.':
U    libcomplex-perso/src/code.h
C    libcomplex-perso/src/code.c
U    libcomplex-perso/README
Résumé des conflits :
  Text conflicts: 1
Conflit découvert dans le fichier 'libcomplex-custom/src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options:
</screen>
      </informalexample>

<!--
      <para>As you can see, <command>svn merge</command> has merged
        the changes required to make libcomplex 1.0.0 look like
        libcomplex 1.0.1 into our working copy.  In our example, it has
        even noticed and flagged a conflict on one file.   It seems
        the vendor modified a region of one of the files we also
        customized.  Subversion safely detects this conflict, and
        gives us the opportunity to resolve it so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  (See <xref linkend="svn.tour.cycle.resolve" />
        for more on resolving conflicts of this sort.)</para>
-->
      <para>Comme vous pouvez le constater, <command>svn merge</command>
        a fusionné les modifications pour obtenir libcomplex 1.0.1 à
        partir de libcomplex 1.0.0 dans votre copie de travail. Dans cet
        exemple, il a même découvert et marqué un fichier comme étant en
        conflit. Il semble que le fournisseur a modifié une zone d'un
        des fichiers que nous avons personnalisé. Subversion détecte ce
        conflit et nous donne la possibilité de le résoudre de manière
        sécurisée, c'est-à-dire que nos modifications à ce qui est
        maintenant libcomplex 1.0.1 puissent continuer à faire sens.
        Pour plus d'informations sur la résolution des conflits de ce
        type, reportez-vous à <xref
        linkend="svn.tour.cycle.resolve" />.</para>

<!--
      <para>Once we've resolved the conflicts and performed any
        testing or review we need, we can commit the changes to our
        vendor branch.</para>
-->
      <para>Une fois que nous avons résolu les conflits et effectué nos
        tests ou passé en revue ce que est nécessaire, nous pouvons
        propager les modifications vers notre branche
        fournisseur.</para>

      <informalexample>
        <screen> <!--
$ svn status libcomplex-custom
M       libcomplex-custom/src/code.h
M       libcomplex-custom/src/code.c
M       libcomplex-custom/README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-custom
Sending        libcomplex-custom/README
Sending        libcomplex-custom/src/code.h
Sending        libcomplex-custom/src/code.c
Transmitting file data ...
Committed revision 1282.-->
$ svn status libcomplex-perso
M       libcomplex-perso/src/code.h
M       libcomplex-perso/src/code.c
M       libcomplex-perso/README
$ svn commit -m "Mise à niveau de la branche fournisseur vers libcomplex 1.0.1." \
             libcomplex-perso
Sending        libcomplex-perso/README
Sending        libcomplex-perso/src/code.h
Sending        libcomplex-perso/src/code.c
Transmission des données ...
Révision 1282 propagée.
$
</screen>
      </informalexample>

<!--
      <para>That, in a nutshell, is how to manage vendor branches when
        the original source is Subversion-accessible.  There are some
        notable shortcomings, though.  First, foreign repository
        merges are not automatically tracked by Subversion itself like
        same-repository merges are.  This means the burden falls to
        the user to know which merges have been performed on their
        vendor branch, and just how to construct the next merge when
        upgrading that branch.  Also, as is the case for all of
        Subversion's merge support, renames in the merge sources can
        cause no small amount of complication and frustration.
        Unfortunately, at this time, we don't have a particularly
        solid recommendation to offer to alleviate that pain.</para>
-->
      <para>Voilà, à grosses mailles, comment gérer des branches
        fournisseurs quand les sources originales sont accessible par
        Subversion. Il faut noter quand même quelques manques. D'abord,
        les fusions de dépôts externes ne sont pas automatiquement
        tracées par Subversion lui-même comme le sont les fusions
        internes au dépôt. Cela veut dire que c'est à l'utilisateur de
        savoir quels changements ont été appliqués sur la branche
        fournisseur et de construire lui-même la prochaine fusion pour
        mettre à niveau la branche. De plus, comme c'est le cas pour
        toutes les fusions faites par Subversion, les renommages à
        l'intérieur des sources de la fusion peuvent entrainer certaines
        complications et frustrations. Malheureusement, à l'heure
        actuelle, nous n'avons pas de recommandation particulière
        réellement valable pour vous soulager dans ce cas.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.mirrored-sources">
<!--
      <title>Vendor Branches from Mirrored Sources</title>
-->
      <title>Branches fournisseurs à partir de sources mirroirs</title>

<!--
      <para>In the previous section
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) we
        looked at how to implement and maintain a vendor branch when
        the vendor drops are accessible via Subversion, which is the
        ideal scenario when it comes to vendor branches.  Subversion
        is pretty good at handling merges of stuff that's been
        Subversion-managed.  Unfortunately, it's not always the case
        that third-party libraries are publicly accessible via
        Subversion.  Many times, a project depends on a library which
        is delivered via only non-Subversion mechanisms, such as a
        source code release distribution tarball.  In such
        circumstances, we strongly recommend that you do all you can
        to get that non-Subversion information into Subversion as
        cleanly as possible.  So let's examine an approach to vendor
        branches in which the third-party library's various releases
        are mirrored within our own repository.</para>
-->
      <para>Dans le paragraphe précédent (<xref
        linkend="svn.advanced.vendorbr.foreign-repos" />) nous avons vu
        comment implémenter et maintenir une branche fournisseur quand
        celui-ci fournit un accès <foreignphrase>via</foreignphrase>
        Subversion, ce qui est le scénario idéal pour les branches
        fournisseurs. Subversion se distingue particulièrement lorsqu'il
        s'agit de fusionner des contenus gérés par Subversion.
        Malheureusement, ce n'est pas toujours le cas. Souvent, un
        projet dépend d'une bibliothèque qui n'est accessible que
        <foreignphrase>via</foreignphrase> des mécanismes
        non-Subversion, tels que des archives compressées de code
        source. Dans ces circonstances, nous recommandons fortement
        de faire tout ce que vous pouvez pour insérer ces données
        non-Subversion dans Subversion de la manière la plus propre
        possible. Examinons donc une approche de branche fournisseur
        dans laquelle les différentes versions de la bibliothèque tierce
        sont répliquées dans votre propre dépôt.</para>

<!--
      <para>Setting up the vendor branch the first time is pretty
        simple, really.  For our example, we'll assume that libcomplex
        1.0.0 is delivered via the common tarball mechanism.  To
        create our vendor branch, we'll first get the contents of the
        libcomplex 1.0.0 tarball into our repository as a read-only
        (by convention only) vendor tag of sorts.</para>
-->
      <para>Configurer la branche fournisseur pour la première fois est
        très simple, vraiment. Dans notre exemple, nous considérons
        que libcomplex 1.0.0 est fournie dans une archive compressée
        classique. Pour créer notre branche fournisseur, nous allons
        dans un premier temps copier le contenu de l'archive dans notre
        dépôt comme une sorte d'arborescence étiquetée fournisseur en
        lecture seule (par convention uniquement).</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.0.tar.gz
libcomplex-1.0.0/
libcomplex-1.0.0/README
libcomplex-1.0.0/LICENSE
&hellip;
libcomplex-1.0.0/src/code.c
libcomplex-1.0.0/tests
libcomplex-1.0.0/tests/TODO
$ svn import libcomplex-1.0.0 \<!--
             http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
             - -no-ignore - -no-auto-props \
             -m "Import libcomplex 1.0.0 sources."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1160.-->
             http://svn.exemple.com/projets/vendor/libcomplex-1.0.0 \
             --no-ignore --no-auto-props \
             -m "import des sources de libcomplex 1.0.0."
Ajout         libcomplex-custom
Ajout         libcomplex-custom/README
Ajout         libcomplex-custom/LICENSE
&hellip;
Ajout         libcomplex-custom/src
Ajout         libcomplex-custom/src/code.h
Ajout         libcomplex-custom/src/code.c
Transmission des données .......................................
Révision 1160 propagée.
$
</screen>
      </informalexample>

<!--
      <para>Note that in our example, we used
        the <option>- -no-ignore</option> option during import so that
        Subversion is sure to pick up every file in the vendor drop
        and not to omit any of them.  We also supply
        the <option>- -no-auto-props</option> option so that our client
        doesn't manufacture property information which isn't present
        in the vendor drop.<footnote><para>Technically, we could let
        the auto-props feature do its thing, but the key to making
        that work well is ensuring that each vendor drop gets
        identical auto-prop treatment.</para></footnote>.</para>
-->
      <para>Notez que dans l'exemple, nous avons utilisé l'option
        <option>--no-ignore</option> pour l'import de manière à ce que
        Subversion récupère bien tous les fichiers de la livraison. Nous
        avons également utilisé l'option
        <option>--no-auto-props</option> afin que notre client n'affecte
        pas de lui-même des propriétés qui ne seraient pas présentes
        dans l'archive officielle<footnote><para>Techniquement, nous
        pourrions laisser la fonctionnalité auto-props faire son travail
        mais l'essentiel,c'est que chaque archive du fournisseur subisse
        exactement le même traitement pour les propriétés
        automatiques.</para></footnote>.</para>

<!--
      <para>Now that the first vendor release drop is present in our
        repository, we can create our vendor branch from it just as we
        would create any other branch&mdash;using <command>svn
        copy</command>.</para>
-->
      <para>Maintenant que la première archive du fournisseur est
        présente dans notre dépôt, nous pouvons nous en servir comme
        point de départ pour créer notre branche fournisseur en
        utilisant <command>svn copy</command> comme pour toute autre
        branche.</para>

      <informalexample>
        <screen> <!--
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-custom \
           -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Committed revision 1161.-->
$ svn copy http://svn.exemple.com/projets/vendor/libcomplex-1.0.0 \
           http://svn.exemple.com/projets/vendor/libcomplex-perso \
           -m "Initialisation de la branche fournisseur libcomplex à partir de libcomplex 1.0.0."
Révision 1161 propagée.
$
</screen>
      </informalexample>

<!--
      <para>Okay.  At this point we have a vendor branch based on
        libcomplex 1.0.0.  We are now poised to begin making the
        customizations to libcomplex required for our
        purposes&mdash;committing them directly to the vendor branch
        we've created&mdash;and then to start using our customized
        libcomplex in our own application.</para>
-->
      <para>Parfait. Ici, nous avons une branche fournisseur basée sur
        libcomplex 1.0.0. Nous sommes maintenant aptes à personnaliser
        libcomplex pour nos besoins propres, en propageant directement
        les modifications vers la branche fournisseur que  nous venons
        de créer. Puis, nous pouvons utilisé notre libcomplex
        personnalisée dans nos applications.</para>

<!--
      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  In order to perform that
        upgrade on our branch, we need to essentially apply the same
        set of changes the vendor has made between 1.0.0 and 1.0.1 to
        our vendor branch without clobbering our own customizations.
        The safest way to perform that application is to first get
        libcomplex 1.0.1 into our repository <emphasis>as a delta
        against the libcomplex 1.0.0 code in our
        repository</emphasis>.  Afterwards, we'll use the 2-URL form
        of the <command>svn merge</command> command to replicate those
        same changes into our vendor branch.</para>
-->
      <para>Quelques temps plus tard, libcomplex 1.0.1 est publiée.
        Après avoir passé en revue les modifications,  nous décidons de
        mettre à niveau notre branche fournisseur vers cette nouvelle
        version. Afin d'effectuer cette mise à niveau, nous devons
        essentiellement appliquer le même ensemble de modifications à
        notre branche fournisseur que le fournisseur a fait entre la
        version 1.0.0 et la version 1.0.1 de sa bibliothèque, ceci sans
        écraser nos propres personnalisations. La façon la plus sûre de
        le faire est d'insérer libcomplex 1.0.1 dans notre dépôt,
        <emphasis>comme un delta vis-à-vis du code de libcomplex 1.0.0
        de notre dépôt</emphasis>. Ensuite, nous utilisons la forme
        2-URL de la sous-commande <command>svn merge</command> pour
        répliquer ces mêmes modifications vers notre branche
        fournisseur.</para>

<!--
      <para>As it turns out, there are several different approaches we
        can take to to get libcomplex 1.0.1 into our repository in the
        right way.<footnote><para>Using another <command>svn
        import</command> operation would be
        an <emphasis>incorrect</emphasis> approach, as the libcomplex
        1.0.0 and 1.0.1 branches would not have any common
        ancestry.</para></footnote>  The approach we'll describe here
        is relatively rudimentary, but it will serve our illustrative
        needs.</para>
-->
      <para>Il existe plusieurs manières d'insérer correctement
        libcomplex 1.0.1 dans notre dépôt<footnote><para>Utiliser une
        autre <command>svn import</command> <emphasis>ne serait pas
        correct</emphasis>, puisque libcomplex 1.0.1 et 1.0.0 se
        retrouveraient sans aucun ancêtre commun.</para></footnote>.
        L'approche que nous décrivons ici est relativement rudimentaire,
        mais elle convient pour illustrer notre exemple.</para>

<!--
      <para>Remember, we want our mirror of the libcomplex 1.0.1
        vendor drop to share ancestry with our 1.0.0 vendor drop,
        which will produce the best results later when we need to
        merge the changes between those drops to our vendor branch.
        So we'll start by creating a libcomplex-1.0.1 branch as copy
        of our previously created libcomplex-1.0.0 <quote>vendor
        tag</quote>&mdash;a copy which will eventually become a
        replica of libcomplex 1.0.1.</para>
-->
      <para>Rappelez-vous que nous voulons que notre replique de
        la livraison libcomplex-1.0.1 partage des ancêtres avec notre
        livraison 1.0.0, afin de produire plus tard les meilleurs
        résultats quand nous devrons fusionner les modifications entre
        les archives vers la branche fournisseur. Nous allons commencer
        par créer une branche libcomplex-1.0.1 comme copie de notre
        branche <quote>étiquetée fournisseur</quote> libcomplex-1.0.0.
        Cette copie sera destinée à devenir une réplique de
        libcomplex 1.0.1.</para>

      <informalexample>
        <screen><!--
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
           -m "Setup a construction zone for libcomplex 1.0.1."
Committed revision 1282.-->
$ svn copy http://svn.exemple.com/projets/vendor/libcomplex-1.0.0 \
           http://svn.exemple.com/projets/vendor/libcomplex-1.0.1 \
           -m "Construction de la zone pour accueillir libcomplex 1.0.1."
Révision 1282 propagée.
$
</screen>
      </informalexample>

<!--
      <para>What we need now is to make a working copy of our
        libcomplex-1.0.1 branch, and then to make it actually look
        like libcomplex 1.0.1.  To do this, we'll take advantage of
        the fact that <command>svn checkout</command> can overlay an
        existing directory and, if the <option>- -force</option> option
        is provided, do so in manner that allows the differences
        between the checked-out tree and the target tree that the
        checkout overlayed to remain as local modifications in the new
        working copy.</para>
-->
      <para>Nous avons besoin maintenant d'avoir une copie de travail de
        notre branche libcomplex-1.0.1 et de la faire ressembler à
        libcomplex 1.0.1. Pour ce faire, nous allons profiter du fait
        que  <command>svn checkout</command> peut agir en superposition
        dans un répertoire existant et, si l'option
        <option>--force</option> est fournie, alors les différences
        entre l'arborescence extraite et l'arborescence cible sur
        laquelle est appliquée l'extraction sont marquées comme
        modifications locales de la nouvelle copie de travail.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.1.tar.gz
libcomplex-1.0.1/
libcomplex-1.0.1/README
libcomplex-1.0.1/LICENSE
&hellip;
libcomplex-1.0.1/src/code.c
libcomplex-1.0.1/tests
libcomplex-1.0.1/tests/TODO<!--
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-1.0.1 \-->
$ svn checkout http://svn.exemple.com/projets/vendor/libcomplex-1.0.1 \
               libcomplex-1.0.1 \
               --force
E    libcomplex-1.0.1/README
E    libcomplex-1.0.1/LICENSE
E    libcomplex-1.0.1/INSTALL
&hellip;
E    libcomplex-1.0.1/src/code.c
E    libcomplex-1.0.1/tests
E    libcomplex-1.0.1/tests/TODO<!--
Checked out revision 1282.-->
Révision 1282 extraite.
$ svn status libcomplex-1.0.1
M       libcomplex-1.0.1/src/code.h
M       libcomplex-1.0.1/src/code.c
M       libcomplex-1.0.1/README
$
</screen>
      </informalexample>

<!--
      <para>As you can see, after checking out what was really
        libcomplex 1.0.0 atop the libcomplex 1.0.1 exploded tarball,
        we are left with a working copy that contains local
        modifications&mdash;those modifications required to morph our
        previous vendor release drop into our new one.</para>
-->
      <para>Comme vous pouvez le constater, après avoir extrait ce
        qu'était réellement libcomplex 1.0.0 <quote>par dessus</quote>
        l'archive décompressée de libcomplex 1.0.1, nous obtenons une
        copie de travail avec des modifications locales (les
        modifications qui correspondent aux différences entre la
        précédente version du fournisseur que nous avions intégrée et la
        nouvelle).</para>

<!--
      <para>Admittedly, this is a pretty simple example.  The changes
        required to perform this particular upgrade involved merely
        content changes to existing files.  In reality, new versions
        of third-party libraries might also add or remove files or
        directories, might rename files or directories, and so on.  In
        those situations, it can be much more challenging to morph the
        new vendor tag into a state where it accurately reflects the
        vendor drop it claims to reflect.  We'll leave the details of
        such transformations as an exercise to the
        reader.<footnote><para>Here's a hint, though: <userinput>svn
        add - -force /path/to/working-copy - -no-ignore
        - -no-auto-props</userinput> is super handy for adding any new
        vendor drop items to version control in this
        situation.</para></footnote></para>
-->
      <para>Certes, c'est un exemple particulièrement simple. Les
        modifications pour effectuer la mise à niveau ne font intervenir
        que quelques modifications dans des fichiers existants. Dans la
        réalité, les nouvelles versions des bibliothèques tierces
        ajoutent ou déplacent sûrement des fichiers ou des dossiers,
        renomment des fichiers ou des dossiers, etc. Dans ces cas, il
        sera plus compliqué de calquer la nouvelle version étiquetée
        avec la livraison qu'elle est censée représenter. Nous
        laissons en exercice au lecteur la résolution des détails de cette
        transformation<footnote><para>Un début de solution peut
        être&nbsp;:<userinput>svn add --force
        /chemin/vers/copie-de-travail --no-ignore
        --no-auto-props</userinput> est super pratique pour ajouter tout
        nouvel élément de la version fournisseur en suivi de versions
        dans cette situation.</para></footnote>.</para>

<!--
      <para>However we make it happen, once our new vendor tag working
        copy is reconciled with the original source distribution, we
        can commit those changes to our repository.</para>
-->
      <para>Quelle que soit la manière dont nous y sommes arrivés, nous
       disposons maintenant d'une copie de travail de la nouvelle
       version étiquetée qui reflète exactement la livraison originale
       du fournisseur. Nous pouvons maintenant propager ces
       modifications à notre dépôt.</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-1.0.1
Sending        libcomplex-1.0.1/README
Sending        libcomplex-1.0.1/src/code.h
Sending        libcomplex-1.0.1/src/code.c
Transmitting file data ...
Committed revision 1283.-->
$ svn commit -m "Mise à niveau de la branche fournisseur vers libcomplex 1.0.1." \
             libcomplex-1.0.1
Envoi      libcomplex-1.0.1/README
Envoi      libcomplex-1.0.1/src/code.h
Envoi      libcomplex-1.0.1/src/code.c
Transmission des données ...
Révision 1283 propagée.
$
</screen>
      </informalexample>

<!--
      <para>We're finally ready to upgrade our vendor branch.
        Remember, our goal is to get the changes made by the vendor
        between the 1.0.0 and 1.0.1 releases of their library into our
        vendor branch.  There is where a 2-URL <command>svn
        merge</command> operation, applied to a working copy of our
        vendor branch, comes into play.</para>
-->
      <para>Nous sommes finalement prêt à mettre à niveau notre branche
        fournisseur, notre but étant d'obtenir les changements faits par
        le fournisseur entre les versions 1.0.0 et 1.0.1 de sa
        bibliothèque dans notre branche fournisseur. C'est là que la
        forme à 2-URL de <command>svn merge</command>, appliquée à une
        copie de travail de notre branche fournisseur, entre en
        scène.</para>

      <informalexample>
        <screen><!--
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-custom \
               libcomplex-custom
E    libcomplex-custom/README
E    libcomplex-custom/LICENSE
E    libcomplex-custom/INSTALL
&hellip;
E    libcomplex-custom/src/code.c
E    libcomplex-custom/tests
E    libcomplex-custom/tests/TODO
Checked out revision 1283.-->
$ svn checkout http://svn.exemple.com/projets/vendor/libcomplex-perso \
               libcomplex-perso
E    libcomplex-perso/README
E    libcomplex-perso/LICENSE
E    libcomplex-perso/INSTALL
&hellip;
E    libcomplex-perso/src/code.c
E    libcomplex-perso/tests
E    libcomplex-perso/tests/TODO
Révision 1283 extraite.<!--
$ cd libcomplex-custom-->
$ cd libcomplex-perso
$ svn merge ^/vendor/libcomplex-1.0.0 \
            ^/vendor/libcomplex-1.0.1<!--
- - Merging differences between repository URLs into '.':-->
--- Fusion des différences entre les URL du dépôt dans '.' :
U    src/code.h
C    src/code.c
U    README<!--
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: -->
Résumé des conflits :
  Text conflicts: 1
Conflit découvert dans le fichier 'src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options:
</screen>
      </informalexample>

<!--
      <para>As you can see, <command>svn merge</command> has merged
        the requisite changes into our working copy, flagging a
        conflict where the vendor modified the same region of one of
        the files as we did during our customizations.  Subversion
        detects this conflict, and gives us the opportunity to resolve
        it (using the methods described in
        <xref linkend="svn.tour.cycle.resolve" />) so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  Once we've resolved the conflicts and performed
        any testing or review we need, we can commit the changes to
        our vendor branch.</para>
-->
      <para>Comme vous pouvez le constater, <command>svn merge</command>
        a fusionné les modifications demandées dans notre copie de
        travail, marquant un conflit où le fournisseur a modifié la
        même zone d'un fichier que nous lors de notre personnalisation.
        Subversion détecte le conflit et nous donne l'opportunité de le
        résoudre (en utilisant les méthodes décrites dans <xref
        linkend="svn.tour.cycle.resolve" />) de façon à ce que nos
        personnalisations relatives à ce qui est maintenant libcomplex
        1.0.1 fassent toujours sens. Une fois que nous avons résolu les
        conflits et effectué les tests et revues nécessaires, nous
        pouvons propager les modifications à notre branche
        fournisseur.</para>

      <informalexample>
        <screen>
$ svn status
M       src/code.h
M       src/code.c
M       README<!--
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1."
Sending        README
Sending        src/code.h
Sending        src/code.c
Transmitting file data ...
Committed revision 1284.-->
$ svn commit -m "Mise à niveau de la branche fournisseur vers libcomplex 1.0.1."
Envoi     README
Envoi     src/code.h
Envoi     src/code.c
Transmission des données ...
Révision 1294 propagée.
$
</screen>
      </informalexample>

<!--
      <para>Our vendor branch upgrade is complete.  And the next time
        we need to upgrade that branch, we'll follow the same
        procedure we used to upgrade it this time.</para>
-->
      <para>La mise à niveau de notre branche fournisseur est terminée.
        Et la prochaine fois que nous aurons besoin de mettre à niveau
        cette branche, nous suivrons la même procédure.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.when">
<!--
    <title>To Branch or Not to Branch?</title>
-->
    <title>Créer une branche ou ne pas créer une branche&nbsp;?</title>

<!--
    <para>To branch or not to branch&mdash;that is an interesting
      question.  This chapter has provided thus far a pretty deep dive
      into the waters of branching and merging, topics which have
      historically been the premier source of Subversion user
      confusion.  As if the rote actions involved in branching and
      branch management aren't sometimes tricky enough, some users get
      hung up on deciding whether they need to branch at all.  As
      you've learned, Subversion can handle common branching and
      branch management scenarios.  So, the decision of whether or not
      to branch a project's history is rarely a technical one.
      Rather, the social impact of the decision often carries more
      weight.  Let's examine some of the benefits and costs of using
      branches in a software project.</para>
-->
    <para>Créer une branche ou ne pas créer une branche&nbsp;? Voilà une
      question intéressante. Ce chapitre vous a montré jusqu'à
      maintenant force détails quant aux créations de branches et aux
      fusions, des sujets qui ont historiquement été la plus grande
      source de confusion pour les utilisateurs. Comme si l'enchainement
      mécanique des actions qui sont mises en œuvre dans la création et
      la fusion de branches n'était pas assez compliqué, quelques
      utilisateurs restent à se demander si cela vaut le coup de créer
      une branche ou pas. Comme vous l'avez appris, Subversion gère les
      scénarios classiques de création et gestion de branches. Ainsi, la
      décision de créer ou pas une branche d'un projet ne relève pas de
      critères techniques. C'est davantage les impacts sociaux qui
      pèsent le plus dans la décision. Examinons quelques avantages et
      inconvénients d'utiliser des branches dans un projet
      logiciel.</para>

<!--
    <para>The most obvious benefit of working on a branch is
      isolation.  Changes made to the branch don't affect the other
      lines of development in the project; changes made to those other
      lines don't affect the branch.  In this way, a branch can serve
      as a great place to experiment with new features, complex bug
      fixes, major code rewrites, and so on.  No matter how much stuff
      Sally breaks on her branch, Harry and the rest of the team can
      continue with their work unhindered outside the branch.</para>
-->
    <para>Le bénéfice le plus évident de travailler sur une branche est
      l'isolation. Les modifications faites à la branche n'affectent pas
      les autres lignes de développement du projet&nbsp;; les
      modifications des autres lignes n'affectent pas la branche. Dans
      un certain sens, une branche peut servir de terrain
      d'expérimentation de nouvelles fonctionnalités, de correction pour
      des bogues complexes, des réécritures majeures du code, etc. Peu
      importe la quantité de choses cassées dans la branche de Sally,
      Harry et le reste de l'équipe peuvent continuer leur travail
      sans entrave, en dehors de la branche.</para>

<!--
    <para>Branches also provide a great way to organize related
      changes into readily identifiable collections.  For example, the
      changes which comprise the complete solution to a particular bug
      might be a list of non-sequential revision numbers.  You might
      describe them in human language as <quote>revisions 1534, 1543,
      1587 and 1588</quote>.  You'd probably reproduce those numbers
      manually (or otherwise) in the issue tracker artifact which
      tracks the bug.  When porting the bug fix to other product
      versions, you'd need to make sure to port all those revisions.
      But had those changes been made on a unique branch, you'd find
      yourself referring only to that branch by its name in
      conversation, in issue tracker comments, and when porting
      changes.</para>
-->
    <para>Les branches fournissent aussi un mécanisme très élégant pour
      organiser les modifications qui sont reliées entre elles dans des
      ensembles immédiatement reconnaissables. Par exemple, les
      modifications qui résolvent complètement un bogue particulier
      peuvent se trouver dans une liste de révisions dont les numéros ne
      se suivent pas. Vous pouvez les énoncer comme <quote>les révisions
      1534, 1543, 1587 und 1588</quote>. Vous les indiquerez sûrement
      à la main (ou autrement) dans le système de suivi de bogues qui
      prend en compte ce bogue. Lorsque vous porterez cette correction
      de bogue vers d'autres versions du produit, vous devrez vous
      assurer que vous n'oubliez aucune révision. Mais si ces
      modifications ont toutes été faites dans la même branche, vous
      pourrez vous référer uniquement à cette branche, par son nom, dans
      les conversations, dans les commentaires du système de suivi de
      bogues et lorsque vous portez les modifications ailleurs.</para>

<!--
    <para>The unfortunate downside of branches, though, is that the
      very isolation that makes them so
      useful <emphasis>can</emphasis> be at odds with the
      collaborative needs of the project team.  Depending on the work
      habits of your project peers, changes made to branches might not
      get the kind of constructive review, criticism, and testing that
      changes made to the main line of development do.  The isolation
      of a branch can encourage users to forsake certain version
      control <quote>best practices</quote>, leading to version
      history which is difficult to review <foreignphrase>post
      facto</foreignphrase>.  Developers on long-lived branches
      sometimes need to work extra hard to ensure that the
      evolutionary direction of their isolated copy of the codebase is
      in harmony with the direction their peers are steering the main
      code lines.  Now, these drawbacks might be less of an issue for
      true exploratory branches aimed at experimenting with the future
      of a codebase with no expectation of reintegrating the results
      back into the main development lines&mdash;mere policy needn't
      be a vision-killer!  But the simple fact remains that projects
      generally benefit from an orderly approach to version control
      where code and code changes enjoy the review and comprehension
      of more than one team member.</para>
-->
    <para>L'inconvénient des branches, cependant, c'est que cette
      isolation forte qui les rend si utiles <emphasis>peut</emphasis>
      parfois aller à l'encontre du besoin de collaboration de l'équipe
      de projet. En fonction des habitudes de travail de vos collègues,
      les modifications faites à votre branches ne recevront peut-être
      pas toutes les revues, critiques et tests que subissent les
      changements de la ligne principale de développement. L'isolation
      de la branche peut encourager les utilisateurs à oublier certaines
      bonnes pratiques de la gestion de versions, entrainant un
      historique des versions difficile à exploiter <foreignphrase>a
      posteriori</foreignphrase>. Les développeurs de branches à longue
      durée de vie doivent parfois travailler beaucoup plus dur pour
      s'assurer que la direction vers laquelle évolue leur branche
      isolée est bien en harmonie avec la direction prise par leurs
      collègues dans la ligne de développement principale. Maintenant,
      ces inconvénients peuvent s'avérer sans objet si le développement
      de la branche consiste justement à explorer une nouvelle souche
      du logiciel dont le résultat n'a pas vocation à réintégrer la
      ligne de développement principale (l'application stricte des
      politiques de développement ne doit pas freiner
      l'innovation&nbsp;!). En tout état de cause, les projets retirent
      en général un bon bénéfice d'une approche méthodique dans la
      gestion de versions où le code et les modifications font l'objet
      d'un passage en revue et de compréhension par plus d'un membre de
      l'équipe.</para>

<!--
    <para>That's not to say that there are no technical penalties to
      branching.  Pardon us while we <quote>go meta</quote> for a bit
      here.  If you think about it, every time you checkout a
      Subversion working copy, you're creating a branch of sorts of
      your project.  It's a special sort of branch.  It lives only on
      your client machine; not in the repository.  You synchronize
      this branch with changes made in the repository
      using <command>svn update</command>&mdash;which acts almost like
      a special-cased, simplified form of an <command>svn
      merge</command> command.<footnote><para>Actually, you
      <emphasis>could</emphasis> use <userinput>svn merge
      -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>
      in your working copy to quite literally merge in all the
      repository changes since your last update if really wanted
      to!</para></footnote> You effectively reintegrate your branch
      each time you run <command>svn commit</command>.  So, in that
      special sense, Subversion users deal with branches and merges
      all the time.  Given the similarities between updating and
      merging, it's no surprise, then, that the areas in which
      Subversion seems to have the most shortcomings&mdash;namely,
      handling file and directory renames and dealing with tree
      conflicts in general&mdash;are problematic for both
      the <command>svn update</command> and <command>svn
      merge</command> operations.  Unfortunately, <command>svn
      merge</command> has a harder time of it precisely because of the
      fact that, for every way in which <command>svn update</command>
      is a special-cased, simplified kind of generic merge operation,
      a true Subversion merge is neither special-cased nor simplified.
      For this reason, merges perform much more slowly than updates,
      require explicit tracking (via
      the <literal>svn:mergeinfo</literal> property we've discussed in
      this chapter) and history-crunching arithmetic, and generally
      offer more opportunities for something to go awry.</para>
-->
    <para>En fin de compte, nous ne proclamons pas qu'il n'y a aucun
      inconvénient technique à créer des branches. Pardonnez-nous de
      <quote>diverger</quote> quelque peu dans ce paragraphe. Si vous
      réfléchissez bien, à chaque fois que vous extrayez une copie de
      travail Subversion, vous créez en quelque sorte une branche de
      votre projet. C'est une branche d'une sorte un peu spéciale, qui
      ne réside que sur la machine cliente, pas dans le dépôt. Vous
      synchronisez cette branche avec les modifications faites dans le
      dépôt par la commande <command>svn update</command> (qui agit
      d'une certaine manière comme une version simplifiée de la commande
      <command>svn merge</command>
      <footnote><para>En fait, vous <emphasis>pourriez</emphasis>
      utiliser <userinput>svn merge
      -r<replaceable>DERNIERE_REV_EXTRAITE</replaceable>:HEAD
      .</userinput> dans votre copie de travail pour fusionner toutes
      les modifications en provenance du dépôt depuis votre dernière
      extraction si vous le vouliez&nbsp;!</para></footnote>.
      Vous réintégrer effectivement la branche à chaque fois que vous
      lancez <command>svn commit</command>. Ainsi, dans un certain sens,
      les utilisateurs de Subversion créent des branches et les
      fusionnent sans arrêt. Compte tenu des similitudes entre la mise
      à jour et la fusion, il n'est pas étonnant que les points durs de
      Subversion (la gestion des renommages des fichiers et de dossiers
      ainsi que les conflits d'arborescences) soient aussi
      problématiques pour les opérations <command>svn update</command>
      et <command>svn merge</command>. Malheureusement, <command>svn
      merge</command> souffre encore plus, précisément parce que, alors
      que <command>svn update</command> n'est qu'un cas particulier,
      simplifié, d'une opération de fusion, une véritable opération de
      fusion Subversion n'est pas un cas particulier ou simplifié. C'est
      pourquoi les opérations de fusion sont beaucoup plus lentes de les
      mises à jour, demandent d'avoir un traçage de l'historique
      (<foreignphrase>via</foreignphrase> la propriété
      <literal>svn:mergeinfo</literal> que nous avons abordée dans ce
      chapitre) et des calculs sur cet historique, introduisant
      généralement beaucoup d'occasions pour que quelque chose se passe
      de travers.</para>

<!--
    <para>To branch or not to branch?  Ultimately, that depends on
      what your team needs in order to find that sweet balance of
      collaboration and isolation.</para>
-->
    <para>Créer une branche ou ne pas créer une branche&nbsp;?
    Finalement, cela dépend des besoins de votre équipe pour trouver le
    juste équilibre entre le travail collaboratif et l'isolation.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
<!--
    <title>Summary</title>
-->
    <title>Résumé</title>

<!--
    <para>We covered a lot of ground in this chapter.  We
      discussed the concepts of tags and branches and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We showed how
      to use <command>svn merge</command> to copy changes from one
      branch to another or roll back bad changes.  We went over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>
-->
    <para>Nous avons traité de nombreux sujets dans ce chapitre. Nous
      avons présenté les concepts d'étiquettes et de branches et
      montré comment Subversion implémente ces concepts en copiant des
      répertoires avec la commande <command>svn copy</command>. Nous
      avons expliqué comment utiliser <command>svn merge</command>
      pour copier des modifications d'une branche à l'autre ou pour
      revenir en arrière sur des modifications non-satisfaisantes.
      Nous avons étudié l'utilisation de <command>svn switch</command>
      pour créer des copies de travail mixtes, pointant vers des
      emplacements variés d'un dépôt. Et nous avons évoqué la façon
      dont on peut gérer l'organisation et le cycle de vie des branches
      dans un dépôt.</para>

<!--
    <para>Remember the Subversion mantra: branches and tags are cheap.
      So don't be afraid to use them when needed!</para>
-->
    <para>Tâchez de garder en mémoire la devise de Subversion&nbsp;:
      les branches et les étiquettes ne coûtent quasiment rien. Donc
      n'ayez pas peur de les utiliser quand vous en avez
      besoin&nbsp;!</para>

<!--
    <para>As a helpful reminder of all the operations we discussed,
      here is handy reference table you can consult as
      you begin to make use of branches.</para>
-->
    <para>En guise de pense-bête face à toutes les opérations dont nous
      avons parlé, voici un tableau de référence très pratique, à
      consulter lorsque vous commencerez à utiliser des branches.</para>

    <table id="svn.branchmerge.summary.tbl-1">
<!--
      <title>Branching and merging commands</title>
-->
      <title>Commandes de gestion des branches et des fusions</title>
      <tgroup cols="2">
        <thead>
          <row>
<!--
            <entry>Action</entry>
            <entry>Command</entry>
-->
            <entry>Action</entry>
            <entry>Commande</entry>
          </row>
        </thead>
        <tbody>
          <row>
<!--
            <entry>Create a branch or tag</entry>
-->
            <entry>Créer une branche ou une étiquette</entry>
            <entry><userinput>svn copy <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Switch a working copy to a branch or tag</entry>
-->
            <entry>Faire pointer une copie de travail vers une branche
              ou une étiquette</entry>
            <entry><userinput>svn switch <replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Synchronize a branch with trunk</entry>
-->
            <entry>Synchroniser une branche avec le tronc</entry>
            <entry><userinput>svn merge <replaceable>trunkURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>See merge history or eligible changesets</entry>
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
-->
            <entry>Voir l'historique des fusions ou les ensembles de modifications susceptibles d'être fusionnés</entry>
<!--
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
-->
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>CIBLE</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Merge a branch back into trunk</entry>
-->
            <entry>Réintégrer une branche dans le tronc</entry>
            <entry><userinput>svn merge <replaceable>branchURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Merge one specific change</entry>
-->
            <entry>Fusionner une modification précise</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Merge a range of changes</entry>
-->
            <entry>Fusionner un intervalle de modifications</entry>
            <entry><userinput>svn merge -r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Block a change from automatic merging</entry>
-->
            <entry>Empêcher qu'une modification ne soit fusionnée
              automatiquement</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> --record-only <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Preview a merge</entry>
-->
            <entry>Prévisualiser une fusion</entry>
            <entry><userinput>svn merge <replaceable>URL</replaceable> --dry-run</userinput></entry>
          </row>

          <row>
<!--
            <entry>Abandon merge results</entry>
-->
            <entry>Abandonner une fusion</entry>
            <entry><userinput>svn revert -R .</userinput></entry>
          </row>

          <row>
<!--
            <entry>Resurrect something from history</entry>
-->
            <entry>Ressusciter un élément de l'historique</entry>
            <entry><userinput>svn copy <replaceable>URL</replaceable>@<replaceable>REV</replaceable> <replaceable>localPATH</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Undo a committed change</entry>
-->
            <entry>Revenir en arrière sur une modification déjà propagée</entry>
            <entry><userinput>svn merge -c -<replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
<!--
            <entry>Examine merge-sensitive history</entry>
-->
            <entry>Examiner l'historique en tenant compte des
              informations de fusion</entry>
            <entry><userinput>svn log -g; svn blame -g</userinput></entry>
          </row>

          <row>
<!--
            <entry>Create a tag from a working copy</entry>
-->
            <entry>Créer une version étiquetée à partir d'une copie de
              travail</entry>
            <entry><userinput>svn copy . <replaceable>tagURL</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Rearrange a branch or tag</entry>
-->
            <entry>Réorganiser une branche ou une version
              étiquetée</entry>
            <entry><userinput>svn move <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
<!--
            <entry>Remove a branch or tag</entry>
-->
            <entry>Supprimer une branche ou une version étiquetée</entry>
            <entry><userinput>svn delete <replaceable>URL</replaceable></userinput></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
