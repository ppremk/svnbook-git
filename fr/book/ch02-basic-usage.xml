<!-- -*- sgml -*- -->

<chapter id="svn.tour">
<!--
  <title>Basic Usage</title>
-->
  <title>Utilisation de base</title>

<!--
  <para>Theory is useful, but its application is just plain fun.
    Let's move now into the details of using Subversion.  By the time
    you reach the end of this chapter, you will be able to perform all
    the tasks you need to use Subversion in a normal day's work.
    You'll start with getting your files into Subversion, followed by
    an initial checkout of your code.  We'll then walk you through
    making changes and examining those changes.  You'll also see how
    to bring changes made by others into your working copy, examine
    them, and work through any conflicts that might arise.</para>
-->
  <para>La théorie est utile, mais son application est tout simplement
    passionnante. Nous allons maintenant voir plus en détail
    l'utilisation de Subversion. Quand vous aurez terminé ce chapitre,
    vous serez capable d'effectuer toutes les tâches nécessaires à une
    utilisation quotidienne de Subversion. Nous allons commencer par
    enregistrer nos fichiers dans Subversion, puis extraire
    notre code. Ensuite, nous expliquons comment modifier des
    fichiers et examiner ces changements. Nous voyons aussi comment
    faire pour intégrer les changements venant d'autres personnes dans
    notre copie de travail, les examiner et résoudre les conflits qui
    pourraient apparaître.</para>

<!--
  <para>This chapter will not provide exhaustive coverage
    of all of Subversion's commands&mdash;rather, it's a conversational
    introduction to the most common Subversion tasks that you'll
    encounter.  This chapter assumes that you've read and understood
    <xref linkend="svn.basic"/> and are familiar with the general
    model of Subversion.  For a complete reference of all commands,
    see <xref linkend="svn.ref.svn"/>.</para>
-->
  <para>Notez que ce chapitre ne doit pas être vu comme une liste
    complète de toutes les commandes de Subversion, mais plutôt comme
    une introduction conviviale aux opérations Subversion les plus
    courantes que vous êtes susceptible de rencontrer. Ici, nous
    supposons que vous avez lu et compris le <xref
    linkend="svn.basic"/> et que vous êtes familier avec le modèle
    général de Subversion. Pour une liste complète de toutes les
    commandes, reportez-vous à la <xref linkend="svn.ref"/>.</para>

<!--
  <para>Also, this chapter assumes that the reader is seeking
    information about how to interact in a basic fashion with an
    existing Subversion repository.  No repository means no working
    copy; no working copy means not much of interest in this chapter.
    There are many Internet sites which offer free or inexpensive
    Subversion repository hosting services.  Or, if you'd prefer to
    set up and administer your own repositories, check out
    <xref linkend="svn.reposadmin"/>.  But don't expect the
    examples in this chapter to work without the user having access
    to a Subversion repository.</para>
-->
  <para>Dans ce chapitre, nous considérons également que le lecteur
    cherche comment interagir de manière simple avec un dépôt Subversion
    existant. S'il n'y a pas de dépôt, il n'y a pas de copie de
    travail&nbsp;; s'il n'y a pas de copie de travail, ce chapitre ne
    présente pas grand intérêt. Il existe de nombreux sites Internet
    qui propose d'héberger un dépôt Subversion gratuitement ou pour
    une somme modique. Sinon, si vous préférez mettre en place et
    administrer vos propres dépôts, référez-vous au <xref
    linkend="svn.reposadmin"/>. Mais n'espérez pas que les exemples de
    ce chapitre fonctionnent si vous n'avez pas accès à un dépôt
    Subversion.</para>

<!--
  <para>Finally, any Subversion operation that contacts the repository
    over a network may potentially require that the user authenticate.
    For the sake of simplicity, our examples throughout this chapter
    avoid demonstrating and discussing authentication.  Be aware that
    if you hope to apply the knowledge herein to an existing,
    real-world Subversion instance, you'll probably be forced to
    provide at least a username and password to the server.  See
    <xref linkend="svn.serverconfig.netmodel.creds"/> for a detailed
    description of Subversion's handling of authentication and client
    credentials.</para>

-->
  <para>Enfin, toutes les opérations Subversions qui contactent le dépôt
    à travers le réseau peuvent potentiellement nécessiter une
    authentification de l'utilisateur. Par souci de simplicité, nos
    exemples tout au long de ce chapitre n'abordent pas
    l'authentification. Soyez conscient que si vous souhaitez mettre en
    pratique les exemples fournis ici avec une instance Subversion du
    monde réel, vous serez certainement obligé de fournir un identifiant
    et un mot de passe au serveur. Lisez
    <xref linkend="svn.serverconfig.netmodel.creds"/> pour une
    description détaillée de la façon dont Subversion gère
    l'authentification des utilisateurs et les éléments associés.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.help">
<!--
    <title>Help!</title>
-->
    <title>À l'aide&nbsp;!</title>

    <indexterm>
      <primary>svn</primary>
<!--
      <secondary>subcommands</secondary>
-->
      <secondary>sous-commandes</secondary>
      <tertiary>help</tertiary>
    </indexterm>

<!--
    <para>It goes without saying that this book exists to be a source
      of information and assistance for Subversion users new and old.
      Conveniently, though, the Subversion command-line is
      self-documenting, alleviating the need to grab a book off the
      shelf (wooden, virtual, or otherwise).  The <command>svn
      help</command> command is your gateway to that built-in
      documentation:</para>
-->
    <para>Il va de soi que ce livre existe dans le but d'informer et
      d'assister les utilisateurs de Subversion, qu'ils soient débutants
      ou chevronnés. Cependant, pour plus de confort, le client texte
      interactif de Subversion inclut sa propre documentation,
      réduisant le besoin d'aller chercher un livre dans les
      rayonnages (qu'ils soient en bois, virtuels ou quoi que soit
      d'autre). La commande <command>svn help</command> est la porte
      d'entrée vers cette documentation.</para>

    <informalexample>
      <screen>
$ svn help <!--
usage: svn &lt;subcommand&gt; [options] [args]
Subversion command-line client, version 1.8.13.
Type 'svn help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svn - -version' to see the program version and RA modules
  or 'svn - -version - -quiet' to see just the version number.

Most subcommands take file and/or directory arguments, recursing
on the directories.  If no arguments are supplied to such a
command, it recurses on the current directory (inclusive) by default.

Available subcommands:
-->
Client texte interactif de Subversion, version 1.8.13.
Entrer 'svn help &lt;sous-commande&gt;' pour l'aide sur une sous-commande.
Entrer 'svn --version' pour avoir la version et les modules d'accès (RA)
    ou 'svn --version --quiet' pour la version seule.

La plupart des sous-commandes prennent en argument des dossiers et/ou
des fichiers, et s'appliquent récursivement sur les dossiers.
Si aucun argument n'est précisé à une telle sous-commande, elle s'applique
par défaut récursivement sur le dossier courant, qui est inclus.

Sous-commandes disponibles :
&hellip;
</screen>
    </informalexample>

<!--
    <para>As described in the previous output, you can ask for help on
      a particular subcommand by running <userinput>svn help
      <replaceable>SUBCOMMAND</replaceable></userinput>.  Subversion
      will respond with the full usage message for that subcommand,
      including its syntax, options, and behavior:</para>

-->
    <para>Comme indiqué dans la sortie d'écran précédente, vous pouvez
      demande de l'aide sur une sous-commande particulière en lançant
      <userinput>svn help
      <replaceable>SOUS_COMMANDE</replaceable></userinput>. Subversion
      affiche le message complet d'utilisation de cette sous-commande,
      ce qui inclut la syntaxe, les options et le
      comportement&nbsp;:</para>

    <informalexample>
      <screen>
$ svn help help <!--
help (?, h): Describe the usage of this program or its subcommands.
usage: help [SUBCOMMAND...]

Global options:
  - -username ARG           : specify a username ARG
  - -password ARG           : specify a password ARG
-->
help (?, h): Décrit l'usage de ce programme ou de ses sous-commandes.
usage : help [SOUS_COMMANDE...]

Options globales :
  --username ARG           : précise le nom d'utilisateur ARG
  --password ARG           : précise le mot de passe ARG
&hellip;
</screen>
    </informalexample>

    <sidebar>
<!--
      <title>Options and Switches and Flags, Oh My!</title>
-->
      <title>Options, sélecteurs, drapeaux&hellip; Doux
        Jésus&nbsp;!</title>

      <indexterm>
        <primary>svn</primary>
<!--
        <secondary>options</secondary>
-->
        <secondary>options</secondary>
      </indexterm>

<!--
      <para>The Subversion command-line client has numerous command
        modifiers.  Some folks refer to such things
        as <quote>switches</quote> or <quote>flags</quote>&mdash;in
        this book, we'll call them <quote>options</quote>.  You'll
        find the options supported by a given <command>svn</command>
        subcommand, plus a set of options which are globally supported
        by all subcommands, listed near the bottom of the built-in
        usage message for that subcommand.</para>

-->
      <para>Le client texte interactif de Subversion possède de
          nombreux modificateurs de commandes, que nous appelons
          <quote>options</quote>. Vous trouverez la liste des options
          disponibles pour une sous-commande <command>svn</command>
          donnée, ainsi qu'un ensemble d'options disponibles
          globalement pour toutes les sous-commandes, à la fin du
          message d'utilisation de la sous-commande.</para>

<!--
      <para>Subversion's options have two distinct forms:  short
        options are a single hyphen followed by a single letter, and
        long options consist of two hyphens followed by several
        letters and hyphens (e.g., <literal>-s</literal>
        and <literal>- -this-is-a-long-option</literal>, respectively).
        Every option has at least one long format.  Some, such as
        the <option>- -changelist</option> option, feature an
        abbreviated long-format alias (<option>- -cl</option>, in this
        case).  Only certain options&mdash;generally the most-used
        ones&mdash;have an additional short format.  To maintain
        clarity in this book, we usually use the long form in code
        examples, but when describing options, if there's a short
        form, we'll provide the long form (to improve clarity) and the
        short form (to make it easier to remember).  Use the form
        you're more comfortable with when executing your own
        Subversion commands.</para>
-->

      <para>il existe deux types d'options distincts&nbsp;: les options
        courtes sont constituées d'un unique tiret suivi d'une unique
        lettre, tandis que les options longues sont formées de deux
        tirets suivis d'un certain nombre de lettres (c'est-à-dire
        respectivement <literal>-s</literal> et
        <literal>--ceci-est-une-option-longue</literal>). Chaque option
        possède une option longue, mais seules certaines options ont
        aussi un format court (ce sont généralement des options qui sont
        utilisées très souvent). Par souci de clarté, nous utilisons
        généralement la forme longue dans les exemples de code, mais
        lorsque nous décrivons les options, s'il existe une forme
        courte, nous donnons à la fois la forme longue (pour plus de
        clarté) et la forme courte (car plus facile à retenir).
        En ce qui vous concerne, utilisez la forme qui vous convient le
        mieux.</para>

    </sidebar>

<!--
    <para>Many Unix-based distributions of Subversion include manual
      pages of the sort that can be invoked using
      the <command>man</command> program, but those tend to carry only
      pointers to other sources of real help, such as the project's
      website and to the website which hosts this book.  Also, several
      companies offer Subversion help and support, too, usually via a
      mixture of web-based discussion forums and fee-based consulting.
      And of course, the Internet holds a decade's worth of
      Subversion-related discussions just begging to be located by
      your favorite search engine.  Subversion help is never too far
      away.</para>

-->
    <para>Beaucoup de distributions de Subversion sur des plateformes de
      type Unix incluent des pages de manuel qui peuvent être affichées
      en utilisant la commande <command>man</command>, mais ces pages ne
      recèlent généralement que des pointeurs vers d'autres sources
      d'aide réelle, telles que le site Internet du projet et le site
      qui héberge ce livre. Par ailleurs, plusieurs entreprises
      proposent de l'assistance et de l'aide pour Subversion,
      habituellement par l'intermédiaire de forums de discussion en
      ligne et de prestations de conseil. Et bien sûr, Internet
      regorge de discussions relatives à Subversion, prêtes à être mises
      au jour à l'aide de votre moteur de recherche favori. L'aide de
      Subversion ne se trouve jamais bien loin.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.importing">
<!--
    <title>Getting Data into Your Repository</title>
-->
    <title>Enregistrement de données dans le dépôt</title>

<!--
    <para>You can get new files into your Subversion
      repository in two ways: <command>svn import</command> and <command>svn
      add</command>.  We'll discuss <command>svn import</command> now
      and will discuss <command>svn add</command> later in this
      chapter when we review a typical day with Subversion.</para>
-->
    <para>Deux moyens sont à votre disposition pour enregistrer de
      nouveaux fichiers dans votre dépôt Subversion&nbsp;:
      <command>svn import</command> et <command>svn add</command>.
      Nous abordons ici la commande <command>svn import</command> et,
      plus loin dans le chapitre, la commande <command>svn add</command>,
      lorsque nous passerons en revue une journée typique avec
      Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.import">
<!--
      <title>Importing Files and Directories</title>
-->
      <title>Importation de fichiers et de dossiers</title>

      <indexterm>
        <primary>svn</primary>
<!--
        <secondary>subcommands</secondary>
-->
        <secondary>sous-commandes</secondary>
        <tertiary>import</tertiary>
      </indexterm>

<!--
      <para>The <command>svn import</command> command is a quick way to
        copy an unversioned tree of files into a repository, creating
        intermediate directories as necessary.  <command>svn
        import</command> doesn't require a working copy, and your files
        are immediately committed to the repository.  You typically
        use this when you have an existing tree of files that you want to
        begin tracking in your Subversion repository.  For example:</para>
-->
      <para>La commande <command>svn import</command> est un moyen
        rapide de copier une arborescence non-suivie en versions dans
        le dépôt, créant des dossiers intermédiaires si nécessaire.
        <command>svn import</command> ne nécessite pas de copie de
        travail et vos fichiers sont immédiatement propagés dans le
        dépôt. Ce moyen est utilisé essentiellement quand vous avez
        une arborescence existante dont vous voulez suivre les
        changements dans votre dépôt Subversion. Par
        exemple&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn import /path/to/mytree \
             http://svn.example.com/svn/repo/some/project \
             -m "Initial import"
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.-->
$ svn import chemin/vers/mon/arborescence \
             http://svn.exemple.com/svn/depot/un/projet \
             -m "Import initial"
Ajout         mon-arborescence/truc.c
Ajout         mon-arborescence/machin.c
Ajout         mon-arborescence/sous-repertoire
Ajout         mon-arborescence/sous-repertoire/bidule.h

Révision 1 propagée.
$
</screen>
      </informalexample>

<!--
      <para>The previous example copied the contents of the local
        directory <filename>mytree</filename> into the directory
        <filename>some/project</filename> in the repository.  Note
        that you didn't have to create that new directory
        first&mdash;<command>svn import</command> does that for you.
        Immediately after the commit, you can see your data in the
        repository:</para>
-->
      <para>L'exemple précédent copie le contenu d'un dossier local
        <filename>mon-arborescence</filename> dans le dossier
        <filename>un/projet</filename> du dépôt. Notez que vous n'avez
        pas eu besoin de créer d'abord ce nouveau dossier,
        <command>svn import </command> le faisant pour vous.
        Immédiatement après la propagation, vous pouvez voir vos données
        dans le dépôt&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn list http://svn.example.com/svn/repo/some/project
bar.c
foo.c
subdir/-->
$ svn list http://svn.exemple.com/svn/depot/un/projet
machin.c
sous-repertoire/
truc.c
$
</screen>
      </informalexample>

<!--
      <para>Note that after the import is finished, the original local
        directory is <emphasis>not</emphasis> converted into a working
        copy.  To begin working on that data in a versioned fashion,
        you still need to create a fresh working copy of that
        tree.</para>
-->
      <para>Notez qu'après la fin de l'import, l'arborescence
        d'origine n'est <emphasis>pas</emphasis> transformée en copie
        de travail. Pour commencer à travailler, vous devez extraire
        grâce à <command>svn checkout</command> une copie de travail
        toute fraîche de l'arborescence.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.layout">
<!--
      <title>Recommended Repository Layout</title>
-->
      <title>Organisation conseillée d'un dépôt</title>

<!--
      <para>Subversion provides the ultimate flexibility in terms of
        how you arrange your data.  Because it simply versions
        directories and files, and because it ascribes no particular
        meaning to any of those objects, you may arrange the data in
        your repository in any way that you choose.  Unfortunately,
        this flexibility also means that it's easy to find
        yourself <quote>lost without a roadmap</quote> as you attempt
        to navigate different Subversion repositories which may carry
        completely different and unpredictable arrangements of the
        data within them.</para>
-->
      <para>On ne peut pas être plus flexible que Subversion pour
        l'organisation de vos données. Comme il ne fait que suivre en
        versions les fichiers et les dossiers et comme il n'attache
        aucune sémantique à ces objets, vous avez tout loisir de
        disposer les données dans votre dépôt comme bon vous semble.
        Malheureusement, la contrepartie de cette flexibilité est qu'il
        est facile de se retrouver perdu quand on essaye de
        parcourir différents dépôts Subversion, les schémas de stockage
        des données pouvant être très différents voire
        imprévisibles.</para>

<!--
      <para>
        <indexterm>
          <primary>trunk</primary>
        </indexterm>
        <indexterm>
          <primary>tags</primary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
        </indexterm>
        <indexterm>
          <primary>project root</primary>
        </indexterm>To counteract this confusion, we recommend that
        you follow a repository layout convention (established long
        ago, in the nascency of the Subversion project itself) in
        which a handful of strategically named Subversion repository
        directories convey valuable meaning about the data they hold.
        Most projects have a recognizable <quote>main line</quote>,
        or <firstterm>trunk</firstterm>, of development;
        some <firstterm>branches</firstterm>, which are divergent
        copies of development lines; and
        some <firstterm>tags</firstterm>, which are named, stable
        snapshots of a particular line of development.  So we first
        recommend that each project have a
        recognizable <firstterm>project root</firstterm> in the
        repository, a directory under which all of the versioned
        information for that project&mdash;and only that
        project&mdash;lives.  Secondly, we suggest that each project
        root contain a <filename>trunk</filename> subdirectory for the
        main development line, a
        <filename>branches</filename> subdirectory in which specific
        branches (or collections of branches) will be created, and
        a <filename>tags</filename> subdirectory in which specific
        tags (or collections of tags) will be created.  Of course, if
        a repository houses only a single project, the root of the
        repository can serve as the project root, too.</para>

      <para>Here are some examples:</para>
-->
      <para>
        <indexterm>
        <primary>tronc</primary>
        </indexterm>
        <indexterm>
          <primary>trunk</primary>
          <see>tronc</see>
        </indexterm>
        <indexterm>
          <primary>étiquettes</primary>
        </indexterm>
        <indexterm>
          <primary>tags</primary>
          <see>étiquettes</see>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
        </indexterm>
        <indexterm>
          <primary>racine de projet</primary>
        </indexterm> Pour pallier cette confusion possible, nous vous
        recommandons de suivre la convention suivante (établie il y a
        bien longtemps, avec l'éclosion du projet Subversion
        lui-même) qui consiste à nommer judicieusement quelques
        dossiers du dépôt Subversion en fonction des données qu'ils
        renferment. La plupart des projets possèdent <quote>une ligne de
        développement principale</quote> identifiable, autrement appelée
        <firstterm>tronc</firstterm> (<foreignphrase>trunk</foreignphrase>
        en anglais), des <firstterm>branches</firstterm>, qui sont des
        copies avec des variantes de la ligne de développement
        principale et des <firstterm>étiquettes</firstterm>
        (<foreignphrase>tags</foreignphrase> en anglais) qui sont des
        instantanés de la ligne de développement que l'on a nommés. En
        conséquence, nous recommandons premièrement que chaque projet
        dispose  d'une <firstterm>racine de projet</firstterm> bien
        identifiée au sein du dépôt, un dossier sous lequel toutes
        les données du projet &mdash; et uniquement les données du
        projet &mdash; seront hébergées. Deuxièmement, nous
        recommandons que chaque racine de projet contienne un
        sous-dossier <filename>trunk</filename> pour la ligne de
        développement principale, un sous-dossier
        <filename>branches</filename> dans lequel les branches
        spécifiques (ou groupes de branches) seront créées et un
        sous-dossier <filename>tags</filename> dans lequel seront
        placés les instantanés (ou les groupes d'instantanés). Bien
        sûr, si un dépôt n'héberge qu'un seul projet, la racine du
        dépôt peut servir de racine du projet.</para>

      <para>Voici quelques exemples&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn list file:///var/svn/single-project-repo
trunk/
branches/
tags/
$ svn list file:///var/svn/multi-project-repo
project-A/
project-B/
$ svn list file:///var/svn/multi-project-repo/project-A
trunk/
branches/
tags/-->
$ svn list file:///var/svn/depot-projet-unique
trunk/
branches/
tags/
$ svn list file:///var/svn/depot-multiples-projets
projet-A/
projet-B/
$ svn list file:///var/svn/depot-multiples-projets/projet-A
trunk/
branches/
tags/
$
</screen>

      </informalexample>

<!--
      <para>We talk much more about tags and branches in
        <xref linkend="svn.branchmerge"/>.  For details and some
        advice on how to set up repositories when you have multiple
        projects, see <xref linkend="svn.branchmerge.maint.layout"/>.
        Finally, we discuss project roots more in
        <xref linkend="svn.reposadmin.projects.chooselayout"/>.</para>
-->
      <para>Vous en apprendrez plus sur les étiquettes et les branches
        dans le <xref linkend="svn.branchmerge"/>. Pour plus de
        détails et pour voir comment gérer plusieurs projets,
        reportez-vous à <xref linkend="svn.branchmerge.maint.layout"/>,
        et à <xref linkend="svn.reposadmin.projects.chooselayout"/>
        pour en savoir plus sur les dossiers racines
        d'un projet.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.naming">
<!--
      <title>What's In a Name?</title>
-->
      <title>Limitations sur les <emphasis>noms</emphasis></title>

<!--
      <para>Subversion tries hard not to limit the type of data you
        can place under version control.  The contents of files and
        property values are stored and transmitted as binary data, and
        <xref linkend="svn.advanced.props.special.mime-type"/>
        tells you how to give Subversion a hint that
        <quote>textual</quote> operations don't make sense for a
        particular file.  There are a few places, however, where
        Subversion places restrictions on information it
        stores.</para>
-->
      <para>Subversion s'efforce de ne pas limiter le type de données
        que vous placez en suivi de versions. Le contenu des fichiers
        et les valeurs des propriétés sont stockés et transmis en
        tant que données binaires. <xref
        linkend="svn.advanced.props.special.mime-type"/> vous explique
        comment indiquer à Subversion que des opérations
        <quote>textuelles</quote> n'ont pas de sens pour un fichier
        particulier. Il existe toutefois quelques cas pour lesquels
        Subversion définit des limitations sur les informations
        qu'il stocke.</para>

<!--
      <para>Subversion internally handles certain bits of
        data&mdash;for example, property names, pathnames, and log
        messages&mdash;as UTF-8-encoded Unicode.  This is not to say
        that all your interactions with Subversion must involve UTF-8,
        though.  As a general rule, Subversion clients will gracefully
        and transparently handle conversions between UTF-8 and the
        encoding system in use on your computer, if such a conversion
        can meaningfully be done (which is the case for most common
        encodings in use today).</para>
-->
      <para>Subversion gère en interne certaines parties des données au
        format Unicode UTF-8, par exemple les noms de propriétés, les
        noms de chemins et les messages de trace. Cela ne veut
        toutefois pas dire que toutes vos interactions avec Subversion
        doivent faire intervenir l'UTF-8. En règle générale, les
        clients Subversion vont gérer de façon transparente les
        conversions entre l'UTF-8 et le système de codage utilisé
        par votre ordinateur, si cela a un sens de faire une telle
        conversion (ce qui est le cas pour les codages les plus
        courants utilisés de nos jours).</para>

<!--
      <para>In WebDAV exchanges and older versions of some of
        Subversion's administrative files, paths are used as XML
        attribute values, and property names in XML tag names.  This
        means that pathnames can contain only legal XML (1.0)
        characters, and properties are further limited to ASCII
        characters.  Subversion also prohibits <literal>TAB</literal>,
        <literal>CR</literal>, and <literal>LF</literal> characters in
        path names to prevent paths from being broken up in diffs or
        in the output of commands such as <command>svn log</command>
        or <command>svn status</command>.</para>
-->
      <para>Dans les échanges WebDAV ainsi que dans des anciennes
        versions de certains fichiers de gestion interne de
        Subversion, les chemins sont utilisés en tant que valeurs
        d'attribut XML et les noms de propriétés en tant que noms
        de tags XML. Cela veut dire que les chemins ne peuvent
        contenir que des caractères XML&nbsp;(1.0) valides et que les
        noms de propriétés sont encore plus limités, ne pouvant
        contenir que des caractères ASCII. Subversion interdit
        également les caractères <literal>TAB</literal> (tabulation),
        <literal>CR</literal> et <literal>LF</literal>
        (caractères de fin de ligne) dans les noms de chemins pour
        empêcher les chemins d'être coupés en deux lors des
        comparaisons ou dans les sorties de commandes comme
        <command>svn log</command> ou
        <command>svn status</command>.</para>

<!--
      <para>While it may seem like a lot to remember, in practice
        these limitations are rarely a problem.  As long as your
        locale settings are compatible with UTF-8 and you don't use
        control characters in path names, you should have no trouble
        communicating with Subversion.  The command-line client adds
        an extra bit of help&mdash;to create
        <quote>legally correct</quote> versions for internal
        use it will automatically escape illegal
        path characters as needed in URLs that you type.</para>
-->
      <para>Bien que cela fasse beaucoup de choses à se rappeler, ces
        limitations sont rarement un problème en pratique. Tant que
        vos paramètres régionaux sont compatibles avec UTF-8 et que vous
        n'utilisez pas de caractères de contrôle dans les chemins, vous
        ne devriez pas avoir de problème pour communiquer avec
        Subversion. Le client texte interactif apporte un peu
        d'aide supplémentaire&nbsp;: afin de créer des versions
        <quote>valides</quote> pour un usage interne, il banalise
        automatiquement, si nécessaire, les caractères illégaux
        contenus dans les chemins d'URL que vous tapez.</para>

      <warning>
<!--
        <para>Of course, when it comes to choosing valid path names,
          Subversion isn't the only limiting factor.  Teams using
          multiple operating systems need to consider the limitations
          placed on path names by those operating systems, too.  For
          example, while Windows disallows the use of colon characters
          in file names, a user on a Linux system can very easily add
          such a file to version control, resulting in a dataset that
          can no longer be checked out on Windows.  Adding multiple
          files to a directory whose names differ only in their letter
          casing will likewise cause problems for users checking out
          working copies onto case-insensitive filesystems.  So, some
          broad awareness of the various limitations introduced by
          different operating systems and filesystems, then, is
          recommended.</para>
-->
        <para>Évidemment, au moment de choisir des noms de chemins
          valides, Subversion n'est pas l'unique facteur limitant. Les
          équipes qui travaillent avec plusieurs systèmes
          d'exploitation doivent aussi prendre en compte les
          limitations imposées par ces systèmes d'exploitation. Par
          exemple, Windows n'autorise pas l'utilisation de la virgule
          dans les noms de fichiers alors qu'un utilisateur de Linux
          peut très bien placer un tel fichier en suivi de versions,
          générant des données qui ne pourront plus être extraites sous
          Windows. De même, ajouter plusieurs fichiers dont les noms
          ne diffèrent que par la casse entraîne des problèmes
          pour les utilisateurs de systèmes de fichiers non sensibles
          à la casse. En conséquence, nous vous recommandons de bien
          prendre aussi en compte les limitations posées par les
          différents systèmes d'exploitation et systèmes de
          fichiers.</para>
      </warning>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.initial">
<!--
    <title>Creating a Working Copy</title>
-->
    <title>Création d'une copie de travail</title>

<!--
    <para>
      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands</secondary>
        <tertiary>checkout</tertiary>
      </indexterm>Most of the time, you will start using a Subversion
      repository by performing a <firstterm>checkout</firstterm> of
      your project.  Checking out a directory from a repository
      creates a working copy of that directory on your local machine.
      Unless otherwise specified, this copy contains the youngest
      (that is, most recently created or modified) versions of the
      directory and its children found in the Subversion
      repository:</para>
-->
    <para>
      <indexterm>
        <primary>svn</primary>
        <secondary>sous-commandes</secondary>
        <tertiary>checkout</tertiary>
      </indexterm>En général, vous commencerez à utiliser un dépôt
      Subversion en faisant une <firstterm>extraction</firstterm>
      (<foreignphrase>checkout</foreignphrase> en anglais) de votre
      projet. Extraire un dossier d'un dépôt crée sur votre
      ordinateur une copie de travail de ce dossier. Cette copie
      contient la dernière version (c'est-à-dire la plus récemment créée
      ou modifiée) du dossier et de sa sous-arborescence trouvée dans
      le dépôt Subversion&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/svn/repo/trunk
A    trunk/README
A    trunk/INSTALL
A    trunk/src/main.c
A    trunk/src/header.h
&hellip;
Checked out revision 8810.-->
$ svn checkout http://svn.exemple.com/svn/depot/trunk
A    trunk/LISEZMOI
A    trunk/INSTALL
A    trunk/src/main.c
A    trunk/src/header.h
&hellip;
Révision 8810 extraite.
$
</screen>

    </informalexample>


<!--
    <para>Although the preceding example checks out the trunk
      directory, you can just as easily check out a deeper
      subdirectory of a repository by specifying that subdirectory's
      URL as the checkout URL:</para>
-->
    <para>Alors que l'exemple précédent extrait le dossier de
      base <filename>trunk</filename>, vous pouvez tout aussi
      facilement extraire un sous-dossier situé à n'importe quelle
      profondeur dans le dépôt en spécifiant le sous-dossier dans
      l'URL d'extraction&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/svn/repo/trunk/src
A    src/main.c
A    src/header.h
A    src/lib/helpers.c
&hellip;
Checked out revision 8810.-->
$ svn checkout http://svn.exemple.com/svn/depot/trunk/src
A    src/main.c
A    src/header.h
A    src/lib/helpers.c
&hellip;
Révision 8810 extraite.
$
</screen>
    </informalexample>

<!--
    <para>Since Subversion uses a copy-modify-merge model instead of
      lock-modify-unlock (see <xref linkend="svn.basic.vsn-models"/>),
      you can immediately make changes to the files and directories in
      your working copy.  Your working copy is just like any other
      collection of files and directories on your system.  You can
      edit the files inside it, rename it, even delete the entire
      working copy and forget about it.</para>
-->
    <para>Comme Subversion utilise le modèle copier-modifier-fusionner
      à la place du modèle verrouiller-modifier-libérer (voir
      <xref linkend="svn.basic.vsn-models"/>), vous pouvez commencer
      immédiatement à modifier les fichiers et les dossiers de
      votre copie de travail. Votre copie de travail n'est qu'un
      ensemble de fichiers et de dossiers comme les autres dans
      votre système. Vous pouvez y éditer des fichiers, la modifier,
      la déplacer, vous pouvez même supprimer toute votre copie de
      travail et l'oublier définitivement.</para>

<!--
    <warning>
      <para>While your working copy is <quote>just like any other
        collection of files and directories on your system,</quote>
        you can edit files at will, but you must tell Subversion
        about <emphasis>everything else</emphasis> that you do.  For
        example, if you want to copy or move an item in a working
        copy, you should use <command>svn copy</command> or
        <command>svn move</command> instead of the copy and move
        commands provided by your operating system.  We'll talk more
        about them later in this chapter.</para>
    </warning>
-->
    <warning>
      <para>Bien que votre copie de travail <quote>n'est qu'un
         ensemble de fichiers et de dossiers comme les autres
         dans votre système</quote>, vous pouvez éditer vos
         fichiers comme vous le voulez, mais vous devez signaler à
         Subversion <emphasis>toutes vos autres opérations</emphasis>.
         Par exemple, si vous voulez copier ou déplacer un élément
         dans votre copie de travail, vous devez utiliser
         <command>svn copy</command> ou <command>svn move</command>
         à la place des commandes de copie ou de déplacement fournies
         par votre système d'exploitation. Nous aborderons plus en
         détail ces commandes plus loin dans ce chapitre.</para>
    </warning>

<!--
    <para>Unless you're ready to commit the addition of a new file or
      directory or changes to existing ones, there's no need to
      further notify the Subversion server that you've done
      anything.</para>
-->
    <para>À moins que vous ne soyez prêt à propager l'ajout d'un
      nouveau fichier ou d'un nouveau dossier ou la modification
      d'un fichier ou dossier existant, il n'est pas nécessaire
      d'informer davantage le serveur Subversion que vous avez fait
      quelque chose.</para>

    <sidebar>
<!--
      <title>What Is This .svn Directory?</title>
-->
      <title>À propos du répertoire .svn&nbsp;?</title>

<!--
      <para>The topmost directory of a working copy&mdash;and prior to
        version 1.7, every versioned subdirectory
        thereof&mdash;contains a special administrative subdirectory
        named <filename>.svn</filename>.  Usually, your operating
        system's directory listing commands won't show this
        subdirectory, but it is nevertheless an important directory.
        Whatever you do, don't delete or change anything in the
        administrative area!  Subversion uses that directory and its
        contents to manage your working copy.</para>
-->
      <para>Le dossier racine d'une copie de travail &mdash; et
        avant la version 1.7 de Subversion, chaque sous-dossier
        &mdash; contient une zone administrative, un sous-répertoire
        nommé <filename>.svn</filename>. Habituellement, les commandes
        d'affichage du contenu des dossiers ne font pas
        apparaître ce sous-répertoire, mais il s'agit tout de même
        d'un répertoire important. Quoique vous fassiez, ne supprimez
        ni ne changez rien dans la zone administrative&nbsp;! Subversion
        dépend d'elle pour gérer votre copie de travail.</para>
    </sidebar>

<!--
    <para>Notice that in the previous pair of examples, Subversion
      chose to create a working copy in a directory named for the
      final component of the checkout URL.  This occurs only as a
      convenience to the user when the checkout URL is the only bit of
      information provided to the <command>svn checkout</command>
      command.  Subversion's command-line client gives you additional
      flexibility, though, allowing you to optionally specify the
      local directory name that Subversion should use for the working
      copy it creates.  For example:</para>
-->
    <para>Vous avez certainement remarqué que, dans les deux exemples
      précédents, Subversion crée la copie de travail dans un
      dossier nommé d'après le dernier composant de l'URL
      extraite. Ce comportement n'est qu'une facilité lorsque la seule
      information fournie à la commande <command>svn
      checkout</command> est l'URL d'extraction. Le client texte
      interactif de Subversion vous permet d'indiquer le nom d'un
      répertoire local afin d'y placer la copie de travail
      nouvellement créée. Par exemple&nbsp;:</para>

    <informalexample>
      <screen><!--
$ svn checkout http://svn.example.com/svn/repo/trunk my-working-copy
A    my-working-copy/README
A    my-working-copy/INSTALL
A    my-working-copy/src/main.c
A    my-working-copy/src/header.h
&hellip;
Checked out revision 8810.-->
$ svn checkout http://svn.exemple.com/svn/depot/trunk ma-copie-de-travail
A    ma-copie-de-travail/LISEZMOI
A    ma-copie-de-travail/INSTALL
A    ma-copie-de-travail/src/main.c
A    ma-copie-de-travail/src/header.h
&hellip;
Révision 8810 extraite.
$
</screen>
    </informalexample>

<!--
    <para>If the local directory you specify doesn't yet
      exist, that's okay&mdash;<command>svn checkout</command> will
      create it for you.</para>
-->
    <para>Le dossier <literal>ma-copie-de-travail</literal> est créé
      par la commande <command>svn checkout</command> s'il n'existait pas
      auparavant.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.cycle">
<!--
    <title>Basic Work Cycle</title>
-->
    <title>Cycle de travail de base</title>

<!--
    <para>Subversion has numerous features, options, bells, and
      whistles, but on a day-to-day basis, odds are that you will use
      only a few of them.  In this section, we'll run through the most
      common things that you might find yourself doing with Subversion
      in the course of a day's work.</para>
-->
    <para>Subversion dispose de nombreuses fonctionnalités, d'options,
      d'avertissements et de garde-fous. Mais dans une utilisation au
      jour le jour, vous n'utilisez qu'un petit nombre d'entre eux.
      Dans cette section, nous passons en revue l'utilisation
      quotidienne de Subversion.</para>

<!--
    <para>The typical work cycle looks like this:</para>
-->
    <para>Le cycle de travail typique ressemble à ceci&nbsp;:</para>

    <orderedlist>
      <listitem>
<!--
        <para><emphasis>Update your working copy.</emphasis> This
          involves the use of the <command>svn update</command>
          command.</para>
-->
        <para><emphasis>Mettre à jour votre copie de
          travail</emphasis>, par l'utilisation de la commande
          <command>svn update</command>.</para>
      </listitem>
      <listitem>
<!--
        <para><emphasis>Make your changes.</emphasis> The most common
          changes that you'll make are edits to the contents of your
          existing files.  But sometimes you need to add, remove, copy
          and move files and directories&mdash;the <command>svn
          add</command>, <command>svn delete</command>, <command>svn
          copy</command>, and <command>svn move</command> commands
          handle those sorts of structural changes within the working
          copy.</para>
-->
        <para><emphasis>Faire des changements</emphasis>. Les
          changements les plus courants seront des modifications du
          contenu des fichiers existants. Parfois, vous aurez besoin
          d'ajouter, supprimer, copier ou déplacer des fichiers et des
          dossiers&nbsp;; les commandes <command>svn
          add</command>, <command>svn delete</command>, <command>svn
          copy</command> et <command>svn move</command> prennent en
          charge ces modifications structurelles de la copie de
          travail.</para>
      </listitem>
      <listitem>
<!--
        <para><emphasis>Review your changes.</emphasis>
          The <command>svn status</command> and <command>svn
          diff</command> commands are critical to reviewing the
          changes you've made in your working copy.</para>
-->
        <para><emphasis>Examiner les changements effectués</emphasis>.
          Les commandes <command>svn status</command> et <command>svn
          diff</command> sont là pour passer en revue les modifications
          que vous avez apportées à votre copie de travail.</para>
      </listitem>

      <listitem>
<!--
        <para><emphasis>Fix your mistakes.</emphasis>  Nobody's
          perfect, so as you review your changes, you may spot
          something that's not quite right.  Sometimes the easiest way
          to fix a mistake is start all over again from scratch.
          The <command>svn revert</command> command restores a file
          or directory to its unmodified state.</para>
-->
        <para><emphasis>Annuler des changements</emphasis>. Personne
          n'est parfait, aussi lorsque vous passez en revue vos
          modifications, vous pouvez constater des erreurs. Parfois, le
          plus simple est de repartir de zéro. La commande <command>svn
          revert</command> rétablit un fichier ou un dossier dans
          son état initial.</para>
      </listitem>
      <listitem>
<!--
        <para><emphasis>Resolve any conflicts (merge others'
          changes).</emphasis>  In the time it takes you to make and
          review your changes, others might have made and published
          changes, too.  You'll want to integrate their changes into
          your working copy to avoid the potential out-of-dateness
          scenarios when you attempt to publish your own.  Again,
          the <command>svn update</command> command is the way to do
          this.  If this results in local conflicts, you'll need to
          resolve those using the <command>svn resolve</command>
          command.</para>
-->
        <para><emphasis>Résoudre les conflits (fusionner les
          modifications)</emphasis>. Dans le temps qu'il vous faut
          pour réaliser et passer en revue vos modifications, d'autres
          utilisateurs  effectuent et publient peut-être des
          modifications également. Vous voulez sûrement intégrer
          leurs changements dans votre copie de travail pour éviter
          qu'ils ne deviennent <quote>périmés</quote> quand vous voudrez
          les publier. Une fois encore, la commande <command>svn
          update</command> prend cette opération en charge. Si des
          conflits apparaissent sur votre copie locale, vous devrez les
          résoudre à l'aide de la commande <command>svn
          resolve</command>.</para>
      </listitem>
      <listitem>
<!--
        <para><emphasis>Publish (commit) your changes.</emphasis>
          The <command>svn commit</command> command transmits your
          changes to the repository where, if they are accepted, they
          create the newest versions of all the things you modified.
          Now others can see your work, too!</para>
-->
        <para><emphasis>Propager les changements</emphasis>. La
          commande <command>svn commit</command> transmet vos
          modifications au dépôt et, si elles sont acceptées,
          créeront une nouvelle version de toutes les choses que vous
          avez modifiées. Maintenant, les autres aussi peuvent voir
          votre travail&nbsp;!</para>
      </listitem>
    </orderedlist>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.update">
<!--
      <title>Update Your Working Copy</title>
-->
      <title>Mise à jour de la copie de travail</title>

      <indexterm>
        <primary>svn</primary>
<!--
        <secondary>subcommands</secondary>
-->
        <secondary>sous-commandes</secondary>
        <tertiary>update</tertiary>
      </indexterm>

<!--
      <para>When working on a project that is being modified via
        multiple working copies, you'll want to update your working
        copy to receive any changes committed from other working
        copies since your last update.  These might be changes that
        other members of your project team have made, or they might
        simply be changes you've made yourself from a different
        computer.  To protect your data, Subversion won't
        allow you commit new changes to out-of-date files and
        directories, so it's best to have the latest versions
        of all your project's files and directories before making new
        changes of your own.</para>
-->
      <para>Si vous travaillez sur un projet donné qui est modifié
        par des copies de travail multiples, vous voudrez mettre à jour
        votre copie locale pour recevoir toutes les modifications qui
        ont pu être faites par les autres copies de travail depuis votre
        dernière mise à jour. Ce peut être des modifications que les
        autres membres de l'équipe de projet ont faites, ou simplement
        des modifications que vous avez faites vous-même sur un autre
        ordinateur. Afin de protéger vos données, Subversion ne vous
        autorise pas à publier des changements sur des fichiers ou
        des dossiers qui ne sont pas à jour. Il est donc toujours
        mieux d'avoir les dernières versions de tous les fichiers et
        dossiers des projets sur lesquels vous travaillez avant
        d'apporter vous-même des modifications.</para>

<!--
      <para>Use <command>svn update</command> to bring your working
        copy into sync with the latest revision in the
        repository:</para>

-->
      <para>Utilisez <command>svn update</command> pour synchroniser
        votre copie de travail avec la dernière version présente
        dans le dépôt&nbsp;:</para>

      <informalexample>
        <screen><!--
Updating '.':
U    foo.c
U    bar.c
Updated to revision 2.-->
$ svn update
Mise à jour de '.' :
U  truc.c
U  machin.c
Actualisé à la révision 2.
$
</screen>
      </informalexample>

<!--
      <para>In this case, it appears that someone committed
        modifications to both <filename>foo.c</filename>
        and <filename>bar.c</filename> since the last time you
        updated, and Subversion has updated your working copy to
        include those changes.</para>
-->
      <para>Dans cet exemple, il se trouve que quelqu'un a propagé
        des modifications à <filename>truc.c</filename> ainsi qu'à
        <filename>machin.c</filename> depuis votre dernière mise à jour
        et Subversion vient de répercuter ces modifications dans votre
        copie de travail.</para>

<!--
      <para>When the server sends changes to your working copy via
        <command>svn update</command>, a letter code is displayed next
        to each item to let you know what actions Subversion performed
        to bring your working copy up to date.  To find out what these
        letters mean, run <userinput>svn help update</userinput> or
        see <xref linkend="svn.ref.svn.c.update"/> in
        <xref linkend="svn.ref.svn"/>.</para>
-->
      <para>Lorsque le serveur envoie des modifications vers votre
        copie de travail <foreignphrase>via</foreignphrase> <command>svn
        update</command>, un code, sous forme de lettre, est affiché à
        côté de chaque élément pour vous permettre de savoir quelles
        actions Subversion a effectuées pour mettre votre copie de
        travail à jour. Pour en savoir plus sur le sens de ces lettres,
        exécutez <userinput>svn help update</userinput> ou
        reportez-vous à <xref linkend="svn.ref.svn.c.update"/> dans
        <xref linkend="svn.ref.svn"/>.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.edit">
<!--
      <title>Make Your Changes </title>
-->
      <title>Modifications dans la copie de travail</title>

<!--
      <para>
        <indexterm>
          <primary>file changes</primary>
        </indexterm>
        <indexterm>
          <primary>tree changes</primary>
        </indexterm>Now you can get to work and make changes in your
        working copy.  You can make two kinds of changes to your
        working copy: <firstterm>file changes</firstterm>
        and <firstterm>tree changes</firstterm>.  You don't need to
        tell Subversion that you intend to change a file; just make
        your changes using your text editor, word processor, graphics
        program, or whatever tool you would normally use.  Subversion
        automatically detects which files have been changed, and in
        addition, it handles binary files just as easily as it handles
        text files&mdash;and just as efficiently, too.  Tree changes
        are different, and involve changes to a directory's structure.
        Such changes include adding and removing files, renaming files
        or directories, and copying files or directories to new
        locations.  For tree changes, you use Subversion operations
        to <quote>schedule</quote> files and directories for removal,
        addition, copying, or moving.  These changes may take place
        immediately in your working copy, but no additions or removals
        will happen in the repository until you commit them.</para>
-->
      <para>
        <indexterm>
          <primary>modifications de fichiers</primary>
        </indexterm>
        <indexterm>
          <primary>modifications de dossiers</primary>
        </indexterm>Vous pouvez à présent vous mettre au travail et
        apporter des modifications à votre copie de travail. Vous
        pouvez effectuer deux types de modifications&nbsp;: les
        <firstterm>modifications de fichiers</firstterm> et les
        <firstterm>modifications de dossiers</firstterm>. Vous
        n'avez pas à prévenir Subversion que vous voulez modifier un
        fichier&nbsp;; faites vos modifications avec un éditeur de
        texte, un traitement de texte, un logiciel de dessin ou
        n'importe quel autre outil que vous utilisez d'habitude.
        Subversion détecte automatiquement quels fichiers ont été
        modifiés et, en plus, il traite les fichiers binaires tout aussi
        facilement et aussi efficacement que les fichiers textes.
        Les modifications dans l'arborescence sont différentes&nbsp;;
        cela comprend l'ajout et la suppression de fichiers, le
        renommage de fichiers ou de dossier ainsi que la copie ou
        le déplacement de fichiers ou dossiers vers un nouvel
        emplacement. Pour les modifications d'arborescence, les
        opérations de Subversion consistent à <quote>marquer</quote>
        la suppression, l'ajout, la copie ou le déplacement des
        fichiers et dossiers. Ces modifications prennent effet
        immédiatement sur votre copie de travail mais aucun ajout ou
        suppression n'interviendra sur le dépôt avant que vous ne les
        propagiez.</para>
      <sidebar>
<!--
        <title>Versioning Symbolic Links</title>
-->
        <title>Gestion des liens symboliques</title>

<!--
        <para>
          <indexterm>
            <primary>symlink</primary>
          </indexterm>
          <indexterm>
            <primary>symbolic link</primary>
            <see>symlink</see>
          </indexterm>On non-Windows platforms, Subversion is able to
          version files of the special type <firstterm>symbolic
          link</firstterm> (or <quote>symlink</quote>).  A symlink is
          a file that acts as a sort of transparent reference to some
          other object in the filesystem, allowing programs to read
          and write to those objects indirectly by performing
          operations on the symlink itself.</para>
-->
        <para>
          <indexterm>
            <primary>lien symbolique</primary>
          </indexterm>
          <indexterm>
            <primary>symlink</primary>
            <see>lien symbolique</see>
          </indexterm>Dans des environnements non-Windows, Subversion
          est capable de suivre en versions les fichiers de type
          <firstterm>lien symbolique</firstterm>
          (<foreignphrase>symlink</foreignphrase> en anglais). Un lien
          symbolique est un fichier qui agit comme une sorte de
          référence transparente vers un autre objet du système de
          fichiers, permettant à des programmes de consulter et de
          modifier ces objets de façon indirecte en effectuant les
          opérations sur le lien symbolique lui-même.</para>

<!--
        <para>When a symlink is committed into a Subversion
          repository, Subversion remembers that the file was in fact a
          symlink, as well as the object to which the symlink
          <quote>points.</quote>  When that symlink is checked out to
          another working copy on a non-Windows system, Subversion
          reconstructs a real filesystem-level symbolic link from the
          versioned symlink.  But that doesn't in any way limit the
          usability of working copies on systems such as Windows that
          do not support symlinks.  On such systems, Subversion simply
          creates a regular text file whose contents are the path to
          which the original symlink pointed.  While that file
          can't be used as a symlink on a Windows system, it also
          won't prevent Windows users from performing their other
          Subversion-related activities.</para> </sidebar>
-->
        <para>Quand un symlink est propagé vers un dépôt Subversion,
          Subversion enregistre que ce fichier était en fait un
          symlink et note l'objet vers lequel il
          <quote>pointait</quote>. Quand ce symlink est extrait vers
          une autre copie de travail sur un système non-Windows,
          Subversion reconstruit un véritable lien symbolique, au
          niveau du système de fichiers, à partir du symlink
          enregistré. Mais ceci ne limite en aucune façon l'usage
          des copies de travail sur des systèmes tels que Windows,
          qui ne possèdent pas d'implémentation des symlinks. Sur
          de tels systèmes, Subversion se contente de créer un
          fichier texte ordinaire, qui contient le chemin vers
          lequel le symlink pointait à l'origine. Bien que ce fichier
          ne puisse être utilisé comme un symlink sur un système
          Windows, il n'empêche pas les utilisateurs de Windows
          d'effectuer leurs autres opérations Subversion.</para>
      </sidebar>

<!--
      <para>Here is an overview of the five Subversion subcommands
        that you'll use most often to make tree changes:</para>
-->
      <para>Voici un aperçu des cinq sous-commandes Subversion les plus
        utilisées pour faire des modifications sur
        l'arborescence&nbsp;:</para>

      <variablelist>

        <varlistentry>
<!--
          <term><userinput>svn add FOO</userinput></term>
-->
          <term><userinput>svn add TRUC</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
<!--
              <secondary>subcommands</secondary>
-->
              <secondary>sous-commandes</secondary>
              <tertiary>add</tertiary>
            </indexterm>
<!--
            <para>Use this to schedule the file, directory, or
              symbolic link <filename>FOO</filename> to be added to
              the repository.  When you next
              commit, <filename>FOO</filename> will become a child of
              its parent directory.  Note that if
              <filename>FOO</filename> is a directory, everything
              underneath <filename>FOO</filename> will be scheduled
              for addition.  If you want only to add
              <filename>FOO</filename> itself, pass the
              <option>- -depth=empty</option> option.</para>
-->
            <para>Marque le fichier, le dossier ou le lien
              symbolique <filename>TRUC</filename> pour ajout. Lors
              de la prochaine propagation, <filename>TRUC</filename>
              devient un fils de son dossier parent. Notez que
              si <filename>TRUC</filename> est un dossier, tout ce
              qui se trouve à l'intérieur de <filename>TRUC</filename>
              est marqué pour ajout. Si vous ne désirez ajouter que
              <filename>TRUC</filename> lui-même, passez l'option
              <option>--depth empty</option>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><userinput>svn delete FOO</userinput></term>
-->
          <term><userinput>svn delete TRUC</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
<!--
              <secondary>subcommands</secondary>
-->
              <secondary>sous-commandes</secondary>
              <tertiary>delete</tertiary>
            </indexterm>
<!--
            <para>Use this to schedule the file, directory, or
              symbolic link <filename>FOO</filename> to be deleted
              from the repository.  <filename>FOO</filename> is
              immediately deleted from your working copy.
              (Of course, nothing is ever totally deleted from the
              repository&mdash;just from its <literal>HEAD</literal> revision.
              You may continue to access the deleted item in previous
              revisions).
              <footnote><para>Should you desire to resurrect the item
              so that it is again present in <literal>HEAD</literal>, see
              <xref linkend="svn.branchmerge.basicmerging.resurrect"
              />.</para></footnote></para>
-->
            <para>Marque le fichier, le dossier ou le lien
              symbolique <filename>TRUC</filename> pour suppression.
              <filename>TRUC</filename> est immédiatement supprimé de
              votre copie de travail. Bien sûr, rien n'est jamais
              totalement supprimé du dépôt &mdash; seulement de la révision
              <literal>HEAD</literal> du dépôt. Vous avez accès à
              l'élément supprimé dans les révisions précédentes.
              <footnote>
              <para>Si vous avez l'intention de recouvrer cet élément
              afin qu'il soit de nouveau présent dans
              <literal>HEAD</literal>, lisez <xref
                linkend="svn.branchmerge.basicmerging.resurrect"/>.</para>
              </footnote></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn copy TRUC MACHIN</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
<!--
              <secondary>subcommands</secondary>
-->
              <secondary>sous-commandes</secondary>
              <tertiary>copy</tertiary>
            </indexterm>
<!--
            <para>Create a new item <filename>BAR</filename> as a
              duplicate of <filename>FOO</filename> and automatically
              schedule <filename>BAR</filename> for addition.  When
              <filename>BAR</filename> is added to the repository on
              the next commit, its copy history is recorded (as having
              originally come from <filename>FOO</filename>).
              <command>svn copy</command> does not create intermediate
              directories unless you pass the
              <option>- -parents</option> option.</para>
-->
            <para>Crée un nouvel élément
              <filename>MACHIN</filename> par duplication de
              <filename>TRUC</filename> et marque automatiquement
              <filename>MACHIN</filename> pour ajout. Lorsque
              <filename>MACHIN</filename> est ajouté au dépôt, lors
              de la prochaine propagation, son historique est
              enregistré (comme ayant été créé à partir de
              <filename>TRUC</filename>). <command>svn copy</command>
              ne crée pas de dossiers intermédiaires, à moins que
              vous ne lui passiez l'option
              <option>--parents</option>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><userinput>svn move FOO BAR</userinput></term>
-->
          <term><userinput>svn move TRUC MACHIN</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
<!--
              <secondary>subcommands</secondary>
-->
              <secondary>sous-commandes</secondary>
              <tertiary>move</tertiary>
            </indexterm>
<!--
            <para>This command is exactly the same as running
              <userinput>svn copy FOO BAR; svn delete FOO</userinput>.
              That is, <filename>BAR</filename> is scheduled for
              addition as a copy of <filename>FOO</filename>, and
              <filename>FOO</filename> is scheduled for removal.
              <command>svn move</command> does not create intermediate
              directories unless you pass the
              <option>- -parents</option> option.</para>
-->
            <para>Cette commande équivaut exactement à
            <userinput>svn copy TRUC MACHIN; svn delete
            MACHIN</userinput>. C'est-à-dire que
            <filename>MACHIN</filename> est marqué pour ajout en tant
            que copie de <filename>TRUC</filename> et que
            <filename>TRUC</filename> est marqué pour suppression.
            <command>svn move</command> ne crée pas de dossiers
            intermédiaires, à moins que vous ne lui passiez
            l'option <option>--parents</option>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><userinput>svn mkdir FOO</userinput></term>
-->
          <term><userinput>svn mkdir TRUC</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
<!--
              <secondary>subcommands</secondary>
-->
              <secondary>sous-commandes</secondary>
              <tertiary>mkdir</tertiary>
            </indexterm>
<!--
            <para>This command is exactly the same as running
              <userinput>mkdir FOO; svn add FOO</userinput>.  That is,
              a new directory named <filename>FOO</filename> is
              created and scheduled for addition.</para>
-->
            <para>Cette commande équivaut exactement à
              <userinput>mkdir TRUC; svn add TRUC</userinput>.
              C'est-à-dire qu'un nouveau dossier nommé
              <filename>TRUC</filename> est créé et marqué pour
              ajout.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <sidebar>
<!--
        <title>Changing the Repository Without a Working Copy</title>
-->
        <title>Modifications dans le dépôt sans copie de travail</title>

<!--
        <para>Subversion <emphasis>does</emphasis> offer ways to
          immediately commit tree changes to the repository without an
          explicit commit action.  In particular, specific uses
          of <command>svn mkdir</command>, <command>svn
          copy</command>, <command>svn move</command>, and
          <command>svn delete</command> can operate directly on
          repository URLs as well as on working copy paths.  Of
          course, as previously mentioned, <command>svn
          import</command> always makes direct changes to the
          repository. We discuss the ways to commit tree changes
          without a working copy in
          <xref linkend="svn.advanced.working-without-a-wc"/>.</para>
-->
        <para>Dans <emphasis>certains</emphasis> cas, les
          modifications d'arborescence sont propagées immédiatement
          vers le dépôt. Cela n'arrive que quand une sous-commande
          opère directement sur une URL et non sur le chemin d'une
          copie de travail. En particulier, certains usages de
          <command>svn mkdir</command>, <command>svn copy</command>,
          <command>svn move</command> et <command>svn delete</command>
          peuvent fonctionner avec des URL de la même manière que sur
          des chemins de la copie de travail. Et n'oubliez pas que
          <command>svn import</command> agit toujours immédiatement
          sur le contenu du dépôt. Nous abordons les différentes
          façons de propager des modifications d'arborescences sans
          copie de travail dans <xref
          linkend="svn.advanced.working-without-a-wc"/>.</para>

<!--
        <para>There are pros and cons to performing URL-based
          operations.  One obvious advantage to doing so is speed:
          sometimes, checking out a working copy that you don't
          already have solely to perform some seemingly simple action
          is an overbearing cost.  A disadvantage is that you are
          generally limited to a single, or single type of, operation
          at a time when operating directly on URLs.  Finally, the
          primary advantage of a working copy is in its utility as a
          sort of <quote>staging area</quote> for changes.  You can
          make sure that the changes you are about to commit make
          sense in the larger scope of your project before committing
          them.  And, of course, these staged changes can be as
          complex or as a simple as they need to be, yet result in but
          a single new revision when committed.</para>
-->
        <para>Les opérations sur les URL apportent des avantages et des
          inconvénients. L'avantage le plus évident est la
          vitesse&nbsp;: quelquefois, extraire une copie de travail que
          vous n'avez pas localement pour effectuer quelques
          modifications mineures n'en vaut pas la peine.
          L'inconvénient est que vous êtes généralement limité à
          une unique opération, ou type d'opération à la fois.
          Finalement, le principal avantage d'une copie de travail
          réside dans sa capacité à être une sorte de <quote>zone de
          transit</quote> pour vos modifications. Vous pouvez vous
          assurer que les modifications que vous avez faites font sens
          (dans la perspective du projet) avant de les propager vers le
          dépôt. Et, bien sûr, les modifications de la zone de
          transit peuvent être aussi complexes ou aussi simples que
          requis, et formant un tout qui sera propagé de manière
          atomique pour former une nouvelle révision.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.examine">
<!--
      <title>Review Your Changes</title>
-->
      <title>Revue des changements apportés</title>

<!--
      <para>
        <indexterm>
          <primary>log message</primary>
        </indexterm>Once you've finished making changes, you need to commit
        them to the repository, but before you do so, it's usually a
        good idea to take a look at exactly what you've changed.  By
        examining your changes before you commit, you can compose a
        more accurate <firstterm>log message</firstterm> (a
        human-readable description of the committed changes stored
        alongside those changes in the repository).  You may also
        discover that you've inadvertently changed a file, and that
        you need to undo that change before committing.  Additionally,
        this is a good opportunity to review and scrutinize changes
        before publishing them.  You can see an overview of the
        changes you've made by using the <command>svn status</command>
        command, and you can dig into the details of those changes by
        using the <command>svn diff</command> command.</para>
-->
      <para>
        <indexterm>
          <primary>commentaire de propagation</primary>
        </indexterm>Une fois vos modifications apportées, vous devez les
        intégrer au dépôt. Avant de le faire, il est souvent utile de
        jeter un coup d'œil sur ces modifications pour savoir
        exactement ce que vous avez changé. En examinant
        les modifications avant de les intégrer au dépôt, vous pouvez
        rédiger un <firstterm>commentaire de propagation</firstterm>,
        c'est-à-dire une description à l'attention des utilisateurs
        des changements propagés, ce commentaire étant conservé avec
        les données dans le dépôt. Éventuellement, vous verrez que vous
        avez modifié un fichier par inadvertance et cela vous donne une
        chance de revenir sur ces modifications avant de les propager au
        dépôt. En outre, c'est une bonne occasion de passer en revue
        et d'examiner les modifications avant de les publier. Vous
        pouvez obtenir une vue d'ensemble des modifications que vous
        avez faites en utilisant la commande <command>svn
        status</command> et voir le détail de ces changements en
        utilisant <command>svn diff</command>.</para>

      <sidebar>
<!--
        <title>Look Ma! No Network!</title>
-->
        <title>Regardez ça&nbsp;: pas besoin de réseau&nbsp;!</title>

<!--
        <para>You can use the commands <command>svn status</command>,
          <command>svn diff</command>, and <command>svn
          revert</command> without any network access even if your
          repository <emphasis>is</emphasis> across the network.  This
          makes it easy to manage and review your changes-in-progress
          when you are working offline or are otherwise unable to
          contact your repository over the network.</para>
-->
        <para>Vous pouvez utiliser les commandes
          <command>svn status</command>, <command>svn diff</command>,
          et <command>svn revert</command> sans aucun accès réseau
          même si votre dépôt <emphasis>est</emphasis> distant. C'est
          ainsi plus facile de gérer vos changements lorsque vous
          travaillez sans être connecté ou que vous n'avez pas la
          possibilité de joindre votre dépôt par le réseau.</para>

<!--
        <para>
          <indexterm>
            <primary>text-base</primary>
          </indexterm>
          <indexterm>
            <primary>delta</primary>
          </indexterm>Subversion does this by keeping private caches
          of pristine, unmodified versions of each versioned file
          inside its working copy administrative area (or prior to
          version 1.7, potentially multiple administrative areas).
          This allows Subversion to report&mdash;and
          revert&mdash;local modifications to those
          files <emphasis>without network access</emphasis>.  This
          cache (called the
          <firstterm>text-base</firstterm>) also allows Subversion to
          send the user's local modifications during a commit to the
          server as a compressed <firstterm>delta</firstterm> (or
          <quote>difference</quote>) against the pristine version.
          Having this cache is a tremendous benefit&mdash;even if you
          have a fast Internet connection, it's generally much faster
          to send only a file's changes rather than the whole file to
          the server.</para>
-->
        <para>
          <indexterm>
            <primary>base texte</primary>
          </indexterm>
          <indexterm>
            <primary>delta</primary>
          </indexterm>En effet, Subversion garde en cache des copies
          privées des versions originales de chaque fichier suivi en
          versions dans la zone administrative de la copie de travail
          (ou, avant la version 1.7, dans de multiples zones
          administratives). Cela lui permet d'afficher (et éventuellement d'annuler)
          les modifications faites localement à ces fichiers,
          <emphasis>sans le moindre accès réseau</emphasis>.
          Ce cache (appelé la <quote>base texte</quote>) permet
          également à Subversion, lors d'une propagation,
          de n'envoyer au dépôt que les modifications compressées,
          appelées <firstterm>delta</firstterm> (ou
          <quote>différence</quote>) faites par l'utilisateur. Disposer
          d'un tel cache est un énorme avantage, même dans le cas d'une
          connexion Internet haut débit, car il est généralement
          beaucoup plus rapide d'envoyer des différences sur un fichier
          plutôt que l'ensemble du fichier au serveur.</para>

      </sidebar>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.examine.status">
<!--
        <title>See an overview of your changes</title>
-->
        <title>Vue d'ensemble des changements effectués</title>

        <indexterm>
          <primary>svn</primary>
<!--
          <secondary>subcommands</secondary>
-->
          <secondary>sous-commandes</secondary>
          <tertiary>status</tertiary>
        </indexterm>

<!--
        <para>To get an overview of your changes, use the
          <command>svn status</command> command.  You'll probably use
          <command>svn status</command> more than any other Subversion
          command.</para>
-->
        <para>Pour avoir une vue d'ensemble des changements que vous
          avez effectués, utilisez la commande
          <command>svn status</command>. C'est certainement la
          commande Subversion que vous utiliserez le plus.</para>

<!--
        <tip>
          <para>Because the <command>cvs status</command> command's
            output was so noisy, and because <command>cvs
            update</command> not only performs an update, but also
            reports the status of your local changes, most CVS users
            have grown accustomed to using <command>cvs
            update</command> to report their changes.  In Subversion,
            the update and status reporting facilities are completely
            separate.  See
            <xref linkend="svn.forcvs.status-vs-update"/> for more
            details.</para>
        </tip>

-->
        <tip>
          <para>Parce que l'affichage produit par la commande
            <command>cvs status</command> était tellement verbeux et
            parce que la commande <command>cvs update</command> ne
            faisait pas qu'une mise à jour mais affichait également
            l'état des changements effectués localement, la plupart des
            utilisateurs de CVS ont appris à utiliser <command>cvs
            update</command> pour propager leurs modifications. Dans
            Subversion, les opérations de mise-à-jour et d'examen des
            changements sont complètement séparées. Reportez-vous à
            <xref linkend="svn.forcvs.status-vs-update"/> pour plus de
            détails.</para>
        </tip>

<!--
        <para>If you run <userinput>svn status</userinput> at the top
          of your working copy with no additional arguments, it will
          detect and report all file and tree changes you've
          made.</para>
-->
        <para>Si vous lancez <command>svn status</command> sans
          argument à la racine de votre copie de travail, Subversion
          détecte toutes les modifications effectuées sur les
          fichiers et sur l'arborescence.</para>

        <informalexample>
          <screen><!--
$ svn status
?       scratch.c
A       stuff/loot
A       stuff/loot/new.c
D       stuff/old.c
M       bar.c
$-->
$ svn status
?       gribouillage.c
A       bazar/pognon
A       bazar/pognon/nouveau.h
D       bazar/vieux.c
M       machin.c
</screen>
        </informalexample>

<!--
        <para>In its default output mode, <command>svn
          status</command> prints seven columns of characters,
          followed by several whitespace characters, followed by a
          file or directory name.  The first column tells the status
          of a file or directory and/or its contents.  Some of the
          most common codes that <command>svn status</command>
          displays are:</para>
-->
        <para>Dans le format d'affichage par défaut, <command>svn
          status</command> affiche sept colonnes de caractères, suivis
          par plusieurs espaces, suivis par un nom de fichier ou de
          dossier. La première colonne indique le statut du fichier
          ou du dossier et/ou son contenu. Les codes les plus
          utilisés sont&nbsp;:</para>

        <variablelist>

          <varlistentry>
<!--
            <term><computeroutput>?      item</computeroutput></term>
-->
            <term><computeroutput>?      élément</computeroutput></term>
            <listitem>
<!--
              <para>The file, directory, or symbolic link
                <filename>item</filename> is not under version
                control.</para>
-->
              <para>Le fichier, dossier ou lien symbolique
                <filename>élément</filename> n'est pas suivi en
                versions.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
<!--
            <term><computeroutput>A      item</computeroutput></term>
-->
            <term><computeroutput>A      élément</computeroutput></term>
            <listitem>
<!--
              <para>The file, directory, or symbolic link
                <filename>item</filename> has been scheduled for
                addition into the repository.</para>
-->
              <para>Le fichier, dossier ou lien symbolique
                <filename>élément</filename> est marqué pour ajout
                au dépôt.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
<!--
            <term><computeroutput>C      item</computeroutput></term>
-->
            <term><computeroutput>C      élément</computeroutput></term>
            <listitem>

<!--
              <para>The file <filename>item</filename> is in a state
                of conflict.  That is, changes received from the
                server during an update overlap with local changes
                that you have in your working copy (and weren't
                resolved during the update).  You must resolve this
                conflict before committing your changes to the
                repository.</para>
-->
              <para>Le fichier <filename>élément</filename> est dans
                un état de conflit. C'est-à-dire que des modifications
                ont eu lieu dans le dépôt depuis votre dernière mise à
                jour et ces modifications interfèrent avec les
                modifications que vous avez effectuées sur votre copie
                de travail (et la mise à jour n'a pas résolu ce conflit).
                Vous devez résoudre ce conflit avant de propager vos
                changements vers le dépôt.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
<!--
            <term><computeroutput>D      item</computeroutput></term>
-->
            <term><computeroutput>D      élément</computeroutput></term>
            <listitem>
<!--
              <para>The file, directory, or symbolic link
                <filename>item</filename> has been scheduled for
                deletion from the repository.</para>
-->
              <para>Le fichier, dossier ou lien symbolique
                <filename>élément</filename> est marqué pour
                suppression (<foreignphrase>Deletion</foreignphrase> en
                anglais).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
<!--
            <term><computeroutput>M      item</computeroutput></term>
-->
            <term><computeroutput>M      élément</computeroutput></term>
            <listitem>
<!--
              <para>The contents of the file <filename>item</filename>
                have been modified.</para>
-->
              <para>Le contenu du fichier <filename>élément</filename>
                a été modifié.</para>
            </listitem>
          </varlistentry>

        </variablelist>

<!--
        <para>If you pass a specific path to <command>svn
          status</command>, you get information about that item
          alone:</para>
-->
        <para>Si vous spécifiez un chemin à
          <command>svn status</command>, vous obtenez uniquement
          les informations relatives à ce chemin&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn status stuff/fish.c
D       stuff/fish.c-->
$ svn status bazar/poisson.c
D      bazar/poisson.c
</screen>
        </informalexample>

<!--
        <para><command>svn status</command> also has a
          <option>- -verbose</option> (<option>-v</option>) option,
          which will show you the status of <emphasis>every</emphasis>
          item in your working copy, even if it has not been
          changed:</para>
-->
        <para><command>svn status</command> possède aussi une option
          <option>--verbose</option> (<option>-v</option>) pour la
          rendre plus verbeuse&nbsp;: elle affiche alors le statut de
          <emphasis>tous</emphasis> les éléments de votre copie de
          travail, même ceux qui n'ont pas subi de
          modification&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svn status -v
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c-->
$ svn status -v
M               44        23    sally     LISEZMOI
                44        30    sally     INSTALL
M               44        20    harry     machin.c
                44        18    ira       bazar
                44        35    harry     bazar/truite.c
D               44        19    ira       bazar/poisson.c
                44        21    sally     bazar/divers
A                0         ?     ?        bazar/divers/bitoniau.h
                44        36    harry     bazar/divers/tartempion.c
</screen>
        </informalexample>

<!--
        <para>This is the <quote>long form</quote> output of
          <command>svn status</command>.  The letters in the first
          column mean the same as before, but the second column shows
          the working revision of the item.  The third and fourth
          columns show the revision in which the item last changed,
          and who changed it.</para>
-->
        <para>C'est la <quote>version longue</quote> de l'affichage
          de <command>svn status</command>. Les lettres de la première
          colonne ont la même signification que précédemment, mais la
          deuxième colonne indique le numéro de révision de travail
          de l'élément. Les troisième et quatrième colonnes indiquent
          le numéro de la révision dans laquelle a eu lieu le
          changement le plus récent et qui l'a effectué.</para>

<!--
        <para>None of the prior invocations to <command>svn
          status</command> contact the repository&mdash;they merely
          report what is known about the working copy items based on
          the records stored in the working copy administrative area
          and on the timestamps and contents of modified files.  But
          sometimes it is useful to see which of the items in your
          working copy have been modified in the repository since the
          last time you updated your working copy.  For
          this, <command>svn status</command> offers the
          <option>- -show-updates</option> (<option>-u</option>)
          option, which contacts the repository and adds information
          about items that are out of date:</para>
-->
        <para>Aucune des commandes citées ci-dessus n'induit de
          connexion vers le dépôt&nbsp;: elles comparent les métadonnées
          de la zone administrative et les horodatages avec la copie de
          travail. Parfois, il peut être utile de voir quels
          éléments de la copie de travail ont été modifiés dans le
          dépôt depuis la dernière mise à jour de la copie de
          travail. À cette fin, <command>svn status</command> propose
          l'option <option>--show-updates</option> (<option>-u</option>)
          qui effectue une connexion au dépôt et ajoute les informations
          sur les éléments périmés&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn status -u -v
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46-->
$ svn status -u -v
M      *        44        23    sally     LISEZMOI
M               44        20    harry     machin.c
       *        44        35    harry     bazar/truite.c
D               44        19    ira       bazar/poisson.c
A                0         ?     ?        bazar/divers/bitoniau.h
État par rapport à la révision   46
</screen>
        </informalexample>

<!--
        <para>Notice in the previous example the two asterisks: if you
          were to run <userinput>svn update</userinput> at this point,
          you would receive changes to <filename>README</filename>
          and <filename>trout.c</filename>.  This tells you some very
          useful information&mdash;because one of those items is also
          one that you have locally modified (the
          file <filename>README</filename>), you'll need to update and
          get the server's changes for that file before you commit, or
          the repository will reject your commit for being out of
          date.  We discuss this in more detail later.</para>
-->
        <para>Notez les deux astérisques&nbsp;: si vous lanciez la
          commande <command>svn update</command>, vous recevriez les
          changements relatifs à <filename>LISEZMOI</filename> et
          <filename>truite.c</filename>. Cela vous procure des
          informations particulièrement intéressantes, puisque l'un
          des éléments a fait l'objet de modifications de votre part (le
          fichier <filename>LISEZMOI</filename>)&nbsp;; vous devez
          faire une mise à jour et récupérer les changements effectués
          sur <filename>LISEZMOI</filename> avant de propager les
          vôtres, sinon le dépôt rejettera votre propagation en la
          considérant comme périmée (le sujet est approfondi plus
          tard).</para>

<!--
        <para><command>svn status</command> can display much more
          information about the files and directories in your working
          copy than we've shown here&mdash;for an exhaustive
          description of <command>svn status</command> and its output,
          run <userinput>svn help status</userinput> or see
          <xref linkend="svn.ref.svn.c.status"/> in
          <xref linkend="svn.ref.svn"/>.</para>
-->
        <para><command>svn status</command> peut afficher beaucoup
          plus d'informations sur les fichiers et dossiers de votre
          copie de travail que ce que nous venons de voir ici. Pour
          obtenir une description exhaustive de <command>svn
          status</command> et de ses modes d'affichage, lancez
          <userinput>svn help status</userinput> ou reportez-vous à
          <xref linkend="svn.ref.svn.c.status"/> dans
          <xref linkend="svn.ref.svn"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.examine.diff">
<!--
        <title>Examine the details of your local modifications</title>
-->
        <title>Détail des modifications effectuées localement</title>

<!--
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>diff</tertiary>
          </indexterm>
          <indexterm>
            <primary>differences</primary>
            <secondary>unified diff</secondary>
          </indexterm>Another way to examine your changes is with the
          <command>svn diff</command> command, which displays
          differences in file content.  When you run <userinput>svn
          diff</userinput> at the top of your working copy with no
          arguments, Subversion will print the changes you've made to
          human-readable files in your working copy.  It displays
          those changes in <firstterm>unified diff</firstterm> format,
          a format which describes changes as <quote>hunks</quote>
          (or <quote>snippets</quote>) of a file's content where each
          line of text is prefixed with a single-character code: a
          space, which means the line was unchanged; a minus sign
          (<literal>-</literal>), which means the line was removed
          from the file; or a plus sign (<literal>+</literal>), which
          means the line was added to the file.  In the context
          of <command>svn diff</command>, those minus-sign- and
          plus-sign-prefixed lines show how the lines looked before
          and after your modifications, respectively.</para>
-->
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>sous-commandes</secondary>
            <tertiary>diff</tertiary>
          </indexterm>
          <indexterm>
            <primary>différences</primary>
            <secondary>diff unifié</secondary>
          </indexterm>La commande <command>svn diff</command> offre une
          autre façon d'examiner vos changements. En lançant la commande
          <userinput>svn diff</userinput> dans le dossier racine de
          votre copie de travail et sans argument, Subversion affiche
          les changements que vous avez apportés dans les fichiers
          lisibles par les humains de votre copie de travail. Il
          affiche ces changements au format <firstterm>diff
          unifié</firstterm>, un format qui décrit les changements
          par des <quote>morceaux</quote>
          (<foreignphrase>hunks</foreignphrase> ou
          <foreignphrase>snippets</foreignphrase> en anglais) du
          contenu des fichiers, où chaque ligne de texte est
          préfixée par un code sur un caractère&nbsp;: une espace
          signifie que la ligne n'a pas été modifiée&nbsp;; un signe
          moins (<literal>-</literal>) signifie que la ligne a été
          supprimée du fichier&nbsp;; et un signe plus
          (<literal>+</literal>) signifie que la ligne a été ajoutée
          au fichier. Dans le contexte de <command>svn diff</command>,
          les préfixes respectivement <literal>+</literal> et
          <literal>-</literal> montrent le contenu des lignes
          respectivement avant et après vos modifications.</para>

<!--
        <para>Here's an example:</para>
-->
        <para>Voici un exemple&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn diff
Index: bar.c
===================================================================
- - bar.c	(revision 3)
+++ bar.c	(working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
- - README	(revision 3)
+++ README	(working copy)
@@ -193,3 +193,4 @@
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
- - stuff/fish.c	(revision 1)
+++ stuff/fish.c	(working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
- - stuff/things/bloo.h	(revision 8)
+++ stuff/things/bloo.h	(working copy)
+Here is a new file to describe
+things about bloo.-->
$ svn diff
Index: truc.c
===================================================================
--- machin.c	(révision 3)
+++ machin.c	(copie de travail)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;
 int main(void) {
-  printf("Soixante-quatre tranches de fromage...\n");
+  printf("Soixante-cinq tranches de fromage...\n");
 return 0;
 }
Index: LISEZMOI
===================================================================
--- LISEZMOI	(révision 3)
+++ LISEZMOI	(copie de travail)
@@ -193,3 +193,4 @@
+Pense-bête : passer au pressing.
Index: bazar/poisson.c
===================================================================
--- bazar/poisson.c	(révision 1)
+++ bazar/poisson.c	(copie de travail)
-Bienvenue dans le fichier 'poisson'.
-Plus d'informations seront disponibles prochainement.
Index: bazar/divers/machin.h
==================================================================
--- bazar/divers/bitoniau.h	(révision 8)
+++ bazar/divers/bitoniau.h	(copie de travail)
+Voici un nouveau fichier pour
+écrire sur les petites choses.
</screen>
        </informalexample>

<!--
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>patch</tertiary>
          </indexterm>
          <indexterm>
            <primary>patches</primary>
          </indexterm>
          <indexterm>
            <primary>patch file</primary>
            <see>patches</see>
          </indexterm>The <command>svn diff</command> command produces this
          output by comparing your working files against its pristine
          text-base.  Files scheduled for addition are displayed as
          files in which every line was added; files scheduled for
          deletion are displayed as if every line was removed from
          those files.  The output from <command>svn diff</command> is
          somewhat compatible with the <command>patch</command>
          program&mdash;more so with the <command>svn patch</command>
          subcommand introduced in Subversion 1.7.  Patch processing
          commands such as these read and apply <firstterm>patch
          files</firstterm> (or <quote>patches</quote>), which are
          files that describe differences made to one or more files.
          Because of this, you can share the changes you've made in
          your working copy with someone else without first committing
          those changes by creating a patch file from the redirected
          output of <command>svn diff</command>:</para>
-->
        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>sous-commandes</secondary>
            <tertiary>patch</tertiary>
          </indexterm>
          <indexterm>
            <primary>correctifs</primary>
          </indexterm>
          <indexterm>
            <primary>patches</primary>
            <see>correctifs</see>
          </indexterm>La commande <command>svn diff</command> produit
          ces lignes en comparant vos fichiers de travail aux copies
          <quote>originales</quote> en cache dans la zone
          administrative. Les fichiers marqués pour ajout sont affichés
          comme toute section de texte ajoutée, et les fichiers marqués
          pour suppression sont affichés comme toute section de texte
          supprimée. L'affichage de <command>svn diff</command> est
          compatible avec le programme <command>patch</command> &mdash;
          et encore davantage avec l'introduction de la commande
          <command>svn patch</command> dans Subversion 1.7. Les
          commandes patch lisent et appliquent des
          <firstterm>correctifs</firstterm>
          (<foreignphrase><firstterm>patches</firstterm></foreignphrase>
          en anglais), c'est-à-dire des fichiers qui décrivent les
          modifications appliquées à un ou plusieurs fichiers. Ainsi,
          vous pouvez partager les modifications que vous avez faites
          sur votre copie de travail avec quelqu'un d'autre sans
          propager ces modifications, mais seulement en créant un
          fichier correctif obtenu par la redirection de l'affichage de
          <command>svn diff</command>.</para>

        <informalexample>
          <screen><!--
$ svn diff &gt; patchfile
$-->
$ svn diff &gt; fichier-correctif
$
</screen>
        </informalexample>

<!--
        <para>Subversion uses its internal diff engine, which produces
          unified diff format, by default.  If you want diff output in
          a different format, specify an external diff program using
          <option>- -diff-cmd</option> and pass any additional flags
          that it needs via the <option>- -extensions</option>
          (<option>-x</option>) option.  For example, you might want
          Subversion to defer its difference calculation and display
          to the GNU <command>diff</command> program, asking that
          program to print local modifications made to the
          file <filename>foo.c</filename> in context diff format
          (another flavor of difference format) while ignoring changes
          made only to the case of the letters used in the file's
          contents:</para>
-->
        <para>Subversion utilise son propre moteur de calcul de
          différences, qui produit par défaut des résultats au format
          diff unifié. Si vous désirez obtenir les différences dans un
          autre format, spécifiez un programme de comparaison externe
          en utilisant l'option <option>--diff-cmd</option> et en
          fournissant les paramètres que vous voulez à l'aide de
          l'option <option>--extensions</option> (-<option>x</option>).
          Par exemple, pour obtenir les différences entre votre
          version locale du fichier et l'original de
          <filename>truc.c</filename> au format
          <quote>contexte</quote> et en ignorant la casse des
          caractères, vous pouvez lancer la commande
          suivante&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn diff -diff-cmd /usr/bin/diff -x "-i" foo.c
&hellip;
$-->
$ svn diff --diff-cmd /usr/bin/diff -x "-i" truc.c
&hellip;
$
</screen>
        </informalexample>

      </sect3>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.revert">
<!--
      <title>Fix Your Mistakes</title>
-->
      <title>Annulation des changements de la copie de travail</title>

<!--
      <para>Suppose while viewing the output of <command>svn
        diff</command> you determine that all the changes you made to
        a particular file are mistakes.  Maybe you shouldn't have
        changed the file at all, or perhaps it would be easier to make
        different changes starting from scratch.  You could edit the
        file again and unmake all those changes.  You could try to
        find a copy of how the file looked before you changed it, and
        then copy its contents atop your modified version.  You
        could attempt to apply those changes to the file again in
        reverse using <userinput>svn patch - -reverse-diff</userinput>
        or using your operating system's <userinput>patch -R</userinput>.
        And there are probably other approaches you could take.</para>
-->
      <para>Supposons qu'en examinant la sortie de
        <command>svn diff</command>, vous vous rendiez compte que
        tous les changements effectués sur un fichier donné sont
        erronés. Peut-être auriez-vous dû laisser le fichier tel
        quel, ou bien peut-être qu'il serait plus facile de reprendre
        les changements depuis le début. Vous pourriez éditer à
        nouveau le fichier et défaire tous les changements. Vous
        pourriez essayer de trouver une copie du fichier tel qu'il
        était avant les changements et copier son contenu à la place
        de votre fichier modifié. Vous pourriez essayer d'appliquer
        les changements à l'envers en utilisant <userinput>svn patch
        --reverse-diff</userinput> ou depuis le système d'exploitation
        avec <userinput>patch -R</userinput>. Et il existe probablement
        encore d'autres méthodes.</para>

      <indexterm>
        <primary>svn</primary>
<!--
        <secondary>subcommands</secondary>
-->
        <secondary>sous-commandes</secondary>
        <tertiary>revert</tertiary>
      </indexterm>

<!--
      <para>Fortunately in Subversion, undoing your work and starting
        over from scratch doesn't require such acrobatics.  Just use
        the <command>svn revert</command> command:</para>
-->
      <para>Heureusement, avec Subversion annuler son travail et
        repartir de zéro ne nécessite pas autant d'acrobaties. Vous
        avez juste à utiliser la commande <command>svn
        revert</command>:</para>

      <informalexample>
        <screen><!--
$ svn status README
M       README
$ svn revert README
Reverted 'README'
$-->
$ svn status LISEZMOI
M       LISEZMOI
$ svn revert LISEZMOI
'LISEZMOI' réinitialisé
$
</screen>
      </informalexample>

<!--
      <para>In this example, Subversion has reverted the file to its
        premodified state by overwriting it with the pristine version
        of the file cached in the text-base area.  But note that
        <command>svn revert</command> can undo
        <emphasis>any</emphasis> scheduled operation&mdash;for
        example, you might decide that you don't want to add a new
        file after all:</para>
-->
      <para>Dans cet exemple, Subversion ramène le fichier dans son état
        d'avant les modifications en le remplaçant par la copie de
        l'original stockée dans la zone d'administration. Mais notez
        aussi que <command>svn revert</command> peut annuler
        <emphasis>n'importe quelle</emphasis> opération. Par
        exemple, vous pouvez décider que, après tout, vous ne
        voulez pas ajouter tel fichier&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn status new-file.txt
?       new-file.txt
$ svn add new-file.txt
A         new-file.txt
$ svn revert new-file.txt
Reverted 'new-file.txt'
$ svn status new-file.txt
?       new-file.txt
$-->
$ svn status truc
?      truc

$ svn add truc
A         truc

$ svn revert truc
'truc' réinitialisé

$ svn status truc
?      truc
$
</screen>
      </informalexample>

<!--
      <para>Or perhaps you mistakenly removed a file from version
        control:</para>
-->
      <para>Ou, si vous avez enlevé un fichier du suivi de versions
        par erreur&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn status README

$ svn delete README
D         README
$ svn revert README
Reverted 'README'
$ svn status README

$-->
$ svn status LISEZMOI

$ svn delete LISEZMOI
D       LISEZMOI
$ svn revert LISEZMOI
'LISEZMOI' réinitialisé
$ svn status LISEZMOI

$
</screen>
      </informalexample>

<!--
      <para>The <command>svn revert</command> command offers salvation
        for imperfect people.  It can save you huge amounts of time
        and energy that would otherwise be spent manually unmaking
        changes or, worse, disposing of your working copy and checking
        out a fresh one just to have a clean slate to work with
        again.</para>
-->
      <para>La commande <command>svn revert</command> est le parachute
        des gens imparfaits. Elle peut vous faire gagner un temps et une
        énergie considérables que vous auriez dépensé autrement à
        faire des corrections manuelles, voire à récupérer une copie
        de travail vierge juste pour retrouver un environnement de
        travail propre.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.resolve">
<!--
      <title>Resolve Any Conflicts</title>
-->
      <title>Résolution des conflits</title>

<!--
      <para>
        <indexterm>
          <primary>conflicts</primary>
          <secondary>resolution</secondary>
        </indexterm>We've already seen how <userinput>svn status
        -u</userinput> can predict conflicts, but dealing with those
        conflicts is still something that remains to be done.
        Conflicts can occur any time you attempt to merge or integrate
        (in a very general sense) changes from the repository into
        your working copy.  By now you know that <command>svn
        update</command> creates exactly that sort of
        scenario&mdash;that command's very purpose is to bring your
        working copy up to date with the repository by merging all the
        changes made since your last update into your working copy.
        So how does Subversion report these conflicts to you, and how
        do you deal with them?</para>

-->
      <para>
        <indexterm>
          <primary>conflits</primary>
          <secondary>résolution</secondary>
        </indexterm>Nous avons déjà vu que <userinput>svn status
        -u</userinput> est capable de prévoir les conflits, mais
        il reste à savoir gérer ces conflits. Des conflits peuvent
        survenir à chaque fois que vous voulez fusionner ou intégrer
        (dans le sens le plus général) des modifications en
        provenance du dépôt dans votre copie de travail. Vous savez
        désormais que la commande <userinput>svn update</userinput>
        génère ce type de situation&nbsp;; la fonction essentielle de
        cette commande est de mettre à jour votre copie de travail en
        y intégrant toutes les modifications effectuées depuis votre
        dernière mise à jour. Comment Subversion vous rend-il compte
        de ces conflits et comment pouvez-vous les gérer&nbsp;?</para>

<!--
      <para>Suppose you run <userinput>svn update</userinput> and you
        see this sort of interesting output:</para>
-->
      <para>Supposons que vous lanciez <userinput>svn update</userinput>
        et que le résultat suivant apparaisse&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn update
Updating '.':
U    INSTALL
G    README
Conflict discovered in 'bar.c'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: -->
$ svn update
Mise à jour de '.' :
U  INSTALL
G  LISEZMOI
Conflit découvert dans 'machin.c'.
Sélectionner : (p) report, (df) diff complet, (e) édite, (m) fusion,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) voir toutes les options:
</screen>
      </informalexample>

<!--
      <para>The <computeroutput>U</computeroutput> (which stands for
        <quote>Updated</quote>) and <computeroutput>G</computeroutput>
        (for <quote>merGed</quote>) codes are no cause for concern;
        those files cleanly absorbed changes from the repository.  A
        file marked with <computeroutput>U</computeroutput> contains
        no local changes but was updated with changes from the
        repository.  One marked with
        <computeroutput>G</computeroutput> had local changes to begin
        with, but the changes coming from the repository didn't
        conflict with those local changes.</para>
-->
      <para>Les codes <computeroutput>U</computeroutput> (qui veut dire
        <quote>mis à jour</quote>, <foreignphrase>updated</foreignphrase>
        en anglais) et <computeroutput>G</computeroutput> (qui veut
        dire fusionné, <foreignphrase>merGed</foreignphrase> en
        anglais) ne doivent pas vous inquiéter, les fichiers
        correspondants ayant absorbé sans problème les modifications
        venant du dépôt. Les fichiers notés
        <computeroutput>U</computeroutput> ne contenaient aucun
        changement local mais ont été mis à jour à partir de
        changements présents dans le dépôt. Le fichier marqué
        <computeroutput>G</computeroutput>  avait subi des changements
        localement, mais les changements en provenance du dépôt ont pu
        être appliqués sans affecter les changements locaux.</para>

<!--
      <para>It's the next few lines which are interesting.  First,
        Subversion reports to you that in its attempt to merge
        outstanding server changes into the
        file <filename>bar.c</filename>, it has detected that some of
        those changes clash with local modifications you've made to
        that file in your working copy but have not yet committed.
        Perhaps someone has changed the same line of text you also
        changed.  Whatever the reason, Subversion instantly flags this
        file as being in a state of conflict.  It then asks you what
        you want to do about the problem, allowing you to
        interactively choose an action to take toward resolving the
        conflict.  The most commonly used options are displayed, but
        you can see all of the options by
        typing <replaceable>s</replaceable>:</para>
-->
      <para>Ce sont les quelques lignes suivantes qui sont
        intéressantes.  D'abord, Subversion vous avertit que sa
        tentative pour fusionner les modifications en provenance du
        serveur dans le fichier local <filename>machin.c</filename>, il
        a détecté que certains changements interfèrent avec
        les vôtres&nbsp;quelqu'un a peut-être modifié la même ligne
        que vous. Quelle qu'en soit la raison, Subversion marque
        immédiatement le fichier comme étant dans un état de
        conflit. Ensuite, il vous demande ce que vous voulez faire pour
        résoudre ce conflit, vous proposant de choisir une action de
        manière interactive. Les options les plus utilisées sont
        affichées, mais vous pouvez voir toutes les options possibles en
        tapant <replaceable>s</replaceable>&nbsp;:</para>
      <informalexample>
        <screen><!--
&hellip;
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: s

  (e)  - change merged file in an editor  [edit]
  (df) - show all changes made to merged file
  (r)  - accept merged version of file

  (dc) - show all conflicts (ignoring merged version)
  (mc) - accept my version for all conflicts (same)  [mine-conflict]
  (tc) - accept their version for all conflicts (same)  [theirs-conflict]

  (mf) - accept my version of entire file (even non-conflicts)  [mine-full]
  (tf) - accept their version of entire file (same)  [theirs-full]

  (m)  - use internal merge tool to resolve conflict
  (l)  - launch external tool to resolve conflict  [launch]
  (p)  - mark the conflict to be resolved later  [postpone]
  (q)  - postpone all remaining conflicts
  (s)  - show this list (also 'h', '?')
Words in square brackets are the corresponding - -accept option arguments.

Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options:-->
&hellip;
Sélectionner : (p) report, (df) diff complet, (e) édite, (m) fusion,
               (mc) my side of conflict, (tc) their side of conflict,
               (s) voir toutes les options:

  (e)  - change merged file in an editor  [edit]
  (df) - show all changes made to merged file
  (r)  - accept merged version of file

  (dc) - show all conflicts (ignoring merged version)
  (mc) - accept my version for all conflicts (same)  [mine-conflict]
  (tc) - accept their version for all conflicts (same)  [theirs-conflict]

  (mf) - accept my version of entire file (even non-conflicts)  [mine-full]
  (tf) - accept their version of entire file (same)  [theirs-full]

  (m)  - use internal merge tool to resolve conflict
  (l)  - launch external tool to resolve conflict  [launch]
  (p)  - mark the conflict to be resolved later  [postpone]
  (q)  - postpone all remaining conflicts
  (s)  - show this list (also 'h', '?')
Words in square brackets are the corresponding --accept option arguments.

Select: (p) postpone, (df) show diff, (e) edit file, (m) fusion,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options:

</screen>
      </informalexample>

<!--
      <para>Let's briefly review each of these options before we go
        into detail on what each option means.</para>
-->
      <para>Regardons brièvement ce que recèle chaque option avant
        de les détailler&nbsp;:</para>

      <variablelist>
        <varlistentry>
<!--
          <term><computeroutput>(e)  edit  [edit]</computeroutput></term>
-->
          <term><computeroutput>(e)  edit  [edit]</computeroutput></term>
          <listitem>

<!--
            <para>Open the file in conflict with your favorite editor,
              as set in the environment variable
              <literal>EDITOR</literal>.</para>
-->
            <para>Ouvrir le fichier en conflit avec votre éditeur de
              texte favori, qui est spécifié dans la variable
              d'environnement <literal>EDITOR</literal>.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(df)  diff-full</computeroutput></term>
-->
          <term><computeroutput>(df)  diff-full</computeroutput></term>
          <listitem>

<!--
            <para>Display the differences between the base revision
              and the conflicted file itself in unified diff format.</para>
-->
            <para>afficher les différences entre la révision de base
              et le fichier en conflit au format diff unifié.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(r)  resolved</computeroutput></term>
-->
          <term><computeroutput>(r)  resolved</computeroutput></term>
          <listitem>

<!--
            <para>After editing a file, tell
              <command>svn</command> that you've resolved the
              conflicts in the file and that it should accept the
              current contents&mdash;basically that you've
              <quote>resolved</quote> the conflict.</para>
-->
            <para>Après édition du fichier, indiquer à Subversion que
              vous avez résolu les conflits à l'intérieur du fichier
              et qu'il doit accepter son contenu actuel&nbsp;; en bref,
              vous avez <quote>résolu</quote> le conflit.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(dc)  display-conflict</computeroutput></term>
-->
          <term><computeroutput>(dc)  display-conflict</computeroutput></term>
          <listitem>
<!--
            <para>Display all conflicting regions of the file,
              ignoring changes which were successfully merged.</para>
-->
            <para>Afficher toutes les parties du fichier en conflit, en
              ignorant les modifications qui ont réussi à être
              fusionnées.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(mc)  mine-conflict  [mine-conflict]</computeroutput></term>
-->
          <term><computeroutput>(mc)  mine-conflict  [mine-conflict]</computeroutput></term>
          <listitem>

<!--
            <para>Discard any newly received changes from the server
              which conflict with your local changes to the file under
              review.  However, accept and merge all non-conflicting
              changes received from the server for that file.</para>
-->
            <para>ignorer les changements envoyés par le serveur qui
              entrent en conflit avec vos modifications locales pour le
              fichier concerné. Cependant, accepter et fusionner
              toutes les parties qui n'engendrent pas de conflit.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(tc)  theirs-conflict  [theirs-conflict]</computeroutput></term>
-->
          <term><computeroutput>(tc)  theirs-conflict  [theirs-conflict]</computeroutput></term>
          <listitem>
<!--
            <para>Discard any local changes which conflict with
              incoming changes from the server for the file under
              review.  However, preserve all non-conflicting local
              changes to that file.</para>
-->
            <para>Ignorer les modifications locales qui engendrent des
            conflits avec la version envoyée par le serveur pour le
            fichier concerné. Cependant, conserver toutes les parties
            qui n'engendrent pas de conflit pour ce fichier.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(mf)  mine-full  [mine-full]</computeroutput></term>
-->
          <term><computeroutput>(mf)  mine-full  [mine-full]</computeroutput></term>
          <listitem>
<!--
            <para>Discard all newly received changes from the server
              for the file under review, but preserve all your local
              changes for that file.</para>
-->
            <para>Ignorer les changements envoyés par le serveur et
              utiliser uniquement votre version locale pour le
              fichier concerné.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(tf)  theirs-full  [theirs-full]</computeroutput></term>
-->
          <term><computeroutput>(tf)  theirs-full  [theirs-full]</computeroutput></term>
          <listitem>
<!--
            <para>Discard all your local changes to the file under
              review and use only the newly received changes from the
              server for that file.</para>
-->
            <para>Ignorer vos changements sur le fichier concerné et
              utiliser la version envoyée par le serveur.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(m)  merge</computeroutput></term>
-->
          <term><computeroutput>(m)  fusion</computeroutput></term>
          <listitem>
<!--
            <para>Launch an internal file merge tool to perform the
              conflict resolution. The option is available starting
              with Subversion 1.8.</para>
-->
            <para>Lancer un outil interne de fusion pour traiter le
              conflit. Cette option est disponible à partir de
              Subversion 1.8.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(l)  launch</computeroutput></term>
-->
          <term><computeroutput>(l)  launch</computeroutput></term>
          <listitem>

<!--
            <para>Launch an external program to perform the conflict
              resolution.  This requires a bit of preparation
              beforehand.</para>
-->
            <para>Lancer un programme externe pour résoudre le conflit.
              Ceci nécessite un peu de préparation en amont.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(p)  postpone  [postpone]</computeroutput></term>
-->
          <term><computeroutput>(p)  postpone  [postpone]</computeroutput></term>
          <listitem>
<!--
            <para>Leave the file in a conflicted state for you to
              resolve after your update is complete.</para>
-->
            <para>Laisser le fichier en état de conflit, conflit que
              vous devrez résoudre après la fin de la mise à
              jour.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
<!--
          <term><computeroutput>(s)  show all</computeroutput></term>
-->
          <term><computeroutput>(s)  show all</computeroutput></term>
          <listitem>

<!--
            <para>Show the list of all possible commands you can use
              in interactive conflict resolution.</para>
-->
            <para>Afficher la liste de toutes les commandes que vous
              pouvez utiliser dans la résolution interactive des
              conflits.</para>

          </listitem>
        </varlistentry>

      </variablelist>

<!--
      <para>We'll cover these commands in more detail now, grouping
        them together by related functionality.</para>
-->
      <para>Nous allons maintenant passer en revue chaque commande, en
        les classant par fonctionnalité.</para>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.diff">

<!--
        <title>Viewing conflict differences interactively</title>
-->
        <title>Traitement des lignes en conflit de façon interactive</title>

<!--
        <para>
          <indexterm>
            <primary>conflicts</primary>
            <secondary>reviewing</secondary>
          </indexterm>Before deciding how to attack a conflict
          interactively, odds are that you'd like to see exactly what
          is in conflict.  Two of the commands available at the
          interactive conflict resolution prompt can assist you here.
          The first is the <quote>diff-full</quote> command
          (<userinput>df</userinput>), which displays all the local
          modifications to the file in question plus any conflict
          regions:</para>
-->
        <para>
          <indexterm>
            <primary>conflits</primary>
            <secondary></secondary>
          </indexterm>Avant de décider comment résoudre un conflit de
          manière interactive, il est probable que vous vouliez examiner
          le détail des lignes en conflit. Deux des commandes
          accessibles via l'invite interactive de gestion des conflits
          répondent à ce besoin. La première est la commande
          <userinput>df</userinput> (pour
          <foreignphrase>diff-full</foreignphrase> en anglais), qui
          affiche toutes les modifications locales du fichier ainsi que
          les zones en conflit&nbsp;:</para>

        <informalexample>
          <screen><!--
&hellip;
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: df
- - - .svn/text-base/sandwich.txt.svn-base      Tue Dec 11 21:33:57 2007
+++ .svn/tmp/tempfile.32.tmp     Tue Dec 11 21:34:33 2007
@@ -1 +1,5 @@
-Just buy a sandwich.
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
+Go pick up a cheesesteak.
+=======
+Bring me a taco!
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r32
&hellip;-->
&hellip;
Sélectionner : (p) report, (df) diff complet, (e) édite, (m) fusion,
               (mc) my side of conflict, (tc) their side of conflict,
               (s) voir toutes les options:df
--- .svn/text-base/sandwich.txt.svn-base      mar. 11 déc. 2007, 21:33:57
+++ .svn/tmp/tempfile.32.tmp     mar. 11 déc. 2007, 21:34:33
@@ -1 +1,5 @@
-Achète-moi un sandwich.
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mien
+Va chercher un hamburger.
+=======
+Apporte-moi un taco !
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r32
&hellip;
</screen>
        </informalexample>

<!--
        <para>The first line of the diff content shows the previous
          contents of the working copy (the <literal>BASE</literal>
          revision), the next content line is your change, and the
          last content line is the change that was just received from
          the server (<emphasis>usually</emphasis> the
          <literal>HEAD</literal> revision).</para>
-->
        <para>La première ligne du diff correspond à ce que contenait
          la copie de travail dans l'ancienne version (la révision
          <literal>BASE</literal>), la ligne suivante correspond
          à vos modifications et la dernière ligne contient les
          modifications reçues du serveur (la révision
          <literal>HEAD</literal> la plupart du temps).</para>

<!--
        <para>The second command is similar to the first, but
          the <quote>display-conflict</quote>
          (<userinput>dc</userinput>) command shows only the conflict
          regions, not all the changes made to the file.
          Additionally, this command uses a slightly different display
          format for the conflict regions which allows you to more
          easily compare the file's contents in those regions as they
          would appear in each of three states: original and unedited;
          with your local changes applied and the server's conflicting
          changes ignored; and with only the server's incoming changes
          applied and your local, conflicting changes reverted.</para>

-->
        <para>La deuxième commande est similaire à la première mais
        <userinput>dc</userinput>(<foreignphrase>display
        conflict</foreignphrase> en anglais) affiche uniquement les
        zones en conflits, pas toutes les modifications apportées au
        fichier. En plus, cette commande utilise un format d'affichage
        légèrement différent qui permet de comparer facilement le
        contenu du fichier tel qu'il serait dans les trois
        états&nbsp;: original et non édité&nbsp;; avec les
        modifications locales et les changements provenant du serveur
        qui génèrent  des conflits ignorés&nbsp;; uniquement les
        changements provenant du serveur et vos modifications locales
        qui génèrent des conflits ignorés.</para>

<!--
        <para>After reviewing the information provided by these
          commands, you're ready to move on to the next action.</para>

-->
        <para>Après avoir pris connaissance des informations fournies
          par ces commandes, vous être prêt à l'action suivante.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.resolve">

<!--
        <title>Resolving conflict differences interactively</title>
-->
        <title>Résolution des conflits en mode interactif</title>

        <para>
          <indexterm>
<!--
            <primary>conflicts</primary>
            <secondary>resolution</secondary>
            <tertiary>interactive</tertiary>
-->
            <primary>conflits</primary>
            <secondary>résolution</secondary>
            <tertiary>interactive</tertiary>
<!--
          </indexterm>The main way to resolve conflicts interactively
          is to use an internal file merge tool.  The tool asks you
          what to do with each conflicting change and allows you to
          selectively merge and edit changes.  However, there are
          several other different ways to resolve conflicts
          interactively&mdash;two of them allow you to selectively
          merge and edit changes using external editors, the rest of
          which allow you to simply pick a version of the file and
          move along.  Internal merge tool combines all of the
          available ways to resolve conflicts.</para>
-->
          </indexterm>La manière la plus directe de résoudre interactivement
          un conflit utilise un outil interne de fusion. Cet outil vous
          demande quoi faire pour chaque modification qui pose problème
          et permet de fusionner et d'adapter les modifications de
          manière interactive. Cependant, il existe d'autres manières
          de faire interactivement&mdash; deux outils peuvent fusionner
          et adapter les modifications à l'aide d'éditeurs externes, les
          autres vous permettent simplement de
          choisir une version du fichier parmi celles proposées et de
          passer à la suite.</para>

<!--
        <para>You've already reviewed the conflicting changes, so it's
          now time to resolve the conflicts.  The first command that
          should help you is the <quote>merge</quote> command
          (<userinput>m</userinput>) which is available starting with
          Subversion 1.8.  The command displays the conflicting
          areas and allows you to choose from a number of options to
          resolve the conflicts area-by-area:
         </para>
-->
        <para>Vous avez déjà passé en revue les modifications qui posent
          problème, il est donc temps de résoudre ces conflits. La
          première commande qui peut vous aider est <quote>merge</quote>
          (<userinput>m</userinput>), disponible à partir de la version
          1.8 de Subversion. Cette commande affiche les zones en conflit
          et vous permet de choisir parmi différentes options pour chaque
          zone en conflit&nbsp;:
         </para>

        <informalexample>
          <screen><!--
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: m
Merging 'Makefile'.
Conflicting section found during merge:
(1) their version (at line 24)                  |(2) your version (at line 24)
- - - - - - - - - - - - - - - - - - - - - - - - +- - - - - - - - - - - - - -
top_builddir = /bar                             |top_builddir = /foo
- - - - - - - - - - - - - - - - - - - - - - - - +- - - - - - - - - - - - - -
Select: (1) use their version, (2) use your version,
        (12) their version first, then yours,
        (21) your version first, then theirs,
        (e1) edit their version and use the result,
        (e2) edit your version and use the result,
        (eb) edit both versions and use the result,
        (p) postpone this conflicting section leaving conflict markers,
        (a) abort file merge and return to main menu:
-->
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: m
Merging 'Makefile'.
Conflicting section found during merge:
(1) their version (at line 24)                  |(2) your version (at line 24)
------------------------------------------------+------------------------------------------------
top_builddir = /truc                             |top_builddir = /machin
------------------------------------------------+------------------------------------------------
Select: (1) use their version, (2) use your version,
        (12) their version first, then yours,
        (21) your version first, then theirs,
        (e1) edit their version and use the result,
        (e2) edit your version and use the result,
        (eb) edit both versions and use the result,
        (p) postpone this conflicting section leaving conflict markers,
        (a) abort file merge and return to main menu:
</screen>
        </informalexample>

<!--
        <para>As you can see, when you use the internal file merge tool,
          you can cycle through individual conflicting areas in the
          file and select various resolution options or postpone
          conflict resolution for selected conflicts.</para>
-->
        <para>Comme vous le constatez, en utilisant l'outil de fusion
          interne, vous pouvez naviguer entre les différentes zones en
          conflit dans le fichier et choisir différentes stratégies de
          résolution, voire remettre à plus tard la résolution du
          conflit pour certaines zones.</para>
<!--

        <para>However, if you wish to use an external editor to choose some
          combination of your local
          changes, you can use the <quote>edit</quote> command
          (<userinput>e</userinput>) to manually edit the file with
          conflict markers in a text editor (configured per the
          instructions in <xref linkend="svn.advanced.externaleditors"
          />).  After you've edited the file, if you're satisfied with
          the changes you've made, you can tell Subversion that the
          edited file is no longer in conflict by using
          the <quote>resolved</quote> command
          (<literal>r</literal>).</para>
-->
        <para>Cependant, si vous souhaitez utiliser un éditeur externe pour
          choisir une combinaison de vos
          modifications locales, vous pouvez utiliser la commande
          <quote>édite</quote> (<userinput>e</userinput>) pour
          modifier manuellement dans un éditeur de texte (configuré
          en suivant les instructions données dans
          <xref linkend="svn.advanced.externaleditors"/>) le fichier
          avec des marqueurs indiquant les conflits. Après avoir édité
          le fichier et si vous êtes satisfait de vos changements, vous
          pouvez indiquer à Subversion que le fichier n'est plus en
          conflit en utilisant la commande <quote>résolu</quote>
          (<userinput>r</userinput>).</para>

<!--
        <para>Regardless of what your local Unix snob will likely tell
          you, editing the file by hand in your favorite text editor
          is a somewhat low-tech way of remedying conflicts (see
          <xref linkend="svn.tour.cycle.resolve.byhand" /> for a
          walkthrough).  For this reason, Subversion provides
          the <quote>launch</quote> resolution command
          (<userinput>l</userinput>) to fire up a fancy graphical
          merge tool instead (see
          <xref linkend="svn.advanced.externaldifftools.merge"
          />).</para>

-->
        <para>En dehors de quelques puristes d'Unix, l'édition manuelle
          de ce fichier avec votre éditeur préféré peut sembler quelque
          peu <quote>bas de gamme</quote> (voir <xref
          linkend="svn.tour.cycle.resolve.byhand"/> pour une description
          détaillée), c'est pourquoi Subversion propose d'utiliser des
          outils graphiques plus évolués et spécialisés dans la fusion
          de documents (voir <xref
          linkend="svn.advanced.externaldifftools.merge" />) avec la
          commande <quote>launch</quote>
          (lancer en français), raccourci
          <userinput>l</userinput>).</para>

<!--
        <para>There is also a pair of compromise options
          available.  The <quote>mine-conflict</quote>
          (<userinput>mc</userinput>)
          and <quote>theirs-conflict</quote>
          (<userinput>tc</userinput>) commands instruct Subversion to
          select your local changes or the server's incoming changes,
          respectively, as the <quote>winner</quote> for all conflicts
          in the file.  But, unlike the <quote>mine-full</quote>
          and <quote>theirs-full</quote> commands, these commands
          preserve both your local changes and changes received from
          the server in regions of the file where no conflict was
          detected.</para>

-->
        <para>Il existe deux autres options qui offrent des
          compromis. Les commandes respectivement
          <quote>mien-conflits</quote> (<userinput>mc</userinput>) et
          <quote>leur-conflits</quote> (<userinput>tc</userinput>)
          demandent à Subversion de conserver respectivement vos
          modifications locales et les modifications en provenance du
          serveur pour tous les conflits rencontrés. Mais, au
          contraire de <quote>mien complet</quote> et <quote>autre
          complet</quote>, ces commandes conservent à la fois vos
          modifications et les modifications en provenance du serveur
          dans les zones du fichier où il n'est pas détecté de
          conflit.</para>

<!--
        <para>Finally, if you decide that you don't need to merge any changes,
          but just want to accept one version of the file or the
          other, you can either choose your changes (a.k.a.
          <quote>mine</quote>) by using the <quote>mine-full</quote>
          command (<userinput>mf</userinput>) or choose theirs by using the
          <quote>theirs-full</quote> command
          (<userinput>tf</userinput>).</para>
-->
        <para>Enfin, si vous décidez que vous ne voulez pas fusionner
          les modifications mais simplement conserver une version du
          fichier ou une autre, vous pouvez choisir votre version
          (étiquetée <quote>mine</quote>) en sélectionnant
          la commande <quote>mine-full</quote> (<userinput>mf</userinput>)
          ou choisir la version du dépôt en sélectionnant la commande
          <quote>theirs-full</quote> (<userinput>tf</userinput>).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.pending">

<!--
        <title>Postponing conflict resolution</title>
-->
        <title>Remise à plus tard de la résolution d'un conflit</title>

        <para>
          <indexterm>
<!--
            <primary>conflicts</primary>
            <secondary>resolution</secondary>
            <tertiary>postponing</tertiary>
-->
            <primary>conflits</primary>
            <secondary>résolution</secondary>
            <tertiary>remettre à plus tard</tertiary>
<!--
          </indexterm>This may sound like an appropriate section for avoiding
          marital disagreements, but it's actually still about
          Subversion, so read on.  If you're doing an update and
          encounter a conflict that you're not prepared to review or
          resolve, you can type <userinput>p</userinput> to postpone
          resolving a conflict on a file-by-file basis when you run
          <userinput>svn update</userinput>.  If you know in advance
          that you don't want to resolve any conflicts interactively,
          you can pass the <option>- -non-interactive</option> option
          to <command>svn update</command>, and any file in conflict
          will be marked with a <computeroutput>C</computeroutput>
          automatically.</para>
-->
          </indexterm>Le titre peut laisser penser à un paragraphe sur
          l'amélioration des relations conjugales, mais il s'agit bien
          toujours de Subversion, voyez plutôt. Si, lorsque vous
          effectuez une mise à jour, Subversion soulève un conflit
          que vous n'êtes pas prêt à résoudre, vous pouvez, fichier
          par fichier, taper <userinput>p</userinput>, pour remettre
          à plus tard la résolution du conflit. Si, lors de votre
          mise à jour, vous ne voulez résoudre aucun conflit, vous
          pouvez passer l'option <option>--non-interactive</option>
          à <command>svn update</command> et les fichiers en conflit
          sont automatiquement marqués
          <computeroutput>C</computeroutput>.</para>

<!--
        <para>Beginning with Subversion 1.8, an internal file merge
          tool allows you to postpone conflict resolution for certain
          conflicts, but resolve other conflicts.  Therefore, you can
          postpone conflict resolution area-by-area, not just on a
          file-to-file basis.</para>
-->
        <para>À partir de Subversion 1.8, un outil interne de fusion
          vous permet de différer la résolution de conflits pour
          certains conflits et de résoudre les autres. Ainsi, vous
          pouvez différer la résolution des conflits zone par zone
          et non plus uniquement fichier par fichier.</para>

<!--
        <para>The <computeroutput>C</computeroutput>
          (for <quote>Conflicted</quote>) means that the changes from the
          server overlapped with your own, and now you have to
          manually choose between them after the update has completed.
          When you postpone a conflict resolution,
          <command>svn</command> typically does three things to assist
          you in noticing and resolving that conflict:</para>
-->
        <para>Le <computeroutput>C</computeroutput> indique un
          conflit, c'est-à-dire que les changements sur le serveur
          interfèrent avec les vôtres et vous devez donc choisir
          manuellement entre les différentes modifications après la
          fin de la procédure de mise à jour. Quand vous repoussez à
          plus tard la résolution d'un conflit, Subversion
          accomplit trois actions qui vous aideront à repérer et à
          résoudre ce conflit&nbsp;:</para>

        <itemizedlist>

          <indexterm>
<!--
            <primary>conflicts</primary>
            <secondary>conflict markers</secondary>
-->
            <primary>conflits</primary>
            <secondary>marqueurs de conflit</secondary>
          </indexterm>

          <listitem>
<!--
            <para>Subversion prints a <computeroutput>C</computeroutput>
              during the update and remembers that the file is in a
              state of conflict.</para>
-->
            <para>Subversion affiche un
              <computeroutput>C</computeroutput> pendant la mise à
              jour et enregistre que le fichier est dans un état de
              conflit.</para>
          </listitem>

          <listitem>
<!--
            <para>If Subversion considers the file to be mergeable, it
              places <firstterm>conflict
              markers</firstterm>&mdash;special strings of text that
              delimit the <quote>sides</quote> of the
              conflict&mdash;into the file to visibly demonstrate the
              overlapping areas.  (Subversion uses the
              <literal>svn:mime-type</literal> property to decide whether a
              file is capable of contextual, line-based merging.  See
              <xref linkend="svn.advanced.props.special.mime-type"/>
              to learn more.)</para>
-->
            <para>Si Subversion considère que le fichier peut être
              fusionné, il place dans le fichier des
              <firstterm>marqueurs de conflit</firstterm> (des
              chaînes de caractères spéciales qui dénotent les
              <quote>contours</quote> des conflits) pour mettre en
              exergue les zones de conflit (Subversion utilise la
              propriété <literal>svn:mime-type</literal> pour
              déterminer si un fichier peut subir une fusion
              contextuelle ligne par ligne&nbsp;; voir
              <xref linkend="svn.advanced.props.special.mime-type"/>
              pour en apprendre davantage).</para>
          </listitem>

          <listitem>
<!--
            <para>For every conflicted file, Subversion places three
              extra unversioned files in your working copy:</para>
-->
            <para>Pour chaque fichier en conflit, Subversion place
              trois fichiers supplémentaires non-suivis en versions
              dans votre copie de travail&nbsp;:</para>

            <variablelist>

              <varlistentry>
<!--
                <term><filename>filename.mine</filename></term>
-->
                <term><filename>nom_du_fichier.mine</filename></term>
                <listitem>
<!--
                  <para>This is the file as it existed in your working
                    copy before you began the update process.  It
                    contains any local modifications you had made to
                    the file up to that point.  (If Subversion
                    considers the file to be unmergeable,
                    the <filename>.mine</filename> file isn't created,
                    since it would be identical to the working
                    file.)</para>
-->
                  <para>C'est votre fichier tel qu'il était dans votre
                    copie de travail avant la mise à jour,
                    c'est-à-dire sans les marqueurs de conflits. Ce
                    fichier ne comporte que vos derniers changements
                    (si Subversion considère que le fichier ne peut
                    pas être fusionné, le fichier
                    <filename>.mine</filename> n'est pas créé, car il
                    serait identique à la version de travail).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
<!--
                <term><filename>filename.r<replaceable>OLDREV</replaceable>
-->
                <term><filename>nom_du_fichier.r<replaceable>ANCIENNE_REV</replaceable>
                      </filename></term>
                <listitem>
<!--
                  <para>This is the file as it existed in the
                    <literal>BASE</literal> revision&mdash;that is,
                    the unmodified revision of the file in your
                    working copy <emphasis>before</emphasis> you began
                    the update process&mdash;where
                    <replaceable>OLDREV</replaceable> is that base
                    revision number.</para>
-->
                  <para>C'est le fichier tel qu'il était à la révision
                    <literal>BASE</literal>, avant la mise à jour de
                    votre copie de travail. C'est donc le fichier que
                    vous avez extrait <emphasis>avant</emphasis> de
                    faire vos dernières modifications,
                    <replaceable>ANCIENNE_REV</replaceable> désignant le
                    numéro de révision de cette version de base.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
<!--
                <term><filename>filename.r<replaceable>NEWREV</replaceable>
-->
                <term><filename>nom_du_fichier.r<replaceable>NOUVELLE_REV</replaceable>
                      </filename></term>
                <listitem>
<!--
                  <para>This is the file that your Subversion client
                    just received from the server via the update of
                    your working copy, where
                    <replaceable>NEWREV</replaceable> corresponds to
                    the revision number to which you were updating
                    (<literal>HEAD</literal>, unless otherwise
                    requested).</para>
-->
                  <para>C'est le fichier que le client Subversion vient
                    de recevoir du serveur via l'opération de mise à
                    jour, où <replaceable>NOUVELLE_REV</replaceable>
                    désigne le numéro de révision de la mise à jour
                    demandée (<literal>HEAD</literal>, à moins d'avoir
                    spécifié une autre révision).</para>
                </listitem>
              </varlistentry>

            </variablelist>
          </listitem>

        </itemizedlist>

<!--
        <para>For example, Sally makes changes to the file
          <filename>sandwich.txt</filename>, but does not yet commit
          those changes.  Meanwhile, Harry commits changes to that
          same file.  Sally updates her working copy before committing
          and she gets a conflict, which she postpones:</para>
-->
        <para>Par exemple, Sally effectue un changement sur le
          fichier <filename>sandwich.txt</filename> mais elle ne
          propage pas immédiatement ses modifications. Pendant ce
          temps, Harry propage des changements sur ce même fichier.
          Sally met à jour sa copie de travail avant d'effectuer la
          propagation et un conflit apparaît, dont elle remet la
          résolution à plus tard&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn update
Updating '.':
Conflict discovered in 'sandwich.txt'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: p
C    sandwich.txt
Updated to revision 2.
Summary of conflicts:
  Text conflicts: 1-->
$ svn update
Mise à jour de '.' :
Conflit découvert dans 'sandwich.txt'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: p
C  sandwich.txt
Actualisé à la révision 2.
Résumé des conflits :
  Text conflicts: 1
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</screen>
        </informalexample>

<!--
        <para>At this point, Subversion will <emphasis>not</emphasis>
          allow Sally to commit the file
          <filename>sandwich.txt</filename> until the three temporary
          files are removed:</para>
-->
        <para>À partir de là, Subversion n'autorise
          <emphasis>pas</emphasis> Sally à propager le fichier
          <filename>sandwich.txt</filename> avant que les trois
          fichiers temporaires ne soient effacés&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn commit -m "Add a few more things"
svn: E155015: Commit failed (details follow):
svn: E155015: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict-->
$ svn commit -m "Quelques petits ajouts"
svn: Échec de la propagation (commit), détails :
svn: Arrêt de la propagation : '/home/sally/travail-svn/sandwich.txt'
                               demeure en conflit
</screen>
        </informalexample>

<!--
        <para>If you've postponed a conflict, you need to resolve the
          conflict before Subversion will allow you to commit your
          changes.  You'll do this with the <command>svn
          resolve</command> command.  This command accepts
          the <option>- -accept</option> option, which allows you
          specify your desired approach for resolving the conflict.
          Prior to Subversion 1.8, the <command>svn resolve</command>
          command <emphasis>required</emphasis> the use of this option.
          Subversion now allows you to run the <command>svn
          resolve</command> command without that option.  When you do
          so, Subversion cranks up its interactive conflict resolution
          mechanism, which you can read about (if you haven't done so
          already) in the previous section,
          <xref linkend="svn.tour.cycle.resolve.resolve" />.  We'll
          take the opportunity in this section, though, to discuss
          the use of the <option>- -accept</option> option for
          conflict resolution.</para>
-->
        <para>Si vous avez remis à plus tard la résolution d'un
          conflit, vous devez le résoudre pour que Subversion vous
          autorise à propager vos changements. Vous pouvez le faire
          avec la commande <command>svn resolve</command>. Cette
          commande possède l'option <option>--accept</option> afin de
          spécifier votre manière de résoudre le conflit. Avant
          Subversion 1.8, la commande <command>svn resolve</command>
          <emphasis>exigeait</emphasis> de spécifier l'option.
          Dorénavant, Subversion vous autorise à ne pas la
          spécifier. Dans ce cas, Subversion passe en mode de
          résolution interactif tel que présenté dans la section
          précédente (voir <xref
          linkend="svn.tour.cycle.resolve.resolve" />). Dans cette
          section, nous allons présenter l'utilisation de l'option
          <option>--accept</option> pour la résolution de
          conflits.</para>
<!--
        <para>The <option>- -accept</option> option to the <command>svn
          resolve</command> command instructs Subversion to use one of
          its pre-packaged approaches to conflict resolution.  If
          you want Subversion to resolve the conflict using the
          version of the file that you last checked out before making
          your edits, use <option>- -accept=base</option>.  If you'd
          prefer instead to keep the version that contains only your
          edits, use <option>- -accept=mine-full</option>.  You can also
          select the version that your most recent update pulled from
          the server (discarding your edits entirely)&mdash;that's
          done using <option>- -accept=theirs-full</option>.  There
          are other <quote>canned</quote> resolution types, too.  See
          <xref linkend="svn.ref.svn.sw.accept" /> in
          <xref linkend="svn.ref.svn" /> for details.</para>
-->
        <para>L'option <option>--accept</option> de la commande
          <command>svn resolve</command> demande à Subversion d'utiliser
          une des approches prédéfinies pour résoudre un conflit. Si
          vous choisissez la version du fichier que vous avez extraite
          avant de faire vos changements, utilisez l'argument
          <option>--accept=base</option>. Si vous préférez garder la
          version qui contient uniquement vos changements, utilisez
          l'argument <option>--accept=mine-full</option>. Vous pouvez
          aussi choisir la version la plus récente venant du
          serveur (et donc abandonner tous vos changements) en utilisant
          l'argument <option>--accept=theirs-full</option>.
          Il existe d'autres méthodes de résolution
          <quote>pré-emballées</quote>. Lisez <xref
          linkend="svn.ref.svn.sw.accept" /> dans
          <xref linkend="svn.ref.svn" /> pour en obtenir les détails.</para>

<!--
        <para>You aren't limited strictly to all-or-nothing options.
          If you want to pick and choose from your changes and the
          changes that your update fetched from the server, you can
          manually repair the working file, fixing up the conflicted
          text <quote>by hand</quote> (by examining and editing the
          conflict markers within the file), then tell Subversion to
          resolve the conflict by keeping the working file in its
          current state by running <command>svn resolve</command> with
          the <option>- -accept=working</option> option.</para>
-->
        <para>Vous n'êtes pas limité à ces choix tout ou rien. Si vous
          comptez effectuer un mélange de vos modifications et des
          modifications rapatriées du serveur, fusionnez le fichier en
          conflit <quote>à la main</quote> (examinez et éditez les
          marqueurs de conflit dans le fichier) puis indiquez à
          Subversion de résoudre le conflit en gardant la version de
          travail dans son état actuel par la commande <command>svn
          resolve</command> avec l'argument
          <replaceable>--accept=working</replaceable>.</para>

<!--
        <para><command>svn resolve</command> removes the three
          temporary files and accepts the version of the file that you
          specified.  After the command completes
          successfully&mdash;and assuming you didn't interactively
          choose to postpone resolution, of course&mdash;Subversion no
          longer considers the file to be in a state of
          conflict:</para>
-->
        <para>La commande <command>svn resolve</command> supprime les
          trois fichiers temporaires et retient la version du fichier
          que vous avez spécifié avec l'option
          <option>--accept</option>. À la fin d'exécution de la
          commande (en considérant bien évidemment que vous n'avez
          décidé de reporter la résolution du conflit), Subversion
          considère que le fichier n'est plus dans un état de
          conflit&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn resolve - -accept working sandwich.txt
Resolved conflicted state of 'sandwich.txt'-->
$ svn resolve --accept working sandwich.txt
Conflit sur 'sandwich.txt' résolu
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.byhand">
<!--
        <title>Manual conflict resolution</title>
-->
        <title>Résolution des conflits à la main</title>

        <para>
          <indexterm>
<!--
          <primary>conflicts</primary>
          <secondary>resolution</secondary>
          <tertiary>manual</tertiary>
-->
          <primary>conflits</primary>
          <secondary>résolution</secondary>
          <tertiary>à la main</tertiary>
<!--
          </indexterm>Manually resolving conflicts can be quite intimidating the
          first time you attempt it, but with a little practice, it
          can become as easy as falling off a bike.</para>
-->
          </indexterm>Résoudre les conflits à la main peut paraître quelque
          peu intimidant la première fois. Mais avec un peu de
          pratique, un enfant de cinq ans y arriverait.</para>

<!--
        <para>Here's an example.  Due to a miscommunication, you and
          Sally, your collaborator, both edit the file
          <filename>sandwich.txt</filename> at the same time.  Sally
          commits her changes, and when you go to update your working
          copy, you get a conflict and you're going to have to edit
          <filename>sandwich.txt</filename> to resolve the conflict.
          First, let's take a look at the file:</para>
-->
        <para>Prenons un exemple. Par manque de communication entre
          Sally (votre collaboratrice) et vous-même, vous éditez en
          même temps le fichier <filename>sandwich.txt</filename>.
          Sally propage ses changements et, quand vous mettez à jour
          votre copie de travail, un conflit apparaît, que vous devez
          résoudre en éditant <filename>sandwich.txt</filename>.
          Jetons un œil à ce fichier&nbsp;:</para>

        <informalexample>
          <screen><!--
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread-->
$ cat sandwich.txt
Tranche de pain supérieure
Mayonnaise
Laitue
Tomate
Comté
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Saucisson
Mortadelle
Jambon
=======
Choucroute
Poulet rôti
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Moutarde
Tranche de pain inférieure
</screen>

        </informalexample>

<!--
        <para>The strings of less-than signs, equals signs, and
          greater-than signs are conflict markers and are not part of
          the actual data in conflict.  You generally want to ensure
          that those are removed from the file before your next
          commit.  The text between the first two sets of markers is
          composed of the changes you made in the conflicting
          area:</para>
-->
        <para>Les suites de caractères inférieur-à
          (<literal>&lt;</literal>), égal(<literal>=</literal>) ou
          supérieur-à (<literal>&gt;</literal>) sont des marqueurs de
          conflit, ils ne font pas partie des données elles-mêmes.
          Vous devrez en général vous assurer qu'elles ont disparu du
          fichier avant de propager vos modifications. Le texte entre
          les deux premiers marqueurs est constitué des modifications
          que vous avez apportées dans la zone de
          conflit&nbsp;:</para>

        <informalexample>
          <screen><!--
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======-->
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Saucisson
Mortadelle
Jambon
=======
</screen>
        </informalexample>

<!--
        <para>The text between the second and third sets of conflict
          markers is the text from Sally's commit:</para>
-->
        <para>Le texte entre le deuxième et le troisième marqueur est
          celui du fichier propagé par Sally&nbsp;:</para>

        <informalexample>
          <screen><!--
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2-->
=======
Choucroute
Poulet rôti
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</screen>
        </informalexample>

<!--
        <para>Usually you won't want to just delete the conflict
          markers and Sally's changes&mdash;she's going to be awfully
          surprised when the sandwich arrives and it's not what she
          wanted.  This is where you pick up the phone or walk across
          the office and explain to Sally that you can't get
          sauerkraut from an Italian deli.<footnote><para>And if you
          ask them for it, they may very well ride you out of town on
          a rail.</para></footnote>  Once you've agreed on the changes
          you will commit, edit your file and remove the conflict
          markers:</para>
-->
        <para>Normalement, vous n'allez pas juste supprimer les
          marqueurs et les changements effectués par Sally (elle sera
          affreusement déçue quand on lui apportera un sandwich
          différent de ce qu'elle a commandé). Vous décrochez donc le
          téléphone, ou vous traversez le bureau, pour expliquer à
          Sally qu'on ne met pas de choucroute dans un sandwich.
          <footnote>
            <para>Et si vous commandez ça, on vous chassera de la
            ville à coup de baguette rassie.</para>
          </footnote>
          Après vous être mis d'accord sur les changements à
          enregistrer, éditez votre fichier et enlevez les marqueurs
          de conflit.</para>

        <informalexample>
          <screen><!--
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread-->
Tranche de pain supérieure
Mayonnaise
Laitue
Tomate
Comté
Saucisson
Mortadelle
Jambon
Moutarde
Tranche de pain inférieure
</screen>
        </informalexample>

<!--
        <para>Now use <command>svn resolve</command>, and you're
          ready to commit your changes:</para>
-->
        <para>Maintenant utilisez <command>svn resolve</command> et
          vous êtes paré pour propager vos changements&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn resolve - -accept working sandwich.txt
Resolved conflicted state of 'sandwich.txt'
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."-->
$ svn resolve --accept working sandwich.txt
Conflit sur 'sandwich.txt' résolu
$ svn commit -m "Va pour mon sandwich et au diable celui de Sally !"
</screen>
        </informalexample>

<!--
        <para>Naturally, you want to be careful that when using
          <command>svn resolve</command> you don't tell Subversion
          that you've resolved a conflict when you truly haven't.
          Once the temporary files are removed, Subversion will let
          you commit the file even if it still contains conflict
          markers.</para>
-->
        <para>Soyez prudent et ne lancez <command>svn resolve</command>
          qu'une fois certain que vous avez résolu le conflit dans
          votre fichier&nbsp;: une fois les fichiers temporaires
          effacés, Subversion vous laisse propager le fichier même s'il
          contient toujours des marqueurs de conflit.</para>

<!--
        <para>If you ever get confused while editing the conflicted
          file, you can always consult the three files that Subversion
          creates for you in your working copy&mdash;including your
          file as it was before you updated.  You can even use a
          third-party interactive merging tool to examine those three
          files.</para>
-->
        <para>Si jamais vous êtes perdu lors de l'édition du fichier
          en conflit, vous pouvez toujours consulter les trois
          fichiers que Subversion a créé pour vous dans votre copie
          de travail, y compris le fichier tel qu'il était avant que
          vous ne lanciez la mise à jour. Vous pouvez même utiliser
          un outil externe interactif spécialisé dans les fusions pour
          examiner ces trois fichiers.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.theirsfull">
<!--
        <title>Discarding your changes in favor of a newly fetched
          revision</title>
-->
        <title>Abandon des modifications au profit de la révision
          la plus récente</title>

<!--
        <para>
          <indexterm>
            <primary>conflicts</primary>
            <secondary>resolution</secondary>
            <tertiary>discarding local changes</tertiary>
          </indexterm>If you get a conflict and decide that you want
          to throw out your changes, you can run <userinput>svn
          resolve - -accept theirs-full
          <replaceable>CONFLICTED-PATH</replaceable></userinput> and
          Subversion will discard your edits and remove the temporary
          files:</para>
-->
        <para>
          <indexterm>
            <primary>conflits</primary>
            <secondary>résolution</secondary>
          </indexterm>Si vous faites face à un conflit et que vous
          décidez d'abandonner vos changements, vous pouvez lancer
          <userinput>svn resolve --accept theirs-full
          <replaceable>CHEMIN-DU-CONFLIT</replaceable></userinput>,
          Subversion abandonne alors vos modifications et supprime les
          fichiers temporaires&nbsp;:</para>

        <informalexample>
         <screen><!--
$ svn update
Updating '.':
Conflict discovered in 'sandwich.txt'.
Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,
        (mc) my side of conflict, (tc) their side of conflict,
        (s) show all options: p
C    sandwich.txt
Updated to revision 2.
Summary of conflicts:
  Text conflicts: 1
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ svn resolve - -accept theirs-full sandwich.txt
Resolved conflicted state of 'sandwich.txt'
$-->
$ svn update
Conflit découvert dans 'machin.c'.
Sélectionner : (p) report, (df) diff complet, (e) édite,
        (h) aide pour plus d'options :
C    sandwich.txt
Actualisé à la révision 2.
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ svn resolve --accept theirs-full sandwich.txt
Conflit sur 'sandwich.txt' résolu
$
</screen>
       </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.revert">
<!--
        <title>Punting: using svn revert</title>
-->
        <title>Retour en arrière avec svn revert</title>

        <para>
          <indexterm>
<!--
            <primary>conflicts</primary>
            <secondary>resolution</secondary>
            <tertiary>discarding local changes</tertiary>
-->
            <primary>conflits</primary>
            <secondary>résolution</secondary>
            <tertiary>abandonner les changements locaux</tertiary>
<!--
          </indexterm>If you decide that you want to throw out your changes
          and start your edits again (whether this occurs after a
          conflict or anytime), just revert your changes:</para>
-->
          </indexterm>Si vous faites face à un conflit et qu'après examen
          de la situation, vous décidez d'abandonner vos changements
          et de repartir de zéro (peu importe en fait que ce soit
          après un conflit ou à n'importe quel autre moment),
          contentez-vous de revenir en arrière sur vos
          changements&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt-->
$ svn revert sandwich.txt
'sandwich.txt' réinitialisé
$ ls sandwich.*
sandwich.txt
</screen>
        </informalexample>

<!--
        <para>Note that when you revert a conflicted file, you don't
          have to use <command>svn resolve</command>.</para>
-->
        <para>Notez que quand vous revenez en arrière sur un fichier
          en conflit, vous n'avez pas besoin de lancer
          <command>svn resolve</command>.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.commit">
<!--
      <title>Commit Your Changes</title>
-->
      <title>Propagation des modifications</title>

<!--
      <para>Finally!  Your edits are finished, you've merged all
        changes from the server, and you're ready to commit your
        changes to the repository.</para>
-->
      <para>Enfin&nbsp;! Vos modifications sont terminées, vous les avez
        fusionnées avec celles du serveur et vous êtes prêt à les
        propager vers le dépôt.</para>

<!--
      <para>The <command>svn commit</command> command sends all of
        your changes to the repository.  When you commit a change, you
        need to supply a log message describing your change.  Your log
        message will be attached to the new revision you create.  If
        your log message is brief, you may wish to supply it on the
        command line using the <option>- -message</option>
        (<option>-m</option>) option:</para>
-->
      <para>La commande <command>svn commit</command> envoie vos
       changements au dépôt. Quand vous propagez un changement,
       vous devez l'accompagner d'un commentaire de propagation qui décrit
       ce changement. Votre commentaire est associé à la nouvelle révision
       que vous créez. Si votre commentaire est bref, vous pouvez le passer
       en ligne de commande en utilisant l'option
       <option>--message</option> (ou <option>-m</option>)&nbsp;:</para>

      <informalexample>
         <screen><!--
$ svn commit -m "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.-->
$ svn commit -m "Nombre de tranches de fromage corrigé."
Envoi        sandwich.txt
Transmission des données .
Révision 3 propagée.
</screen>
</informalexample>

<!--
      <para>However, if you've been composing your log message in some
        other text file as you work, you may want to tell Subversion
        to get the message from that file by passing its filename as
        the value of the <option>- -file</option> (<option>-F</option>)
        option:</para>
-->
      <para>Cependant, si vous avez rédigé votre commentaire au fur et à
        mesure, vous souhaitez sûrement indiquer à Subversion de le
        récupérer dans un fichier en lui donnant le nom
        du fichier avec l'option <option>--file</option>
        (<option>-F</option>)&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn commit -F logmsg
Sending        sandwich.txt
Transmitting file data .
Committed revision 4.-->
$ svn commit -F commentaire_de_propagation
Envoi        sandwich.txt
Transmission des données .
Révision 4 propagée.
</screen>
      </informalexample>

<!--
      <para>If you fail to specify either the
        <option>- -message</option> (<option>-m</option>)
        or <option>- -file</option> (<option>-F</option>) option,
        Subversion will automatically launch your favorite editor (see
        the information on <literal>editor-cmd</literal> in
        <xref linkend="svn.advanced.confarea.opts.config"/>) for
        composing a log message.</para>
-->
      <para>Si vous ne spécifiez ni l'option <option>--message</option>
        ni l'option <option>--file</option>, Subversion lance
        automatiquement votre éditeur de texte favori (voir les
        détails de <literal>editor-cmd</literal> dans
        <xref linkend="svn.advanced.confarea.opts.config"/>) pour
        que vous rédigiez le commentaire de propagation.</para>

      <tip>
<!--
        <para>If you're in your editor writing a commit message and
          decide that you want to cancel your commit, you can just
          quit your editor without saving changes.  If you've already
          saved your commit message, simply delete all the text, save
          again, and then abort:</para>
-->
        <para>Si, au moment où vous rédigez votre commentaire de
          propagation, vous décidez d'annuler la propagation, vous
          n'avez qu'à quitter l'éditeur de texte sans sauvegarder
          les changements. Si vous avez déjà sauvegardé le commentaire,
          effacez le texte, sauvegardez à nouveau puis choisissez
          d'annuler&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
(a)bort, (c)ontinue, (e)dit
$-->
$ svn commit
Attente de Emacs...Fait

Entrée du journal non modifié ou non précisé
a)nnule, c)ontinue, e)dite
a
$
</screen>
        </informalexample>
      </tip>

<!--
      <para>The repository doesn't know or care whether your changes make
        any sense as a whole; it checks only to make sure nobody
        else has changed any of the same files that you did when you
        weren't looking.  If somebody <emphasis>has</emphasis> done
        that, the entire commit will fail with a message informing you
        that one or more of your files are out of date:</para>
-->
      <para>Le dépôt ne sait pas si vos changements ont un sens ou
        pas&nbsp;; il vérifie seulement que personne n'a modifié,
        pendant que vous aviez le dos tourné, un des fichiers que
        vous-même avez modifié. Si <emphasis>c'est le cas</emphasis>, la
        propagation toute entière échoue, affichant un message vous
        informant qu'un ou plusieurs de vos fichiers ne sont plus à
        jour&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Add another rule"
Sending        rules.txt
Transmitting file data .
svn: E155011: Commit failed (details follow):
svn: E155011: File '/home/sally/svn-work/sandwich.txt' is out of date
&hellip;-->
$ svn commit -m "Ajout d'une autre règle"
Envoi        règles.txt
Transmission des données .
svn: E155011: Echec de la propagation (commit), détails :
svn: E155011: Fichier '/règles.txt' obsolète
&hellip;
</screen>
      </informalexample>

<!--
      <para>(The exact wording of this error message depends on the
        network protocol and server you're using, but the idea is the
        same in all cases.)</para>
-->
      <para>Notez que le phrasé exact de ce message d'erreur dépend du
        protocole réseau et du serveur que vous utilisez, mais l'idée
        reste la même.</para>

<!--
      <para>At this point, you need to run <userinput>svn
        update</userinput>, deal with any merges or conflicts that
        result, and then attempt your commit again.</para>
-->
      <para>À ce moment là, vous devez lancer <userinput>svn
        update</userinput>, traiter les fusions ou conflits qui
        apparaissent et retenter une propagation.</para>

<!--
      <para>That covers the basic work cycle for using Subversion.
        Subversion offers many other features that you can use
        to manage your repository and working copy, but most of your
        day-to-day use of Subversion will involve only the commands
        that we've discussed so far in this chapter.  We will,
        however, cover a few more commands that you'll use fairly
        often.</para>
-->
      <para>Nous en avons terminé avec le cycle d'utilisation de
        base de Subversion. Subversion offre beaucoup d'autres
        fonctionnalités pour gérer votre dépôt et votre copie de
        travail, mais l'utilisation quotidienne de Subversion ne
        requiert pratiquement que les commandes que nous venons de
        voir dans ce chapitre. Intéressons-nous quand même à quelques
        commandes supplémentaires utilisées relativement
        souvent.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.history">
<!--
    <title>Examining History</title>
-->
    <title>Recherche dans l'historique</title>

<!--
    <para>Your Subversion repository is like a time machine.  It keeps
      a record of every change ever committed and allows you to
      explore this history by examining previous versions of files and
      directories as well as the metadata that accompanies them.  With
      a single Subversion command, you can check out the repository
      (or restore an existing working copy) exactly as it was at any
      date or revision number in the past.  However, sometimes you
      just want to <emphasis>peer into</emphasis> the past instead of
      <emphasis>going into</emphasis> it.</para>
-->
    <para>Votre dépôt Subversion est comme une machine à remonter le
      temps. Il garde une trace de tous les changements
      propagés et permet de parcourir cet historique en examinant
      aussi bien les versions précédentes des fichiers et des
      dossiers que les métadonnées associées. D'une simple commande
      Subversion, vous pouvez extraire (ou restaurer) une copie de
      travail du dépôt tel qu'il était à n'importe quelle date ou
      numéro de révision passée. Cependant, vous voulez parfois
      juste <emphasis>sonder</emphasis> le passé sans y
      retourner.</para>

<!--
    <para>Several commands can provide you with historical data from
      the repository:</para>
-->
    <para>Plusieurs commandes renvoient des informations sur
      l'historique des données présentes dans le dépôt&nbsp;:</para>

      <variablelist>

        <varlistentry>
          <term><command>svn diff</command></term>
          <listitem>
<!--
            <para>Shows line-level details of a particular change</para>
-->
            <para>affiche les détails, ligne par ligne, d'un
              changement donné.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn log</command></term>
          <listitem>
<!--
            <para>Shows you broad information: log messages with date
              and author information attached to revisions and which
              paths changed in each revision</para>
-->
            <para>fournit beaucoup d'informations&nbsp;: les commentaires de
              propagation avec la date et l'auteur de la révision
              ainsi que les chemins qui ont été modifiés à chaque
              révision.</para>
          </listitem>
        </varlistentry>


        <varlistentry>
          <term><command>svn cat</command></term>
          <listitem>
<!--
            <para>Retrieves a file as it existed in a particular
              revision number and displays it on your screen</para>
-->
            <para>récupère le fichier tel qu'il existait à un numéro de
              révision donné et l'affiche à l'écran.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn annotate</command></term>
          <listitem>
<!--
            <para>Retrieves a human-readable file as it existed in a
              particular revision number, displaying its contents in a
              tabular form with last-changed information added to
              each line of the file.</para>
-->
            <para>récupère un fichier humainement lisible tel qu'il
              existait à un numéro de révision donné, affiche son
              contenu sous la forme d'un tableau avec, pour chaque
              ligne, les informations relatives au dernier
              changement de celle-ci.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn list</command></term>
          <listitem>
<!--
            <para>Displays the files in a directory for any given
              revision</para>
-->
            <para>liste les fichiers contenus dans un dossier à
              une révision donnée.</para>
          </listitem>
        </varlistentry>

      </variablelist>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.diff">
<!--
      <title>Examining the Details of Historical Changes</title>
-->
      <title>Détail des modifications passées</title>

<!--
      <para>We've already seen <command>svn diff</command>
        before&mdash;it displays file differences in unified diff
        format; we used it to show the local modifications made to
        our working copy before committing to the repository.</para>
-->
      <para>Nous avons déjà vu la commande <command>svn diff</command>,
       qui affiche les différences entre fichiers au format diff
       unifié&nbsp;; nous l'avons utilisée pour afficher les
       modifications locales effectuées sur notre copie de travail
       avant de les propager vers le dépôt.</para>
<!--
      <para>In fact, it turns out that there are
        <emphasis>three</emphasis> distinct uses of <command>svn
        diff</command>:</para>
-->
      <para>En fait, il y a <emphasis>trois</emphasis> façons
        différentes d'utiliser<command> svn diff</command>&nbsp;:</para>

      <itemizedlist>

        <listitem>
<!--
          <para>Examining local changes</para>
-->
          <para>Examiner des modifications locales.</para>
        </listitem>

        <listitem>
<!--
          <para>Comparing your working copy to the repository</para>
-->
	  <para>Comparer votre copie de travail au dépôt.</para>
        </listitem>

        <listitem>
<!--
          <para>Comparing repository revisions</para>
-->
          <para>Comparer des révisions du dépôt.</para>
        </listitem>

      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.local">
<!--
        <title>Examining local changes</title>
-->
        <title>Modifications locales</title>

<!--
        <para>As we've seen, invoking <userinput>svn diff</userinput> with
          no options will compare your working files to the cached
          <quote>pristine</quote> copies in
          the <filename>.svn</filename> area:</para>
-->
        <para>Comme nous l'avons vu précédemment,
          <userinput>svn diff</userinput>, s'il est invoqué sans
          option, compare les fichiers de votre copie de travail à
          leurs versions <quote>originales</quote> gardées en cache
          dans la zone <filename>.svn</filename>&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn diff
Index: rules.txt
===================================================================
- - rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$-->
$ svn diff
Index: règles.txt
===================================================================
--- règles.txt	(révision 3)
+++ règles.txt	(copie de travail)
@@ -1,4 +1,5 @@
 Être attentif envers les autres
 Liberté = Responsabilité
 Tout dans la modération
-Mâcher la bouche ouverte
+Mâcher la bouche fermée
+Écouter quand les autres parlent
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.wcrepos">
<!--
        <title>Comparing working copy to repository</title>
-->
        <title>Comparaison entre la copie de travail et le dépôt</title>

<!--
        <para>If a single <option>- -revision</option>
          (<option>-r</option>) number is passed, your
          working copy is compared to the specified revision in the
          repository:</para>
-->
        <para>Si un seul numéro de révision est fourni à l'option
          <option>--revision</option> (<option>-r</option>), votre
          copie de travail est comparée à la révision spécifiée du
          dépôt&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn diff -r 3 rules.txt
Index: rules.txt
===================================================================
- - rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$-->
$ svn diff -r 3 règles.txt
Index: règles.txt
===================================================================
--- règles.txt	(révision 3)
+++ règles.txt	(copie de travail)
@@ -1,4 +1,5 @@
 Être attentif envers les autres
 Liberté = Responsabilité
 Tout dans la modération
-Mâcher la bouche ouverte
+Mâcher la bouche fermée
+Écouter quand les autres parlent
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.reposrepos">
<!--
        <title>Comparing repository revisions</title>
-->
        <title>Comparaison entre des révisions du dépôt</title>

<!--
        <para>If two revision numbers, separated by a colon, are
          passed via <option>- -revision</option>
          (<option>-r</option>), the two revisions are directly
          compared:</para>
-->
        <para>Si deux numéros de révision sont fournis à l'option
          <option>--revision</option> (<option>-r</option>), séparés
          par le caractère deux-points (<literal>:</literal>), les deux
          révisions sont directement comparées&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svn diff -r 2:3 rules.txt
Index: rules.txt
===================================================================
- - rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$-->
$ svn diff -r 2:3 règles.txt
Index: règles.txt
===================================================================
--- règles.txt	(révision 2)
+++ règles.txt	(révision 3)
@@ -1,4 +1,4 @@
 Être attentif envers les autres
-Liberté = Glace au chocolat
+Liberté = Responsabilité
 Tout dans la modération
 Mâcher la bouche ouverte
$
</screen>
        </informalexample>

<!--
        <para>A more convenient way of comparing one revision to the
          previous revision is to use the <option>- -change</option>
          (<option>-c</option>) option:</para>
-->
        <para>Une autre façon de comparer une révision à la
          précédente, plus conviviale, est d'utiliser l'option
          <option>--change</option> (<option>-c</option>)&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svn diff -c 3 rules.txt
Index: rules.txt
===================================================================
- - rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$-->
$ svn diff -c 3 règles.txt
Index: règles.txt
===================================================================
--- règles.txt	(révision 2)
+++ règles.txt	(révision 3)
@@ -1,4 +1,4 @@
 Être attentif envers les autres
-Liberté = Glace au chocolat
+Liberté = Responsabilité
 Tout dans la modération
 Mâcher la bouche ouverte
$
</screen>
        </informalexample>

<!--
        <para>Lastly, you can compare repository revisions even when
          you don't have a working copy on your local machine, just by
          including the appropriate URL on the command line:</para>
-->
        <para>Enfin, vous pouvez comparer des révisions du dépôt même
          si vous n'avez pas de copie de travail en local sur votre
          ordinateur, simplement en incluant l'URL appropriée sur la
          ligne de commande&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn diff -c 5 http://svn.example.com/repos/example/trunk/text/rules.txt
&hellip;
$-->
$ svn diff -c 5 http://svn.exemple.com/depot/exemple/trunk/texte/règles.txt
&hellip;
$
</screen>
        </informalexample>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.log">
<!--
      <title>Generating a List of Historical Changes</title>
-->
      <title>Historique des modifications</title>

<!--
      <para>To find information about the history of a file or
        directory, use the <command>svn log</command>
        command.  <command>svn log</command> will provide you with a
        record of who made changes to a file or directory, at what
        revision it changed, the time and date of that revision,
        and&mdash;if it was provided&mdash;the log message that accompanied
        the commit:</para>
-->
      <para>Pour connaître l'historique d'un fichier ou d'un
        dossier, utilisez la commande <command>svn log</command>.
        Elle affiche la liste des gens qui ont modifié le fichier ou le
        dossier en question, le numéro de chaque révision où il a
        changé, l'heure et la date de cette révision et, s'il y en avait
        un, le commentaire associé à la propagation&nbsp;:</para>

      <informalexample>
        <screen> <!--
$ svn log
...
r3 | sally | 2008-05-15 23:09:28 -0500 (Thu, 15 May 2008) | 1 line

Added include lines and corrected # of cheese slices.
...
r2 | harry | 2008-05-14 18:43:15 -0500 (Wed, 14 May 2008) | 1 line

Added main() methods.
...
r1 | sally | 2008-05-10 19:50:31 -0500 (Sat, 10 May 2008) | 1 line

Initial import
...
-->
$ svn log
------------------------------------------------------------------------
r3 | sally | 2008-05-15 23:09:28 -0500 (jeu. 15 Mai 2008) | 1 ligne

Ajout des lignes include et correction du nombre de tranches de fromage.
------------------------------------------------------------------------
r2 | harry | 2008-05-14 18:43:15 -0500 (mer. 14 Mai 2008) | 3 lignes

Ajout des méthodes main().
------------------------------------------------------------------------
r1 | sally | 2008-05-10 19:50:31 -0500 (sam. 10 Mai 2008) | 1 ligne

Import initial
------------------------------------------------------------------------
</screen>
      </informalexample>

<!--
      <para>Note that the log messages are printed in
        <emphasis>reverse chronological order</emphasis> by default.
        If you wish to see a different range of revisions in a
        particular order or just a single revision, pass the
        <option>- -revision</option> (<option>-r</option>)
        option:</para>
-->
      <para>Notez que, par défaut, l'historique est affiché en ordre
        chronologique inverse. Si vous voulez afficher un intervalle
        de révisions donné dans un ordre particulier ou juste une
        seule révision, ajoutez l'option
        <option>--revision</option> (<option>-r</option>)&nbsp;:</para>

      <table id="svn.tour.history.log.tbl-1">
<!--
        <title>Common log requests</title>
-->
        <title>Requêtes classiques dans l'historique</title>
        <tgroup cols="2">
          <thead>
            <row>
<!--
              <entry>Command</entry>
              <entry>Description</entry>
-->
              <entry>Commande</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><userinput>svn log -r 5:19</userinput></entry>
<!--
              <entry>Display logs for revisions 5 through 19 in
                chronological order</entry>
-->
              <entry>Affiche l'historique a partir de la révision 5
                jusqu'à la révision 19 dans l'ordre chronologique.
                </entry>
            </row>
            <row>
              <entry><userinput>svn log -r 19:5</userinput></entry>
<!--
              <entry>Display logs for revisions 5 through 19 in
                reverse chronological order</entry>
-->
              <entry>Affiche l'historique à partir de la révision 5
                jusqu'à la révision 19 dans l'ordre chronologique
                inverse.</entry>
            </row>
            <row>
              <entry><userinput>svn log -r 8</userinput></entry>
<!--
              <entry>Display logs for revision 8 only</entry>
-->
              <entry>Affiche l'historique pour la révision 8
                uniquement.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

<!--
      <para>You can also examine the log history of a single file or
        directory.  For example:</para>
-->
      <para>Vous pouvez aussi afficher l'historique d'un fichier ou d'un
        dossier particulier. Par exemple&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn log foo.c
&hellip;
$ svn log http://foo.com/svn/trunk/code/foo.c-->
$ svn log truc.c
&hellip;
$ svn log http://truc.com/svn/trunk/code/truc.c
&hellip;
</screen>
      </informalexample>

<!--
      <para>These will display log messages <emphasis>only</emphasis>
        for those revisions in which the named file (or directory)
        changed.</para>
-->
      <para>Ceci n'affiche le contenu de l'historique
        <emphasis>que</emphasis> pour les révisions dans lesquelles
        le fichier de travail (ou l'URL) a changé.</para>

      <sidebar>

<!--
        <title>Why Does svn log Not Show Me What I
          Just Committed?</title>
-->
        <title>Pourquoi svn log n'affiche-t-il pas ce que je viens
          de propager&nbsp;?</title>

<!--
        <para>If you make a commit and immediately type <userinput>svn
          log</userinput> with no arguments, you may notice that your
          most recent commit doesn't show up in the list of log
          messages.  This is due to a combination of the behavior of
          <command>svn commit</command> and the default behavior of
          <command>svn log</command>.  First, when you commit changes
          to the repository, <command>svn</command> bumps only the
          revision number of files (and directories) that it commits, so
          usually the parent directory remains at the older revision
          (See
          <xref linkend="svn.basic.in-action.mixedrevs.update-commit"/>
          for an explanation of why).  <command>svn log</command> then
          defaults to fetching the history of the directory at its
          current revision, and thus you don't see the newly committed
          changes.  The solution here is to either update your working
          copy or explicitly provide a revision number to <command>svn
          log</command> by using the <option>- -revision</option>
          (<option>-r</option>) option.</para>
-->
        <para>Si vous effectuez une propagation puis tapez
          immédiatement <userinput>svn log</userinput> sans argument,
          vous remarquerez peut-être que votre propagation la plus
          récente est absente de l'historique obtenu. Ceci est dû à
          une combinaison de deux facteurs&nbsp;: la façon dont
          fonctionne <command>svn commit</command> et le fonctionnement
          par défaut de <command>svn log</command>. Tout d'abord, quand
          vous propagez des modifications vers le dépôt, Subversion
          ne modifie le numéro de révision que des fichiers (et dossiers)
          qu'il propage, donc le dossier parent demeure
          généralement à l'ancienne révision (voir
          <xref linkend="svn.basic.in-action.mixedrevs.update-commit"/>
          pour savoir pourquoi). La commande <command>svn log</command>
          ne récupère ensuite par défaut que l'historique du dossier
          à la révision actuelle et n'affiche donc pas les
          modifications propagées dernièrement. La solution à ce
          problème consiste soit à mettre à jour votre copie de
          travail soit à fournir explicitement à
          <command>svn log</command> un numéro de révision grâce
          à l'option <option>--revision</option>
          (<option>-r</option>).</para>


      </sidebar>

<!--
      <para>If you want even more information about a file or
        directory, <command>svn log</command> also takes a
        <option>- -verbose</option> (<option>-v</option>) option.
        Because Subversion allows you to move and copy files and
        directories, it is important to be able to track path changes
        in the filesystem.  So, in verbose mode, <command>svn
        log</command> will include a list of changed paths in a
        revision in its output:</para>
-->
      <para>Si vous voulez obtenir plus d'informations sur un fichier
        ou un dossier, svn log accepte également l'option
        <option>--verbose</option> (<option>-v</option>). Comme
        Subversion autorise les déplacements et les copies de
        dossiers et de fichiers, il est important de pouvoir
        tracer ces modifications de chemin dans le système de
        fichiers. Ainsi, en mode verbeux, <command>svn log</command>
        affiche la liste des déplacements au cours de la révision
        concernée&nbsp;:</para>

      <informalexample>
        <screen>
$ svn log -r 8 -v
------------------------------------------------------------------------ <!--
r8 | sally | 2008-05-21 13:19:25 -0500 (Wed, 21 May 2008) | 1 line

Changed paths:
   M /trunk/code/foo.c
   M /trunk/code/bar.h
   A /trunk/code/doc/README

Frozzled the sub-space winch.
-->
r8 | sally | 2008-05-21 13:19:25 -0500 (mer. 21 Mai 2008) | 1 ligne
Chemins modifiés :
   M /trunk/code/truc.c
   M /trunk/code/machin.h
   A /trunk/code/doc/LISEZMOI

Machination du bidule.
</screen>
      </informalexample>

<!--
      <para><command>svn log</command> also takes
        a <option>- -quiet</option> (<option>-q</option>) option, which
        suppresses the body of the log message.  When combined
        with <option>- -verbose</option> (<option>-v</option>), it
        gives just the names of the changed files.</para>
-->
      <para><command>svn log</command> accepte aussi l'option
        <option>--quiet</option> (<option>-q</option>), qui permet
        de ne pas afficher le contenu du commentaire de propagation. En
        combinaison avec <option>--verbose</option>,
        <command>svn log</command> n'affiche que les noms des
        fichiers qui ont changé.</para>

      <sidebar>
<!--
        <title>Why Does svn log Give Me an Empty
          Response?</title>
-->
        <title>Pourquoi svn log me donne-t-il une réponse
          vide&nbsp;?</title>

<!--
        <para>After working with Subversion for a bit, most users will
          come across something like this:</para>
-->
        <para>Après un certain temps de pratique de Subversion,
          la plupart des utilisateurs sont confrontés à un
          affichage de ce genre&nbsp;:</para>

        <informalexample>
          <screen>
$ svn log -r 2
------------------------------------------------------------------------
$
</screen>
        </informalexample>

<!--
        <para>At first glance, this seems like an error.  But recall
          that while revisions are repository-wide, <command>svn
          log</command> operates on a path in the repository.  If you
          supply no path, Subversion uses the current working
          directory as the default target.  As a result, if you're
          operating in a subdirectory of your working copy and attempt
          to see the log of a revision in which neither that directory
          nor any of its children was changed, Subversion will show you
          an empty log.  If you want to see what changed in that
          revision, try pointing <command>svn log</command> directly at
          the topmost URL of your repository, as in <userinput>svn log
          -r 2 ^/</userinput>.</para>
-->
        <para>Au premier abord, cela ressemble à une erreur. Mais
          rappelez-vous que chaque révision concerne l'ensemble du
          dépôt et que <command>svn log</command> n'opère que sur
          une arborescence à l'intérieur du dépôt. Si vous ne passez
          pas d'argument pour le chemin, Subversion utilise le
          dossier courant par défaut. En conséquence, si vous êtes
          dans un sous-dossier de votre copie de travail et que
          vous demandez à voir l'historique d'une révision pour
          laquelle aucun changement n'a eu lieu sur lesdits fichiers
          et dossiers, Subversion affiche un historique vierge.
          Si vous voulez connaître tous les changements relatifs à
          cette révision, invoquez <command>svn log</command> avec
          l'URL du dossier racine de votre dépôt, par exemple
          <userinput>svn log -r 2 ^/</userinput>.</para>

      </sidebar>

<!--
      <para>As of Subversion 1.7, users of the Subversion command-line
        can also take advantage of a special output mode
        for <command>svn log</command> which integrates a difference
        report such as is generated by the <command>svn diff</command>
        command we introduced earlier.  When you invoke <command>svn
        log</command> with the <option>- -diff</option> option,
        Subversion will append to each revision log chunk in the log
        report a <command>diff</command>-style difference report.
        This is a very convenient way to see both the high-level, semantic
        changes and the line-based modifications of a revision all at
        the same time!</para>
-->
      <para>Depuis Subversion 1.7, les utilisateurs du client texte
        interactif bénéficient du mode d'affichage spécial de
        <command>svn log</command> qui intègre un format similaire à
        celui produit par <command>svn diff</command>, que nous avons
        abordé précédemment. Si vous lancez <command>svn log</command>
        avec l'option <option>--diff</option>, Subversion ajoute, à
        chaque partie de l'historique d'une révision, une édition des
        différences au style <command>diff</command>. C'est très
        pratique pour visualiser à la fois les changements
        sémantiques, de haut niveau et les modifications ligne par
        ligne d'une révision.</para>

<!--
      <para>Beginning with Subversion 1.8, <command>svn log</command>
        accepts <option>- -search</option> and <option>- -search-and</option>
        options.  The options allow you to filter the output of
        <command>svn log</command> based on the search pattern you
        supply.  When using these options, a log message is shown
        only if a revision's author, date, log message text, or list
        of changed paths, matches the search pattern.</para>
-->
      <para>À partir de Subversion 1.8, <command>svn log</command>
        reconnait les options <option>--search</option> et
        <option>--search-and</option>. Ces options vous permettent
        de filtrer la sortie de <command>svn log</command> en fonction
        du motif que vous fournissez. Lorsque vous utilisez ces options,
        le commentaire de propagation n'est affiché que si l'auteur, la
        date, le commentaire ou la liste des chemins modifiés correspond
        au motif fourni.</para>

    </sect2>

    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.browsing">
<!--
      <title>Browsing the Repository</title>
-->
      <title>Navigation dans le dépôt</title>

<!--
      <para>Using <command>svn cat</command> and <command>svn
        list</command>, you can view various revisions of files and
        directories without changing the working revision of your
        working copy.  In fact, you don't even need a working copy to
        use either one.</para>
-->
      <para>Grâce aux commandes <command>svn cat</command> et
        <command>svn list</command>, vous pouvez afficher des
        révisions variées des fichiers et dossiers sans changer
        la révision de votre copie de travail. En fait, vous n'avez
        même pas besoin d'avoir une copie de travail pour les
        utiliser.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.cat">
<!--
        <title>Displaying file contents</title>
-->
        <title>Affichage du contenu d'un fichier</title>


<!--
        <para>If you want to examine an earlier version of a file and
          not necessarily the differences between two files, you can use
          <command>svn cat</command>:</para>
-->
        <para>Si vous voulez examiner une version antérieure d'un
          fichier et pas nécessairement les différences entre deux
          fichiers, vous pouvez utiliser
          <command>svn cat</command>&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svn cat -r 2 rules.txt
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth open
$-->
$ svn cat -r 2 règles.txt
Être attentif envers les autres
Liberté = Glace au chocolat
Tout dans la modération
Mâcher la bouche ouverte
$
</screen>
        </informalexample>

<!--
        <para>You can also redirect the output directly into a
          file:</para>
-->
        <para>Vous pouvez également rediriger la sortie de
          <command>svn cat</command> directement dans un
          fichier&nbsp;:</para>

        <informalexample>
          <screen> <!--
$ svn cat -r 2 rules.txt &gt; rules.txt.v2
$ -->
$ svn cat -r 2 règles.txt > règles.txt.v2
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.annotate">
<!--
        <title>Displaying line-by-line change attribution</title>
-->
        <title>Affichage ligne par ligne des auteurs de modifications</title>

<!--
        <para>Very similar to the <command>svn cat</command> command
          we discussed in the previous section is the <command>svn
          annotate</command> command.  This command also displays the
          contents of a versioned file, but it does so using a tabular
          format.  Each line of output shows not only a line of the
          file's content but also the username, the revision number
          and (optionally) the datestamp of the revision in which that
          line was last modified.</para>
-->
        <para>La commande <command>svn annotate</command> ressemble
          beaucoup à la commande <command>svn cat</command> que nous
          venons d'aborder à la section précédente. Cette commande
          affiche aussi le contenu du fichier suivi en versions mais
          utilise un format en tableau. Chaque ligne, en plus du
          contenu du fichier, indique également le nom de l'utilisateur,
          le numéro de la révision et (optionnellement) l'horodatage
          de la révision dans laquelle la ligne a été modifiée pour
          la dernière fois.</para>

<!--
        <para>When used with a working copy file target, <command>svn
          annotate</command> will by default show line-by-line
          attribution of the file as it currently appears in the
          working copy.</para>
-->
        <para>Quand vous lui spécifiez comme argument un fichier de la
          copie de travail, <command>svn annotate</command> affiche
          par défaut les attributs du fichier correspondant à la
          version de la copie de travail.</para>

        <informalexample>
          <screen><!--
$ svn annotate rules.txt
     1      harry Be kind to others
     3      sally Freedom = Responsibility
     1      harry Everything in moderation
     -          - Chew with your mouth closed
     -          - Listen when others are speaking-->
$ svn annotate règles.txt
     1      harry Être attentif envers les autres
     3      sally Liberté = Responsabilité
     1      harry Tout dans la modération
     -          - Mâcher la bouche fermée
     -          - Écouter quand les autres parlent
</screen>
        </informalexample>

<!--
        <para>Notice that for some lines, there is no attribution
          provided.  In this case, that's because those lines have
          been modified in the working copy's version of the file.  In
          this way, <command>svn annotate</command> becomes another
          way for you to see which lines in the file you have
          changed.  You can use the <literal>BASE</literal> revision
          keyword (see <xref linkend="svn.tour.revs.keywords" />) to
          instead see the unmodified form of the file as it resides
          in your working copy.</para>
-->
        <para>Remarquez que, pour certaines lignes, il n'y a pas
          d'auteur indiqué. C'est parce que ces lignes ont été
          modifiées dans la copie de travail du fichier. De cette
          façon, <command>svn annotate</command> devient un outil
          supplémentaire pour visualiser quelles lignes du fichier
          vous avez modifiées. Vous pouvez utiliser le mot-clé
          <literal>BASE</literal> (voir <xref
          linkend="svn.tour.revs.keywords" />) pour visualiser la
          version non modifiée du fichier telle qu'elle est stockée
          dans votre copie de travail.</para>

        <informalexample>
          <screen><!--
$ svn annotate rules.txt@BASE
     1      harry Be kind to others
     3      sally Freedom = Responsibility
     1      harry Everything in moderation
     1      harry Chew with your mouth open-->
$ svn annotate règles.txt@BASE
     1      harry Être attentif envers les autres
     3      sally Liberté = Responsabilité
     1      harry Tout dans la modération
     1      harry Mâcher la bouche ouverte
</screen>
        </informalexample>

<!--
        <para>The <option>- -verbose (-v)</option> option causes
          <command>svn annotate</command> to also include on each line
          the datestamp associated with that line's reported revision
          number.  (This adds a significant amount of width to each
          line of ouput, so we'll skip the demonstration here.)</para>
-->
        <para>L'option <option>--verbose (-v)</option> demande à
          <command>svn annotate</command> d'inclure également pour
          chaque ligne l'horodatage de la révision. Cela augmentant de
          manière significative la largeur de chaque ligne, nous nous
          passerons d'exemple pour cette option.</para>

<!--
        <para>As with <command>svn cat</command>, you can also
          ask <command>svn annotate</command> to display previous
          versions of the file.  This can be a handy trick when, after
          finding out who most recently modified a particular line of
          interest in the file, you then wish to see who modified the
          same line prior to that.</para>
-->
        <para>De même que pour <command>svn cat</command>, vous pouvez
          demander à <command>svn annotate</command> d'afficher les
          versions précédentes du fichier. C'est une astuce
          particulièrement utile lorsque, après avoir trouvé qui a
          modifié telle ligne dans le fichier, vous voulez savoir qui
          avait écrit la version précédente de cette ligne.</para>

        <informalexample>
          <screen> <!--
$ svn blame rules.txt -r 2
     1      harry Be kind to others
     1      harry Freedom = Chocolate Ice Cream
     1      harry Everything in moderation
     1      harry Chew with your mouth open-->
$ svn blame règles.txt -r 2
     1      harry Être attentif envers les autres
     1      harry Liberté = Glace au chocolat
     1      harry Tout dans la modération
     1      harry Mâcher la bouche ouverte

</screen>
        </informalexample>

<!--
        <para>Unlike the <command>svn cat</command> command, the
          functionality of <command>svn annotate</command> is tied
          heavily to the idea of <quote>lines</quote> of text in a
          human-readable file.  As such, if you attempt to run the
          command on a file that Subversion has determined is
          <emphasis>not</emphasis> human-readable (per the file's
          <literal>svn:mime-type</literal> property&mdash;see <xref
          linkend="svn.advanced.props.special.mime-type" /> for
          details), you'll get an error message.</para>
-->
        <para>Au contraire de <command>svn cat</command>, le
          fonctionnement de <command>svn annotate</command> est
          fortement corrélé à la notion de <quote>ligne</quote> d'un
          fichier texte lisible par un humain. Ainsi, si vous essayez
          de lancer la commande sur un fichier que Subversion considère
          <emphasis>non</emphasis> lisible par un humain (en raison de
          sa propriété <literal>svn:mime-type</literal>, voir <xref
          linkend="svn.advanced.props.special.mime-type"/> pour les
          détails), vous obtiendrez un message d'erreur.</para>

        <informalexample>
          <screen>
$ svn annotate images/logo.png <!--
Skipping binary file (use - -force to treat as text): 'images/logo.png'
-->
Skipping binary file (use --force to treat as text): 'images/logo.png'
$
</screen>
        </informalexample>

<!--
        <para>As revealed in the error message, you can use
          the <option>- -force</option> option to disable this check
          and proceed with the annotation as if the file's contents
          are, in fact, human-readable and line-based.  Naturally, if
          you force Subversion to try to perform line-based annotation
          on a nontextual file, you'll get what you asked for: a
          screenful of nonsense.</para>
-->
        <para>Comme l'indique le message d'erreur, vous pouvez spécifier
          l'option <option>--force</option> pour outrepasser la
          vérification et effectuer les annotations comme pour tout
          fichier contenant des lignes et lisible par un humain.
          Naturellement, si vous forcez Subversion à effectuer des
          annotations sur un fichier non textuel, vous obtiendrez ce
          à quoi vous devez vous attendre&nbsp;: un cafouillis
          incompréhensible.</para>

        <informalexample>
          <screen>
$ svn annotate images/logo.png --force
     6      harry \211PNG
     6      harry ^Z
     6      harry
     7      harry \274\361\MI\300\365\353^X\300&hellip;
</screen>
        </informalexample>

        <tip>
<!--
          <para>Depending on your mood at the time you execute this
            command and your reasons for doing so, you may find
            yourself typing <userinput>svn blame &hellip;</userinput>
            or <userinput>svn praise &hellip;</userinput> instead of
            using the canonical <command>svn annotate</command>
            command form.  That's okay&mdash;the Subversion developers
            anticipated as much, so those particular command aliases
            work, too!</para>
-->
          <para>En fonction de votre humeur du moment ou des raisons
            pour lesquelles vous lancez cette commande, vous vous
            retrouverez à taper <userinput>svn blame
            &hellip;</userinput> ou <userinput>svn praise
            &hellip;</userinput> au lieu de la forme canonique de la
            commande <command>svn annotate</command>. Pas de souci, les
            développeurs de Subversion l'ont anticipé et ces alias
            fonctionnent parfaitement.</para>
        </tip>

<!--
        <para>Finally, as with many of Subversion's informational
          commands, you can also reference files in your <command>svn
          annotate</command> command invocations by their repository
          URLs, allowing access to this information even when you
          don't have ready access to a working copy.</para>
-->
        <para>Pour finir, comme pour beaucoup de commandes de
          Subversion qui interrogent les fichiers suivis en versions,
          <command>svn annotate</command> peut faire référence aux
          fichiers par leur URL dans le dépôt, ce qui permet un
          accès aux informations même sans disposer d'une copie de
          travail.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.list">
<!--
        <title>Listing versioned directories</title>
-->
        <title>Contenu des dossiers suivis en
          versions</title>

<!--
        <para>The <command>svn list</command> command shows you what
          files are in a repository directory without actually
          downloading the files to your local machine:</para>
-->
        <para>La commande <command>svn list</command> liste les
          fichiers présents dans un dossier du dépôt sans pour autant
          les télécharger&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn list http://svn.example.com/repo/project
README-->
$ svn list http://svn.exemple.com/depot/projet
LISEZMOI
branches/
tags/
trunk/
</screen>
        </informalexample>

<!--
        <para>If you want a more detailed listing, pass the
          <option>- -verbose</option> (<option>-v</option>) flag to get
          output like this:</para>
-->
        <para>Si vous désirez une liste plus détaillée, passez
          l'option <option>--verbose</option> (<option>-v</option>)
          et vous obtenez alors quelque chose comme ceci&nbsp;:</para>

        <informalexample>
          <screen><!--
$ svn list -v http://svn.example.com/repo/project
  23351 sally                 Feb 05 13:26 ./
  20620 harry            1084 Jul 13  2006 README
  23339 harry                 Feb 04 01:40 branches/
  23198 harry                 Jan 23 17:17 tags/
  23351 sally                 Feb 05 13:26 trunk/-->
$ svn list -v http://svn.exemple.com/depot/projet
  23351 sally                 05 fev.,  13:26 ./
  20620 sally            1084 13 janv. 2006   LISEZMOI
  23339 harry                 02 sept., 01:40 branches/
  23198 harry                 23 janv., 17:17 tags/
  23351 sally                 27 fevr., 13:26 trunk/
</screen>
        </informalexample>

<!--
        <para>The columns tell you the revision at which the file or
          directory was last modified, the user who modified it, the size
          if it is a file, the date it was last modified, and the item's
          name.</para>
-->
        <para>Les colonnes vous indiquent la révision à laquelle le
          fichier ou le dossier a été modifié pour la dernière
          fois, qui est l'auteur de ce changement, la taille du
          fichier si c'en est un, la date de dernière modification
          et le nom de l'élément.</para>

        <warning>
<!--
          <para>The <userinput>svn list</userinput> command with no
            arguments defaults to the <emphasis>repository
            URL</emphasis> of the current working
            directory, <emphasis>not</emphasis> the local working copy
            directory.  After all, if you want a listing of your local
            directory, you could use just plain
            <command>ls</command> (or any reasonable non-Unixy
            equivalent).</para>
-->
          <para>La commande <command>svn list</command> sans argument
            prend pour cible l'<emphasis>URL du dépôt</emphasis>
            correspondant au dossier local en cours, pas le
            dossier en cours de la copie de travail. Après tout, si
            vous voulez voir le contenu de votre dossier local, vous
            pouvez utiliser <command>ls</command>, tout simplement
            (ou l'équivalent sur votre système non-Unix).</para>
        </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.snapshots">

<!--
      <title>Fetching Older Repository Snapshots</title>
-->
      <title>Extraction d'anciennes versions au sein d'un dépôt</title>

<!--
      <para>In addition to all of the previous commands, you can use
        the <option>- -revision</option> (<option>-r</option>) option
        with <command>svn update</command> to take an entire working
        copy <quote>back in time</quote>:<footnote><para>See?  We told
        you that Subversion was a time
        machine.</para></footnote></para>
-->
      <para>En plus de toutes les commandes citées précédemment, vous
        pouvez utiliser <command>svn update</command> et
        <command>svn checkout</command> avec l'option
        <option>--revision</option> pour ramener une copie de
        travail complète <quote>dans le passé</quote>&nbsp;:
        <footnote>
          <para>Vous voyez, on vous avait bien dit que Subversion
            était une machine à remonter le temps.</para>
        </footnote>
        </para>

      <informalexample>
        <screen> <!--
# Make the current directory look like it did in r1729.
-->
# met le dossier courant tel qu'il était à la révision 1729.
$ svn update -r 1729 <!--
Updating '.': -->
Mise à jour de '.' :
&hellip;
$
</screen>
      </informalexample>

      <tip>
<!--
        <para>Many Subversion newcomers attempt to use the preceding
          <command>svn update</command> example to <quote>undo</quote>
          committed changes, but this won't work as you can't commit
          changes that you obtain from backdating a working copy if
          the changed files have newer revisions.  See <xref
          linkend="svn.branchmerge.basicmerging.resurrect"/> for a
          description of how to <quote>undo</quote> a commit.</para>
-->
        <para>Beaucoup de nouveaux utilisateurs de Subversion essaient
          d'utiliser la commande <command>svn update</command> comme
          dans cet exemple pour <quote>annuler</quote> des
          modifications propagées, mais cela ne fonctionne pas parce
          que vous ne pouvez pas propager des changements que vous avez
          obtenus en remontant le temps d'une copie de travail si le
          contenu des fichiers a changé dans des révisions plus
          récentes. Reportez-vous à <xref
          linkend="svn.branchmerge.basicmerging.resurrect"/> pour une
          description de comment <quote>annuler</quote> une
          propagation.</para>
      </tip>

<!--
      <para>If you'd prefer to create a whole new working copy from an
        older snapshot, you can do so by modifying the typical
        <command>svn checkout</command> command.  As with <command>svn
        update</command>, you can provide
        the <option>- -revision</option> (<option>-r</option>) option.
        But for reasons that we cover in
        <xref linkend="svn.advanced.pegrevs" />, you might instead want
        to specify the target revision as part of Subversion's
        expanded URL syntax.</para>

-->
      <para>Si vous préférez créer une nouvelle copie de travail
        complète à partir d'un instantané plus ancien, vous pouvez
        modifier l'appel classique à <command>svn checkout</command>. De
        même que pour <command>svn update</command>, vous pouvez passer
        l'option <option>--revision</option> (<option>-r</option>).
        Mais pour des raisons que nous explicitons dans <xref
        linkend="svn.advanced.pegrevs"/>, vous voudrez certainement
        spécifier la révision cible comme une partie de l'URL
        étendue suivant la syntaxe de Subversion.</para>

      <informalexample>
        <screen> <!--
# Checkout the trunk from r1729.
-->
# Extraie la branche principale à la révision 1729.<!--
$ svn checkout http://svn.example.com/svn/repo/trunk@1729 trunk-1729 -->
$ svn checkout http://svn.exemple.com/svn/depot/trunk@1729 trunk-1729
&hellip; <!--
# Checkout the current trunk as it looked in r1729.
-->
# Extraie la branche principale actuelle telle qu'elle était
# à la révision 1729.<!--
$ svn checkout http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729-->
$ svn checkout http://svn.exemple.com/svn/depot/trunk -r 1729 trunk-1729
&hellip;
$
</screen>
      </informalexample>

<!--
      <para>Lastly, if you're building a release and wish to bundle up
        your versioned files and directories, you can use <command>svn
        export</command> to create a local copy of all or part of your
        repository without any <filename>.svn</filename>
        administrative directories included.  The basic syntax of this
        subcommand is identical to that of <command>svn
        checkout</command>:</para>
-->
      <para>Enfin, si vous êtes en train de réaliser une version
        officielle et que vous voulez empaqueter vos fichiers et
        dossiers suivis en versions, vous pouvez utiliser la
        commande <command>svn export</command> pour créer une copie
        locale de tout ou partie de votre dépôt sans que la zone
        administrative <filename>.svn</filename> ne soit incluse. La
        syntaxe de base de cette sous-commande est identique à celle de
        <command>svn checkout</command>&nbsp;:</para>

      <informalexample>
        <screen> <!--
# Export the trunk from the latest revision.
$ svn export http://svn.example.com/svn/repo/trunk trunk-export
-->
# Exporte la branche principale à partir de la dernière révision.
$ svn export http://svn.exemple.com/svn/depot/trunk trunk-export
&hellip; <!--
# Export the trunk from r1729.
$ svn export http://svn.example.com/svn/repo/trunk@1729 trunk-1729
-->
# Exporte la branche principale à partir de la révision 1729.
$ svn export http://svn.exemple.com/svn/depot/trunk@1729 trunk-1729
&hellip; <!--
# Export the current trunk as it looked in r1729.
$ svn export http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729
-->
# Exporte la branche principale actuelle, telle qu'elle était à la
# révision 1729.
$ svn export http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729
&hellip;
$
</screen>
      </informalexample>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.cleanup">
<!--
    <title>Sometimes You Just Need to Clean Up</title>
-->
    <title>Parfois, il suffit de faire le ménage</title>

<!--
    <para>Now that we've covered the day-to-day tasks that you'll
      frequently use Subversion for, we'll review a few administrative
      tasks relating to your working copy.</para>
-->
    <para>Maintenant que nous avons traité les tâches quotidiennes
      pour lesquelles vous utiliserez Subversion, nous allons passer
      en revue quelques tâches administratives liées à votre copie
      de travail.</para>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.cleanup.disposal">
<!--
      <title>Disposing of a Working Copy</title>
-->
      <title>Suppression d'une copie de travail</title>

<!--
      <para>Subversion doesn't track either the state or the existence of
        working copies on the server, so there's no server overhead to
        keeping working copies around.  Likewise, there's no need to
        let the server know that you're going to delete a working
        copy.</para>
-->
      <para>Subversion ne conserve sur le serveur aucune trace de
        l'état ni de l'existence des copies de travail, il n'y a donc
        aucun impact côté serveur si des copies de travail traînent
        un peu partout. De la même façon, pas besoin de prévenir le
        serveur quand vous effacez une copie de travail.</para>

<!--
      <para>If you're likely to use a working copy again, there's
        nothing wrong with just leaving it on disk until you're ready
        to use it again, at which point all it takes is an
        <command>svn update</command> to bring it up to date and ready
        for use.</para>
-->
      <para>Si vous envisagez de réutiliser une copie de travail, ça
        ne pose aucun problème de la laisser sur le disque jusqu'à
        ce que vous soyez prêts à l'utiliser à nouveau et, le moment
        venu, il suffit de lancer <command>svn update</command> pour
        la mettre à jour et ainsi la rendre utilisable.</para>

<!--
      <para>However, if you're definitely not going to use a working
        copy again, you can safely delete the entire thing using
        whatever directory removal capabilities your operating system
        offers.  We recommend that before you do so you
        run <userinput>svn status</userinput> and review any files
        listed in its output that are prefixed with a
        <literal>?</literal> to make certain that they're not of
        importance.</para>
-->
      <para>Cependant, si vous êtes certain de ne plus utiliser une
        copie de travail, vous pouvez la supprimer entièrement, en
        utilisant les commandes de votre système d'exploitation. Vous
        seriez cependant bien inspiré d'y jeter un œil avant, en
        lançant la commande <userinput>svn status</userinput> afin
        d'examiner tous les fichiers marqués d'un <literal>?</literal>
        pour vous assurer qu'ils ne sont d'aucune importance.</para>

    </sect2>

    <sect2 id="svn.tour.cleanup.interruption">
<!--
      <title>Recovering from an Interruption</title>
-->
      <title>Reprise après une interruption</title>

<!--
      <para>When Subversion modifies your working copy&mdash;either
        your files or its own administrative state&mdash;it tries to do
        so as safely as possible.  Before changing the working copy,
        Subversion logs its intentions in a private <quote>to-do
        list</quote>, of sorts.  Next, it performs those actions to
        effect the desired change, holding a lock on the relevant part
        of the working copy while it works.  This prevents other
        Subversion clients from accessing the working copy mid-change.
        Finally, Subversion releases its lock and cleans up its
        private to-do list.  Architecturally, this is similar to a
        journaled filesystem.  If a Subversion operation is
        interrupted (e.g, if the process is killed or if the machine
        crashes), the private to-do list remains on disk.  This allows
        Subversion to return to that list later to complete any
        unfinished operations and return your working copy to a
        consistent state.</para>
-->
      <para>Quand Subversion modifie votre copie de travail (ou
        toute information dans la zone administrative), il essaie
        de le faire de la manière la plus sûre possible. Avant de
        modifier votre copie de travail, Subversion inscrit ses
        intentions dans un fichier de traces. Ensuite, il exécute
        les commandes du fichier de traces pour appliquer les
        modifications demandées, en plaçant un verrou sur la partie
        concernée de la copie de travail pendant cette opération
        (pour empêcher d'autres clients Subversion d'accéder à cette
        copie de travail au beau milieu des changements). Pour finir,
        Subversion enlève son verrou et supprime le fichier de traces.
        D'un point de vue architectural, c'est le même fonctionnement
        qu'un système de fichiers journalisé. Si une opération
        Subversion est interrompue (par exemple si le processus est tué
        ou si la machine plante), le fichier de traces reste sur le
        disque. En exécutant de nouveau le fichier de traces, Subversion
        peut terminer l'opération en cours et votre copie de travail
        retrouve un état cohérent.</para>

<!--
      <para>This is exactly what <command>svn cleanup</command> does:
        it searches your working copy and runs any leftover to-do
        items, removing working copy locks as it completes those
        operations.  If Subversion ever tells you that some part of
        your working copy is <quote>locked,</quote> run <command>svn
        cleanup</command> to remedy the problem.  The <command>svn
        status</command> command will inform you about administrative
        locks in the working copy, too, by displaying
        an <literal>L</literal> next to those locked paths:</para>
-->
      <para>C'est exactement ce que fait la commande
        <command>svn cleanup</command>&nbsp;: elle trouve et exécute les
        fichiers de traces restant dans votre copie de travail, en
        enlevant les verrous au passage. Si un beau jour Subversion
        vous indique qu'une partie de votre copie de travail est
        verrouillée (<foreignphrase>locked</foreignphrase> en anglais),
        c'est la commande qu'il faut lancer. Par ailleurs,
        <command>svn status</command> vous informe des verrous posés
        dans la copie de travail, en affichant un <literal>L</literal>
        devant les éléments verrouillés&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status<!--
  L     somedir
M       somedir/foo.c
$ svn cleanup
$ svn status
M       somedir/foo.c-->
  L    un-repertoire
M      un-repertoire/truc.c

$ svn cleanup
$ svn status
M      un-repertoire/truc.c
</screen>
      </informalexample>

<!--
      <para>Don't confuse these working copy administrative locks with
        the user-managed locks that Subversion users create when using
        the lock-modify-unlock model of concurrent version control;
        see the sidebar
        <xref linkend="svn.advanced.locking.meanings"/> for
        clarification.</para>
-->
      <para>Ne confondez pas ces verrous agissant sur la copie de
        travail avec les verrous ordinaires que les utilisateurs de
        Subversion créent quand ils utilisent le modèle de gestion
        de versions parallèles verrouiller-modifier-libérer&nbsp;; voir
        l'encadré <xref linkend="svn.advanced.locking.meanings"/>
        pour des éclaircissements.</para>
    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.treeconflicts">
<!--
    <title>Dealing with Structural Conflicts</title>
-->
    <title>Gestion des conflits d'arborescences</title>

<!--
    <para>So far, we have only talked about conflicts at the level of
      file content.  When you and your collaborators make overlapping
      changes within the same file, Subversion forces you to merge
      those changes before you can commit.<footnote><para>Well,
      you <emphasis>could</emphasis> mark files containing conflict
      markers as resolved and commit them, if you really wanted to.
      But this is rarely done in practice.</para></footnote></para>
-->
    <para>Jusqu'à présent, nous nous sommes occupés des conflits
      intéressant le contenu des fichiers. Quand vos collaborateurs et
      vous faites des changements qui interfèrent dans le même
      fichier, Subversion vous force à fusionner ces changements avant
      de pouvoir les propager. <footnote><para>Certes, vous
      <emphasis>pouvez</emphasis> simplement marquer les fichiers en
      conflits comme résolus et les propager, si vous le voulez
      vraiment. Mais c'est rarement le cas en
      pratique.</para></footnote></para>

<!--
    <para>
      <indexterm>
        <primary>tree conflicts</primary>
      </indexterm>
      <indexterm>
        <primary>conflicts</primary>
        <secondary>tree</secondary>
        <see>tree conflicts</see>
      </indexterm>But what happens if your collaborators move or
      delete a file that you are still working on?  Maybe there was a
      miscommunication, and one person thinks the file should be
      deleted, while another person still wants to commit changes to
      the file.  Or maybe your collaborators did some refactoring,
      renaming files and moving around directories in the process.  If
      you were still working on these files, those modifications may
      need to be applied to the files at their new location.  Such
      conflicts manifest themselves at the directory tree structure
      level rather than at the file content level, and are known
      as <firstterm>tree conflicts</firstterm>.</para>
-->
    <para>
      <indexterm>
        <primary>conflits d'arborescences</primary>
      </indexterm>
      <indexterm>
        <primary>conflits</primary>
        <secondary>arborescence</secondary>
        <see>conflits d'arborescences</see>
      </indexterm>Mais que se passe-t-il si vos collaborateurs
      déplacent ou suppriment un fichier sur lequel vous êtes en
      train de travailler&nbsp;? À la suite d'un malentendu, quelqu'un
      a pensé que le fichier devait être supprimé alors qu'un autre
      veut toujours propager des modifications sur le fichier. Ou à
      l'occasion d'un réusinage de code, des collaborateurs ont renommé
      des fichiers et déplacé des dossiers. Si vous travailliez
      toujours sur ces fichiers, les modifications devront sûrement
      s'appliquer aux fichiers à leurs nouveaux emplacements. Ces
      conflits, qui se manifestent au niveau de la structure des
      dossiers plutôt que dans le contenu des fichiers eux-mêmes,
      portent le nom de <firstterm>conflits
      d'arborescences</firstterm>.</para>

    <sidebar>
<!--
      <title>Tree conflicts prior to Subversion 1.6</title>
-->
      <title>Conflits d'arborescences avant Subversion 1.6</title>

<!--
      <para>Prior to Subversion 1.6, tree conflicts could yield rather
        unexpected results.  For example, if a file was locally
        modified, but had been renamed in the repository,
        running <command>svn update</command> would make Subversion
        carry out the following steps:</para>
-->
      <para>Avant Subversion 1.6, les conflits d'arborescences
        pouvaient produire des résultats inattendus. Par exemple, si
        un fichier était modifié localement mais en ayant changé de
        nom dans le dépôt, la commande <command>svn update</command>
        entrainait les actions suivantes de la part de
        Subversion&nbsp;:</para>

      <itemizedlist>
<!--
        <listitem><para>Check the file to be renamed for local
          modifications.</para></listitem>
-->
        <listitem><para>vérifier le fichier à renommer quant aux
          modifications locales&nbsp;;</para></listitem>

<!--
        <listitem><para>Delete the file at its old location, and if it
          had local modifications, keep an on-disk copy of the file at
          the old location.  This on-disk copy now appears as an
          unversioned file in the working copy.</para></listitem>
-->
        <listitem><para>supprimer le fichier à son ancien emplacement
          et, s'il fait l'objet de modifications locales, garder une
          copie du fichier sur le disque local à l'ancien emplacement.
          Cette copie sur le disque local apparaît maintenant comme un
          fichier non suivi en versions dans la copie de
          travail&nbsp;;</para></listitem>
<!--
        <listitem><para>Add the file, as it exists in the repository,
          at its new location.</para></listitem>
-->
        <listitem><para>ajouter le fichier, tel qu'il existe dans le
          dépôt à son nouvel emplacement.</para></listitem>
      </itemizedlist>

<!--
      <para>When this situation arises, there is the possibility that
        the user makes a commit without realizing that local
        modifications have been left in a now-unversioned file in the
        working copy, and have not reached the repository.  This gets
        more and more likely (and tedious) if the number of files
        affected by this problem is large.</para>
-->
      <para>Quand cette situation se produit, il est possible que
        l'utilisateur lance la propagation sans réaliser que les
        modifications locales ont été mises de côté dans un fichier
        maintenant non suivi en versions dans la copie de travail et
        qu'elles n'ont jamais atteint le dépôt. Et c'est d'autant
        plus probable (et délicat à gérer) que le nombre de fichiers
        concernés par le problème est grand.</para>

<!--
      <para>Since Subversion 1.6, this and other similar situations
        are flagged as conflicts in the working copy.</para>
-->
      <para>Depuis Subversion 1.6, ce cas et d'autres situations
        similaires sont étiquetées comme des conflits dans la copie de
        travail.</para>

    </sidebar>

<!--
    <para>As with textual conflicts, tree conflicts prevent a commit
      from being made from the conflicted state, giving the user the
      opportunity to examine the state of the working copy for
      potential problems arising from the tree conflict, and resolving
      any such problems before committing.</para>
-->
    <para>Comme pour les conflits textuels, les conflits
      d'arborescences empêchent la propagation d'avoir lieu en l'état,
      donnant l'opportunité à l'utilisateur d'examiner les conflits qui
      se présentent dans la copie de travail et de les résoudre avant
      de réaliser la propagation.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.treeconflicts.example">
<!--
      <title>An Example Tree Conflict</title>
-->
      <title>Un exemple de conflit d'arborescences</title>

<!--
      <para>Suppose a software project you were working on currently
        looked like this:</para>
-->
      <para>Prenons l'exemple d'un projet logiciel sur lequel vous
        travaillez et qui ressemble à ceci&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn list -Rv svn://svn.example.com/trunk/
     13 harry                 Sep 06 10:34 ./
     13 harry              27 Sep 06 10:34 COPYING
     13 harry              41 Sep 06 10:32 Makefile
     13 harry              53 Sep 06 10:34 README
     13 harry                 Sep 06 10:32 code/
     13 harry              54 Sep 06 10:32 code/bar.c
     13 harry             130 Sep 06 10:32 code/foo.c-->
$ svn list -Rv svn://svn.exemple.com/trunk/
     13 harry                 06 sept., 10:34 ./
     13 harry              27 06 sept., 10:34 COPYING
     13 harry              41 06 sept., 10:32 Makefile
     13 harry              53 06 sept., 10:34 LISEZMOI
     13 harry                 06 sept., 10:32 code/
     13 harry              54 06 sept., 10:32 code/machin.c
     13 harry             130 06 sept., 10:32 code/truc.c
$
</screen>
      </informalexample>

<!--
      <para>Later, in revision 14, your collaborator Harry renames the file
        <filename>bar.c</filename> to <filename>baz.c</filename>.
        Unfortunately, you don't realize this yet.  As it turns out,
        you are busy in your working copy composing a different set of
        changes, some of which also involve modifications
        to <filename>bar.c</filename>:</para>
-->
      <para>Plus tard, lors de la révision 14, votre collaborateur
        Harry renomme le fichier <filename>machin.c</filename> en
        <filename>bidule.c</filename>. Malheureusement, vous n'y
        prêtez pas attention toute de suite. Vous êtes occupé à
        réaliser un ensemble de modifications différent, dont
        certaines concernent <filename>machin.c</filename>&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn diff
Index: code/foo.c
===================================================================
- - code/foo.c	(revision 13)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/bar.c
===================================================================
- - code/bar.c	(revision 13)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }-->
$ svn diff
Index: code/truc.c
===================================================================
--- code/truc.c	(revision 13)
+++ code/truc.c	(copie de travail)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("Je n'aime pas être baladé !\n%s", machin());
-    return 0;
+    return 1;
 }
Index: code/machin.c
===================================================================
--- code/machin.c	(revision 13)
+++ code/machin.c	(copie de travail)
@@ -1,4 +1,4 @@
 const char *machin(void)
 {
-    return "Moi non plus !\n";
+    return "Bah, moi j'aime bien être ballotté !\n";
 }
$
</screen>
      </informalexample>

<!--
      <para>You first realize that someone else has
        changed <filename>bar.c</filename> when your own commit
        attempt fails:</para>
-->
      <para>Vous commencez à réaliser que quelqu'un a modifié
        <filename>machin.c</filename> quand votre tentative de
        propagation échoue&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Small fixes"
Sending        code/bar.c
Transmitting file data .
svn: E155011: Commit failed (details follow):
svn: E155011: File '/home/svn/project/code/bar.c' is out of date
svn: E160013: File not found: transaction '14-e', path '/code/bar.c'
-->
$ svn commit -m "Quelques petits changements."
Envoi          code/machin.c
Transmission des données .
svn: E155011: Échec de la propagation (commit), détails :
svn: E155011: Fichier '/home/svn/projet/code/machin.c' obsolète
svn: E160013: Fichier non trouvé : transaction '14-e', chemin '/code/machin.c'
$
</screen>
      </informalexample>
<!-- XXX: That error message should be cleaned up! -->

<!--
      <para>At this point, you need to run <command>svn update</command>.
        Besides bringing our working copy up to date so that you can
        see Harry's changes, this also flags a tree conflict so you
        have the opportunity to evaluate and properly resolve it.</para>
-->
      <para>À ce moment, vous devez lancer <command>svn
        update</command>.Non seulement votre copie de travail est mise
        à jour et vous pouvez voir les modifications effectuées par
        Harry, mais aussi l'arborescence est marquée comme étant en
        conflit afin que vous puissiez réellement mesurer ce qui a
        été modifié et résoudre le conflit proprement.</para>

      <informalexample>
        <screen>
$ svn update <!--
Updating '.':
   C code/bar.c
A    code/baz.c
U    Makefile
Updated to revision 14.
Summary of conflicts:
  Tree conflicts: 1
-->
Mise à jour de '.' :
   C  code/machin.c
A     code/bidule.c
U     Makefile
Actualisé à la révision 14.
Résumé des conflits :
  Arborescences en conflit : 1
</screen>
      </informalexample>

<!--
      <para>In its output, <command>svn update</command> signifies tree
        conflicts using a capital C in the fourth output column.
        <command>svn status</command> reveals additional details of the
        conflict:</para>
-->
      <para>Dans la sortie qu'elle produit,
        <command>svn update</command> indique un conflit d'arborescence
        en utilisant un C majuscule dans la quatrième colonne.
        <command>svn status</command> fournit plus de détails sur ce
        conflit&nbsp;:</para>

      <informalexample>
        <screen>
$ svn status<!--
M       code/foo.c
A  +  C code/bar.c
      >   local edit, incoming delete upon update
Summary of conflicts:
  Tree conflicts: 1
-->
M       code/truc.c
A  +  C code/machin.c
      >   local edit, incoming delete upon update
Résumé des conflits :
  Arborescences en conflit : 1
$
</screen>
      </informalexample>

<!--
      <para>Note how <filename>bar.c</filename> is automatically
        scheduled for re-addition in your working copy, which
        simplifies things in case you want to keep the file.</para>
-->
      <para>Notez que <filename>machin.c</filename> est automatiquement
        marqué pour ajout dans votre copie de travail, ce qui simplifie
        les choses si vous décidez de conserver le fichier.</para>

<!--
      <para>Because a move in Subversion is implemented as a copy
        operation followed by a delete operation, and these two
        operations cannot be easily related to one another during an
        update, all Subversion can warn you about is an incoming
        delete operation on a locally modified file.  This delete
        operation <emphasis>may</emphasis> be part of a move, or it
        could be a genuine delete operation.  Determining exactly what
        semantic change was made to the repository is
        important&mdash;you want to know just how your own edits fit
        into the overall trajectory of the project.  So read log
        messages, talk to your collaborators, study the line-based
        differences&mdash;do whatever you must do&mdash;to determine
        your best course of action.</para>
-->
      <para>Du fait qu'un déplacement dans Subversion est implémenté
        comme une copie suivie d'un effacement et que ces deux
        opérations ne peuvent pas être corrélées facilement lors d'une
        mise à jour, tout ce que Subversion peut vous dire c'est que
        la mise à jour va effacer le fichier sur lequel vous avez fait
        des modifications. L'effacement <emphasis>peut</emphasis> faire
        partie d'un déplacement ou n'être simplement qu'un effacement en
        tant que tel. Déterminer exactement quelle est la sémantique
        associée à cette modification dans le dépôt est important&nbsp;:
        vous devez savoir dans quelle mesure vos modifications
        s'intègrent dans l'évolution générale du projet. Lisez donc les
        commentaires de propagation, discutez avec vos collaborateurs,
        étudiez les lignes modifiées à l'aide de la visualisation
        <quote>diff</quote>. Bref, faites ce que vous avez à faire pour
        déterminer quelle est la conduite à tenir dans ce cas
        précis.</para>

<!--
      <para>In this case, Harry's commit log message tells you what
        you need to know.</para>
-->
      <para>Ici, le commentaire de propagation de Harry vous donne toutes
        les informations utiles.</para>


      <informalexample>
        <screen>
$ svn log -r14 ^/trunk
------------------------------------------------------------------------ <!--
r14 | harry | 2011-09-06 10:38:17 -0400 (Tue, 06 Sep 2011) | 1 line

Changed paths:
-->
r14 | harry | 2011-09-06 10:38:17 -0400 (dim. 06. sept. 2011) | 1 ligne
Chemins modifiés:
   M /Makefile
   D /code/machin.c
   A /code/bidule.c (de /code/machin.c:13)

J'ai renommé machin.c en bidule.c et modifié le Makefile en conséquence.
------------------------------------------------------------------------
$
</screen>
      </informalexample>

<!--
      <para><command>svn info</command> shows the URLs of the items
        involved in the conflict.  The <emphasis>left</emphasis> URL
        shows the source of the local side of the conflict, while
        the <emphasis>right</emphasis> URL shows the source of the
        incoming side of the conflict.  These URLs indicate where you
        should start searching the repository's history for the change
        which conflicts with your local change.</para>
-->
      <para><command>svn info</command> affiche les URL des éléments
        en conflit. L'URL de <emphasis>gauche</emphasis> indique la
        source locale du conflit alors que l'URL
        <emphasis>droite</emphasis> indique la source externe du
        conflit. Ces URL vous montrent où vous devez commencer à
        chercher les modifications qui génèrent le conflit dans
        l'historique du dépôt.</para>

      <informalexample>
        <screen><!--
$ svn info code/bar.c
Path: code/bar.c
Name: bar.c
URL: http://svn.example.com/svn/repo/trunk/code/bar.c-->
$ svn info code/machin.c
Chemin: code/machin.c
Nom: machin.c
URL: http://svn.exemple.com/svn/depot/trunk/code/machin.c
&hellip; <!--
Tree conflict: local edit, incoming delete upon update
  Source  left: (file) ^/trunk/code/bar.c@4
  Source right: (none) ^/trunk/code/bar.c@5
-->
Tree conflict: local edit, incoming delete upon update
  Source gauche: (fichier) ^/trunk/code/machin.c@4
  Source  droit: (aucun) ^/trunk/code/machin.c@5

$
</screen>
      </informalexample>

<!--
      <para><filename>bar.c</filename> is now said to be the victim of
        a tree conflict.  It cannot be committed until the conflict is
        resolved:</para>
-->
      <para>On dit que <filename>machin.c</filename> est victime du
        conflit d'arborescence. Il ne peut pas être propagé tant que
        le conflit n'est pas résolu&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn commit -m "Small fixes"
svn: E155015: Commit failed (details follow):
svn: E155015: Aborting commit: '/home/svn/project/code/bar.c' remains in conflict
-->
$ svn commit -m "Petites résolutions de problèmes"
svn: E155015: Échec de la propagation (commit), détails :
svn: E155015: Arrêt de la propagation : '/home/svn/projet/code/machin.c' demeure en conflit
$
</screen>
      </informalexample>

<!--
      <para>To resolve this conflict, you must either agree or
        disagree with the move that Harry made.</para>
-->

      <para>Pour résoudre ce conflit, vous devez soit approuver soit
        rejeter le déplacement effectué par Harry.</para>

<!--
      <para>If you agree with the move, your <filename>bar.c</filename>
        is superfluous.  You'll want to delete it and mark the tree
        conflict as resolved.  But wait:  you made changes to that
        file!  Before deleting <filename>bar.c</filename>, you need to
        decide if the changes you made to it need to be applied
        elsewhere, for example to the new <filename>baz.c</filename>
        file where all of <filename>bar.c</filename>'s code now lives.
        Let's assume that your changes do need to <quote>follow the
        move</quote>.  Subversion isn't smart enough to do this work
        for you<footnote><para>In some cases, Subversion 1.5 and 1.6
        <emphasis>would</emphasis> actually handle this for you, but
        this somewhat hit-or-miss functionality was removed in
        Subversion 1.7.</para></footnote>, so you need to migrate your
        changes manually.</para>
-->
      <para>Si vous approuvez le déplacement, votre
        <filename>machin.c</filename> est superflu. Vous pouvez alors
        l'effacer et marquer le conflit comme résolu. Mais
        attendez&nbsp;: vous avez effectué des modifications dans ce
        fichier&nbsp;! Avant d'effacer <filename>machin.c</filename>,
        vous devez décider si les modifications que vous avez
        effectuées doivent être appliquées ailleurs, par exemple
        dans le nouveau fichier <filename>bidule.c</filename>, qui
        contient en effet tout l'ancien code de
        <filename>machin.c</filename>. Considérons que vos
        modifications doivent <quote>suivre le mouvement</quote>.
        Subversion n'est pas assez perfectionné pour faire ce travail
        à votre place<footnote><para>Dans certains cas, <emphasis>il
        arrive que</emphasis> Subversion 1.5 ou 1.6 fasse le transfert
        pour vous, mais cette fonctionnalité un peu <quote>ça passe
        ou ça casse</quote> a été enlevée dans
        Subversion 1.7.</para></footnote>, vous devez donc faire ces
        modifications manuellement.</para>

<!--
      <para>In our example, you could manually re-make your change
        to <filename>bar.c</filename> pretty easily&mdash;it was,
        after all, a single-line change.  That's not always the case,
        though, so we'll show a more scalable approach.  We'll first
        use <command>svn diff</command> to create a patch file.  Then
        we'll edit the headers of that patch file to point to the new
        name of our renamed file.  Finally, we re-apply the modified
        patch to our working copy.</para>
-->
      <para>Dans notre exemple, vous pourriez manuellement refaire vos
        modifications sur <filename>machin.c</filename> assez
        facilement &mdash; ce n'était qu'un seul changement de ligne
        après tout. Cependant, ce n'est pas toujours le cas, c'est
        pourquoi nous allons voir une approche qui peut s'appliquer sur
        de plus gros changements. Nous commencerons par utiliser
        <command>svn diff</command> pour générer un fichier patch.
        Ensuite, nous allons modifier les entêtes de ce fichier patch
        pour pointer vers le nouveau nom de notre fichier déplacé.
        Finalement, nous appliquons à nouveau le fichier patch modifié
        sur la copie de travail.</para>

      <informalexample>
        <screen> <!--
$ svn diff code/bar.c > PATCHFILE
$ cat PATCHFILE
Index: code/bar.c
===================================================================
- - code/bar.c	(revision 14)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$ ### Edit PATCHFILE to refer to code/baz.c instead of code/bar.c
$ cat PATCHFILE
Index: code/baz.c
===================================================================
- - code/baz.c	(revision 14)
+++ code/baz.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$ svn patch PATCHFILE
U         code/baz.c
$
-->
$ svn diff code/machin.c > FICHIER_CORRECTIF
$ cat FICHIER_CORRECTIF
Index: code/machin.c
===================================================================
--- code/machin.c	(révision 14)
+++ code/machin.c	(copie de travail)
@@ -1,4 +1,4 @@
 const char *machin(void)
 {
-    return "Moi non plus!\n";
+    return "Bah, moi j'aime bien être ballotté !\n";
 }
$ ### Editer FICHIER_CORRECTIF pour pointer vers code/bidule.c au lieu de code/machin.c

$ cat FICHIER_CORRECTIF
Index: code/bidule.c
===================================================================
--- code/bidule.c	(révision 14)
+++ code/bidule.c	(copie de travail)
@@ -1,4 +1,4 @@
 const char *machin(void)
 {
-    return "Moi non plus!\n";
+    return "Bah, moi j'aime bien être ballotté !\n";
 }
$ svn patch FICHIER_CORRECTIF
U         code/bidule.c
$
</screen>
      </informalexample>

<!--
      <para>Now that the changes you originally made
        to <filename>bar.c</filename> have been successfully
        reproduced in <filename>baz.c</filename>, you can
        delete <filename>bar.c</filename> and resolve the conflict,
        instructing the resolution logic to accept what is currently
        in the working copy as the desired result.</para>
-->
      <para>Maintenant que les changements que vous aviez faits
        originellement sur <filename>machin.c</filename> ont été
        correctement reproduits dans <filename>bidule.c</filename>, vous
        pouvez effacer <filename>machin.c</filename> et résoudre le
        conflit en indiquant que vous choisissez la version de la copie
        de travail comme valide.</para>

      <informalexample>
        <screen> <!--
$ svn delete - -force code/bar.c
D         code/bar.c
$ svn resolve - -accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
M       code/baz.c
$ svn diff
Index: code/foo.c
===================================================================
- - code/foo.c  (revision 14)
+++ code/foo.c  (working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/baz.c
===================================================================
- - code/baz.c  (revision 14)
+++ code/baz.c  (working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$-->
$ svn delete --force code/machin.c
D         code/machin.c
$ svn resolve --accept=working code/machin.c
Conflit sur 'code/machin.c' résolu
$ svn status
M       code/bidule.c
M       code/truc.c
$ svn diff
Index: code/truc.c
===================================================================
--- code/truc.c  (revision 14)
+++ code/truc.c  (working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("Je n'aime pas être baladé !\n%s", machin());
-    return 0;
+    return 1;
 }
Index: code/bidule.c
===================================================================
--- code/bidule.c  (revision 14)
+++ code/bidule.c  (working copy)
@@ -1,4 +1,4 @@
 const char *machin(void)
 {
-    return "Moi non plus!\n";
+    return "Bah, moi j'aime bien être ballotté !\n";
 }
$
</screen>
      </informalexample>

<!--
      <para>But what if you do not agree with the move?  Well, in that
        case, you can delete <filename>baz.c</filename> instead, after
        making sure any changes made to it after it was renamed are
        either preserved or not worth keeping.  (Do not forget to also
        revert the changes Harry made to <filename>Makefile</filename>.)
        Since <filename>bar.c</filename> is already scheduled for
        re-addition, there is nothing else left to do, and the
        conflict can be marked resolved:</para>
-->
      <para>Mais que se passe-t-il si vous n'êtes pas d'accord avec le
        déplacement&nbsp;? Eh bien, dans ce cas, vous pouvez effacer
        <filename>bidule.c</filename> après vous être assuré que
        celui-ci ne contient pas de modification postérieure à son
        renommage que vous souhaiteriez conserver (n'oubliez pas non
        plus de revenir sur les modifications effectuées par Harry sur
        <filename>Makefile</filename>). Comme
        <filename>machin.c</filename> est déjà prévu d'être ajouté
        lors de la prochaine propagation, il n'y a rien de plus à
        faire et le conflit peut être marqué comme résolu&nbsp;:</para>

      <informalexample>
        <screen><!--
$ svn delete - -force code/baz.c
D         code/baz.c
$ svn resolve - -accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
A  +    code/bar.c
D       code/baz.c
M       Makefile
$ svn diff
Index: code/foo.c
===================================================================
- - code/foo.c	(revision 14)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/bar.c
===================================================================
- - code/bar.c	(revision 14)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
Index: code/baz.c
===================================================================
- - code/baz.c	(revision 14)
+++ code/baz.c	(working copy)
@@ -1,4 +0,0 @@
-const char *bar(void)
-{
-    return "Me neither!\n";
-}
Index: Makefile
===================================================================
- - Makefile	(revision 14)
+++ Makefile	(working copy)
@@ -1,2 +1,2 @@
 foo:
-	$(CC) -o $@ code/foo.c code/baz.c
+	$(CC) -o $@ code/foo.c code/bar.c-->
$ svn delete --force code/bidule.c
D         code/bidule.c
$ svn resolve --accept=working code/machin.c
Conflit sur 'code/machin.c' résolu
$ svn status
M       code/truc.c
A  +    code/machin.c
D       code/bidule.c
M       Makefile
$ svn diff
Index: code/truc.c
===================================================================
--- code/truc.c	(revision 14)
+++ code/truc.c	(copie de travail)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("Je n'aime pas être baladé !\n%s", machin());
-    return 0;
+    return 1;
 }
Index: code/machin.c
===================================================================
--- code/machin.c	(revision 14)
+++ code/machin.c	(copie de travail)
@@ -1,4 +1,4 @@
 const char *machin(void)
 {
-    return "Moi non plus!\n";
+    return "Bah, moi j'aime bien être ballotté !\n";
 }
Index: code/bidule.c
===================================================================
--- code/bidule.c	(revision 14)
+++ code/bidule.c	(copie de travail)
@@ -1,4 +0,0 @@
-const char *machin(void)
-{
-    return "Moi non plus!\n";
-}
Index: Makefile
===================================================================
--- Makefile	(revision 14)
+++ Makefile	(copie de travail)
@@ -1,2 +1,2 @@
 truc:
-	$(CC) -o $@ code/truc.c code/bidule.c
+	$(CC) -o $@ code/truc.c code/machin.c
</screen>
      </informalexample>

<!--
      <para>You've now resolved your first tree conflict!  You can
        commit your changes and tell Harry during tea break about all
        the extra work he caused for you.</para>
-->
      <para>Vous avez résolu votre premier conflit d'arborescence.
        Vous pouvez propager vos modifications et vous plaindre auprès
        de Harry à la pause café à propos de la surcharge de travail
        qu'il vous a infligée.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.summary">
<!--
    <title>Summary</title>
-->
    <title>Résumé</title>

<!--
      <para>Now we've covered most of the Subversion client commands.
        Notable exceptions are those dealing with branching and
        merging (see <xref linkend="svn.branchmerge"/>) and properties (see
        <xref linkend="svn.advanced.props"/>).  However, you may want to
        take a moment to skim through <xref linkend="svn.ref.svn"/> to
        get an idea of all the different commands that Subversion
        has&mdash;and how you can use them to make your work
        easier.</para>
-->
      <para>Nous en avons maintenant terminé avec la plupart des
        commandes du client Subversion. Les exceptions notables
        concernent les branches et la fusion (voir le
        <xref linkend="svn.branchmerge"/>) ainsi que les propriétés
        (voir le <xref linkend="svn.advanced.props"/>). Cependant,
        prenez le temps de parcourir le <xref linkend="svn.ref.svn"/>
        pour vous faire une idée de toutes les commandes de Subversion
        et de la manière dont vous pouvez les utiliser pour rendre votre
        travail plus convivial.</para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
