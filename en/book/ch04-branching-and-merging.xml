<!-- -*- sgml -*- -->

<chapter id="svn.branchmerge">
  <title>Branching and Merging</title>

  <blockquote>
    <attribution>Confucius</attribution>
    <para><quote>君子务本
      (It is upon the Trunk that a gentleman works.)</quote></para>
  </blockquote>

  <para>Branching and merging are fundamental aspects of version
    control, simple enough to explain conceptually but offering just
    enough complexity and nuance to merit their own chapter in this
    book.  Herein, we'll introduce you to the general ideas behind
    these operations as well as Subversion's somewhat unique approach
    to them.  If you've not familiarized yourself with Subversion's
    basic concepts (found in <xref linkend="svn.basic"/>), we
    recommend that you do so before reading this chapter.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
    <title>What's a Branch?</title>

    <para>Suppose it's your job to maintain a document for a division
      in your company&mdash;a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>

    <para>What do you do in this situation?  You do the obvious: make
      a second copy of your document and begin maintaining the two
      copies separately.  As each department asks you to make small
      changes, you incorporate them into one copy or the other.</para>

    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they differ only in
      small, specific ways.</para>

    <para>
      <indexterm>
        <primary>branches</primary>
      </indexterm>This is the basic concept of a branch&mdash;namely,
      a line of development that exists independently of another line,
      yet still shares a common history if you look far enough back in
      time.  A branch always begins life as a copy of something, and
      moves on from there, generating its own history (see
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

    <figure id="svn.branchmerge.whatis.dia-1">
      <title>Branches of development</title>
      <graphic fileref="images/ch04dia1.png"/>
    </figure>

    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
    <title>Using Branches</title>

    <para>At this point, you should understand how each commit creates
      a new state of the filesystem tree (called a <quote>revision</quote>)
      in the repository.  If you don't, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>

    <para>Let's revisit the example from
      <xref linkend="svn.basic"/>.  Remember that you and your
      collaborator, Sally, are sharing a repository that contains two
      projects, <filename>paint</filename> and
      <filename>calc</filename>.  Notice that in <xref
      linkend="svn.branchmerge.using.dia-1"/>, however, each project
      directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>

    <figure id="svn.branchmerge.using.dia-1">
      <title>Starting repository layout</title>
      <graphic fileref="images/ch04dia2.png"/>
    </figure>

    <para>As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>

    <para>Let's say that you've been given the task of implementing a
      large software feature.  It will take a long time to write, and
      will affect all the files in the project.  The immediate problem
      is that you don't want to interfere with Sally, who is in the
      process of fixing small bugs here and there.  She's depending on
      the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit by bit, you'll surely break
      things for Sally (and other team members as well).</para>

    <para>One strategy is to crawl into a hole: you can stop sharing
      information for a week or two, gutting and reorganizing all the
      files in your private working copy but not committing or
      updating until you're completely finished with your task.  There
      are a number of problems with this, though.  First, it's not
      very safe.  Should something bad happen to your working copy or
      computer, you risk losing all your changes.  Second, it's not
      very flexible.  Unless you manually replicate your changes
      across different working copies or computers, you're stuck trying
      to make your changes in a single working copy.  Similarly, it's
      difficult to share your work-in-progress with anyone else.  A
      common software development <quote>best practice</quote> is to
      allow your peers to review your work as you go.  If nobody sees
      your intermediate commits, you lose potential feedback and may
      end up going down the wrong path for weeks before another person
      on your team notices.  Finally, when you're finished with all
      your changes, you might find it very difficult to merge your
      completed work with the rest of the company's main body of code.
      Sally (or others) may have made many other changes in the
      repository that are difficult to incorporate into your working
      copy when you eventually run <command>svn update</command> after
      weeks of isolation.</para>

    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      not-yet-completed work frequently without interfering with
      others' changes and while still selectively sharing information
      with your collaborators.  You'll see exactly how this works as
      we continue.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
      <title>Creating a Branch</title>

      <para>Creating a branch is very simple&mdash;you make a copy of
        your project tree in the repository using the <command>svn
        copy</command> command.  Since your project's source code is
        rooted in the <filename>/calc/trunk</filename> directory, it's
        that directory that you'll copy.  Where should the new
        copy live?  Wherever you wish.  The repository location in
        which branches are stashed is left by Subversion as a matter
        of project policy.  Finally, your branch will need a name to
        distinguish it from other branches.  Once again, the name you
        choose is unimportant to Subversion&mdash;you can use whatever
        name works best for you and your team.</para>

      <para>Let's assume that your team (like most) has a policy of
        creating branches in the <filename>branches</filename>
        directory that is a sibling of the project's trunk
        (the <filename>/calc/branches</filename> directory in our
        scenario).  Lacking inspiration, you settle
        on <literal>my-calc-branch</literal> as the name you wish to
        give your branch.  This means that you'll create a new
        directory, <filename>/calc/branches/my-calc-branch</filename>,
        which begins its life as a copy
        of <filename>/calc/trunk</filename>.</para>

      <para>
        <indexterm>
          <primary>copying</primary>
          <secondary>remote copies</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
          <secondary>creating</secondary>
        </indexterm>You may already have seen <command>svn
        copy</command> used to copy one file to another within a
        working copy.  But it can also be used to do
        a <firstterm>remote copy</firstterm>&mdash;a copy that
        immediately results in a newly committed repository revision
        and for which no working copy is required at all.  Just copy
        one URL to another:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/my-calc-branch \
           -m "Creating a private branch of /calc/trunk."

Committed revision 341.
$
</screen>
      </informalexample>

      <para>This command causes a near-instantaneous commit in the
        repository, creating a new directory in revision 341.  The new
        directory is a copy of <filename>/calc/trunk</filename>.  This
        is shown in <xref linkend="svn.branchmerge.using.create.dia-1"
        />.<footnote><para>Subversion does not support copying between
        different repositories.  When using URLs with <command>svn
        copy</command> or <command>svn move</command>, you can only
        copy items within the same repository.</para></footnote>  While
        it's also possible to create a branch by using <command>svn
        copy</command> to duplicate a directory within the working
        copy, this technique isn't recommended.  It can be quite slow,
        in fact!  Copying a directory on the client side is a
        linear-time operation, in that it actually has to duplicate
        every file and subdirectory within that working copy directory
        on the local disk.  Copying a directory on the server,
        however, is a constant-time operation, and it's the way most
        people create branches.  In addition, this practice raises the
        possibility of copying mixed-revision working copies.  This isn't
        inherently dangerous, but can cause unnecessary complications later
        during merging.  If you do choose to create a branch by copying a
        working copy path, you should be sure the source directory has no
        local modifications and is not at mixed-revisions.</para>
            
      <figure id="svn.branchmerge.using.create.dia-1">
        <title>Repository with new copy</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
        <title>Cheap Copies</title>

        <para>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&mdash;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're an experienced Unix user, you'll recognize this as
          the same concept behind a hard link.  As further changes are
          made to files and directories beneath the copied directory,
          Subversion continues to employ this hard link concept where
          it can.  It duplicates data only when it is necessary to
          disambiguate different versions of objects.</para>

        <para>This is why you'll often hear Subversion users talk
          about <quote>cheap copies.</quote>  It doesn't matter how
          large the directory is&mdash;it takes a very tiny, constant
          amount of time and space to make a copy of it.  In fact,
          this feature is the basis of how commits work in Subversion:
          each revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's web site and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>

        <para>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and in space.  If you create a branch
          entirely within the repository (by running <userinput>svn copy
          <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput>),
          it's a quick, constant-time operation.  Make branches as
          often as you want.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <title>Working with Your Branch</title> 

      <para>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A    my-calc-branch/doc
A    my-calc-branch/src
A    my-calc-branch/doc/INSTALL
A    my-calc-branch/src/real.c
A    my-calc-branch/src/main.c
A    my-calc-branch/src/button.c
A    my-calc-branch/src/integer.c
A    my-calc-branch/Makefile
A    my-calc-branch/README
Checked out revision 341.

$
</screen>
      </informalexample>

      <para>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't see them when she
        updates, because her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternative way of
        creating a working copy of a branch.)</para>

      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>

      <itemizedlist>
        <listitem>
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>,
            which creates revision 342.</para>
        </listitem>
        <listitem>
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>,
            which creates revision 343.</para>
        </listitem>
        <listitem>
          <para>Sally makes a change to
            <filename>/calc/trunk/src/integer.c</filename>, which creates
            revision 344.</para>
        </listitem>
      </itemizedlist>

      <para>Now two independent lines of development (shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>) are happening on
        <filename>integer.c</filename>.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
        <title>The branching of one file's history</title>
        <graphic width="4.81in" depth="2.18in" fileref="images/basic-branch.png" />
      </figure>

      <para>Things get interesting when you look at the history of
        changes made to your copy of <filename>integer.c</filename>:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -v src/integer.c
------------------------------------------------------------------------
r343 | user | 2013-02-15 14:11:09 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch/src/integer.c

* integer.c:  frozzled the wazjub.
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look at what happens when Sally runs the same
        command on her copy of the file:</para>

      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/integer.c
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Refactor the bazzle functions.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch copy was made in revision
        341, the files used to be the same file.  That's why you and
        Sally both see the changes made between revisions 8 and
        154.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
      <title>The Key Concepts Behind Branching</title> 

      <para>You should remember two important lessons
        from this section.  First, Subversion has no internal concept
        of a branch&mdash;it knows only how to make copies.  When you
        copy a directory, the resultant directory is only
        a <quote>branch</quote> because <emphasis>you</emphasis>
        attach that meaning to it.  You may think of the directory
        differently, or treat it differently, but to Subversion it's
        just an ordinary directory that happens to carry some extra
        historical information.</para>

      <para>Second, because of this copy mechanism, Subversion's
        branches exist as <emphasis>normal filesystem
        directories</emphasis> in the repository.  This is different
        from other version control systems, where branches are
        typically defined by adding
        extra-dimensional <quote>labels</quote> to collections of
        files.  The location of your branch directory doesn't matter
        to Subversion.  Most teams follow a convention of putting all
        branches into a <filename>/branches</filename> directory, but
        you're free to invent any policy you wish.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.basicmerging">
    <title>Basic Merging</title>

    <para>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the trunk, or main line of development.</para>

    <para>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>

    <para>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>

    <para>
      <indexterm>
        <primary>merging</primary>
      </indexterm>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <firstterm>merging</firstterm>, and
      it is performed using various invocations of the <command>svn
      merge</command> subcommand.</para>

    <para>In the examples that follow, we're assuming that both your
      Subversion client and server are running Subversion 1.8 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won't track changes
      automatically, forcing you to use painful manual methods to
      achieve similar results.  That is, you'll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/> later
      in this chapter), and take special care to keep track of what's
      already been merged and what hasn't.  For this reason,
      we <emphasis>strongly</emphasis> recommend that you make sure your
      client and server are at least at version 1.5.</para>

    <sidebar id="svn.branchmerge.basicmerging.mergetracking">
      <title>Merge Tracking</title>
      <para>
        <indexterm>
          <primary>merge tracking</primary>
        </indexterm>Subversion 1.5 introduced the
        <firstterm>merge tracking</firstterm> feature to Subversion.
        Prior to this feature keeping track of merges required cumbersome
        manual procedures or the use of external tools. Subsequent
        releases of Subversion introduced many enhancements and bug
        fixes to merge tracking, which is why we recommend using the
        most recent versions for both your server and client.  Keep in
        mind that even if your server is running 1.5-1.7, you can still
        use a 1.8 client.  This is particularly important with regard to merge
        tracking, because the overwhelming majority of fixes and enhancements
        to it are on the client side.</para>
    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.changesets">
      <title>Changesets</title>

      <para>
        <indexterm>
          <primary>changesets</primary>
        </indexterm>Before we proceed further, we should warn you that there's
        a lot of discussion of <quote>changes</quote> in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms <quote>change</quote>
        and <quote>changeset</quote> interchangeably, and we should
        clarify what Subversion understands as
        a <firstterm>changeset</firstterm>.</para>

      <para>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let's say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</para>

      <para>In Subversion, a global revision
        number <replaceable>N</replaceable> names a tree in the
        repository: it's the way the repository looked after the
        <replaceable>N</replaceable>th commit.  It's also the name of
        an implicit changeset: if you compare
        tree <replaceable>N</replaceable> with
        tree <replaceable>N</replaceable>-1, you can derive the exact
        patch that was committed.  For this reason, it's easy to think
        of revision <replaceable>N</replaceable> as not just a tree,
        but a changeset as well.  If you use an issue tracker to
        manage bugs, you can use the revision numbers to refer to
        particular patches that fix bugs&mdash;for example,
        <quote>this issue was fixed by r9238.</quote> Somebody
        can then run <userinput>svn log -r 9238</userinput> to read about
        the exact changeset that fixed the bug, and run
        <userinput>svn diff -c 9238</userinput> to see the patch itself.
        And (as you'll see shortly)
        Subversion's <command>svn merge</command> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <userinput>-c 9238</userinput>
        to <command>svn merge</command> would merge changeset r9238
        into your working copy.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync">
      <title>Keeping a Branch in Sync</title>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>sync merges</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>merge</tertiary>
        </indexterm>Continuing with our running example, let's suppose
        that a week has passed since you started working on your
        private branch.  Your new feature isn't finished yet, but at
        the same time you know that other people on your team continue
        to make important changes in the
        project's <filename>/trunk</filename>.  It's in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  This is done
        by performing an <firstterm>automatic sync merge</firstterm>&mdash;a
        merge operation designed to bring your branch up to date with
        any changes made to its ancestral parent branch since your
        branch was created.
        <indexterm>
          <primary>merging</primary>
          <secondary>automatic</secondary>
        </indexterm> An <quote>automatic</quote> merge is simply
        one in which you provide the bare minimum of information required
        for a merge (i.e. a single merge source and a working copy target)
        and let Subversion determine which changes need merging&mdash;no
        changesets are passed to <command>svn merge</command> via the
        <option>-r</option> or <option>-c</option> options in an automatic
        merge.</para>

      <tip>
        <para>Frequently keeping your branch in sync with the main
          development line helps prevent <quote>surprise</quote>
          conflicts when the time comes for you to fold your changes
          back into the trunk.</para>
      </tip>

      <para>Subversion is aware of the history of your branch and
        knows when it split away from the trunk.  To perform a sync
        merge, first make sure your working copy of the branch
        is <quote>clean</quote>&mdash;that it has no local
        modifications reported by <command>svn status</command>.  Then
        simply run:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn merge ^/calc/trunk
--- Merging r341 through r351 into '.':
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
--- Recording mergeinfo for merge of r341 through r351 into '.':
 U   .
 $
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>properties</primary>
          <secondary>svn:mergeinfo</secondary>
        </indexterm>This basic syntax&mdash;<userinput>svn merge
        <replaceable>URL</replaceable></userinput>&mdash;tells
        Subversion to merge all changes which have not been previously
        merged from the URL to the current working directory (which is
        typically the root of your working copy).  Notice that we're
        using the caret (<literal>^</literal>)
        syntax<footnote><para>This was introduced in svn
        1.6.</para></footnote> to avoid having to type out the
        entire <filename>/trunk</filename> URL.  Also note
        the <quote>Recording mergeinfo for merge&hellip;</quote>
        notification.  This tells you that the merge is updating
        the <literal>svn:mergeinfo</literal> property. We'll discuss
        both this property and these notifications later in this
        chapter, in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>

      <tip>
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
          </indexterm>In this book and elsewhere (Subversion mailing
          lists, articles on merge tracking, etc.) you will frequently
          come across the term <firstterm>mergeinfo</firstterm>. This
          is simply shorthand for the <literal>svn:mergeinfo</literal>
          property.</para>
      </tip>

      <sidebar>
        <title>Keeping a Branch in Sync Without Merge Tracking</title>

        <para>You may not always be able to use Subversion's merge
          tracking feature, perhaps because your server is running
          Subversion 1.4 or earlier or you must use an older client.
          In such a scenario, you can of course still perform merges,
          but Subversion will need you to manually do many of the historical
          calculations that it automatically does on your behalf when the
          merge tracking feature is available.</para>

        <para>To replicate the most recent trunk changes you need to
          perform sync merges the <quote>old-fashioned</quote>
          way&mdash;by specifying ranges of revisions you wish to
          merge.</para>

        <para>Using the ongoing example, you know that you branched
          <filename>/calc/trunk</filename> to 
          <filename>/calc/branches/my-calc-branch</filename> in revision
          341:</para>

        <informalexample>
          <screen>
$ svn log -v -r341
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
</screen>
        </informalexample>

        <para>When you are ready to synchronize your branch with the
          ongoing changes from trunk, you specify the starting
          revision as the revision of <filename>/calc/trunk</filename>
          which the branch was copied from and the ending revision as
          the youngest change on <filename>/calc/trunk</filename>.  You
          can find the latter with the <command>svn log</command> command
          with the <option>-r</option> set to <literal>HEAD</literal>:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r340:351
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
</screen>
        </informalexample>

        <para>After any conflicts have been resolved, you can commit
          the merged changes to your branch.  Now, to avoid
          accidentally trying to merge these same changes into your
          branch again in the future, you'll need to record the fact
          that you've already merged them.  But where should that
          record be kept?  One of the simplest places to record this
          information is in the log message for the commit of the
          merge:</para>

        <informalexample>
          <screen>
$ svn ci -m "Sync the my-calc-branch with ^/calc/trunk through r351."
&hellip;
</screen>
        </informalexample>

        <para>The next time you sync
          <filename>/calc/branches/my-calc-branch</filename>  with
          <filename>/calc/trunk</filename> you repeat this process, except
          that the starting revision is the <emphasis>youngest</emphasis>
          revision that's already been merged in from the trunk.
          If you've been keeping good records of your merges in the
          commit log messages, you should be able to determine what
          that youngest revision was by reading the revision logs
          associated with your branch.  Once you know your starting
          revision, you can perform another sync merge:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------
r959 | sally | 2013-03-5 7:30:21 -0500 (Tue, 05 Mar 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r351:959
&hellip;
</screen>
        </informalexample>

      </sidebar>

      <para>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</para>

      <informalexample>
        <screen>
$ svn status
 M      .
M       Makefile
M       doc/INSTALL
M       src/button.c
M       src/real.c
</screen>
      </informalexample>

      <para>At this point, the wise thing to do is look at the changes
        carefully with <command>svn diff</command>, and then build and
        test your branch.  Notice that the current working directory
        (<quote><filename>.</filename></quote>) has also been
        modified; <command>svn diff</command> shows that
        its <literal>svn:mergeinfo</literal> property has been created.
        </para>

      <informalexample>
        <screen>
$ svn diff --depth empty .
Index: .
===================================================================
--- .   (revision 351)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /calc/trunk:r341-351
</screen>
      </informalexample>

      <para>
        This new property is important merge-related metadata
        that you should <emphasis>not</emphasis> touch, since it is
        needed by future <command>svn merge</command> commands.
        (We'll learn more about this metadata later in the
        chapter.)</para>

      <para>After performing the merge, you might also need to resolve
        some conflicts&mdash;just as you do with <command>svn
        update</command>&mdash;or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <emphasis>syntactic</emphasis> conflicts doesn't mean there
        aren't any <emphasis>semantic</emphasis> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <userinput>svn revert . -R</userinput> (which
        will undo all local modifications) and starting a
        long <quote>what's going on?</quote> discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</para>

      <informalexample>
        <screen>
$ svn commit -m "Sync latest trunk changes to my-calc-branch."
Sending        .
Sending        Makefile
Sending        doc/INSTALL
Sending        src/button.c
Sending        src/real.c
Transmitting file data ....
Committed revision 352.
</screen>
      </informalexample>

      <para>At this point, your private branch is now <quote>in
        sync</quote> with the trunk, so you can rest easier knowing
        that as you continue to work in isolation, you're not drifting
        too far away from what everyone else is doing.</para>

      <sidebar>
        <title>Why Not Use Patches Instead?</title>

        <para>A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use <command>svn patch</command> or the
          operating system's <command>patch</command> command to
          accomplish the same job?  For example:</para>

        <informalexample>
          <screen>
$ cd my-calc-branch

$ svn diff -r 341:351 ^/calc/trunk > my-patch-file

$ svn patch my-patch-file
U         doc/INSTALL
U         src/real.c
U         src/button.c
U         Makefile
</screen>
        </informalexample>

        <para>In this particular example, there really isn't much
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's able to tweak file contents only.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <command>patch</command> program
          notice changes to properties.  If Sally's change had,
          say, added a new directory, the output of <command>svn
          diff</command> wouldn't have mentioned it at
          all.  <command>svn diff</command> outputs only the limited
          patch format, so there are some ideas it simply can't
          express.  Even Subversion's own <command>svn patch</command>
	  subcommand, while more flexible than the <command>patch</command>
	  program, still has
          similar limitations.</para>

        <para>The <command>svn merge</command> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven't been merged
          yet.</para>

      </sidebar>

      <para>Suppose that another week has passed.  You've committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you want to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk
svn: E195020: Cannot merge into mixed-revision working copy [352:357]; try up\
dating first
$
</screen>
      </informalexample>

      <para>Well that was unexpected!  After making changes to your
        branch over the past week you now find yourself with a working
        copy that contains a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs"/>).  With Subversion
        1.7 and later, the <command>svn merge</command>
        subcommand disables merges into mixed-revision working copies
        by default.  Without going into too much detail, this is
        because of limitations in the way merges are tracked by the
        <literal>svn:mergeinfo</literal> property (see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details).  These limitations mean that merges into
        mixed-revision working copies can result in unexpected text
        and tree conflicts.<footnote><para>The <command>svn
        merge</command> subcommand
        option <option>--allow-mixed-revisions</option> allows you to
        override this prohibition, but you should only do so if you
        understand the ramifications and have a good reason for
        it.</para></footnote>  We don't want any needless conflicts, so
        we update the working copy and then reattempt the
        merge.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
At revision 361.

$ svn merge ^/calc/trunk
--- Merging r352 through r361 into '.':
U    src/real.c
U    src/main.c
--- Recording mergeinfo for merge of r352 through r361 into '.':
 U   .
</screen>
      </informalexample>

      <para>Subversion knows which trunk changes you previously
        replicated to your branch, so it carefully replicates only
        those changes you don't yet have.  And once again, you build,
        test, and <command>svn commit</command> the local modifications
        to your branch.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync.subtree">
      <title>Subtree Merges and Subtree Mergeinfo</title>
      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>subtree merge</secondary>
        </indexterm>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>subtree mergeinfo</secondary>
        </indexterm>In most of the examples in this chapter the
        merge target is the root directory of a branch (see
        <xref linkend="svn.branchmerge.whatis"/>). While this is a
        best practice, you may occasionally need to merge directly
        to some child of the branch root. This type of merge is
        called a <firstterm>subtree merge</firstterm> and the
        mergeinfo recorded to describe it is called
        <firstterm>subtree mergeinfo</firstterm>. There is nothing
        special about subtree merges or subtree mergeinfo.  In fact
        there is really only one important point to keep in mind
        about these concepts: the complete record of merges to a
        branch may not be contained solely in the mergeinfo on the
        branch root.  You may have to consider subtree mergeinfo
        to get a full accounting.  Fortunately Subversion does this
        for you and rarely will you need to concern yourself with
        it.  A brief example will help explain:</para>

      <informalexample>
        <screen>
# We need to merge r958 from trunk to branches/proj-X/doc/INSTALL,
# but that revision also affects main.c, which we don't want to merge:
$ svn log --verbose --quiet -r 958 ^/
------------------------------------------------------------------------
r958 | bruce | 2011-10-20 13:28:11 -0400 (Thu, 20 Oct 2011)
Changed paths:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
------------------------------------------------------------------------

# No problem, we'll do a subtree merge targeting the INSTALL file
# directly, but first take a note of what mergeinfo exists on the
# root of the branch:
$ cd branches/proj-X

$ svn propget svn:mergeinfo --recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652

# Now we perform the subtree merge, note that merge source
# and target both point to INSTALL:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
--- Merging r958 into 'doc/INSTALL':
U    doc/INSTALL
--- Recording mergeinfo for merge of r958 into 'doc/INSTALL':
 G   doc/INSTALL

# Once the merge is complete there is now subtree mergeinfo on INSTALL:
$ svn propget svn:mergeinfo --recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652
Properties on 'doc/INSTALL':
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# What if we then decide we do want all of r958? Easy, all we need do is
# repeat the merge of that revision, but this time to the root of the
# branch, Subversion notices the subtree mergeinfo on INSTALL and doesn't
# try to merge any changes to it, only the changes to main.c are merged:
$ svn merge ^/subversion/trunk . -c 958
--- Merging r958 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r958 into '.':
 U   .
--- Eliding mergeinfo from 'doc/INSTALL':
 U   doc/INSTALL
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>elision</secondary>
        </indexterm>You might be wondering
        why <filename>INSTALL</filename> in the above example has
        mergeinfo for r651-652, when we only merged r958. This is
        due to mergeinfo inheritance, which we'll cover in the
        sidebar
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
        />.  Also note that the subtree mergeinfo on
        <filename>doc/INSTALL</filename> was removed, or
        <quote>elided</quote>.  This is called
        <firstterm>mergeinfo elision</firstterm> and it occurs
        whenever Subversion detects redundant subtree mergeinfo.</para>

      <tip>
        <para>Prior to Subversion 1.7, merges unconditionally updated
          <emphasis>all</emphasis> of the subtree mergeinfo under the
          target to describe the merge. For users with a lot of subtree
          mergeinfo this meant that relatively <quote>simple</quote>
          merges (e.g. one which applied a diff to only a single file)
          resulted in changes to every subtree with mergeinfo, even
          those that were not parents of the affected path(s). This
          caused some level of confusion and frustration. Subversion 1.7
          and later addresses this problem by only updating the mergeinfo
          on subtrees which are parents of the paths modified by the merge
          (i.e. paths changed, added, or deleted by application of the
          difference, see
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          The one exception to this behavior regards the actual merge
          target; the merge target's mergeinfo is always updated to
          describe the merge, even if the applied difference made no
          changes.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.reintegrate">
      <title>Reintegrating a Branch</title>

      <para>What happens when you finally finish your work, though?
        Your new feature is done, and you're ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch into sync with the trunk again, just as you've been
        doing all along<footnote><para>Since Subversion 1.7 you don't
        absolutely have to do all your sync merges to the root of your
        branch as we do in this example.  <emphasis>If</emphasis> your
        branch is effectively synced via a series of subtree
        merges then the reintegrate will work, but ask yourself, if the
        branch is effectively synced, then why are you doing subtree
        merges? Doing so is almost always needlessly
        complex.</para></footnote>:</para>

      <informalexample>
        <screen>
$ svn up # (make sure the working copy is up to date)
Updating '.':
At revision 378.

$ svn merge ^/calc/trunk
--- Merging r362 through r378 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r362 through r378 into '.':
 U   .

$ # build, test, ...

$ svn commit -m "Final merge of trunk changes to my-calc-branch."
Sending        .
Sending        src/main.c
Transmitting file data .
Committed revision 379.
</screen>
      </informalexample>

      <para>Now, use <command>svn merge</command> subcommand to automatically
        replicate your branch changes back into the trunk.  This type of
        merge is called an
        <indexterm>
          <primary>merging</primary>
          <secondary>reintegrate merges</secondary>
        </indexterm> <quote>automatic reintegrate</quote> merge.  You'll need
        a working copy of <filename>/calc/trunk</filename>.  You can get one
        by doing an <command>svn checkout</command>, dredging up an old trunk
        working copy from somewhere on your disk, or
        using <command>svn switch</command> (see
        <xref linkend="svn.branchmerge.switchwc" />).</para>

      <tip>
        <para>The term <quote>reintegrating</quote> comes from the
          <command>merge</command> option <option>--reintegrate</option>.
          This option is deprecated in Subversion 1.8 (which automatically
          detects when a reintegrate merge is needed), but is required
          for Subversion 1.5 through 1.7 clients when performing reintegrate
          merges.</para>
      </tip>

      <para>Your trunk working copy cannot have any local edits, switched
        paths, or contain a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs" />).  While
        these are typically best practices for merging anyway, they
        are <emphasis>required</emphasis> for automatic reintegrate
        merges.</para>

      <para>Once you have a clean working copy of the trunk, you're
        ready to merge your branch back into it:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/calc-trunk

$ svn update
Updating '.':
At revision 379.

$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
U    src/real.c
U    src/main.c
U    Makefile
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .

$ # build, test, verify, ...

$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        Makefile
Sending        src/main.c
Sending        src/real.c
Transmitting file data ...
Committed revision 380.
</screen>
      </informalexample>

      <para>Congratulations, your branch-specific changes have now
        been merged back into the main line of development.  Notice that
        the automatic reintegrate merge did a different sort of work than
        what you've done up until now.  Previously, we were
        asking <command>svn merge</command> to grab the <quote>next
        set</quote> of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 341:351 from
        <filename>/calc/trunk</filename> to
        <filename>/calc/branches/my-calc-branch</filename>;
        later on, it continues by merging the next contiguously
        available range, 351:361.  When doing the final sync, it
        merges the range 361:378.</para>

      <para>When merging <filename>/calc/branches/my-calc-branch</filename>
        back to the <filename>/calc/trunk</filename>, however, the
        underlying mathematics are quite different.  Your feature
        branch is now a mishmash of both duplicated trunk changes and
        private branch changes, so there's no simple contiguous range
        of revisions to copy over.  By using an automatic merge, you're
        asking Subversion to carefully replicate <emphasis>only</emphasis>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</para>

      <para>Keep in mind that the automatic reintegrate merges only support
        the use case described above.  Because of this narrow focus, in
        addition to the requirements previously mentioned (up-to-date working
        copy <footnote><para>Automatic reintegrate merges are allowed if the
        target is a shallow checkout
        (see <xref linkend="svn.advanced.sparsedirs"/>) but any paths
        affected by the diff which are <quote>missing</quote> due to the
        sparse working copy will be skipped&mdash;this is probably
        <emphasis>not</emphasis> what you intended!</para></footnote>
        with no mixed-revisions, switched paths or local changes) it will not
        function in combination with most of the other
        <command>svn merge</command> options. You'll get an error if you
        use any non-global options but these: <option>--accept</option>,
        <option>--dry-run</option>, <option>--diff3-cmd</option>,
        <option>--extensions</option>, or <option>--quiet</option>.</para>

      <para>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</para>

      <informalexample>
        <screen>
$ svn delete ^/calc/branches/my-calc-branch \
             -m "Remove my-calc-branch, reintegrated with trunk in r381."
&hellip;
</screen>
      </informalexample>

      <para>But wait!  Isn't the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <filename>/calc/branches</filename> directory, its
        existence is still an immutable part of the repository's
        history.  A simple <command>svn log</command> command on
        the <filename>/calc/branches</filename> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>

      <para>If you choose not to delete your branch after reintegrating
        it to the trunk you may continue to perform sync merges from the
        trunk and then reintegrate the branch again<footnote><para>Only
        Subversion 1.8 supports this reuse of a feature branch.  Earlier
        versions require some special handling before a feature branch
        can be reintegrated more than once.  See the earlier version of
        this chapter for more information: <ulink
        url="http://svnbook.red-bean.com/en/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. If you do this, only the changes made on your
        branch after the first reintegrate are merged to the trunk.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.mergeinfo">
      <title>Mergeinfo and Previews</title>

      <para>
        <indexterm>
          <primary>mergeinfo</primary>
          <secondary>property</secondary>
        </indexterm>The basic mechanism Subversion uses to track
        changesets&mdash;that is, which changes have been merged to
        which branches&mdash;is by recording data in versioned
        properties.  Specifically, merge data is tracked in
        the <literal>svn:mergeinfo</literal> property attached to
        files and directories.  (If you're not familiar with
        Subversion properties, see <xref linkend="svn.advanced.props"
        />.)</para>

      <para>You can examine the mergeinfo property, just like any other
        versioned property:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn pg svn:mergeinfo -v
Properties on '.':
  svn:mergeinfo
    /calc/trunk:341-378
</screen>
      </informalexample>

      <warning>
        <para>While it is possible to
          modify <literal>svn:mergeinfo</literal> just as you might
          any other versioned property, we strongly discourage doing
          so unless you <emphasis>really</emphasis> know what you're
          doing.</para>
      </warning>

      <tip>
        <para>The amount of <literal>svn:mergeinfo</literal> on a single
          path can get quite large, as can the output of a
          <command>svn propget --recursive</command> or
          <command>svn proplist --recursive</command> when dealing with
          large amounts of subtree mergeinfo. See
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>
          . The formatted output produced by the
          <option>--verbose</option> option with either of these
          subcommands is often very helpful in these cases.</para>
      </tip>

      <para>The <literal>svn:mergeinfo</literal> property is
        automatically maintained by Subversion whenever you
        run <command>svn merge</command>.  Its value indicates which
        changes made to a given path have been replicated into the
        directory in question.  In our previous example, the path
        which is the source of the merged changes is
        <filename>/calc/trunk</filename> and the directory which has
        received the changes is
        <filename>/calc/branches/my-calc-branch</filename>.
        Earlier versions of Subversion maintained the
        <literal>svn:mergeinfo</literal> property silently. You could
        still detect the changes, after a merge completed, with the
        <command>svn diff</command> or <command>svn status</command>
        subcommands, but the merge itself gave no indication when it
        changed the <literal>svn:mergeinfo</literal> property. In
        Subversion 1.7 and later this is no longer true as there are
        several notifications to alert you when a merge updates the
        <literal>svn:mergeinfo</literal> property. These notifications
        all begin with <quote>--- Recording mergeinfo for</quote>
        and appear at the end of the merge.  Unlike other merge
        notifications, these don't describe the application of a
        difference to a working copy
        (see <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        but instead describe "housekeeping" changes made to keep
        track of what was merged.</para>

      <para>Subversion also provides a subcommand, <command>svn
        mergeinfo</command>, which is helpful in seeing the merge
        relationships between two branches; specifically which changesets
        a directory has absorbed or which changesets it's still eligible
        to receive.  The latter gives a sort of preview of which changes a
        subsequent <command>svn merge</command> operation would replicate
        to your branch.  By default, <command>svn mergeinfo</command> gives
        an graphical overview of the relationship between to branches.
        Returning to our earlier example, we use the subcommand to analyze
        the relationship between <filename>/calc/trunk</filename> and
        <filename>/calc/branches/my-calc-branch</filename>:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn mergeinfo ^/calc/trunk
    youngest common ancestor
    |         last full merge
    |         |        tip of branch
    |         |        |         repository path

    340                382
    |                  |
  -------| |------------         calc/trunk
     \          /
      \        /
       --| |------------         calc/branches/my-calc-branch
              |        |
              379      382
</screen>
      </informalexample>

      <para>The diagram shows that <filename>/calc/branches/my-calc-branch
      </filename> was copied from <filename>/calc/trunk@340</filename> and
      that most recent automatic merge was the reintegrate merge we made
      from the branch to the trunk in r380.  Notice that the diagram does
      <emphasis>not</emphasis> show the four automatic sync merges we made
      in revisions 352, 362, 372, and 379.  Only the most recent automatic
      merge, in either direction<footnote><para>By <quote>direction</quote>
      we mean either trunk-to-branch (automatic sync) or branch-to-trunk
      (automatic reintegrate) merges.</para></footnote>, is shown.  This
      default output is useful for obtaining an overview of the merges
      between two branches, but to see the specific revisions which were
      merged we use the <option>--show-revs=merged</option> option:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs merged
r344
r345
r346
&hellip;
r366
r367
r368
</screen>
      </informalexample>

      <para>Likewise, to see which changes are eligible to merge from the
        trunk to the branch we can use the <option>--show-revs=eligible
        </option> option:</para>
      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r380
r381
r382
</screen>
      </informalexample>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.operativerevs">
        <title>Operative and Inoperative Merge Revisions</title>

        <para>The revision lists produced by the <option>--show-revs
          </option> option include only revisions which made (or would make)
          changes when merged.  So while we have merged a contiguous range of
          revisions (i.e. r341-378) from <filename>/calc/trunk</filename> to
          <filename>/calc/branches/my-calc-branch</filename>, only the
          revisions listed with the <option>--show-revs=merged</option> option
          actually represent changes made on <filename>/calc/trunk</filename>.
          These revisions are described as <quote>operative</quote>
          revisions as regards merging, not to be confused with the
          operative revision used with the <option>-r</option> option, see
          <xref linkend="svn.advanced.pegrevs"/>.  Not suprisingly, the
          revisions in the range r341-378 that are <emphasis>not</emphasis>
          listed as merged are termed <quote>inoperative</quote> revisions.
        </para>
      </sidebar>

      <para>The <command>svn mergeinfo</command> command requires
        a <quote>source</quote> URL (where the changes come
        from), and takes an optional <quote>target</quote> URL (where
        the changes merge to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we're querying our
        branch working copy, the command assumes we're interested in
        receiving changes to <filename>/calc/branches/my-calc-branch
        </filename> from the specified trunk URL.</para>

      <para>Since Subversion 1.7, the
        <command>svn mergeinfo</command> subcommand can also account for
        subtree mergeinfo and non-inheritable mergeinfo.  It accounts for
        subtree mergeinfo by use of the <option>--recursive</option> or
        <option>--depth</option> options, while non-inheritable mergeinfo
        is considered by default.</para>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.inheritance">
        <title>Mergeinfo Inheritance</title>

        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>inheritance</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>explicit</secondary>
          </indexterm>When a path has
          the <literal>svn:mergeinfo</literal> property set on it we
          say it has <firstterm>explicit mergeinfo</firstterm>.  This
          explicit mergeinfo describes not only what changes were
          merged into that particular directory, but also all the
          children of that directory (because those children inherit
          the mergeinfo of their parent path).  For example:</para>

        <informalexample>
          <screen>
# What explicit mergeinfo exists on a branch?
$ svn propget svn:mergeinfo ^/branches/proj-X --recursive
/trunk:651-652

# What children does proj-X have?
$ svn list --recursive ^/branches/proj-X
doc/
doc/INSTALL
README
src/main.c

# Ask what revs were merged to a file with no explicit mergeinfo
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

        <para>Notice from our first subcommand that only the root of
          <filename>/branches/proj-X</filename> has any explicit
          mergeinfo.  However, when we use
          <command>svn mergeinfo</command> to ask what was merged to
          <filename>/branches/proj-X/src/main.c</filename> it reports
          that the two revisions described in the explicit mergeinfo
          on <filename>/branches/proj-X</filename> were merged.  This is
          because <filename>/branches/proj-X/src/main.c</filename>, having
          no explicit mergeinfo of its own, inherits the mergeinfo from
          its nearest parent with explicit mergeinfo,
          <filename>/branches/proj-X</filename>.</para>

        <para>There are two cases in which mergeinfo is not inherited.
          First, if a path has explicit mergeinfo, then it never inherits
          mergeinfo. Another way to think of this is that explicit
          mergeinfo is always a complete record of the merges to a given
          path. Once it exists it overrides any mergeinfo that path might
          otherwise inherit. The second way is when dealing with
          non-inheritable mergeinfo, a special type of explicit mergeinfo
          that applies <emphasis>only</emphasis> to the directory on which
          the <literal>svn:mergeinfo</literal> property is set (and it's
          only directories, non-inheritable mergeinfo is never set on
          files). For example:</para>

        <informalexample>
          <screen>
# The '*' decorator indicates non-inheritable mergeinfo
$ svn propget svn:mergeinfo ^/branches/proj-X
/trunk:651-652,758*

# Revision 758 is non-inheritable, but still applies to the path it is
# set on. Here the '*' decorator signals that r758 is only partially
# merged from trunk. 
$ svn mergeinfo ^/trunk ^/branches/proj-X --show-revs merged
651
652
758*

# Revision 758 is not reported as merged because it is non-inheritable
# and applies only to ^/trunk
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

        <para>You might never have to think about mergeinfo inheritance
          or encounter non-inheritable mergeinfo in your own repository.
          A discussion of the full ramifications of mergeinfo inheritance
          are beyond the scope of this book.  If you have more questions
          check out some of the references mentioned in
          <xref linkend="svn.branchmerge.advanced.finalword"/></para>
      </sidebar>

      <para>Let's say we have a branch with both subtree and
        non-inheritable mergeinfo:</para>

        <informalexample>
          <screen>
$ svn pg svn:mergeinfo -vR
# Non-inheritable mergeinfo
Properties on '.':
  svn:mergeinfo
    /calc/trunk:354,385-388*
# Subtree mergeinfo
Properties on 'Makefile':
  svn:mergeinfo
    /calc/trunk/Makefile:354,380
</screen>
        </informalexample>

      <para>From the above mergeinfo we see that r385-388 has only been
        merged into the root of the branch, but not any of the root's
        children.  We also see that r380 has only been merged to
        <filename>Makefile</filename>.
        When we use <command>svn mergeinfo</command> with the
        <option>--recursive</option> option to see what has been merged
        from <filename>/calc/trunk</filename> to this branch, we see three
        revisions are flagged with the <literal>*</literal> marker:</para>
      
        <informalexample>
          <screen>
$ svn mergeinfo -R --show-revs=merged ^/calc/trunk .
r354
r380*
r385
r386
r387*
r388*
</screen>
        </informalexample>

      <para>The <literal>*</literal> indicates revisions that are only
        <emphasis>partially</emphasis> merged to the target in question
        (the meaning is the same if we are checking for eligible
        revisions).  What this means in this example is that if we tried
        to merge r380, r387, or r388 from <filename>^/trunk</filename> then
        more changes would result. Likewise, because r354, r385 and r386 are
        <emphasis>not</emphasis> flagged with a <literal>*</literal>,
        we know that re-merging those revisions would have no result.
        <footnote><para>This is a good example of inoperative merge
        revisions.</para></footnote></para>

      <para>Another way to get a more precise preview of a merge
        operation is to use the <option>--dry-run</option>
        option:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk paint-feature-branch --dry-run
--- Merging r290 through r383 into 'paint-feature-branch':
U    paint-feature-branch/src/palettes.c
U    paint-feature-branch/src/brushes.c
U    paint-feature-branch/Makefile

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>
      </informalexample>

      <para>The <option>--dry-run</option> option doesn't actually
        apply any local changes to the working copy.  It shows only
        status codes that <emphasis>would</emphasis> be printed in a
        real merge.  It's useful for getting a <quote>high-level</quote>
        preview of the potential merge, for those times
        when running <command>svn diff</command> gives too much
        detail.</para>

      <tip>
        <para>After performing a merge operation, but before
          committing the results of the merge, you can use
          <userinput>svn diff --depth=empty <replaceable>
          /path/to/merge/target</replaceable></userinput> to see only the
          changes to the immediate target of your merge.  If your merge
          target was a directory, only property differences are displayed.
          This is a handy way to see the changes to the
          <literal>svn:mergeinfo</literal> property recorded by the
          merge operation, which will remind you about what you've
          just merged.</para>
      </tip>

      <para>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <command>svn merge</command>
        isn't an inherently risky thing (unless you've made local
        modifications to your working copy&mdash;but we already
        stressed that you shouldn't merge into such an
        environment).  If you don't like the results of the merge,
        simply run <userinput>svn revert . -R</userinput> to revert
        the changes from your working copy and retry the command with
        different options.  The merge isn't final until you
        actually <command>svn commit</command> the results.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.undo">
      <title>Undoing Changes</title>

      <para>An extremely common use for <command>svn merge</command>
        is to roll back a change that has already been committed.
        Suppose you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made back in revision 392, which changed
        several code files, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference.  (You can do this by
        specifying <option>--revision 392:391</option>, or by an
        equivalent <option>--change -392</option>.)</para>


      <informalexample>
        <screen>
$ svn merge ^/calc/trunk . -c-392
--- Reverse-merging r392 into '.':
U    src/real.c
U    src/main.c
U    src/button.c
U    src/integer.c
--- Recording mergeinfo for reverse merge of r392 into '.':
 U   .

$ svn st
M       src/button.c
M       src/integer.c
M       src/main.c
M       src/real.c

$ svn diff
&hellip;
# verify that the change is removed
&hellip;

$ svn commit -m "Undoing erroneous change committed in r392."
Sending        src/button.c
Sending        src/integer.c
Sending        src/main.c
Sending        src/real.c
Transmitting file data ....
Committed revision 399.
</screen>
      </informalexample>

      <para>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <option>-r</option> option, you can ask <command>svn
        merge</command> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset r392 to our working copy
        <emphasis>backward</emphasis>.</para>

      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>

      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 392.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 392 and
        398, she'll still see the bad change, right?</para>

      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from the <literal>HEAD</literal> revision.  The
        original change still exists in the repository's history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.<footnote><para>The
        Subversion project has plans, however, to someday implement a
        command that would accomplish the task of permanently deleting
        information.  In the meantime, see
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a
        possible workaround.</para></footnote></para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.resurrect">
      <title>Resurrecting Deleted Items</title>

      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote></para>

      <para>The first step is to define
        exactly <emphasis>which</emphasis> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        is defined by a specific coordinate pair.  (Remember the
        <quote>peg revision</quote>
        syntax&mdash;foo.c@224&mdash;mentioned back in
        <xref linkend="svn.advanced.pegrevs"/>.)</para>

      <para>First, you might need to use <command>svn log</command> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <userinput>svn log --verbose</userinput>
        in a directory that used to contain your deleted item.  The
        <option>--verbose</option> (<option>-v</option>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).  If you know that
        the item in question was recently deleted you might also use
        the <option>--limit</option> option to keep the log output brief
        enough to examine manually.</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn log -v --limit 3
------------------------------------------------------------------------
r401 | sally | 2013-02-19 23:15:44 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/main.c

Follow-up to r400: Fix typos in help text.
------------------------------------------------------------------------
r400 | bill | 2013-02-19 20:55:08 -0500 (Tue, 19 Feb 2013) | 4 lines
Changed paths:
   M /calc/trunk/src/main.c
   D /calc/trunk/src/real.c

* calc/trunk/src/main.c: Update help text.

* calc/trunk/src/real.c: Remove this file, none of the APIs
  implemented here are used anymore.
------------------------------------------------------------------------
r399 | sally | 2013-02-19 20:05:14 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/button.c
   M /calc/trunk/src/integer.c
   M /calc/trunk/src/main.c
   M /calc/trunk/src/real.c

Undoing erroneous change committed in r392.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 400.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        399.</para>

      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>

      <para>One option is to use <command>svn merge</command> to apply
        revision 400 <quote>in reverse.</quote> (We already
        discussed how to undo changes in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.)  This
        would have the effect of re-adding <filename>real.c</filename>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <literal>HEAD</literal>.</para>

      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 400 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>main.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 400 and
        then <command>svn revert</command> the local modifications to
        <filename>main.c</filename>, but this technique doesn't
        scale well.  What if 90 files were changed in revision
        400?</para>

      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather to use the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ./real.c
A         real.c

$ svn st
A  +    real.c

# Commit the resurrection.
&hellip;
</screen>
      </informalexample>

      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history.</quote>  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 399.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <emphasis>without</emphasis>
        maintaining a historical link to the old file, this technique
        works just as well:</para>

      <informalexample>
        <screen>
$ svn cat ^/calc/trunk/src/real.c@399 &gt; ./real.c

$ svn add real.c
A         real.c

# Commit the resurrection.
&hellip;
</screen>
      </informalexample>

      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn't
        have to happen in your working copy&mdash;it can happen
        entirely in the repository:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ^/calc/trunk/src/real.c \
           -m "Resurrect real.c from revision 399."

Committed revision 402.

$ svn up
Updating '.':
A    real.c
Updated to revision 402.
</screen>
      </informalexample>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.advanced">
    <title>Advanced Merging</title>

    <para>Here ends the automated magic.  Sooner or later, once you
      get the hang of branching and merging, you're going to have to
      ask Subversion to merge <emphasis>specific</emphasis> changes
      from one place to another.  To do this, you're going to
      have to start passing more complicated arguments to <command>svn
      merge</command>.  The next section describes the fully expanded
      syntax of the command and discusses a number of common
      scenarios that require it.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.cherrypicking">
      <title>Cherrypicking</title>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>cherrypicking</secondary>
        </indexterm>Just as the term <quote>changeset</quote> is often used in
        version control systems, so is the term
        <firstterm>cherrypicking</firstterm>.  This word refers to
        the act of choosing <emphasis>one</emphasis> specific
        changeset from a branch and replicating it to another.
        Cherrypicking may also refer to the act of duplicating a
        particular set of (not necessarily contiguous!) changesets
        from one branch to another.  This is in contrast to more
        typical merging scenarios, where the <quote>next</quote>
        contiguous range of revisions is duplicated
        automatically.</para>

      <para>Why would people want to replicate just a single change?
        It comes up more often than you'd think.  For example, let's
        assume you've created a new feature branch <filename>
        /calc/branches/my-calc-feature-branch</filename> copied from
        <filename>/calc/trunk</filename>:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/new-calc-feature-branch -v -r403
------------------------------------------------------------------------
r403 | user | 2013-02-20 03:26:12 -0500 (Wed, 20 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/new-calc-feature-branch (from /calc/trunk:402)

Create a new calc branch for Feature 'X'.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>At the water cooler, you get word that Sally made an interesting
        change to <filename>main.c</filename> on the trunk.
        Looking over the history of commits to the trunk, you see that
        in revision 413 she fixed a critical bug that directly
        impacts the feature you're working on.  You might not be ready
        to merge all the trunk changes to your branch just yet, but
        you certainly need that particular bug fix in order to continue
        your work.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/trunk -r413 -v
------------------------------------------------------------------------
r413 | sally | 2013-02-21 01:57:51 -0500 (Thu, 21 Feb 2013) | 3 lines
Changed paths:
   M /calc/trunk/src/main.c

Fix issue #22 'Passing a null value in the foo argument
of bar() should be a tolerated, but causes a segfault'.
------------------------------------------------------------------------

$ svn diff ^/calc/trunk -c413
Index: src/main.c
===================================================================
--- src/main.c  (revision 412)
+++ src/main.c  (revision 413)
@@ -34,6 +34,7 @@
&hellip;
# Details of the fix
&hellip;
</screen>
      </informalexample>

      <para>Just as you used <command>svn diff</command> in the prior
        example to examine revision 413, you can pass the same option
        to <command>svn merge</command>:</para>

      <informalexample>
        <screen>
$ cd new-calc-feature-branch

$ svn merge ^/calc/trunk -c413
--- Merging r413 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r413 into '.':
 U   .

$ svn st
 M      .
M       src/main.c
</screen>
      </informalexample>

      <para>You can now go through the usual testing procedures before
        committing this change to your branch.  After the commit,
        Subversion updates the <literal>svn:mergeinfo</literal> on your
        branch to reflect that r413 was been merged to the branch.  This
        prevents future automatic sync merges from attempting to merge
        r413 again.  (Merging the same change to the same branch almost
        always results in a conflict!) Notice also the mergeinfo <literal>
        /calc/branches/my-calc-branch:341-379</literal>.  This was
        recorded during the earlier reintegrate merge to <filename>
        /calc/trunk</filename> from the <filename>
        /calc/branches/my-calc-branch</filename> branch which we made in
        r380.  When we created the <filename>my-calc-branch</filename>
        branch in r403, this mergeinfo was carried along with the copy.
        </para>

      <informalexample>
        <screen>
$ svn pg svn:mergeinfo -v
Properties on '.':
  svn:mergeinfo
    /calc/branches/my-calc-branch:341-379
    /calc/trunk:413
</screen>
      </informalexample>

      <para>Notice too that the <command>mergeinfo</command> doesn't list r413
        as "eligible" to merge, because it's already been merged:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r404
r405
r406
r407
r409
r410
r411
r412
r414
r415
r416
&hellip;
r455
r456
r457
</screen>
      </informalexample>

      <para>The preceding means that when the time finally comes to do an
        automatic sync merge, Subversion breaks the merge into two parts.
        First it merges all eligible merges up to revision 412.  Then it
        merges all eligible revisions from revisions 414 to the <literal>HEAD
        </literal> revision.  Because we already cherrypicked r413, that
        change is skipped:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk
--- Merging r403 through r412 into '.':
U    doc/INSTALL
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
--- Merging r414 through r458 into '.':
G    doc/INSTALL
G    src/main.c
G    src/integer.c
G    Makefile
--- Recording mergeinfo for merge of r403 through r458 into '.':
 U   .
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>backporting</secondary>
        </indexterm>This use case of replicating
        (or <firstterm>backporting</firstterm>) bug fixes from one
        branch to another is perhaps the most popular reason for
        cherrypicking changes; it comes up all the time, for example,
        when a team is maintaining a <quote>release branch</quote> of
        software.  (We discuss this pattern in
        <xref linkend="svn.branchmerge.commonpatterns.release"/>.)</para>

      <warning>
        <para>Did you notice how, in the last example, the merge
          invocation merged two distinct ranges?
          The <command>svn merge</command> command applied
          two independent patches to your working copy to skip over
          changeset 413, which your branch already contained.  There's
          nothing inherently wrong with this, except that it has the
          potential to make conflict resolution trickier.  If the
          first range of changes creates conflicts,
          you <emphasis>must</emphasis> resolve them interactively for
          the merge process to continue and apply the second range of
          changes.  If you postpone a conflict from the first wave of
          changes, the whole merge command will bail out with an error
          message and you must resolve the conflict before running the
          merge a second time to get the remainder of the changes.</para>
      </warning>

      <para>A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in <xref linkend="svn.ref.svn"/> for details, or ask
        <command>svn help</command>.  For example, <command>svn
        merge</command> requires a working copy path as a target, that is,
        a place where it should apply the generated patch.  If the
        target isn't specified, it assumes you are trying to perform
        one of the following common operations:</para>

      <itemizedlist>
        <listitem>
          <para>You want to merge directory changes into your current
            working directory.</para>
        </listitem>
        <listitem>
          <para>You want to merge the changes in a specific file into
            a file by the same name that exists in your current working
            directory.</para>
        </listitem>
      </itemizedlist>

      <para>If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first
        case and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a
        file by the same name) exists in your current working
        directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.advancedsyntax">
      <title>Merge Syntax: Full Disclosure</title>

      <para>You've now seen some examples of the <command>svn
        merge</command> command, and you're about to see several more.
        If you're feeling confused about exactly how merging works,
        you're not alone.  Many users (especially those new to version
        control) are initially perplexed about the proper syntax of
        the command and about how and when the feature should be
        used.  But fear not, this command is actually much simpler
        than you think!  There's a very easy technique for
        understanding exactly how <command>svn merge</command>
        behaves.</para>

      <para>The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that some sort of mysterious
        blending of data is going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>

      <para>If you're using <command>svn merge</command> to do basic
        copying of changes between branches, an automatic merge will
        generally do the right thing.  For example, a command such as the
        following,</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/some-branch
</screen>
      </informalexample>

      <para>will attempt to duplicate any changes made
        on <filename>some-branch</filename> into your current working
        directory, which is presumably a working copy that shares some
        historical connection to the branch.  The command is smart
        enough to only duplicate changes that your working copy
        doesn't yet have.  If you repeat this command once a week, it
        will only duplicate the <quote>newest</quote> branch changes
        that happened since you last merged.</para>

      <para>If you choose to use the <command>svn merge</command>
        command in all its full glory by giving it specific revision
        ranges to duplicate, the command takes three main
        arguments:</para>

      <orderedlist>
        <indexterm>
          <primary>merging</primary>
          <secondary>left side</secondary>
        </indexterm>
        <indexterm>
          <primary>merging</primary>
          <secondary>right side</secondary>
        </indexterm>
        <indexterm>
          <primary>merging</primary>
          <secondary>target</secondary>
        </indexterm>

        <listitem>
          <para>An initial repository tree (often called the
            <firstterm>left side</firstterm> of the comparison)</para>
        </listitem>
        <listitem>
          <para>A final repository tree (often called the
            <firstterm>right side</firstterm> of the
            comparison)</para>
        </listitem>
        <listitem>
          <para>A working copy to accept the differences as local
            changes (often called the <firstterm>target</firstterm> of
            the merge)</para>
        </listitem>
      </orderedlist>

      <para>Once these three arguments are specified, then the two trees
        are compared and the differences applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>

      <para>The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>

      <informalexample>
        <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>
      </informalexample>

      <para>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax is used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.
        <indexterm>
          <primary>merging</primary>
          <secondary>2-URL</secondary>
        </indexterm> This type of merge is referred to (for obvious
        reasons) as a <quote>2-URL</quote> merge. The last syntax shows
        how the working copy argument is optional; if omitted, it
        defaults to the current directory.</para>

      <para>While the first example shows the <quote>full</quote>
        syntax of <command>svn merge</command>, use it
        very carefully;  it can result in merges which do not record
        any <literal>svn:mergeinfo</literal> metadata at all.  The
        next section talks a bit more about this.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.nomergedata">
      <title>Merges Without Mergeinfo</title>

      <para>Subversion tries to generate merge metadata whenever it
        can, to make future invocations of <command>svn
        merge</command> smarter.  There are still situations, however,
        where <literal>svn:mergeinfo</literal> data is not created or
        changed.  Remember to be a bit wary of these scenarios:</para>

      <variablelist>
        <varlistentry>
          <term>Merging unrelated sources</term>
          <listitem>
            <para>If you ask <command>svn merge</command> to compare
              two URLs that aren't related to each other, a patch is
              still generated and applied to your working copy, but
              no merging metadata is created.  There's no common
              history between the two sources, and
              future <quote>smart</quote> merges depend on that common
              history.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Merging from foreign repositories</term>
          <listitem>
            <para>While it's possible to run a command such
              as <userinput>svn merge -r 100:200
              <replaceable>http://svn.foreignproject.com/repos/trunk</replaceable></userinput>,
              the resultant patch also lacks any historical merge
              metadata.  At the time of this writing, Subversion has no
              way of representing different repository URLs within
              the <literal>svn:mergeinfo</literal> property.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Using <option>--ignore-ancestry</option></term>
          <listitem>
            <para>If this option is passed to <command>svn
              merge</command>, it causes the merging logic to
              mindlessly generate differences the same way
              that <command>svn diff</command> does, ignoring any
              historical relationships.  We discuss this later in this
              chapter in
              <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Applying reverse merges from a target's natural history</term>
          <listitem>
            <para>Earlier in this chapter
              (<xref linkend="svn.branchmerge.basicmerging.undo"/>) we
              discussed how to use <command>svn merge</command> to
              apply a <quote>reverse patch</quote> as a way of rolling
              back changes.  If this technique is used to undo a
              change to an object's personal history (e.g., commit r5
              to the trunk, then immediately roll back r5
              using <userinput>svn merge . -c -5</userinput>), this
              sort of merge doesn't affect the recorded
              mergeinfo.<footnote><para>Interestingly, after rolling
              back a revision like this, we wouldn't be able to
              reapply the revision using <userinput>svn merge . -c
              5</userinput>, since the mergeinfo would already list r5
              as being applied.  We would have to use
              the <option>--ignore-ancestry</option> option to make
              the merge command ignore the existing
              mergeinfo!</para></footnote></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <!-- TODO: We might need to introduce a glossary of merge
                 tracking terms into this chapter.  Here we use
                 "mergeinfo" to help defined "natural history", but
                 we've not really defined "mergeinfo" either.  -->

      <sidebar id="svn.branchmerge.nomergedata.impicit.mergeinfo">
        <title>Natural History and Implicit Mergeinfo</title>

        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>implicit</secondary>
          </indexterm>
          <indexterm>
            <primary>natural history</primary>
            <see>mergeinfo, implicit</see>
          </indexterm>As we mentioned earlier when discussing
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>,
          a path that has the
          <literal>svn:mergeinfo</literal> property set on it is said to
          have <quote>explicit</quote> mergeinfo.  Yes, this implies a
          path can have <quote>implicit</quote> mergeinfo, too!  Implicit
          mergeinfo, or <firstterm>natural history</firstterm>, is
          simply a path's own history (see
          <xref linkend="svn.tour.history" />) interpreted as mergeinfo.
          While implicit mergeinfo is largely
          an implementation detail, it can be a useful abstraction for
          understanding merge tracking behavior.</para>

        <para>Let's say you created <filename>^/trunk</filename> in
          revision 100 and then later, in revision 201,
          created <filename>^/branches/feature-branch</filename> as
          a copy of <filename>^/trunk@200</filename>.  The natural
          history of <filename>^/branches/feature-branch</filename>
          contains all the repository paths and revision ranges
          through which the history of the new branch has ever
          passed:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201
</literallayout>
        </informalexample>

        <para>With each new revision added to the repository, the
          natural history&mdash;and thus, implicit mergeinfo&mdash;of
          the branch continues to expand to include those revisions
          until the day the branch is deleted.  Here's what the
          implicit mergeinfo of our branch would look like when
          the <literal>HEAD</literal> revision of the repository had
          grown to 234:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201-234
</literallayout>
        </informalexample>

        <para>Implicit mergeinfo does not actually show up in the
          <literal>svn:mergeinfo</literal> property, but Subversion
          acts as if it does.  This is why if you check out
          <filename>^/branches/feature-branch</filename> and then
          run <userinput>svn merge ^/trunk -c 58</userinput> in the
          resulting working copy, nothing happens.  Subversion knows
          that the changes committed to <filename>^/trunk</filename>
          in revision 58 are already present in the target's natural
          history, so there's no need to try to merge them again.
          After all, avoiding repeated merges of
          changes <emphasis>is</emphasis> the primary goal of
          Subversion's merge tracking feature!</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.mergeconflicts">
      <title>More on Merge Conflicts</title>

      <para>Just like the <command>svn update</command> command,
        <command>svn merge</command> applies changes to your working
        copy.  And therefore it's also capable of creating
        conflicts.  The conflicts produced by <command>svn
          merge</command>, however, are sometimes different, and this
        section explains those differences.</para>

      <para>To begin with, assume that your working copy has no
        local edits.  When you <command>svn update</command> to a
        particular revision, the changes sent by the server
        always apply <quote>cleanly</quote> to your working copy.
        The server produces the delta by comparing two trees: a
        virtual snapshot of your working copy, and the revision tree
        you're interested in.  Because the left hand side of the
        comparison is exactly equal to what you already have, the
        delta is guaranteed to correctly convert your working copy
        into the right hand tree.</para>

      <para>But <command>svn merge</command> has no such guarantees
        and can be much more chaotic: the advanced user can ask the
        server to compare <emphasis>any</emphasis> two trees at all,
        even ones that are unrelated to the working copy!  This means
        there's large potential for human error.  Users will sometimes
        compare the wrong two trees, creating a delta that doesn't
        apply cleanly. The <command>svn merge</command> subcommand does
        its best to apply as much of the delta as possible, but some
        parts may be impossible. A common sign that you merged the wrong
        delta is unexpected tree conflicts:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk -r104:115
--- Merging r105 through r115 into '.':
   C doc
   C src/button.c
   C src/integer.c
   C src/real.c
   C src/main.c
--- Recording mergeinfo for merge of r105 through r115 into '.':
 U   .
Summary of conflicts:
  Tree conflicts: 5

$ svn st
 M      .
!     C doc
      >   local dir missing, incoming dir edit upon merge
!     C src/button.c
      >   local file missing, incoming file edit upon merge
!     C src/integer.c
      >   local file missing, incoming file edit upon merge
!     C src/main.c
      >   local file missing, incoming file edit upon merge
!     C src/real.c
      >   local file missing, incoming file edit upon merge
Summary of conflicts:
  Tree conflicts: 5
</screen>
      </informalexample>

      <para>In the previous example, it might be the case that
        <filename>doc</filename> and the four <filename>*.c</filename>
        files all exist in both snapshots of the
        branch being compared.  The resultant delta wants to change
        the contents of the corresponding paths in your working copy,
        but those paths don't exist in the working copy.  Whatever the
        case, the preponderance of tree conflicts most likely means that
        the user compared the wrong two trees or that you are merging to
        the wrong working copy target; both are classic signs of user
        error.  When this happens, it's easy to recursively revert all
        the changes created by the merge
        (<userinput>svn revert . --recursive</userinput>), delete any
        unversioned files or directories left behind after the
        revert, and rerun <command>svn merge</command> with the
        correct arguments.</para>

      <para>Also keep in mind that a merge into a working copy with no
        local edits can still produce text conflicts.</para>

      <informalexample>
        <screen>
$ svn st

$ svn merge ^/paint/trunk -r289:291
--- Merging r290 through r291 into '.':
C    Makefile
--- Recording mergeinfo for merge of r290 through r291 into '.':
 U   .
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'Makefile'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: p

$ svn st
 M      .
C       Makefile
?       Makefile.merge-left.r289
?       Makefile.merge-right.r291
?       Makefile.working
Summary of conflicts:
  Text conflicts: 1
</screen>
      </informalexample>

      <para>How can a conflict possibly happen?  Again, because the user
        can request <command>svn merge</command> to define and apply any
        old delta to the working copy, that delta may contain textual
        changes that don't cleanly apply to a working file, even if
        the file has no local modifications.</para>

      <para>Another small difference between <command>svn
        update</command> and <command>svn merge</command> is the names
        of the full-text files created when a conflict happens.  In
        <xref linkend="svn.tour.cycle.resolve"/>, we saw that an
        update produces files named
        <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename>, and
        <filename>filename.rNEWREV</filename>.  When <command>svn
        merge</command> produces a conflict, though, it creates three
        files named <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename>, and
        <filename>filename.merge-right.rNEWREV</filename>.  In this case,
        the terms <quote>merge-left</quote> and <quote>merge-right</quote>
        are describing which side of the double-tree comparison the file
        came from, <quote>rOLDREV</quote> describes the revision of the
        left side, and <quote>rNEWREV</quote> the revision of the right
        side. In any case, these differing names help you distinguish
        between conflicts that happened as a result of an  update and
        ones that happened as a result of a merge.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.blockchanges">
      <title>Blocking Changes</title>

      <para>Sometimes there's a particular changeset that you don't
        want automatically merged.  For example, perhaps your
        team's policy is to do new development work on
        <filename>/trunk</filename>, but is more conservative about
        backporting changes to a stable branch you use for releasing
        to the public.  On one extreme, you can manually cherrypick
        single changesets from the trunk to the branch&mdash;just the
        changes that are stable enough to pass muster.  Maybe things
        aren't quite that strict, though; perhaps most of the time
        you just let <command>svn merge</command>
        automatically merge most changes from trunk to branch.  In
        this case, you want a way to mask a few specific changes
        out, that is, prevent them from ever being automatically
        merged.</para>

      <para>To block a changeset you must make Subversion believe that the
        change has <emphasis>already</emphasis> been merged.  To do this,
        invoke the merge subcommand with the <option>--record-only</option>
        option.  The option makes Subversion record mergeinfo as if it had
        actually performed the merge, but no difference is actually
        applied:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn merge ^/calc/trunk -r386:388 --record-only
--- Recording mergeinfo for merge of r387 through r388 into '.':
 U   .

# Only the mergeinfo is changed
$ svn st
 M      .

$ svn pg svn:mergeinfo -vR
Properties on '.':
  svn:mergeinfo
    /calc/trunk:341-378,387-388

$ svn commit -m "Block r387-388 from being merged to my-calc-branch."
Sending        .

Committed revision 461.
</screen>
      </informalexample>

      <para>Since Subversion 1.7, <option>--record-only</option>
        merges are transitive.  This means that, in addition to recording
        mergeinfo describing the blocked revision(s), any
        <literal>svn:mergeinfo</literal> property differences in the
        merge source are also applied.  For example, let's say we want to
        block the 'paint-python-wrapper' feature from ever being merged from
        <filename>^/paint/trunk</filename> to the
        <filename>^/paint/branches/paint-1.0.x</filename> branch.  We know
        the work on this feature was done on its own branch, which was
        reintegrated to <filename>/paint/trunk</filename> in revision
        465:</para>
      
      <informalexample>
        <screen>
$ svn log -v -r465 ^/paint/trunk
------------------------------------------------------------------------
r465 | joe | 2013-02-25 14:05:12 -0500 (Mon, 25 Feb 2013) | 1 line
Changed paths:
   M /paint/trunk
   A /paint/trunk/python (from /paint/branches/paint-python-wrapper/python:464)

Reintegrate Paint Python wrapper.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Because revision 465 was a reintegrate merge we know
        that mergeinfo was recorded describing the merge:</para>

      <informalexample>
        <screen>
$ svn diff ^/paint/trunk --depth empty -c465
Index: .
===================================================================
--- .   (revision 464)
+++ .   (revision 465)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
</screen>
      </informalexample>

      <para>Now simply blocking merges of revision 465 from
        <filename>/paint/trunk</filename> isn't foolproof since someone could
        merge r462:464 directly from
        <filename>/paint/branches/paint-python-wrapper</filename>.
        Fortunately the transitive nature
        of <option>--record-only</option> merges prevents this; the
        <option>--record-only</option> merge
        applies the <literal>svn:mergeinfo</literal> diff from
        revision 465, thus blocking merges of that change directly from
        <filename>/paint/trunk</filename> <emphasis>and</emphasis> indirectly
        from <filename>/paint/branches/paint-python-wrapper</filename>:
        </para>

      <informalexample>
        <screen>
$ cd paint/branches/paint-1.0.x

$ svn merge ^/paint/trunk --record-only -c465
--- Merging r465 into '.':
 U   .
--- Recording mergeinfo for merge of r465 into '.':
 G   .

$ svn diff --depth empty
Index: .
===================================================================
--- .   (revision 462)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
   Merged /paint/trunk:r465

$ svn ci -m "Block the Python wrappers from the first release of paint."
Sending        .

Committed revision 466.
</screen>
      </informalexample>

      <para>Now any subsequent attempts to merge the feature to <filename>
        /paint/trunk</filename> are inoperative:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465
--- Recording mergeinfo for merge of r465 into '.':
 U   .

$ svn st # No change!

$ svn merge ^/paint/branches/paint-python-wrapper -r462:464
--- Recording mergeinfo for merge of r463 through r464 into '.':
 U   .

$ svn st  # No change!

$
</screen>
      </informalexample>

      <para>If at a later time you realize that you actually <emphasis>do
        </emphasis> need the blocked feature merged to <filename>/paint/trunk
        </filename> you have a couple of choices.  You can reverse merge r466,
        (the revision you blocked the feature), as we discussed in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.  Once you commit
        that change you can repeat the merge of r465 from <filename>
        /paint/trunk</filename>.  Alternatively, you can simply repeat the
        merge of r465 from <filename>/paint/trunk</filename> using the
        <option>--ignore-ancestry</option> option, which will cause the merge
        to disregard any mergeinfo and simply apply the requested diff, see
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465 --ignore-ancestry
--- Merging r465 into '.':
A    python
A    python/paint.py
 G   .
</screen>
      </informalexample>

      <para>Blocking changes with <option>--record-only</option>
        works, but it's also a little bit
        dangerous.  The main problem is that we're not clearly
        differentiating between the ideas of <quote>I already have
        this change</quote> and <quote>I don't have this change, but
        don't currently want it.</quote> We're effectively lying to
        the system, making it think that the change was previously
        merged.  This puts the responsibility on you&mdash;the
        user&mdash;to remember that the change wasn't actually merged,
        it just wasn't wanted.  There's no way to ask Subversion for a
        list of <quote>blocked changelists.</quote> If you want to
        track them (so that you can unblock them someday) you'll need
        to record them in a text file somewhere, or perhaps in an
        invented property.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.logblame">
      <title>Merge-Sensitive Logs and Annotations</title>

      <para>One of the main features of any version control system is
        to keep track of who changed what, and when they did it.
        The <command>svn log</command> and <command>svn
        blame</command> subcommands are just the tools for this: when
        invoked on individual files, they show not only the history of
        changesets that affected the file, but also exactly which user
        wrote which line of code, and when she did it.</para>

      <para>When changes start getting replicated between branches,
        however, things start to get complicated.  For example, if you
        were to ask <command>svn log</command> about the history of
        your feature branch, it would show exactly every revision that ever
        affected the branch:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn log -q
------------------------------------------------------------------------
r461 | user | 2013-02-25 05:57:48 -0500 (Mon, 25 Feb 2013)
------------------------------------------------------------------------
r379 | user | 2013-02-18 10:56:35 -0500 (Mon, 18 Feb 2013)
------------------------------------------------------------------------
r378 | user | 2013-02-18 09:48:28 -0500 (Mon, 18 Feb 2013)
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
r7 | bill | 2013-01-17 16:49:36 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
r3 | bill | 2013-01-17 09:07:04 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>But is this really an accurate picture of all the changes
        that happened on the branch?  What's left out here is
        the fact that revisions 352, 362, 372 and 379 were actually the
        results of merging changes from the trunk.  If you look at one
        of these logs in detail, the multiple trunk changesets that
        comprised the branch change are nowhere to be seen:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v
------------------------------------------------------------------------
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>We happen to know that this merge to the branch was
        nothing but a merge of trunk changes.  How can we see those
        trunk changes as well?  The answer is to use the
        <option>--use-merge-history</option> (<option>-g</option>)
        option.  This option expands those <quote>child</quote>
        changes that were part of the merge.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v -g
------------------------------------------------------------------------
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
------------------------------------------------------------------------
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/real.c
Merged via: r352

Trunk work on calc project.
------------------------------------------------------------------------
&hellip;
------------------------------------------------------------------------
r345 | sally | 2013-02-15 16:51:17 -0500 (Fri, 15 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/Makefile
   M /calc/trunk/src/integer.c
Merged via: r352

Trunk work on calc project.
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c
Merged via: r352

Refactor the bazzle functions.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>By making the log operation use merge history, we see not
        just the revision we queried (r352), but also the other revisions
        that came along on the ride with it&mdash;Sally's work on trunk.
        This is a much more complete picture of history!</para>

      <para>The <command>svn blame</command> command also takes the
        <option>--use-merge-history</option> (<option>-g</option>)
        option.  If this option is neglected, somebody looking at
        a line-by-line annotation of <filename>src/button.c</filename> may
        get the mistaken impression that you were responsible for a
        particular change:</para>

      <informalexample>
        <screen>
$ svn blame src/button.c
&hellip;
   352    user    retval = inverse_func(button, path);
   352    user    return retval;
   352    user    }
&hellip;
</screen>
      </informalexample>

      <para>And while it's true that you did actually commit those
        three lines in revision 352, two of them were actually written
        by Sally back in revision 348 and were brought into your branch
        via a sync merge:</para>

      <informalexample>
        <screen>
$ svn blame button.c -g
&hellip;
G    348    sally   retval = inverse_func(button, path);
G    348    sally   return retval;
     352    user    }
&hellip;
</screen>
      </informalexample>

      <para>Now we know who to <emphasis>really</emphasis> blame for
        those two lines of code!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.ancestry">
      <title>Noticing or Ignoring Ancestry</title>

      <para>
        <indexterm>
          <primary>ancestry</primary>
        </indexterm>When conversing with a Subversion developer, you
        might very likely hear reference to the term
        <firstterm>ancestry</firstterm>.  This word is used to
        describe the relationship between two objects in a
        repository: if they're related to each other, one
        object is said to be an ancestor of the other.</para>

      <para>For example, suppose you commit revision 100, which
        includes a change to a file <filename>foo.c</filename>.
        Then <filename>foo.c@99</filename> is an
        <quote>ancestor</quote> of <filename>foo.c@100</filename>.
        On the other hand, suppose you commit the deletion of
        <filename>foo.c</filename> in revision 101, and then add a
        new file by the same name in revision 102.  In this case,
        <filename>foo.c@99</filename> and
        <filename>foo.c@102</filename> may appear to be related
        (they have the same path), but in fact are completely
        different objects in the repository.  They share no history
        or <quote>ancestry.</quote></para>

      <para>The reason for bringing this up is to point out an
        important difference between <command>svn diff</command> and
        <command>svn merge</command>.  The former command ignores
        ancestry, while the latter command is quite sensitive to it.
        For example, if you asked <command>svn diff</command> to
        compare revisions 99 and 102 of <filename>foo.c</filename>,
        you would see line-based diffs; the <command>diff</command>
        command is blindly comparing two paths.  But if you asked
        <command>svn merge</command> to compare the same two objects,
        it would notice that they're unrelated and first attempt to
        delete the old file, then add the new file;  the output would
        indicate a deletion followed by an add:</para>

      <informalexample>
        <screen>
D    foo.c
A    foo.c
</screen>
      </informalexample>

      <para>Most merges involve comparing trees that are ancestrally
        related to one another; therefore, <command>svn
        merge</command> defaults to this behavior.  Occasionally,
        however, you may want the <command>merge</command> command to
        compare two unrelated trees.  For example, you may have
        imported two source-code trees representing different vendor
        releases of a software project (see
        <xref linkend="svn.advanced.vendorbr"/>).  If you ask
        <command>svn merge</command> to compare the two trees, you'd
        see the entire first tree being deleted, followed by an add
        of the entire second tree!  In these situations, you'll want
        <command>svn merge</command> to do a path-based comparison
        only, ignoring any relations between files and directories.
        Add the <option>--ignore-ancestry</option> option to your
        <command>merge</command> command, and it will behave just
        like <command>svn diff</command>.  (And conversely, the
        <option>--notice-ancestry</option> option will cause
        <command>svn diff</command> to behave like the
        <command>svn merge</command> command.)</para>

      <tip>
        <para>
        <indexterm>
          <primary>merge tracking</primary>
          <secondary>disabling</secondary>
        </indexterm>
        The <option>--ignore-ancestry</option> option also disables
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This means that <literal>svn:mergeinfo</literal> is not considered
        when <command>svn merge</command> is determining what revisions
        to merge, nor is <literal>svn:mergeinfo</literal> recorded to
        describe the merge.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.moves">
      <title>Merges and Moves</title>

      <para>A common desire is to refactor source code, especially
        in Java-based software projects.  Files and directories are
        shuffled around and renamed, often causing great disruption
        to everyone working on the project.  Sounds like a perfect
        case to use a branch, doesn't it?  Just create a branch,
        shuffle things around, and then merge the branch back to the
        trunk, right?</para>

      <para>Alas, this scenario doesn't work so well right now and
        is considered one of Subversion's current weak spots.  The
        problem is that Subversion's <command>svn merge</command>
        command isn't as robust as it should be, particularly when
        dealing with copy and move operations.</para>

      <para>When you use <command>svn copy</command> to duplicate a
        file, the repository remembers where the new file came from,
        but it fails to transmit that information to the client which
        is running <command>svn update</command> or <command>svn
        merge</command>.  Instead of telling the client, <quote>Copy
        that file you already have to this new location,</quote> it
        sends down an entirely new file.  This can lead to
        problems, particularly tree conflicts in the case of renames,
        which involve not only the new copy, but a deletion of the old
        path&mdash;a lesser-known fact about Subversion is that
        it lacks <quote>true renames</quote>&mdash;the <command>svn
        move</command> command is nothing more than an aggregation
        of <command>svn copy</command> and <command>svn
        delete</command>.</para>

      <para>For example, suppose that you want to make some changes on
        your private branch <filename>/calc/branch/my-calc-branch
        </filename>.  First you perform an automatic sync merge with
        <filename>/calc/trunk</filename> and commit that in r470:</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn merge ^/calc/trunk
--- Merging differences between repository URLs into '.':
U    doc/INSTALL
A    FAQ
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
 U   .
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .

$ svn ci -m "Sync all changes from ^/calc/trunk through r469."
Sending        .
Sending        Makefile
Sending        README
Sending        FAQ
Sending        doc/INSTALL
Sending        src/main.c
Sending        src/button.c
Sending        src/integer.c
Transmitting file data ....
Committed revision 470.
</screen>
      </informalexample>

      <para>Then you rename <filename>integer.c</filename> to <filename>
        whole.c</filename> in r471 and then make some edits to the same
        file in r473.  Effectively you've created a new file in your branch
        (that is a copy of the original file plus some edits) and deleted
        the original file.  Meanwhile, back on <filename>/calc/trunk
        </filename>, Sally has committed some improvements of her own to
        <filename>integer.c</filename> in r472:</para>

      <informalexample>
        <screen>
$ svn log -v -r472 ^/calc/trunk
------------------------------------------------------------------------
r472 | sally | 2013-02-26 07:05:18 -0500 (Tue, 26 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Trunk work on integer.c.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Now you decide to merge your branch back to the trunk.
        How will Subversion combine the rename and edits you made
        with Sally's edits?</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
   C src/integer.c
 U   src/real.c
A    src/whole.c
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .
Summary of conflicts:
  Tree conflicts: 1

$ svn st
 M      .
      C src/integer.c
      >   local file edit, incoming file delete upon merge
 M      src/real.c
A  +    src/whole.c
Summary of conflicts:
  Tree conflicts: 1
</screen>
      </informalexample>

      <para>The answer is that Subversion <emphasis>won't</emphasis>
        combine those changes, but rather raises a tree conflict<footnote>
        <para>If Sally hadn't made her change in r472, then Subversion would
        notice that <filename>integer.c</filename> in the
        target working copy is identical to <filename>integer.c</filename>
        in the left-side of the merge and would allow your rename to
        succeed without a tree conflict:</para>
        <informalexample>
          <screen>
$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
 U   src/real.c
A    src/whole.c
D    src/integer.c
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .
</screen>
      </informalexample></footnote>because it needs your help
        to figure out what part of your changes and what part of Sally's
        changes should ultimately end up in <filename>whole.c</filename>
        or even if the rename should take place at all!</para>

      <para>You will need to resolve this tree conflict before committing
        the merge and this may require some manual intervention on your
        part, see <xref linkend="svn.tour.treeconflicts"/>.  The moral of
        this story is that until Subversion improves, be careful about
        merging copies and renames from one branch to another and when you
        do, be prepared for some manual resolution.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.pre1.5clients">
      <title>Blocking Merge Tracking Unaware Clients</title>

      <para>If you've just upgraded your server to Subversion 1.5 or
        later, there's a risk that pre-1.5 Subversion
        clients can cause problems with
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This is because pre-1.5 clients don't support this feature;
        when one of these older clients performs <command>svn
        merge</command>, it doesn't modify the value of
        the <literal>svn:mergeinfo</literal> property at all.  So the
        subsequent commit, despite being the result of a merge,
        doesn't tell the repository about the duplicated
        changes&mdash;that information is lost.  Later on,
        when <quote>merge-aware</quote> clients attempt automatic
        merging, they're likely to run into all sorts of conflicts
        resulting from repeated merges.</para>

      <para>If you and your team are relying on the merge-tracking
        features of Subversion, you may want to configure your
        repository to prevent older clients from committing changes.
        The easy way to do this is by inspecting
        the <quote>capabilities</quote> parameter in
        the <literal>start-commit</literal> hook script.  If the
        client reports itself as having <literal>mergeinfo</literal>
        capabilities, the hook script can allow the commit to start.
        If the client doesn't report that capability, have the hook
        deny the commit.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> gives an
        example of such a hook script:</para>

      <example id="svn.branchmerge.advanced.hook-ex1">
        <title>Merge-tracking gatekeeper start-commit hook script</title>

        <programlisting>
#!/usr/bin/env python
import sys

# The start-commit hook is invoked immediately after a Subversion txn is
# created and populated with initial revprops in the process of doing a
# commit. Subversion runs this hook by invoking a program (script, 
# executable, binary, etc.) named 'start-commit' (for which this file
# is a template) with the following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] USER         (the authenticated user attempting to commit)
#   [3] CAPABILITIES (a colon-separated list of capabilities reported
#                     by the client; see note below)
#   [4] TXN-NAME     (the name of the commit txn just created)

capabilities = sys.argv[3].split(':')
if "mergeinfo" not in capabilities:
  sys.stderr.write("Commits from merge-tracking-unaware clients are "
                   "not permitted.  Please upgrade to Subversion 1.5 "
                   "or newer.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>

      <para>For more information about hook scripts, see
        <xref linkend="svn.reposadmin.hooks" />.</para>

    </sect2>
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.finalword">
      <title>The Final Word on Merge Tracking</title>

      <para>The bottom line is that Subversion's merge-tracking
        feature has an complex internal implementation, and
        the <literal>svn:mergeinfo</literal> property is the only
        window the user has into the machinery.</para>

      <para>How and when mergeinfo is recorded by a merge can sometimes
        be difficult to understand.  Furthermore, the management of
        mergeinfo metadata has a whole set of taxonomies and behaviors
        around it, such as <quote>explicit</quote> versus <quote>implicit
        </quote> mergeinfo, <quote>operative</quote>
        versus <quote>inoperative</quote> revisions, specific
        mechanisms of mergeinfo <quote>elision,</quote> and
        even <quote>inheritance</quote> from parent to child
        directories.</para>

      <para>We've chosen to only briefly cover, if at all, these detailed
        topics for a couple of reasons.  First, the level of detail is
        overwhelming for a typical user.  Second, and more
        importantly, the typical user <emphasis>doesn't</emphasis> need
        to understand these concepts; typically they remain in the
        background as implementation details.  All that said, if you
        enjoy this sort of thing, you can get a fantastic overview in a
        paper posted at CollabNet's website: <ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>

      <para>For now, if you want to steer clear of the complexities of
        merge tracking, we recommend that you follow these simple best
        practices:</para>

      <itemizedlist>
        <listitem>
          <para>For short-term feature branches, follow the simple
            procedure described throughout
            <xref linkend="svn.branchmerge.basicmerging"/>.</para>
        </listitem>
        <listitem>
          <para>Avoid subtree merges and subtree mergeinfo. Perform
            merges only on the root of your branches, not on
            subdirectories or files (see <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>)
            .</para>
        </listitem>
        <listitem>
          <para>Don't ever edit the <literal>svn:mergeinfo</literal>
            property directly; use <command>svn
            merge</command> with the <option>--record-only</option> option
            to effect a desired change to the metadata (as demonstrated in
            <xref linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
        </listitem>
        <listitem>
          <para>Your merge target should be a working copy which
            represents the root of a <emphasis>complete</emphasis> tree
            representing a <emphasis>single</emphasis> location in the
            repository at a single point in time:
            <itemizedlist>
              <listitem>
                <para>Update before you merge!  Don't use the <option>
                --allow-mixed-revisions</option> option to merge into
                mixed-revision working copies.</para>
              </listitem>
              <listitem>
                <para>Don't merge to targets with <quote>switched</quote>
                subdirectories (as described next in
                <xref linkend="svn.branchmerge.switchwc"/>).</para>
              </listitem>
              <listitem>
                <para>Avoid merges to targets with sparse directories.
                  Likewise, don't merge to depths other than
                  <option>--depth=infinity</option></para>
              </listitem>
              <listitem>
                <para>Be sure you have read access to all of the merge
                  source and read/write access to all of the merge
                  target.</para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>

      <para>Of course sometimes you may need to violate some of these
        best practices.  Don't worry if you need to, just be sure you
        understand the ramifications of doing so.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
    <title>Traversing Branches</title>

    <para>The <command>svn switch</command> command transforms an
      existing working copy to reflect a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut.  In one of our earlier examples,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>

    <informalexample>
      <screen>
$ cd calc
$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk
Relative URL: ^/calc/trunk
$ svn switch ^/calc/branches/my-calc-branch
U    integer.c
U    button.c
U    Makefile
Updated to revision 341.
$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
Relative URL: ^/calc/branches/my-calc-branch
$
</screen>
    </informalexample>

    <para><quote>Switching</quote> a working copy that has no local
      modifications to a different branch results in the working copy
      looking just as it would if you'd done a fresh checkout of the
      directory.  It's usually more efficient to
      use this command, because often branches differ by only a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>

    <para>The <command>svn switch</command> command also takes a
      <option>--revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the
      <literal>HEAD</literal> of the branch.</para>

    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, and contain multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>

    <orderedlist>
      <listitem>
        <para>Copy the project's entire <quote>trunk</quote> to a new
          branch directory.</para>
      </listitem>
      <listitem>
        <para>Switch only <emphasis>part</emphasis> of the trunk
          working copy to mirror the branch.</para>
      </listitem>
    </orderedlist>

    <para>In other words, if a user knows that the branch work needs
      to happen on only a specific subdirectory, she uses
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, the user can continue to
      receive normal <quote>trunk</quote> updates to most of her
      working copy, but the switched portions will remain immune
      (unless someone commits a change to her branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote>&mdash;not only can working copies contain a
      mixture of working revisions, but they can also contain a
      mixture of repository locations as well.</para>

    <tip>
      <para>Typically switched subdirectories share common ancestry with
        the location which is switched <quote>away</quote> from.  However
        <command>svn switch</command> can switch a subdirectory to mirror
        a repository location which it shares no common ancestry with.
        To do this you need to use the
        <option>--ignore-ancestry</option> option.
    </para>
    </tip>

    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes are still
      applied as a single, atomic change to the repository.</para>

    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that feature is planned for the
      future.<footnote><para>You <emphasis>can</emphasis>, however,
      use <command>svn relocate</command> if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See <xref linkend="svn.ref.svn.c.relocate"/> in
      <xref linkend="svn.ref.svn"/> for more information and an
      example.</para></footnote></para>

    <tip>
      <para>Administrators who need to change the URL of a repository
        which is accessed via HTTP are encouraged to add to
        their <filename>httpd.conf</filename> configuration file a
        permanent redirect from the old URL location to the new one
        (via the <literal>RedirectPermanent</literal> directive).
        Subversion clients will generally display the new repository
        URL in error messages generated when the user attempts to use
        working copies which still reflect the old URL location.  Since
        Subversion 1.7 clients will go a step further,
        automatically relocating the working copy to the new
        URL.</para>
    </tip>

    <sidebar>
      <title>Switches and Updates</title>

      <para>Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> looks the
        same?  The switch command is actually a superset of the update
        command.</para>

      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        latter command always compares two identical repository
        paths.</para>

      <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch directory in the
        <literal>HEAD</literal> revision.</para>

      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
    </sidebar>

    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.</para>

    <tip>
      <para>Have you ever found yourself making some complex edits (in
        your <filename>/trunk</filename> working copy) and suddenly
        realized, <quote>Hey, these changes ought to be in their own
        branch?</quote> There is a great two step technique to do
        this:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \
           -m "Create branch 'newbranch'."
Committed revision 353.
$ svn switch ^/calc/branches/newbranch
At revision 353.
</screen>
      </informalexample>

      <para>The <command>svn switch</command> command, like
        <command>svn update</command>, preserves your local edits.  At
        this point, your working copy is now a reflection of the newly
        created branch, and your next <command>svn commit</command>
        invocation will send your changes there.</para>
    </tip>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
    <title>Tags</title>

    <para>
      <indexterm>
        <primary>tags</primary>
      </indexterm>
      Another common version control concept is a tag.  A tag is
      just a <quote>snapshot</quote> of a project in time.  In
      Subversion, this idea already seems to be everywhere.  Each
      repository revision is exactly that&mdash;a snapshot of the
      filesystem after each commit.</para>

    <para>However, people often want to give more human-friendly names
      to tags, such as <literal>release-1.0</literal>.  And they want
      to make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release 1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <title>Creating a Simple Tag</title>

      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, make a copy of it:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
           -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 902.
</screen>
      </informalexample>

      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If
        it doesn't, you can create it using <command>svn
        mkdir</command>.)  After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the <filename>/trunk</filename> directory
        looked in the <literal>HEAD</literal> revision at the time you
        made the copy.  Of course, you might want to be more precise
        about exactly which revision you copy, in case somebody else
        may have committed changes to the project when you weren't
        looking.  So if you know that revision 901 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 901</option> to
        the <command>svn copy</command> command.</para>

      <para>But wait a moment: isn't this tag creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>

      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy.  (That is, make sure
        they know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags area (see
        <xref linkend="svn.serverconfig"/>).  The paranoid approach,
        however, isn't usually necessary.  If a user accidentally
        commits a change to a tag directory, you can simply undo the
        change as discussed in the previous section.  This is version
        control, after all!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <title>Creating a Complex Tag</title>

      <para>Sometimes you may want a <quote>snapshot</quote> that is
        more complicated than a single directory at a single
        revision.</para>

      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn
        update</command> with the <option>-r</option> option
        liberally), by switching files and directories to particular
        branches (making use of <command>svn switch</command>), or
        even just by making a bunch of local changes.  When you're
        done, your working copy is a hodgepodge of repository
        locations from different revisions.  But after testing, you
        know it's the precise combination of data you need to
        tag.</para>

      <para>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (see <xref linkend="svn.ref.svn.c.copy"/> in <xref
        linkend="svn.ref.svn"/>), including the ability to copy a
        working copy tree to the repository:</para>

      <informalexample>
        <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \
           -m "Tag my existing working copy state."

Committed revision 940.
</screen>
      </informalexample>

      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, URLs,
        local changes, and all.</para>

      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        directory or symlink changes), you can
        use <command>svn copy</command> to <quote>upload</quote> your
        working copy to a private area of the repository.  Your
        collaborator can then either check out a verbatim copy of your
        working copy or use <command>svn merge</command> to receive
        your exact changes.</para>

      <para>While this is a nice method for uploading a quick snapshot
        of your working copy, note that this is <emphasis>not</emphasis>
        a good way to initially create a branch.  Branch creation should
        be an event unto itself, and this method conflates the creation
        of a branch with extra changes to files, all within a single revision.
        This makes it very difficult (later on) to identify a single
        revision number as a branch point.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
    <title>Branch Maintenance</title>

    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <title>Repository Layout</title>

      <para>There are some standard, recommended ways to organize the
        contents of a repository.  Most people create a
        <filename>trunk</filename> directory to hold the <quote>main
        line</quote> of development, a <filename>branches</filename>
        directory to contain branch copies, and
        a <filename>tags</filename> directory to contain tag copies.
        If a repository holds only one project, often people create
        these top-level directories:</para>

      <informalexample>
        <literallayout>
/
   trunk/
   branches/
   tags/
</literallayout>
      </informalexample>

      <para>If a repository contains multiple projects, admins
        typically index their layout by project.  See <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>, but here's an example of such a
        layout:</para>

      <informalexample>
        <literallayout>
/
   paint/
      trunk/
      branches/
      tags/
   calc/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>

      <para>Remember, though, that while moving directories is
        easy to do, you need to be considerate of other users as well.
        Your juggling can disorient users with existing
        working copies.  If a user has a working copy of a particular
        repository directory and your <command>svn move</command>
        subcommand removes the path from the latest revision, then
        when the user next runs <command>svn update</command>, she is
        told that her working copy represents a path that no
        longer exists.  She is then forced to <command>svn
        switch</command> to the new location.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <title>Data Lifetimes</title>

      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>

      <informalexample>
        <screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 474.
</screen>
      </informalexample>

      <tip>
        <para>Recall from the previous section that if the repository
          location your working copy refers to is deleted, then when
          you try to update you will receive an error:</para>
        <informalexample>
          <screen>
$ svn up
Updating '.':
svn: E160005: Target path '/calc/branches/my-calc-branch' does not exist
</screen>
        </informalexample>

        <para>All you need to do in this situation is switch your working
          copy to a location that still exits:</para>

        <informalexample>
          <screen>
$ svn sw ^/calc/trunk
D    src/whole.c
 U   src/real.c
A    src/integer.c
 U   .
Updated to revision 474.
</screen>
        </informalexample>
      </tip>

      <para>And now your branch is gone.  Of course, it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you can still see
        your old branch.</para>

      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy</command> to copy it from the old
        revision:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/branches/my-calc-branch@473 \
           ^/calc/branches/my-calc-branch \
           -m "Restore my-calc-branch."

Committed revision 475.
</screen>
      </informalexample>

      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side by side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/stable-1.0 \
           -m "Creating stable branch of calc project."

Committed revision 476.
</screen>
      </informalexample>

      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        cherrypicks bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.  We'll
        discuss this more in the next section.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonpatterns">
    <title>Common Branching Patterns</title>

    <para>There are many different uses for branching and <command>svn
        merge</command>, and this section describes the most
        common.</para>

    <para>Version control is most often used for software
      development, so here's a quick peek at two of the most common
      branching/merging patterns used by teams of programmers.  If
      you're not using Subversion for software development, feel
      free to skip this section.  If you're a software developer
      using version control for the first time, pay close attention,
      as these patterns are often considered best practices by
      experienced folk.  These processes aren't specific to
      Subversion; they're applicable to any version control system.
      Still, it may help to see them described in Subversion
      terms.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.release">
      <title>Release Branches</title>

      <para>Most software has a typical life cycle: code, test,
        release, repeat.  There are two problems with this process.
        First, developers need to keep writing new features while
        quality assurance teams take time to test supposedly stable
        versions of the software.  New work cannot halt while the
        software is tested.  Second, the team almost always needs to
        support older, released versions of software; if a bug is
        discovered in the latest code, it most likely exists in
        released versions as well, and customers will want to get
        that bug fix without having to wait for a major new
        release.</para>

      <para>Here's where version control can help.  The typical
        procedure looks like this:</para>

      <orderedlist>

        <listitem>
          <para><emphasis>Developers commit all new work to the
            trunk.</emphasis>  Day-to-day changes are committed to
            <filename>/trunk</filename>: new features, bug fixes, and
            so on.</para>
        </listitem>
        <listitem>
          <para><emphasis>The trunk is copied to a
            <quote>release</quote> branch.</emphasis>  When the team
            thinks the software is ready for release (say, a 1.0
            release), <filename>/trunk</filename> might be copied to
            <filename>/branches/1.0</filename>.</para>
        </listitem>
        <listitem>
          <para><emphasis>Teams continue to work in
            parallel.</emphasis>  One team begins rigorous testing of
            the release branch, while another team continues new work
            (say, for version 2.0) on <filename>/trunk</filename>.  If
            bugs are discovered in either location, fixes are cherrypicked
            back and forth as necessary.  At some point, however, even
            that process stops.  The branch is <quote>frozen</quote>
            for final testing right before a release.</para>
        </listitem>
        <listitem>
          <para><emphasis>The branch is tagged and
            released.</emphasis>  When testing is complete,
            <filename>/branches/1.0</filename> is copied to
            <filename>/tags/1.0.0</filename> as a reference
            snapshot.  The tag is packaged and released to
            customers.</para>
        </listitem>
        <listitem>
          <para><emphasis>The branch is maintained over
            time.</emphasis>  While work continues
            on <filename>/trunk</filename> for version 2.0, bug fixes
            continue to be ported from <filename>/trunk</filename> to
            <filename>/branches/1.0</filename>.  When enough
            bug fixes have accumulated, management may decide to do a
            1.0.1 release: <filename>/branches/1.0</filename> is
            copied to <filename>/tags/1.0.1</filename>, and the tag
            is packaged and released.</para>
        </listitem>

      </orderedlist>

      <para>This entire process repeats as the software matures:
        when the 2.0 work is complete, a new 2.0 release branch is
        created, tested, tagged, and eventually released.  After
        some years, the repository ends up with a number of release
        branches in <quote>maintenance</quote> mode, and a number
        of tags representing final shipped versions.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.feature">
      <title>Feature Branches</title>

      <para>
        <indexterm>
          <primary>branches</primary>
          <secondary>feature branches</secondary>
        </indexterm>A <firstterm>feature branch</firstterm> is the sort of
        branch that's been the dominant example in this chapter (the
        one you've been working on while Sally continues to work on
        <filename>/trunk</filename>).  It's a temporary branch created
        to work on a complex change without interfering with the
        stability of <filename>/trunk</filename>.  Unlike release
        branches (which may need to be supported forever), feature
        branches are born, used for a while, merged back to the trunk,
        and then ultimately deleted.  They have a finite span of
        usefulness.</para>

      <para>Again, project policies vary widely concerning exactly
        when it's appropriate to create a feature branch.  Some
        projects never use feature branches at all: commits to
        <filename>/trunk</filename> are a free-for-all.  The
        advantage to this system is that it's simple&mdash;nobody
        needs to learn about branching or merging.  The disadvantage
        is that the trunk code is often unstable or unusable.  Other
        projects use branches to an extreme: no change is
        <emphasis>ever</emphasis> committed to the trunk directly.
        Even the most trivial changes are created on a short-lived
        branch, carefully reviewed, and merged to the trunk.  Then
        the branch is deleted.  This system guarantees an
        exceptionally stable and usable trunk at all times, but at
        the cost of tremendous process overhead.</para>

      <para>Most projects take a middle-of-the-road approach.  They
        commonly insist that <filename>/trunk</filename> compile and
        pass regression tests at all times.  A feature branch is
        required only when a change requires a large number of
        destabilizing commits.  A good rule of thumb is to ask this
        question: if the developer worked for days in isolation and
        then committed the large change all at once (so that
        <filename>/trunk</filename> were never destabilized), would it
        be too large a change to review?  If the answer to that
        question is <quote>yes,</quote> the change should be
        developed on a feature branch.  As the developer commits
        incremental changes to the branch, they can be easily reviewed
        by peers.</para>

      <para>Finally, there's the issue of how to best keep a feature
        branch in <quote>sync</quote> with the trunk as work
        progresses.  As we mentioned earlier, there's a great risk to
        working on a branch for weeks or months; trunk changes may
        continue to pour in, to the point where the two lines of
        development differ so greatly that it may become a nightmare
        trying to merge the branch back to the trunk.</para>

      <para>This situation is best avoided by regularly running an
        automatic merge from trunk to the branch.  Make up a policy:
        once a week, merge the last week's worth of trunk changes to
        the branch.</para>

      <para>When you are eventually ready to merge the
        <quote>synchronized</quote> feature branch back to the trunk,
        begin by doing a final automatic merge of the latest trunk
        changes to the branch.  When that's done, the latest versions
        of branch and trunk are absolutely identical except for
        your branch changes.  You can then run an automatic reintegrate
        merge from the branch back to the trunk:</para>

      <informalexample>
        <screen>
$ cd trunk-working-copy

$ svn update
Updating '.':
At revision 1910.

$ svn merge ^/calc/branches/mybranch
--- Merging differences between repository URLs into '.':
U    real.c
U    integer.c
A    newdirectory
A    newdirectory/newfile
 U   .
&hellip;
</screen>
      </informalexample>

      <para>Another way of thinking about this pattern is that your
        weekly sync of trunk to branch is analogous to running
        <command>svn update</command> in a working copy, while the
        final merge step is analogous to running <command>svn
        commit</command> from a working copy.  After all, what else
        <emphasis>is</emphasis> a working copy but a very shallow
        private branch?  It's a branch that's capable of
        storing only one change at a time.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
    <title>Vendor Branches</title>

    <para>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&mdash;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</para>

    <para>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see <xref linkend="svn.developer.usingapi.apr" />).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <quote>bleeding edge</quote> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</para>

    <para>Now, if your project depends on someone else's information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions of
      that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <quote>pin down</quote> specific
      versions of that information to some location in your own
      working copy (see <xref linkend="svn.advanced.externals"
      />).</para>

    <para>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</para>

    <para>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</para>

    <para>
      <indexterm>
        <primary>vendor drop</primary>
      </indexterm>The solution to this problem is to
      use <firstterm>vendor branches</firstterm>.  A vendor branch is
      a directory tree in your own version control system that
      contains information provided by a third-party entity, or
      vendor.  Each version of the vendor's data that you decide to
      absorb into your project is called a <firstterm>vendor
      drop</firstterm>.</para>

    <para>Vendor branches provide two benefits.  First, by storing the
      currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need
      to question whether they have the right version of the vendor's
      data.  They simply receive that correct version as part of their
      regular working copy updates.  Second, because the data lives in
      your own Subversion repository, you can store your custom
      changes to it in-place&mdash;you have no more need of an
      automated (or worse, manual) method for swapping in your
      customizations.</para>

    <para>Unfortunately, there is no single best way to manage vendor
      branches in Subversion.  The flexibility of the system offers
      several different approaches, each of which has its advantages
      and disadvantages, and none of which can be clearly considered
      a <quote>silver bullet</quote> for the problem.  We'll cover a
      few of these approaches at a high level in the following
      sections, using the common example of a software project which
      depends on a third-party library.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
      <title>General Vendor Branch Management Procedure</title>

      <para>Maintaining customizations to a third-party library
        involves three data sources: the version of the third-party
        library upon which your modifications were last based, the
        customized version (that is, the actual vendor branch) of that
        library which is used by your project, and any new version of
        the vendor's library to which you may be hoping to upgrade.
        Managing the vendor branch (which should live within your
        source code repository per our definition of the thing), then,
        essentially boils down to performing merge operations (in the
        general sense).  But different teams take different approaches
        to the other data sources&mdash;the pristine versions of the
        third-party library code.  Thus, there are likewise different
        specific ways to perform the requisite merges.</para>

      <para>Strictly speaking, there are a couple of different ways
        that those merges can be performed in the general sense.  For
        the sake of simplicity and with the goal of at least providing
        <emphasis>something</emphasis> concrete in this section of the
        book, we'll assume that there is but a single vendor branch
        which is upgraded to each successive new release of the
        third-party library by receiving updates that describe the
        differences between the current and new pristine versions of
        that library.</para>

      <note>
        <para>Another approach is to create new vendor branches for
          each successive pristine library version, applying the
          differences between the current pristine library and the
          customized version thereof (from the current vendor branch)
          to the new branch.  There's nothing wrong with that
          approach&mdash;we just don't feel compelled to document
          every legitimate possibility in this space.</para>
      </note>

      <para>The following sections examine how to create and manage a
        vendor branch in a few different scenarios.  In the examples
        which follow, we'll assume that the third-party library is
        called libcomplex, and that we will be implementing a vendor
        branch based on libcomplex 1.0.0 which lives in our repository
        at <filename>^/vendor/libcomplex-custom</filename>.  We'll
        then look at how we can upgrade to libcomplex 1.0.1 while
        still preserving our customizations to the library.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.foreign-repos">
      <title>Vendor Branches from Foreign Repositories</title>

      <para>Let's look first at a vendor branch management approach
        that is possible when the original third-party library is
        itself Subversion-accessible.  For the sake of the example,
        we'll assume that the libcomplex library we previously
        discussed is developed in a publicly accessible Subversion
        repository, and that its developers use sane release
        procedures which include the creation of tags for each stable
        release version.</para>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>foreign repository merges</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository merges</primary>
          <see>merging, foreign repository merges</see>
        </indexterm>
        <indexterm>
          <primary>copying</primary>
          <secondary>foreign repository copies</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository copies</primary>
          <see>copying, foreign repository copies</see>
        </indexterm>Since Subversion 1.5, <command>svn merge</command>
        has been able to perform so-called <firstterm>foreign
        repository merges</firstterm>, where the sources of the merge
        live in a different repository than the repository from which
        the merge target working copy was checked out.  And in
        Subversion 1.8, the behavior of <command>svn copy</command>
        was changed so that when you perform a copy from a foreign
        repository into an existing working copy, the resulting tree
        is incorporated into that working copy and scheduled for
        addition.  It's this <firstterm>foreign repository
        copy</firstterm> functionality that we'll use to bootstrap our
        vendor branch.</para>

      <para>So let's create our vendor branch.  We'll begin by
        creating a placeholder directory for all such vendor branches
        in our repository, and then checking out a working copy of
        that location.</para>

      <informalexample>
        <screen>
$ svn mkdir http://svn.example.com/projects/vendor \
            -m "Create a container for vendor branches."
Committed revision 1160.
$ svn checkout http://svn.example.com/projects/vendor \
               /path/to/vendor
Checked out revision 1160.
$
</screen>
      </informalexample>

      <para>Now, we'll take advantage of Subversion's foreign
        repository copy support to get an exact copy of libcomplex
        1.0.0&mdash;including any Subversion properties stored on its
        files and directories&mdash;from the vendor repository.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn copy http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
           libcomplex-custom
--- Copying from foreign repository URL 'http://svn.othervendor.com/repos/lib\
complex/tags/1.0.0':
A    libcomplex-custom
A    libcomplex-custom/README
A    libcomplex-custom/LICENSE
&hellip;
A    libcomplex-custom/src/code.c
A    libcomplex-custom/tests
A    libcomplex-custom/tests/TODO
$ svn commit -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1161.
$
</screen>
      </informalexample>

      <note>
        <para>If you happen to be using an older version of
          Subversion, the closest available approximation of the new
          foreign repository copy support in <command>svn
          copy</command> is to instead import (via <command>svn
          import</command>) a working copy of the vendor's tag,
          including the <option>--no-auto-props</option>
          and <option>--no-ignore</option> options so that the
          complete tree and any of its versioned properties are
          accurately replicated in your own repository.</para>
      </note>

      <para>Now that we have a vendor branch based on libcomplex 1.0.0,
        we can begin making the customizations to libcomplex required
        for our purposes, committing them directly to the vendor
        branch we've created.  And of course, we can begin using
        libcomplex in our own application.</para>

      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  Here is where Subversion's
        foreign repository merge operation is useful.  We have in our
        vendor branch the original libcomplex 1.0.0 plus our
        customizations to it.  What we need now is to get the set of
        changes the vendor has made between 1.0.0 and 1.0.1 into our
        vendor branch, ideally without clobbering our own
        customizations.  This is precisely what the 2-URL form of
        the <command>svn merge</command> command is for.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn merge http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
            http://svn.othervendor.com/repos/libcomplex/tags/1.0.1 \
            libcomplex-custom
--- Merging differences between foreign repository URLs into '.':
U    libcomplex-custom/src/code.h
C    libcomplex-custom/src/code.c
U    libcomplex-custom/README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'libcomplex-custom/src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: 
</screen>
      </informalexample>

      <para>As you can see, <command>svn merge</command> has merged
        the changes required to make libcomplex 1.0.0 look like
        libcomplex 1.0.1 into our working copy.  In our example, it has
        even noticed and flagged a conflict on one file.   It seems
        the vendor modified a region of one of the files we also
        customized.  Subversion safely detects this conflict, and
        gives us the opportunity to resolve it so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  (See <xref linkend="svn.tour.cycle.resolve" />
        for more on resolving conflicts of this sort.)</para>

      <para>Once we've resolved the conflicts and performed any
        testing or review we need, we can commit the changes to our
        vendor branch.</para>

      <informalexample>
        <screen>
$ svn status libcomplex-custom
M       libcomplex-custom/src/code.h
M       libcomplex-custom/src/code.c
M       libcomplex-custom/README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-custom
Sending        libcomplex-custom/README
Sending        libcomplex-custom/src/code.h
Sending        libcomplex-custom/src/code.c
Transmitting file data ...
Committed revision 1282.
$
</screen>
      </informalexample>

      <para>That, in a nutshell, is how to manage vendor branches when
        the original source is Subversion-accessible.  There are some
        notable shortcomings, though.  First, foreign repository
        merges are not automatically tracked by Subversion itself like
        same-repository merges are.  This means the burden falls to
        the user to know which merges have been performed on their
        vendor branch, and just how to construct the next merge when
        upgrading that branch.  Also, as is the case for all of
        Subversion's merge support, renames in the merge sources can
        cause no small amount of complication and frustration.
        Unfortunately, at this time, we don't have a particularly
        solid recommendation to offer to alleviate that pain.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.mirrored-sources">
      <title>Vendor Branches from Mirrored Sources</title>

      <para>In the previous section
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) we
        looked at how to implement and maintain a vendor branch when
        the vendor drops are accessible via Subversion, which is the
        ideal scenario when it comes to vendor branches.  Subversion
        is pretty good at handling merges of stuff that's been
        Subversion-managed.  Unfortunately, it's not always the case
        that third-party libraries are publicly accessible via
        Subversion.  Many times, a project depends on a library which
        is delivered via only non-Subversion mechanisms, such as a
        source code release distribution tarball.  In such
        circumstances, we strongly recommend that you do all you can
        to get that non-Subversion information into Subversion as
        cleanly as possible.  So let's examine an approach to vendor
        branches in which the third-party library's various releases
        are mirrored within our own repository.</para>

      <para>Setting up the vendor branch the first time is pretty
        simple, really.  For our example, we'll assume that libcomplex
        1.0.0 is delivered via the common tarball mechanism.  To
        create our vendor branch, we'll first get the contents of the
        libcomplex 1.0.0 tarball into our repository as a read-only
        (by convention only) vendor tag of sorts.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.0.tar.gz
libcomplex-1.0.0/
libcomplex-1.0.0/README
libcomplex-1.0.0/LICENSE
&hellip;
libcomplex-1.0.0/src/code.c
libcomplex-1.0.0/tests
libcomplex-1.0.0/tests/TODO
$ svn import libcomplex-1.0.0 \
             http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
             --no-ignore --no-auto-props \
             -m "Import libcomplex 1.0.0 sources."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
&hellip;
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1160.
$
</screen>
      </informalexample>

      <para>Note that in our example, we used
        the <option>--no-ignore</option> option during import so that
        Subversion is sure to pick up every file in the vendor drop
        and not to omit any of them.  We also supply
        the <option>--no-auto-props</option> option so that our client
        doesn't manufacture property information which isn't present
        in the vendor drop.<footnote><para>Technically, we could let
        the auto-props feature do its thing, but the key to making
        that work well is ensuring that each vendor drop gets
        identical auto-prop treatment.</para></footnote>.</para>
       
      <para>Now that the first vendor release drop is present in our
        repository, we can create our vendor branch from it just as we
        would create any other branch&mdash;using <command>svn
        copy</command>.</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-custom \
           -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Committed revision 1161.
$
</screen>
      </informalexample>

      <para>Okay.  At this point we have a vendor branch based on
        libcomplex 1.0.0.  We are now poised to begin making the
        customizations to libcomplex required for our
        purposes&mdash;committing them directly to the vendor branch
        we've created&mdash;and then to start using our customized
        libcomplex in our own application.</para>

      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  In order to perform that
        upgrade on our branch, we need to essentially apply the same
        set of changes the vendor has made between 1.0.0 and 1.0.1 to
        our vendor branch without clobbering our own customizations.
        The safest way to perform that application is to first get
        libcomplex 1.0.1 into our repository <emphasis>as a delta
        against the libcomplex 1.0.0 code in our
        repository</emphasis>.  Afterwards, we'll use the 2-URL form
        of the <command>svn merge</command> command to replicate those
        same changes into our vendor branch.</para>

      <para>As it turns out, there are several different approaches we
        can take to to get libcomplex 1.0.1 into our repository in the
        right way.<footnote><para>Using another <command>svn
        import</command> operation would be
        an <emphasis>incorrect</emphasis> approach, as the libcomplex
        1.0.0 and 1.0.1 branches would not have any common
        ancestry.</para></footnote>  The approach we'll describe here
        is relatively rudimentary, but it will serve our illustrative
        needs.</para>

      <para>Remember, we want our mirror of the libcomplex 1.0.1
        vendor drop to share ancestry with our 1.0.0 vendor drop,
        which will produce the best results later when we need to
        merge the changes between those drops to our vendor branch.
        So we'll start by creating a libcomplex-1.0.1 branch as copy
        of our previously created libcomplex-1.0.0 <quote>vendor
        tag</quote>&mdash;a copy which will eventually become a
        replica of libcomplex 1.0.1.</para>
        
      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
           -m "Setup a construction zone for libcomplex 1.0.1."
Committed revision 1282.
$
</screen>
      </informalexample>

      <para>What we need now is to make a working copy of our
        libcomplex-1.0.1 branch, and then to make it actually look
        like libcomplex 1.0.1.  To do this, we'll take advantage of
        the fact that <command>svn checkout</command> can overlay an
        existing directory and, if the <option>--force</option> option
        is provided, do so in manner that allows the differences
        between the checked-out tree and the target tree that the
        checkout overlayed to remain as local modifications in the new
        working copy.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.1.tar.gz
libcomplex-1.0.1/
libcomplex-1.0.1/README
libcomplex-1.0.1/LICENSE
&hellip;
libcomplex-1.0.1/src/code.c
libcomplex-1.0.1/tests
libcomplex-1.0.1/tests/TODO
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
               libcomplex-1.0.1 \
               --force
E    libcomplex-1.0.1/README
E    libcomplex-1.0.1/LICENSE
E    libcomplex-1.0.1/INSTALL
&hellip;
E    libcomplex-1.0.1/src/code.c
E    libcomplex-1.0.1/tests
E    libcomplex-1.0.1/tests/TODO
Checked out revision 1282.
$ svn status libcomplex-1.0.1
M       libcomplex-1.0.1/src/code.h
M       libcomplex-1.0.1/src/code.c
M       libcomplex-1.0.1/README
$
</screen>
      </informalexample>

      <para>As you can see, after checking out what was really
        libcomplex 1.0.0 atop the libcomplex 1.0.1 exploded tarball,
        we are left with a working copy that contains local
        modifications&mdash;those modifications required to morph our
        previous vendor release drop into our new one.</para>

      <para>Admittedly, this is a pretty simple example.  The changes
        required to perform this particular upgrade involved merely
        content changes to existing files.  In reality, new versions
        of third-party libraries might also add or remove files or
        directories, might rename files or directories, and so on.  In
        those situations, it can be much more challenging to morph the
        new vendor tag into a state where it accurately reflects the
        vendor drop it claims to reflect.  We'll leave the details of
        such transformations as an exercise to the
        reader.<footnote><para>Here's a hint, though: <userinput>svn
        add --force /path/to/working-copy --no-ignore
        --no-auto-props</userinput> is super handy for adding any new
        vendor drop items to version control in this
        situation.</para></footnote></para>

      <para>However we make it happen, once our new vendor tag working
        copy is reconciled with the original source distribution, we
        can commit those changes to our repository.</para>

      <informalexample>
        <screen>
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-1.0.1
Sending        libcomplex-1.0.1/README
Sending        libcomplex-1.0.1/src/code.h
Sending        libcomplex-1.0.1/src/code.c
Transmitting file data ...
Committed revision 1283.
$
</screen>
      </informalexample>

      <para>We're finally ready to upgrade our vendor branch.
        Remember, our goal is to get the changes made by the vendor
        between the 1.0.0 and 1.0.1 releases of their library into our
        vendor branch.  There is where a 2-URL <command>svn
        merge</command> operation, applied to a working copy of our
        vendor branch, comes into play.</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-custom \
               libcomplex-custom
E    libcomplex-custom/README
E    libcomplex-custom/LICENSE
E    libcomplex-custom/INSTALL
&hellip;
E    libcomplex-custom/src/code.c
E    libcomplex-custom/tests
E    libcomplex-custom/tests/TODO
Checked out revision 1283.
$ cd libcomplex-custom
$ svn merge ^/vendor/libcomplex-1.0.0 \
            ^/vendor/libcomplex-1.0.1
--- Merging differences between repository URLs into '.':
U    src/code.h
C    src/code.c
U    README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: 
</screen>
      </informalexample>

      <para>As you can see, <command>svn merge</command> has merged
        the requisite changes into our working copy, flagging a
        conflict where the vendor modified the same region of one of
        the files as we did during our customizations.  Subversion
        detects this conflict, and gives us the opportunity to resolve
        it (using the methods described in
        <xref linkend="svn.tour.cycle.resolve" />) so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  Once we've resolved the conflicts and performed
        any testing or review we need, we can commit the changes to
        our vendor branch.</para>

      <informalexample>
        <screen>
$ svn status
M       src/code.h
M       src/code.c
M       README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1."
Sending        README
Sending        src/code.h
Sending        src/code.c
Transmitting file data ...
Committed revision 1284.
$
</screen>
      </informalexample>

      <para>Our vendor branch upgrade is complete.  And the next time
        we need to upgrade that branch, we'll follow the same
        procedure we used to upgrade it this time.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.when">
    <title>To Branch or Not to Branch?</title>

    <para>To branch or not to branch&mdash;that is an interesting
      question.  This chapter has provided thus far a pretty deep dive
      into the waters of branching and merging, topics which have
      historically been the premier source of Subversion user
      confusion.  As if the rote actions involved in branching and
      branch management aren't sometimes tricky enough, some users get
      hung up on deciding whether they need to branch at all.  As
      you've learned, Subversion can handle common branching and
      branch management scenarios.  So, the decision of whether or not
      to branch a project's history is rarely a technical one.
      Rather, the social impact of the decision often carries more
      weight.  Let's examine some of the benefits and costs of using
      branches in a software project.</para>

    <para>The most obvious benefit of working on a branch is
      isolation.  Changes made to the branch don't affect the other
      lines of development in the project; changes made to those other
      lines don't affect the branch.  In this way, a branch can serve
      as a great place to experiment with new features, complex bug
      fixes, major code rewrites, and so on.  No matter how much stuff
      Sally breaks on her branch, Harry and the rest of the team can
      continue with their work unhindered outside the branch.</para>

    <para>Branches also provide a great way to organize related
      changes into readily identifiable collections.  For example, the
      changes which comprise the complete solution to a particular bug
      might be a list of non-sequential revision numbers.  You might
      describe them in human language as <quote>revisions 1534, 1543,
      1587 and 1588</quote>.  You'd probably reproduce those numbers
      manually (or otherwise) in the issue tracker artifact which
      tracks the bug.  When porting the bug fix to other product
      versions, you'd need to make sure to port all those revisions.
      But had those changes been made on a unique branch, you'd find
      yourself referring only to that branch by its name in
      conversation, in issue tracker comments, and when porting
      changes.</para>

    <para>The unfortunate downside of branches, though, is that the
      very isolation that makes them so
      useful <emphasis>can</emphasis> be at odds with the
      collaborative needs of the project team.  Depending on the work
      habits of your project peers, changes made to branches might not
      get the kind of constructive review, criticism, and testing that
      changes made to the main line of development do.  The isolation
      of a branch can encourage users to forsake certain version
      control <quote>best practices</quote>, leading to version
      history which is difficult to review <foreignphrase>post
      facto</foreignphrase>.  Developers on long-lived branches
      sometimes need to work extra hard to ensure that the
      evolutionary direction of their isolated copy of the codebase is
      in harmony with the direction their peers are steering the main
      code lines.  Now, these drawbacks might be less of an issue for
      true exploratory branches aimed at experimenting with the future
      of a codebase with no expectation of reintegrating the results
      back into the main development lines&mdash;mere policy needn't
      be a vision-killer!  But the simple fact remains that projects
      generally benefit from an orderly approach to version control
      where code and code changes enjoy the review and comprehension
      of more than one team member.</para>

    <para>That's not to say that there are no technical penalties to
      branching.  Pardon us while we <quote>go meta</quote> for a bit
      here.  If you think about it, every time you checkout a
      Subversion working copy, you're creating a branch of sorts of
      your project.  It's a special sort of branch.  It lives only on
      your client machine; not in the repository.  You synchronize
      this branch with changes made in the repository
      using <command>svn update</command>&mdash;which acts almost like
      a special-cased, simplified form of an <command>svn
      merge</command> command.<footnote><para>Actually, you
      <emphasis>could</emphasis> use <userinput>svn merge
      -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>
      in your working copy to quite literally merge in all the
      repository changes since your last update if really wanted
      to!</para></footnote> You effectively reintegrate your branch
      each time you run <command>svn commit</command>.  So, in that
      special sense, Subversion users deal with branches and merges
      all the time.  Given the similarities between updating and
      merging, it's no surprise, then, that the areas in which
      Subversion seems to have the most shortcomings&mdash;namely,
      handling file and directory renames and dealing with tree
      conflicts in general&mdash;are problematic for both
      the <command>svn update</command> and <command>svn
      merge</command> operations.  Unfortunately, <command>svn
      merge</command> has a harder time of it precisely because of the
      fact that, for every way in which <command>svn update</command>
      is a special-cased, simplified kind of generic merge operation,
      a true Subversion merge is neither special-cased nor simplified.
      For this reason, merges perform much more slowly than updates,
      require explicit tracking (via
      the <literal>svn:mergeinfo</literal> property we've discussed in
      this chapter) and history-crunching arithmetic, and generally
      offer more opportunities for something to go awry.</para>

    <para>To branch or not to branch?  Ultimately, that depends on
      what your team needs in order to find that sweet balance of
      collaboration and isolation.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
    <title>Summary</title>

    <para>We covered a lot of ground in this chapter.  We
      discussed the concepts of tags and branches and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We showed how
      to use <command>svn merge</command> to copy changes from one
      branch to another or roll back bad changes.  We went over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>

    <para>Remember the Subversion mantra: branches and tags are cheap.
      So don't be afraid to use them when needed!</para>

    <para>As a helpful reminder of all the operations we discussed,
      here is handy reference table you can consult as
      you begin to make use of branches.</para>

    <table id="svn.branchmerge.summary.tbl-1">
      <title>Branching and merging commands</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Action</entry>
            <entry>Command</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Create a branch or tag</entry>
            <entry><userinput>svn copy <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Switch a working copy to a branch or tag</entry>
            <entry><userinput>svn switch <replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Synchronize a branch with trunk</entry>
            <entry><userinput>svn merge <replaceable>trunkURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>See merge history or eligible changesets</entry>
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Merge a branch back into trunk</entry>
            <entry><userinput>svn merge <replaceable>branchURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Merge one specific change</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Merge a range of changes</entry>
            <entry><userinput>svn merge -r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Block a change from automatic merging</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> --record-only <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Preview a merge</entry>
            <entry><userinput>svn merge <replaceable>URL</replaceable> --dry-run</userinput></entry>
          </row>

          <row>
            <entry>Abandon merge results</entry>
            <entry><userinput>svn revert -R .</userinput></entry>
          </row>

          <row>
            <entry>Resurrect something from history</entry>
            <entry><userinput>svn copy <replaceable>URL</replaceable>@<replaceable>REV</replaceable> <replaceable>localPATH</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Undo a committed change</entry>
            <entry><userinput>svn merge -c -<replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Examine merge-sensitive history</entry>
            <entry><userinput>svn log -g; svn blame -g</userinput></entry>
          </row>

          <row>
            <entry>Create a tag from a working copy</entry>
            <entry><userinput>svn copy . <replaceable>tagURL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Rearrange a branch or tag</entry>
            <entry><userinput>svn move <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Remove a branch or tag</entry>
            <entry><userinput>svn delete <replaceable>URL</replaceable></userinput></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->


