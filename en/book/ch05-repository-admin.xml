<!-- -*- sgml -*- -->

<chapter id="svn.reposadmin">
  <title>Repository Administration</title>

  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>

  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use various
    related tools provided with Subversion.  We'll address some common
    questions and mistakes and give some suggestions on how to arrange
    the data in the repository.</para>

  <para>If you plan to access a Subversion repository only in the role
    of a user whose data is under version control (i.e., via a
    Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,<footnote><para>This may sound really prestigious
    and lofty, but we're just talking about anyone who is interested
    in that mysterious realm beyond the working copy where everyone's
    data hangs out.</para></footnote> this chapter is for you.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>The Subversion Repository, Defined</title>

    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective&mdash;how a repository looks and
      acts with respect to non-Subversion tools&mdash;and from a
      logical perspective&mdash;dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>

    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>

    <informalexample>
      <screen>
$ ls repos
conf/  db/  format  hooks/  locks/  README.txt
</screen>
    </informalexample>

    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology&mdash;detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>

    <variablelist>
      <varlistentry>
        <term>conf/</term>
        <listitem>
          <para>This directory is a container for configuration
            files.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db/</term>
        <listitem>
          <para>This directory contains the data store for all of your
            versioned data.<footnote><para>Strictly speaking,
            Subversion doesn't dictate that the versioned data live
            here, and there are known (albeit proprietary) alternative
            backend storage implementations which do not, in fact,
            store data in this directory.</para></footnote></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>This file describes the repository's internal
            organizational scheme.  (As it turns out,
            the <filename>db/</filename> subdirectory sometimes also
            contains a <filename>format</filename> file which
            describes only the contents of that subdirectory and which
            is not to be confused with this file.)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks/</term>
        <listitem>
          <para>This directory contains hook script templates and
            hook scripts, if any have been installed.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks/</term>
        <listitem>
          <para>Subversion uses this directory to house repository
            lock files, used for managing concurrent access to the
            repository.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>This is a brief text file containing merely a notice
            to readers that the directory they are looking in is a
            Subversion repository.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>
        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activities</secondary>
        </indexterm>Prior to Subversion 1.5, the on-disk repository
        structure also always contained a <filename>dav</filename>
        subdirectory. <filename>mod_dav_svn</filename> used this
        directory to store information about
        WebDAV <firstterm>activities</firstterm>&mdash;mappings of
        high-level WebDAV protocol concepts to Subversion commit
        transactions.  Subversion 1.5 changed that behavior, moving
        ownership of the activities directory, and the ability to
        configure its location, into <filename>mod_dav_svn</filename>
        itself.  Now, new repositories will not necessarily have
        a <filename>dav</filename> subdirectory
        unless <filename>mod_dav_svn</filename> is in use and hasn't
        been configured to store its activities database elsewhere.
        See <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" />
        for more information.</para>
    </note>

    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem&mdash;it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>

    <sidebar id="svn.reposadmin.basics.backends">
      <title>Speaking of Filesystems&hellip;</title>

      <para>When the initial design phase of Subversion was in
        progress, the developers decided to use Berkeley DB (BDB) as
        the storage mechanism behind the virtual versioned filesystem
        implementation.  Berkeley DB was a logical choice for a
        variety of reasons, including its open source license,
        transaction support, reliability, performance, API simplicity,
        thread safety, support for cursors, and so on.</para>

      <para>In the years since, the
        newer <firstterm>FSFS</firstterm><footnote><para>While it is
        often pronounced <quote>fuzz-fuzz,</quote> per Jack
        Repenning's rendition, this book assumes that the reader is
        thinking <quote>eff-ess-eff-ess.</quote></para></footnote>
        backend was introduced.  This so-called <quote>filesystem
        filesystem</quote> was a versioned filesystem implemented not
        within an opaque database container, but instead as a larger
        collection of more transparent files stored in the OS's
        filesystem.  FSFS enjoyed continual development and
        improvement, and eventually earned the right to be the default
        Subversion backend.  But improvements to that backend kept
        coming, and ultimately the FSFS storage layer surpassed the
        Berkeley DB one in nearly every meaningful metric, from
        performance to scalability to reliability and beyond.</para>

      <para>These days, it is generally assumed that if you are using
        the open source Subversion product, you are using the FSFS
        backend for your repositories.  In fact, beginning with
        Subversion 1.8, the Berkeley DB Subversion repository
        filesystem backend has been officially deprecated.  Subversion
        repositories which still use this storage layer option will
        continue to function with newer Subversion 1.x releases, but
        no further development&mdash;including feature introduction or
        expansion&mdash;is planned for the Berkeley DB backend.
        Subversion effectively offers a single viable repository
        storage layer option.  FSFS won.</para>

      <para>This book will continue to provide information relevant to
        administrators of BDB-backed repositories where it makes sense
        to do so, but most of this chapter will assume what the rest
        of the world does: that FSFS is <emphasis>the</emphasis>
        Subversion storage backend implementation.  Please refer to
        <xref linkend="svn.berkeleydb"/> or to older versions of this
        documentation for more complete information about
        administering such repositories.</para>
    </sidebar>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Strategies for Repository Deployment</title>

    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>

    <para>Some things you'll want to consider beforehand, though, are:</para>

    <itemizedlist>
      <listitem>
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
      </listitem>
      <listitem>
        <para>Where will your repository live, and how will it be
          accessed?</para>
      </listitem>
      <listitem>
        <para>What types of access control do you need?</para>
      </listitem>
    </itemizedlist>

    <para>In this section, we'll try to help you answer those
      questions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Planning Your Repository Organization</title>

      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>

      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>

      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>

      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course&mdash;it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.<footnote><para>Whether founded in
        ignorance or in poorly considered concepts about how to derive
        legitimate software development metrics, global revision
        numbers are a silly thing to fear,
        and <emphasis>not</emphasis> the kind of thing you should
        weigh when deciding how to arrange your projects and
        repositories.</para></footnote></para>

      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>

      <para>
        <indexterm>
          <primary>project root</primary>
        </indexterm>

        After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each project
        root&mdash;the <quote>topmost</quote> directory
        that contains data related to that project&mdash;and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.<footnote><para>The <filename>trunk</filename>,
        <filename>tags</filename>, and <filename>branches</filename>
        trio is sometimes referred to as <quote>the TTB
        directories.</quote></para></footnote></para>

      <para>For example, your repository might look like this:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</literallayout>
      </informalexample>

      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>

      <informalexample>
        <literallayout>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</literallayout>
      </informalexample>

      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>

      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>

      <informalexample>
        <literallayout>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</literallayout>
      </informalexample>

      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons&mdash;it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history&mdash;past, present, tagged, and branched&mdash;for
        that project and that project alone.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Deciding Where and How to Host Your Repository</title>

      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>

      <para>We cover server choice and configuration in
        <xref linkend="svn.serverconfig" />, but the point we'd like
        to briefly make here is simply that the answers to some of
        these other questions might have implications that force your
        hand when deciding where your repository will live.  For
        example, certain deployment scenarios might require accessing
        the repository via a remote filesystem from multiple
        computers, or using multiple repositories with syncronized
        contents distributed geographically to permit more performant
        access to that data by users around the globe.  Addressing
        each possible way to deploy Subversion is both impossible and
        outside the scope of this book.  We simply encourage you to
        evaluate your options using these pages and other sources as
        your reference material and to plan ahead.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.accesscontrol">
      <title>Controlling Access to Your Repository</title>

      <para>Access control in Subversion is almost entirely managed by
        the Subversion server processes.  We discuss the available
        Subversion servers in <xref linkend="svn.serverconfig" />, and
        explain path-based access control specifically in
        <xref linkend="svn.serverconfig.pathbasedauthz" />.  In
        addition to those user-level access control questions, you'll also
        want to ensure that your repository is accessible by the
        programs on your hosting machine which need to access it.
        Consider the OS-level user and group ownership that makes
        sense for your repository.  Once again, the information found
        in <xref linkend="svn.serverconfig" /> should be able to help
        you make these decisions.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Creating and Configuring Your Repository</title>

    <para>Earlier in this chapter (in
      <xref linkend="svn.reposadmin.planning" />), we looked at some
      of the important decisions that should be made before creating
      and configuring your Subversion repository.  Now, we finally get
      to get our hands dirty!  In this section, we'll see how to
      actually create a Subversion repository and configure it to
      perform custom actions when special repository events
      occur.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Creating the Repository</title>

      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>

      <informalexample>
        <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
      </informalexample>

      <para>Assuming that the parent directory 
        <filename>/var/svn</filename> exists and that you have
        sufficient permissions to modify that directory, the previous
        command creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store (FSFS).  You can explicitly choose the
        filesystem type using the <option>--fs-type</option> argument,
        which accepts as a parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>

      <informalexample>
        <screen>
$ # Create an FSFS-backed repository
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</screen>
      </informalexample>

      <informalexample>
        <screen>
# Create a legacy Berkeley-DB-backed repository
$ svnadmin create --fs-type bdb /var/svn/repos
$
</screen>
      </informalexample>

      <para>After running this simple command, you have a Subversion
        repository.  Depending on how users will access this new
        repository, you might need to fiddle with its filesystem
        permissions.  But since basic system administration is rather
        outside the scope of this text, we'll leave further
        exploration of that topic as an exercise to the reader.</para>

      <tip>
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities&mdash;they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
      </tip>

      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem.  Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>

      <para>Now that you have a repository, it's time to customize
        it.</para>

      <warning>
        <para>While some parts of a Subversion repository&mdash;such
          as the configuration files and hook scripts&mdash;are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools for tweaking relevant subsections of the
          repository.  Do <emphasis>not</emphasis> attempt manual
          manipulation of your version control history by poking and
          prodding around in your repository's data store
          files!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.hooks">
      <title>Implementing Repository Hooks</title>

      <para>
        <indexterm>
          <primary>hook scripts</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>hook scripts</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>hooks</secondary>
          <see>hook scripts</see>
        </indexterm>A <firstterm>hook</firstterm> is a program
        triggered by some repository event, such as the creation of a
        new revision or the modification of an unversioned property.
        Some hooks (the so-called <quote>pre hooks</quote>) run in
        advance of a repository operation and provide a means by which
        to both report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine&mdash;but don't
        modify&mdash;the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
            
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>

      <informalexample>
        <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
      </informalexample>
            
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>

      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>

      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>

      <para>There are several hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.configuration">
        <title>Hook script environment configuration</title>

        <para>By default, Subversion executes hook scripts with an
          empty environment&mdash;that is, no environment variables
          are set at all, not even <literal>$PATH</literal>
          (or <literal>%PATH%</literal>, under Windows).  Because of
          this, many administrators are baffled when their hook
          program runs fine by hand, but doesn't work when invoked by
          Subversion.  Administrators have historically worked around
          this problem by manually setting all the environment
          variables their hook scripts need in the scripts
          themselves.</para>

        <para>Subversion 1.8 introduces a new way to manage the
          environment of Subversion-executed hook scripts&mdash;the
          hook script environment configuration file.  If a Subversion
          server finds a file named <filename>hooks-env</filename> in
          the repository's <filename>conf/</filename> subdirectory, it
          parses that file as an INI-formatted configuration file and
          applies the option names and variables found therein to the
          hook script's execution environment as environment
          variables.</para>

        <para>The syntax of the <filename>hooks-env</filename> file is
          pretty straightforward: each section name is the name of a
          hook script (such as <literal>pre-commit</literal>
          or <literal>post-revprop-change</literal>, and the
          configuration items inside that section are treated as
          mappings of environment variable names to desired values.
          Additionally, there is a
          special <literal>[default]</literal> section, which can be
          used to configure environment variable mappings that should
          be applied to <emphasis>all</emphasis> hook scripts (unless
          explicitly overridden by per-hook-script settings).  See
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          for a sample <filename>hooks-env</filename> configuration
          file.</para>

        <example id="svn.reposadmin.hooks.configuration.ex-1">
          <title>hooks-env (custom hook script environment
            configuration)</title>

          <programlisting>
# All scripts should use a UTF-8 locale and have our hook script
# utilities directory on the search path.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# The post-commit and post-revprop-change scripts want to run
# programs from our custom synctools replication software suite, too.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>

        <note>
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> also demonstrates the nifty string substitution syntax
            found in Subversion's configuration file parser.  In this
            example, the value of the <literal>PATH</literal>
            option&mdash;pulled from the <literal>[default]</literal>
            section of the file&mdash;is substituted in place of
            the <literal>%(PATH)s</literal> placeholder text in the
            per-hook sections.  For more about this special syntax,
            see the <filename>README.txt</filename> file which lives
            in the Subversion runtime configuration directory.  (And
            for more information about that directory, see
            <xref linkend="svn.advanced.confarea" />.)</para>
        </note>

        <para>Of course, having exact duplicates of your custom hook
          script environment configuration files in every single
          repository's <filename>conf/</filename> directory could get
          cumbersome, especially when you need to make changes to them
          all.  So Subversion's servers allow you to specify an
          alternate (possibly shared) location for this configuration
          information.</para>

        <!-- ### TODO:  Add cross reference for the above! -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.uses">
        <title>Common uses for hook scripts</title>

        <para>Repository hook scripts can offer a wide range of
          utility, but most tend to fall into a few basic categories:
          notification, validation, and replication.</para>

        <para>Notification scripts are those which tell someone that
          something happened.  The most common of these found in a
          Subversion service offering involve programs which send
          commit and revision property change notification emails to
          project members, driven by the post-commit and
          post-revprop-change hooks, respectively.  There are numerous
          other notification approaches, from issue tracker integration
          scripts to scripts which operate as IRC bots to announce
          that something's changed in the repository.</para>

        <para>On the validation side of things, the start-commit and
          pre-commit hooks are widely used to allow or disallow
          commits based on various criteria: the author of the commit,
          the formatting and/or content of the log message which describes the
          commit, and even the low-level details of the changes made
          to files and directories in the commit.  Likewise, the
          pre-revprop-change hook acts as the gateway to revision
          property changes, which is an especially valuable role
          considering the fact that revision properties are not
          themselves versioned, and can therefore only be modified
          destructively.</para>
        
        <para>One special class of change validation that has seen
          widespread use since Subversion 1.5 was released is
          validation of the committing client software itself.  When
          Subversion's merge tracking feature (described extensively
          in <xref linkend="svn.branchmerge" />) was introduced in
          that release, Subversion administrators needed a way to
          ensure that once users of their repositories started using
          the new feature that <emphasis>all</emphasis> their merges
          were tracked.  To reduce the chance of someone committing an
          untracked merge to the repository, they used start-commit
          hooks to examine the feature capabilities string advertised
          by Subversion clients.  If the committing client didn't
          advertise support for merge tracking, the commit was denied
          with instructions to the user to immediately update their
          Subversion client!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> provides
          an example of a start-commit script which does precisely
          this.</para>

        <example id="svn.reposadmin.hooks.uses.ex-1">
          <title>start-commit hook to require merge tracking
            support</title>

          <programlisting>
#!/usr/bin/env python
import sys

# sys.argv[3] is a colon-delimited capabilities list
if 'mergeinfo' not in sys.argv[3].split(':'):
  sys.stderr.write("""\
ERROR: Commits to this repository must be made using Subversion
clients which support the merge tracking feature.  Please upgrade
your client to at least Subversion 1.5.0.
""")
  sys.exit(1)
</programlisting>
        </example>
        
        <para>
          <indexterm>
            <primary>properties</primary>
            <secondary>ephemeral transaction properties</secondary>
          </indexterm>Beginning in Subversion 1.8, clients committing
          against a Subversion 1.8 server will still provide the
          feature capabilities string, but will also provide
          additional information about themselves by way
          of <firstterm>ephemeral transaction properties</firstterm>.
          Ephemeral transaction properties are essentially revision
          properties which are set on the commit transaction by the
          client at the earliest opportunity while committing, but
          which are automatically removed by the server immediately
          prior to the transaction becoming a finalized revision.  You
          can inspect these properties using the same tools with which
          you'd inspect other unversioned properties set on commit
          transactions during the timeframe between which the
          start-commit and pre-commit repository hook scripts would
          operate.</para>

        <para>The following are the ephemeral transaction properties
          which Subversion currently provides and implements:</para>

        <variablelist>
  
          <varlistentry>
            <term><literal>svn:txn-client-compat-version</literal></term>
            <listitem>
              <para>Carries the Subversion library version string with
                which the committing client claims compatibility.
                This is useful for deciding whether the client
                supports the minimal feature set required for proper
                handling of the repository data.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:txn-user-agent</literal></term>
            <listitem>
              <para>Carries the <quote>user agent</quote> string which
                describes the committing client program.  Subversion's
                libraries define the initial portion of this string,
                but third-party consumers of the API (GUI clients,
                etc.) can append custom information to it.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>

        <!-- ### TODO: Show an example of these being used?  Or ### -->
        <!-- ###       do so in ch07 - Customizing Subversion   ### -->
        <!-- ###       with a cross-reference here.             ### -->

        <note>
          <para>While most clients will transmit ephemeral transaction
            properties early enough in the commit process that they
            may be inspected by the start-commit hook script, some
            configurations of Subversion will cause those properties
            to not be set on the transaction until later in the commit
            process.  Administrators should consider performing any
            validation based on ephemeral transaction properties in
            both the start-commit and pre-commit hooks&mdash;the
            former to rule out invalid clients before those clients
            transmit the commit payload; the latter <quote>just in
            case</quote> the validation checks couldn't be performed
            by the start-commit hook.</para>
        </note>

        <para>As noted before, ephemeral transaction properties are
          removed from the transaction just before it is promoted to a
          new revision.  Some administrators may wish to preserve the
          information in those properties indefinitely.  We suggest
          that you do so by using the pre-commit hook script to copy
          the values of those properties to new property names.  In
          fact, the Subversion source code distribution provides a
          <filename>persist-ephemeral-txnprops.py</filename> script
          (in the <filename>tools/hook-scripts/</filename>
          subdirectory) for doing precisely that.</para>

        <para>The third common type of hook script usage is for the
          purpose of replication.  Whether you are driving a simple
          backup process or a more involved remote repository
          mirroring scenario, hook scripts can be critical.  See
          <xref linkend="svn.reposadmin.maint.backup" /> and
          <xref linkend="svn.reposadmin.maint.replication" /> for more
          information about these aspects of repository
          maintenance.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.summary">
        <title>Finding hook scripts or rolling your own</title>

        <para>As you might imagine, there is no shortage of Subversion
          hook programs and scripts that are freely available either
          from the Subversion community itself or elsewhere.  In fact,
          the Subversion distribution provides several commonly used
          hook scripts in its <filename>tools/hook-scripts/</filename>
          subdirectory.  However, if you are unable to find one that
          meets your specific needs, you might consider writing your
          own.  See <xref linkend="svn.developer" /> for information
          about developing software using Subversion's public
          APIs.</para>

        <warning>
          <para>While hook scripts can do almost anything, there is
            one dimension in which hook script authors should show
            restraint: do <emphasis>not</emphasis> modify a commit
            transaction using hook scripts.  While it might be
            tempting to use hook scripts to automatically correct
            errors, shortcomings, or policy violations present in the
            files being committed, doing so can cause problems.
            Subversion keeps client-side caches of certain bits of
            repository data, and if you change a commit transaction in
            this way, those caches become indetectably stale.  This
            inconsistency can lead to surprising and unexpected
            behavior.  Instead of modifying the transaction, you
            should simply <emphasis>validate</emphasis> the
            transaction in the <filename>pre-commit</filename> hook
            and reject the commit if it does not meet the desired
            requirements.  As a bonus, your users will learn the value
            of careful, compliance-minded work habits.</para>
        </warning>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.fsfs">
      <title>FSFS Configuration</title>

      <para>As of Subversion 1.8, FSFS filesystems have several
        configurable parameters which an administrator can use to
        fine-tune the performance or disk usage of their repositories.
        You can find these options&mdash;and the documentation for
        them&mdash;in the <filename>db/fsfs.conf</filename> file in
        the repository.</para>

      <!-- TODO: Document the fsfs.conf options herein. -->

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Repository Maintenance</title>

    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>An Administrator's Toolkit</title>

      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your
        repository.  Let's look more closely at each of those
        tools.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>

        <informalexample>
          <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>
        </informalexample>

        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>
            
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>revisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
            
        <para><command>svnlook</command> has a straightforward
          syntax:</para>

        <informalexample>
          <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
&hellip;
</screen>
        </informalexample>

        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>--revision</option>
          (<option>-r</option>) and <option>--transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>--revision</option> (<option>-r</option>)
          and <option>--transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>
        </informalexample>

        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>

        <informalexample>
          <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>
        </informalexample>

        <note>
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>--revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
        </note>
            
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
$
</screen>
        </informalexample>

        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>

        <orderedlist>
          <listitem>
            <para>The author, followed by a newline</para>
          </listitem>
          <listitem>
            <para>The date, followed by a newline</para>
          </listitem>
          <listitem>
            <para>The number of characters in the log message,
              followed by a newline</para>
          </listitem>
          <listitem>
            <para>The log message itself, followed by a newline</para>
          </listitem>
        </orderedlist>

        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>

        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>

        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>

        <informalexample>
          <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type 'svndumpfilter help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
</screen>
        </informalexample>

        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnrdump">
        <title>svnrdump</title>

        <para>The <command>svnrdump</command> program is, to put it
          simply, essentially just network-aware flavors of
          the <command>svnadmin dump</command> and <command>svnadmin
          load</command> subcommands, rolled up into a separate
          program.</para>

        <informalexample>
          <screen>
$ svnrdump help
general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]
Type 'svnrdump help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnrdump --version' to see the program version and RA modules.

Available subcommands:
   dump
   load
   help (?, h)

$
</screen>
        </informalexample>

        <para>We discuss the use of <command>svnrdump</command> and
          the aforementioned <command>svnadmin</command> commands
          later in this chapter (see
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>The <command>svnsync</command> program provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote><footnote><para>Or is that,
          the <quote>sync</quote>?</para></footnote> repositories may
          be on different computers from each other and
          from <command>svnsync</command> itself.</para>

        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>

        <informalexample>
          <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)
$
</screen>
        </informalexample>

        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories use individual
          files to house information about each revision.  Sometimes
          these files all live in a single directory; sometimes they
          are sharded across many directories.</para>

        <para>The earliest FSFS release versions would house all the
          revision files within a single directory that grew&mdash;one
          file per revision&mdash;throughout the lifetime of your
          repository.  This created problems on systems which have
          hard limits on the number of files permitted in a given
          directory, and was a performance burden even on systems
          where such limits didn't exist or were set sufficiently
          high.</para>

        <para>Beginning in version 1.5, Subversion creates FSFS-backed
          repositories using a slightly modified layout in which the
          contents of the revision files directory (and other
          always-growing directories)
          are <firstterm>sharded</firstterm>, or scattered across
          several subdirectories.  This can greatly reduce the time it
          takes the system to locate any one of these files, and
          therefore increases the overall performance of Subversion
          when reading from the repository.</para>

        <para>The number of files permitted to live in a given
          subdirectory is a configurable thing (though the defaults
          are reasonable ones for most known platforms), but changing
          that configuration after the repository has been in use for
          some time could cause Subversion to be unable to locate the
          files it is looking for.  That's
          where <command>fsfs-reshard.py</command> comes in.</para>

        <para><command>fsfs-reshard.py</command> reshuffles the
          repository's file structure into a new arrangement that
          reflects the requested number of sharding subdirectories and
          updates the repository configuration to preserve this
          change.  When used in conjunction with the <command>svnadmin
          upgrade</command> command, this is especially useful for
          upgrading a pre-1.5 Subversion (unsharded) repository to the
          latest filesystem format and sharding its data files (which
          Subversion will not automatically do for you).  This script
          can also be used for fine-tuning an already sharded
          repository.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Commit Log Message Correction</title>
            
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> hook; see
        <xref linkend="svn.reposadmin.hooks" />) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>

      <informalexample>
        <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      </informalexample>
      
      <para>The <command>svnadmin setlog</command> command, by
        default, is still bound by the same protections against
        modifying unversioned properties as a remote client
        is&mdash;the <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
 
      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Managing Disk Space</title>

      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>How Subversion saves disk space</title>

        <para>
          <indexterm>
            <primary>deltification</primary>
          </indexterm>To keep the repository small, Subversion uses
          <firstterm>deltification</firstterm> (or delta-based storage)
          within the repository itself.  Deltification involves
          encoding the representation of a chunk of data as a
          collection of differences against some other chunk of data.
          If the two pieces of data are very similar, this
          deltification results in storage savings for the deltified
          chunk&mdash;rather than taking up space equal to the size of
          the original data, it takes up only enough space to
          say, <quote>I look just like this other piece of data over
          here, except for the following couple of changes.</quote>
          The result is that most of the repository data that tends to
          be bulky&mdash;namely, the contents of versioned
          files&mdash;is stored at a much smaller size than the
          original full-text representation of that data.</para>

        <para>
          <indexterm>
            <primary>representation sharing</primary>
          </indexterm>While deltified storage has been a part of Subversion's
          design since the very beginning, there have been additional
          improvements made over the years.  Subversion repositories
          created with Subversion 1.4 or later benefit from
          compression of the full-text representations of file
          contents.  Repositories created with Subversion 1.6 or later
          further enjoy the disk space savings afforded by
          <firstterm>representation sharing</firstterm>, a feature
          which allows multiple files or file revisions with identical
          file content to refer to a single shared instance of that data
          rather than each having their own distinct copy thereof.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removing dead transactions</title>

        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>

        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>

        <informalexample>
          <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
        </informalexample>

        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>--transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>

        <informalexample>
          <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
        </informalexample>

        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (reporting outstanding transactions)</title>

          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>

        <informalexample>
          <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
        </informalexample>

        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>

        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.fsfspacking">
        <title>Packing FSFS filesystems</title>

        <para>FSFS repositories contain files that describe the
          changes made in a single revision, and files that contain
          the revision properties associated with a single revision.
          Repositories created in versions of Subversion prior to 1.5
          keep these files in two directories&mdash;one for each type
          of file.  As new revisions are committed to the repository,
          Subversion drops more files into these two
          directories&mdash;over time, the number of these files in
          each directory can grow to be quite large.  This has been
          observed to cause performance problems on certain
          network-based filesystems.</para>

        <para>The first problem is that the operating system has to
          reference many different files over a short period of time.
          This leads to inefficient use of disk caches and, as a
          result, more time spent seeking across large disks.  Because
          of this, Subversion pays a performance penalty when
          accessing your versioned data.</para>

        <para>The second problem is a bit more subtle.  Because of the
          ways that most filesystems allocate disk space, each file
          claims more space on the disk than it actually uses.  The
          amount of extra space required to house a single file can
          average anywhere from 2 to 16 kilobytes <emphasis>per
          file</emphasis>, depending on the underlying
          filesystem in use.  This translates directly
          into a per-revision disk usage penalty for FSFS-backed
          repositories.  The effect is most pronounced in repositories
          which have many small revisions, since the overhead involved
          in storing the revision file quickly outgrows the size of
          the actual data being stored.</para>

        <para>To solve these problems, Subversion 1.6 introduced the
          <command>svnadmin pack</command> command.  By concatenating
          all the files of a completed shard into a single <quote>pack</quote> file
          and then removing the original per-revision
          files, <command>svnadmin pack</command> reduces the file
          count within a given shard down to just a single file.  In
          doing so, it aids filesystem caches and reduces (to one) the
          number of times a file storage overhead penalty is
          paid.</para>

        <para>Subversion can pack existing sharded repositories which
          have been upgraded to the 1.6 filesystem format or later (see
          <xref linkend="svn.ref.svnadmin.c.upgrade"/>) in
          <xref linkend="svn.ref.svnadmin"/>.  To do so, just
          run <command>svnadmin pack</command> on the
          repository:</para>

        <informalexample>
          <screen>
$ svnadmin pack /var/svn/repos
Packing shard 0...done.
Packing shard 1...done.
Packing shard 2...done.
&hellip;
Packing shard 34...done.
Packing shard 35...done.
Packing shard 36...done.
$
</screen>
        </informalexample>

        <para>Because the packing process obtains the required locks
          before doing its work, you can run it on live repositories,
          or even as part of a post-commit hook.  Repacking packed
          shards is legal, but will have no effect on the disk usage
          of the repository.</para>

        <para><command>svnadmin pack</command> has no effect on
          BDB-backed Subversion repositories.</para>

      </sect3>
    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrating Repository Data Elsewhere</title>
    
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>

      <para>
        <indexterm>
          <primary>repository dump streams</primary>
        </indexterm>
        <indexterm>
          <primary>dump files</primary>
          <see>repository dump streams</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands, respectively,
        and the <command>svnrdump</command> program.</para>

      <warning>
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      </warning>

      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>

      <note>
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      </note>

      <para>The Subversion repository dump format also enables
        conversion from a different storage mechanism or version
        control system altogether.  Because the dump file format is,
        for the most part, human-readable, it should be relatively
        easy to describe generic sets of changes&mdash;each of which
        should be treated as a new revision&mdash;using this file
        format.  In fact, the <command>cvs2svn</command> utility (see
        <xref linkend="svn.forcvs.convert" />) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>

      <para>For now, we'll concern ourselves only with migration of
        repository data between Subversion repositories, which we'll
        describe in detail in the sections which follow.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnadmin">
        <title>Repository data migration using svnadmin</title>

        <para>Whatever your reason for migrating repository history,
          using the <command>svnadmin dump</command> and
          <command>svnadmin load</command> subcommands is
          straightforward.  <command>svnadmin dump</command> will output
          a range of repository revisions that are formatted using
          Subversion's custom filesystem dump format.  The dump format
          is printed to the standard output stream, while informative
          messages are printed to the standard error stream.  This
          allows you to redirect the output stream to a file while
          watching the status output in your terminal window.  For
          example:</para>

        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
        </informalexample>

        <para>At the end of the process, you will have a single file
          (<filename>dumpfile</filename> in the previous example) that
          contains all the data stored in your repository in the
          requested range of revisions.  Note that <command>svnadmin
          dump</command> is reading revision trees from the repository
          just like any other <quote>reader</quote> process would
          (e.g., <command>svn checkout</command>), so it's safe
          to run this command at any time.</para>

        <para>The other subcommand in the pair, <command>svnadmin
          load</command>, parses the standard input stream as a
          Subversion repository dump file and effectively replays those
          dumped revisions into the target repository for that
          operation.  It also gives informative feedback, this time
          using the standard output stream:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        </informalexample>

        <para>The result of a load is new revisions added to a
          repository&mdash;the same thing you get by making commits
          against that repository from a regular Subversion client.
          Just as in a commit, you can use hook programs to perform
          actions before and after each of the commits made during a
          load process.  By passing the
          <option>--use-pre-commit-hook</option> and
          <option>--use-post-commit-hook</option> options to
          <command>svnadmin load</command>, you can instruct
          Subversion to execute the pre-commit and post-commit hook
          programs, respectively, for each loaded revision.  You might
          use these, for example, to ensure that loaded revisions pass
          through the same validation steps that regular commits pass
          through.  Of course, you should use these options with
          care&mdash;if your post-commit hook sends emails to a
          mailing list for each new commit, you might not want to spew
          hundreds or thousands of commit emails in rapid succession
          at that list!  You can read more about the use of hook
          scripts in <xref linkend="svn.reposadmin.hooks" />.</para>

        <para>Note that because <command>svnadmin</command> uses
          standard input and output streams for the repository dump and
          load processes, people who are feeling especially saucy can try
          things such as this (perhaps even using different versions of
          <command>svnadmin</command> on each side of the pipe):</para>

        <informalexample>
          <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>
        </informalexample>

        <para>By default, the dump file will be quite large&mdash;much
          larger than the repository itself.  That's because by default
          every version of every file is expressed as a full text in the
          dump file.  This is the fastest and simplest behavior, and
          it's nice if you're piping the dump data directly into some other
          process (such as a compression program, filtering program, or
          loading process).  But if you're creating a dump file
          for longer-term storage, you'll likely want to save disk space
          by using the <option>--deltas</option> option.  With this
          option, successive revisions of files will be output as
          compressed, binary differences&mdash;just as file revisions
          are stored in a repository.  This option is slower, but it
          results in a dump file much closer in size to the original
          repository.</para>

        <para>We mentioned previously that <command>svnadmin
          dump</command> outputs a range of revisions.  Use the
          <option>--revision</option> (<option>-r</option>) option to
          specify a single revision, or a range of revisions, to dump.
          If you omit this option, all the existing repository revisions
          will be dumped.</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>
        </informalexample>

        <para>As Subversion dumps each new revision, it outputs only
          enough information to allow a future loader to re-create that
          revision based on the previous one.  In other words, for any
          given revision in the dump file, only the items that were
          changed in that revision will appear in the dump.  The only
          exception to this rule is the first revision that is dumped
          with the current <command>svnadmin dump</command>
          command.</para>

        <para>By default, Subversion will not express the first dumped
          revision as merely differences to be applied to the previous
          revision.  For one thing, there is no previous revision in the
          dump file!  And second, Subversion cannot know the state of
          the repository into which the dump data will be loaded (if it
          ever is).  To ensure that the output of each
          execution of <command>svnadmin dump</command> is
          self-sufficient, the first dumped revision is, by default, a
          full representation of every directory, file, and property in
          that revision of the repository.</para>

        <para>However, you can change this default behavior.  If you add
          the <option>--incremental</option> option when you dump your
          repository, <command>svnadmin</command> will compare the first
          dumped revision against the previous revision in the
          repository&mdash;the same way it treats every other revision that
          gets dumped.  It will then output the first revision exactly
          as it does the rest of the revisions in the dump
          range&mdash;mentioning only the changes that occurred in that
          revision.  The benefit of this is that you can create several
          small dump files that can be loaded in succession, instead of
          one large one, like so:</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>
        </informalexample>

        <para>These dump files could be loaded into a new repository
          with the following command sequence:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
        </informalexample>

        <para>Another neat trick you can perform with this
          <option>--incremental</option> option involves appending to an
          existing dump file a new range of dumped revisions.  For
          example, you might have a <literal>post-commit</literal> hook
          that simply appends the repository dump of the single revision
          that triggered the hook.  Or you might have a script that runs
          nightly to append dump file data for all the revisions that
          were added to the repository since the last time the script
          ran.  Used like this, <command>svnadmin dump</command> can be
          one way to back up changes to your repository over time in case
          of a system crash or some other catastrophic event.</para>

        <para>The dump format can also be used to merge the contents of
          several different repositories into a single repository.  By
          using the <option>--parent-dir</option> option of
          <command>svnadmin load</command>, you can specify a new
          virtual root directory for the load process.  That means if
          you have dump files for three repositories&mdash;say
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename>, and
          <filename>ss-dumpfile</filename>&mdash;you can first create a new
          repository to hold them all:</para>

        <informalexample>
          <screen>
$ svnadmin create /var/svn/projects
$
</screen>
        </informalexample>

        <para>Then, make new directories in the repository that will
          encapsulate the contents of each of the three previous
          repositories:</para>

        <informalexample>
          <screen>
$ svn mkdir -m "Initial project roots" \
            file:///var/svn/projects/calc \
            file:///var/svn/projects/calendar \
            file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>
        </informalexample>

        <para>Lastly, load the individual dump files into their
          respective locations in the new repository:</para>

        <informalexample>
          <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnrdump">
        <title>Repository data migration using svnrdump</title>

        <para>In Subversion 1.7, <command>svnrdump</command> joined
          the set of stock Subversion tools.  It offers fairly
          specialized functionality, essentially as a network-aware
          version of the <command>svnadmin dump</command>
          and <command>svnadmin load</command> commands which we
          discuss in depth in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> will generate a dump
          stream from a remote repository, spewing it to standard
          output; <command>svnrdump load</command> will read a dump
          stream from standard input and load it into a remote
          repository.  Using <command>svnrdump</command>, you can
          generate incremental dumps just as you might
          with <command>svnadmin dump</command>.  You can even dump a
          subtree of the repository&mdash;something
          that <command>svnadmin dump</command> cannot do.</para>

        <para>The primary difference is that instead of requiring
          direct access to the repository, <command>svnrdump</command>
          operates remotely, using the very same Repository Access
          (RA) protocols that the Subversion client does.  As such,
          you might need to provide authentication credentials.  Also,
          your remote interactions are subject to any authorization
          limitations configured on the Subversion server.</para>

        <note>
          <para><command>svnrdump dump</command> requires that the
            remote server be running Subversion 1.4 or newer.  It
            currently generates dump streams only of the sort which
            are created when you pass the <option>--deltas</option>
            option to <command>svnadmin dump</command>.  This isn't
            interesting in the typical use-cases, but might impact
            specific types of custom transformations you might wish to
            apply to the resulting dump stream.</para>
        </note>

        <note>
          <para>Because it modifies revision properties after
            committing new revisions, <command>svnrdump load</command>
            requires that the target repository have revision property
            changes enabled via the pre-revprop-change hook.  See
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/> for details.</para>
        </note>

        <para>As you might expect, you can use
          <command>svnadmin</command> and <command>svnrdump</command>
          in concert.  You can, for example, use <command>svnrdump
          dump</command> to generate a dump stream from a remote
          repository, and pipe the results thereof through
          <command>svnadmin load</command> to copy all that repository
          history into a local repository.  Or you can do the reverse,
          copying history from a local repository into a remote
          one.</para>

        <tip>
          <para>By using <literal>file://</literal>
            URLs, <command>svnrdump</command> can also access local
            repositories, but it will be doing so via Subversion's
            Repository Access (RA) abstraction layer&mdash;you'll get
            better performance out of <command>svnadmin</command> in
            such situations.</para>
        </tip>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtering Repository History</title>

      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion generally
        doesn't provide an easy way to remove that
        data.<footnote><para>That's rather the reason you use version
        control at all, right?</para></footnote>  But inevitably, there
        will be times when you would like to manipulate the history of
        your repository.  You might need to strip out all instances of
        a file that was accidentally added to the repository (and
        shouldn't be there for whatever
        reason).<footnote><para>Conscious, cautious removal of certain
        bits of versioned data is actually supported by real use
        cases.  That's why an <quote>obliterate</quote> feature has
        been one of the most highly requested Subversion features, and
        one which the Subversion developers hope to soon
        provide.</para></footnote>  Or, perhaps you have multiple
        projects sharing a single repository, and you decide to split
        them up into their own repositories.  To accomplish tasks such
        as these, administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>

      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> or <command>svnrdump
        dump</command> command to generate the dump data,
        and <command>svnadmin load</command> or <command>svnrdump
        load</command> to populate a new repository with it.  The
        great thing about the human-readability aspect of the dump
        format is that, if you aren't careless about it, you can
        manually inspect and modify it.  Of course, the downside is
        that if you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>

      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>

      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>

      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>

      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
      </informalexample>

      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>

      <informalexample>
        <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>
      </informalexample>

      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>

      <informalexample>
        <programlisting>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</programlisting>
      </informalexample>

      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>

      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>

      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
      </informalexample>

      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>If empty revisions are dropped (using the
              <option>--drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>

      <informalexample>
        <programlisting>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</programlisting>
      </informalexample>

      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an
        inconsistent usage of leading slashes for some
        reason,<footnote><para>While <command>svnadmin dump</command>
        has a consistent leading slash policy (to not include them),
        other programs that generate dump data might not be so
        consistent.</para></footnote> you should probably normalize
        those paths so that they all have, or all lack, leading
        slashes.</para> <!-- ### FIXME: Is this still accurate?
                             Surely we've fixed ### this by now! -->

      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>

      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Repository Replication</title>

      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>

      <para>Subversion provides a program for managing scenarios such
        as these.  <command>svnsync</command> works by essentially
        asking the Subversion server to <quote>replay</quote>
        revisions, one at a time.  It then uses that revision
        information to mimic a commit of the same to another
        repository.  Neither repository needs to be locally accessible
        to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>

      <note>
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync">
        <title>Replication with svnsync</title>

        <para>Assuming you already have a source repository that you'd
          like to mirror, the next thing you need is a target repository
          that will actually serve as that mirror.  This target
          repository can use either of the available filesystem
          data-store backends (see
          <xref linkend="svn.reposadmin.basics.backends"
          />)&mdash;Subversion's abstraction layers ensure that such
          details don't matter.  But by default, it must
          not yet have any version history in it.  (We'll discuss an
          exception to this later in this section.)</para>
  
        <para>The protocol that <command>svnsync</command> uses to
          communicate revision information is highly sensitive to
          mismatches between the versioned histories contained in the
          source and target repositories.  For this reason,
          while <command>svnsync</command>
          cannot <emphasis>demand</emphasis> that the target repository
          be read-only,<footnote><para>In fact, it can't truly be
          read-only, or <command>svnsync</command> itself would have a
          tough time copying revision history into it.</para></footnote>
          allowing the revision history in the target repository to
          change by any mechanism other than the mirroring process is a
          recipe for disaster.</para>

        <warning>
          <para>Do <emphasis>not</emphasis> modify a mirror repository
            in such a way as to cause its version history to deviate
            from that of the repository it mirrors.  The only commits
            and revision property modifications that ever occur on that
            mirror repository should be those performed by the
            <command>svnsync</command> tool.</para>
        </warning>

        <para>Another requirement of the target repository is that the
          <command>svnsync</command> process be allowed to modify
          revision properties.  Because <command>svnsync</command> works
          within the framework of that repository's hook system, the
          default state of the repository (which is to disallow revision
          property changes; see <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) is insufficient.
          You'll need to explicitly implement the pre-revprop-change
          hook, and your script must allow <command>svnsync</command>
          to set and change revision properties.  With those
          provisions in place, you are ready to start mirroring
          repository revisions.</para>

        <tip>
          <para>It's a good idea to implement authorization measures
            that allow your repository replication process to perform
            its tasks while preventing other users from modifying the
            contents of your mirror repository at all.</para>
        </tip>

        <para>Let's walk through the use of <command>svnsync</command>
          in a somewhat typical mirroring scenario.  We'll pepper this
          discourse with practical recommendations, which you are free to
          disregard if they aren't required by or suitable for your
          environment.</para>

        <para>We will be mirroring the public Subversion repository
          which houses the source code for this very book and exposing
          that mirror publicly on the Internet, hosted on a different
          machine than the one on which the original Subversion source
          code repository lives.  This remote host has a global
          configuration that permits anonymous users to read the
          contents of repositories on the host, but requires users to
          authenticate to modify those repositories.  (Please forgive
          us for glossing over the details of Subversion server
          configuration for the moment&mdash;those are covered
          thoroughly in <xref linkend="svn.serverconfig" />.)  And for
          no other reason than that it makes for a more interesting
          example, we'll be driving the replication process from a
          third machine&mdash;the one that we currently find ourselves
          using.</para>

        <para>First, we'll create the repository which will be our
          mirror.  This and the next couple of steps do require shell
          access to the machine on which the mirror repository will
          live.  Once the repository is all configured, though, we
          shouldn't need to touch it directly again.</para>

        <informalexample>
          <screen>
$ ssh admin@svn.example.com "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>
        </informalexample>

        <para>At this point, we have our repository, and due to our
          server's configuration, that repository is now
          <quote>live</quote> on the Internet.  Now, because we don't
          want anything modifying the repository except our replication
          process, we need a way to distinguish that process from other
          would-be committers.  To do so, we use a dedicated username
          for our process.  Only commits and revision property
          modifications performed by the special username
          <literal>syncuser</literal> will be allowed.</para>

        <para>We'll use the repository's hook system both to allow the
          replication process to do what it needs to do and to enforce
          that only it is doing those things.  We accomplish this by
          implementing two of the repository event
          hooks&mdash;pre-revprop-change and start-commit.  Our
          <filename>pre-revprop-change</filename> hook script is found
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />, and basically verifies that the user attempting the
          property changes is our <literal>syncuser</literal> user.  If
          so, the change is allowed; otherwise, it is denied.</para>

        <example id="svn.reposadmin.maint.replication.pre-revprop-change">
          <title>Mirror repository's pre-revprop-change hook script</title>
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
        </example>

        <para>That covers revision property changes.  Now we need to
          ensure that only the <literal>syncuser</literal> user is
          permitted to commit new revisions to the repository.  We do
          this using a <filename>start-commit</filename> hook script
          such as the one in <xref
          linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>

        <example id="svn.reposadmin.maint.replication.start-commit">
          <title>Mirror repository's start-commit hook script</title>
  
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
        </example>

        <para>After installing our hook scripts and ensuring that they
          are executable by the Subversion server, we're finished with
          the setup of the mirror repository.  Now, we get to actually
          do the mirroring.</para>

        <para>The first thing we need to do with
          <command>svnsync</command> is to register in our target
          repository the fact that it will be a mirror of the source
          repository.  We do this using the <command>svnsync
          initialize</command> subcommand.  The URLs we provide point
          to the root directories of the target and source
          repositories, respectively.  In Subversion 1.4, this is
          required&mdash;only full mirroring of repositories is
          permitted.  Beginning with Subversion 1.5, though, you can
          use <command>svnsync</command> to mirror only some subtree
          of the repository, too.</para>

        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     https://svn.code.sf.net/p/svnbook/source \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0 (svn:sync-* properties skipped).
NOTE: Normalized svn:* properties to LF line endings (1 rev-props, 0 node-props).
$
</screen>
        </informalexample>

        <para>Our target repository will now remember that it is a
          mirror of the public Subversion source code repository.
          Notice that we provided a username and password as arguments
          to <command>svnsync</command>&mdash;that was required by the
          pre-revprop-change hook on our mirror repository.</para>

        <note>
          <para>In Subversion 1.4, the values given to
            <command>svnsync</command>'s <option>--username</option> and
            <option>--password</option> command-line options were used
            for authentication against both the source and destination
            repositories.  This caused problems when a user's
            credentials weren't exactly the same for both repositories,
            especially when running in noninteractive mode (with the
            <option>--non-interactive</option> option).  This was
            fixed in Subversion 1.5 with the introduction of two new
            pairs of options.  Use
            <option>--source-username</option> and
            <option>--source-password</option> to provide authentication
            credentials for the source repository; use
            <option>--sync-username</option> and
            <option>--sync-password</option> to provide credentials for
            the destination repository.  (The old
            <option>--username</option> and <option>--password</option>
            options still exist for compatibility, but we advise against
            using them.)</para>
        </note>

        <para>And now comes the fun part.  With a single subcommand, we
          can tell <command>svnsync</command> to copy all the
          as-yet-unmirrored revisions from the source repository to the
          target.<footnote><para>Be forewarned that while it will take
          only a few seconds for the average reader to parse this
          paragraph and the sample output that follows it, the actual
          time required to complete such a mirroring operation is, shall
          we say, quite a bit longer.</para></footnote> The
          <command>svnsync synchronize</command> subcommand will peek
          into the special revision properties previously stored on the
          target repository and determine how much of the source
          repository has been previously mirrored&mdash;in this case,
          the most recently mirrored revision is r0.  Then it will query
          the source repository and determine what the latest revision
          in that repository is.  Finally, it asks the source
          repository's server to start replaying all the revisions
          between 0 and that latest revision.  As
          <command>svnsync</command> gets the resultant response from
          the source repository's server, it begins forwarding those
          revisions to the target repository's server as new
          commits.</para>

        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL [SOURCE_URL]

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      https://svn.code.sf.net/p/svnbook/source
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data .
Committed revision 4063.
Copied properties for revision 4063.
Transmitting file data .
Committed revision 4064.
Copied properties for revision 4064.
Transmitting file data ....
Committed revision 4065.
Copied properties for revision 4065.
$
</screen>
        </informalexample>

        <para>Of particular interest here is that for each mirrored
          revision, there is first a commit of that revision to the
          target repository, and then property changes follow.  This
          two-phase replication is required because the initial commit
          is performed by (and attributed to) the user
          <literal>syncuser</literal> and is datestamped with the time
          as of that revision's creation.  <command>svnsync</command>
          has to follow up with an immediate series of property
          modifications that copy into the target repository all the
          original revision properties found for that revision in the
          source repository, which also has the effect of fixing the
          author and datestamp of the revision to match that of the
          source repository.</para>

        <para>Also noteworthy is that <command>svnsync</command>
          performs careful bookkeeping that allows it to be safely
          interrupted and restarted without ruining the integrity of the
          mirrored data.  If a network glitch occurs while mirroring a
          repository, simply repeat the <command>svnsync
          synchronize</command> command, and it will happily pick up
          right where it left off.  In fact, as new revisions appear in
          the source repository, this is exactly what you do
          to keep your mirror up to date.</para>

        <warning>
          <para>As part of its bookkeeping, <command>svnsync</command>
            records in the mirror repository the URL with which the
            mirror was initialized.  Because of this, invocations of
            <command>svnsync</command> which follow the initialization
            step do not <emphasis>require</emphasis> that you provide
            the source URL on the command line again.  However, for
            security purposes, we recommend that you continue to do so.
            Depending on how it is deployed, it may not be safe for
            <command>svnsync</command> to trust the source URL which it
            retrieves from the mirror repository, and from which it
            pulls versioned data.</para>
        </warning>

        <sidebar>
          <title>svnsync Bookkeeping</title>

          <para><command>svnsync</command> needs to be able to set and
            modify revision properties on the mirror repository because
            those properties are part of the data it is tasked with
            mirroring.  As those properties change in the source
            repository, those changes need to be reflected in the mirror
            repository, too.  But <command>svnsync</command> also uses a
            set of custom revision properties&mdash;stored in revision 0
            of the mirror repository&mdash;for its own internal
            bookkeeping.  These properties contain information such as
            the URL and UUID of the source repository, plus some
            additional state-tracking information.</para>

          <para>One of those pieces of state-tracking information is a
            flag that essentially just means <quote>there's a
            synchronization in progress right now.</quote> This is used
            to prevent multiple <command>svnsync</command> processes
            from colliding with each other while trying to mirror data
            to the same destination repository.  Now, generally you
            won't need to pay any attention whatsoever to
            <emphasis>any</emphasis> of these special properties (all of
            which begin with the prefix <literal>svn:sync-</literal>).
            Occasionally, though, if a synchronization fails
            unexpectedly, Subversion never has a chance to remove this
            particular state flag.  This causes all future
            synchronization attempts to fail because it appears that a
            synchronization is still in progress when, in fact, none is.
            Fortunately, recovering from this situation is easy to do.
            In Subversion 1.7, you can use the newly introduced
            <option>--steal-lock</option> option with
            <command>svnsync</command>'s commands.  In previous
            Subversion versions, you need only to remove the
            <literal>svn:sync-lock</literal> property which serves as
            this flag from revision 0 of the mirror repository:</para>

          <informalexample>
            <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
          </informalexample>

          <para>Also, <command>svnsync</command> stores the source
            repository URL provided at mirror initialization time in a
            bookkeeping property on the mirror repository.  Future
            synchronization operations against that mirror which omit
            the source URL at the command line will consult the
            special <literal>svn:sync-from-url</literal> property
            stored on the mirror itself to know where to synchronize
            from.  This value is used literally by the synchronization
            process, though.  Be wary of using non-fully-qualified
            domain names (such as referring
            to <literal>svnbook.red-bean.com</literal> as
            simply <literal>svnbook</literal> because that happens to
            work when you are connected directly to
            the <literal>red-bean.com</literal> network), domain names
            which don't resolve or resolve differently depending on
            where you happen to be operating from, or IP addresses
            (which can change over time).  But here again, if you need
            an existing mirror to start referring to a different URL
            for the same source repository, you can change the
            bookkeeping property which houses that information.  Users
            of Subversion 1.7 or better can use <command>svnsync init
            --allow-non-empty</command> to reinitialize their mirrors
            with new source URL:</para>

          <informalexample>
            <screen>
$ svnsync initialize --allow-non-empty http://svn.example.com/svn-mirror \
                                       <replaceable>NEW-SOURCE-URL</replaceable>
Copied properties for revision 4065.
$
</screen>
          </informalexample>

          <para>If you are running an older version of Subversion,
            you'll need to manually tweak
            the <literal>svn:sync-from-url</literal> bookkeeping
            property:</para>
          
          <informalexample>
            <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>
          </informalexample>

          <para>Another interesting thing about these special
            bookkeeping properties is that <command>svnsync</command>
            will not attempt to mirror any of those properties when they
            are found in the source repository.  The reason is probably
            obvious, but basically boils down to
            <command>svnsync</command> not being able to distinguish the
            special properties it has merely copied from the source
            repository from those it needs to consult and maintain for
            its own bookkeeping needs.  This situation could occur if,
            for example, you were maintaining a mirror of a mirror of a
            third repository.  When <command>svnsync</command> sees its
            own special properties in revision 0 of the source
            repository, it simply ignores them.</para>

          <para>An <command>svnsync info</command> subcommand was
            added in Subversion 1.6 to easily display the special
            bookkeeping properties in the destination
            repository.</para>

          <informalexample>
            <screen>
$ svnsync help info
info: usage: svnsync info DEST_URL

Print information about the synchronization destination repository
located at DEST_URL.
&hellip;
$ svnsync info http://svn.example.com/svn-mirror
Source URL: https://svn.code.sf.net/p/svnbook/source
Source Repository UUID: 931749d0-5854-0410-9456-f14be4d6b398
Last Merged Revision: 4065
$
</screen>
          </informalexample>
        </sidebar>

        <para>There is, however, one bit of inelegance in the process.
          Because Subversion revision properties can be changed at any
          time throughout the lifetime of the repository, and because
          they don't leave an audit trail that indicates when they were
          changed, replication processes have to pay special attention
          to them.  If you've already mirrored the first 15 revisions of
          a repository and someone then changes a revision property on
          revision 12, <command>svnsync</command> won't know to go back
          and patch up its copy of revision 12.  You'll need to tell it
          to do so manually by using (or with some additional tooling
          around) the <command>svnsync copy-revprops</command>
          subcommand, which simply rereplicates all the revision
          properties for a particular revision or range thereof.</para>

        <informalexample>
          <screen>
$ svnsync help copy-revprops
copy-revprops: usage:

    1. svnsync copy-revprops DEST_URL [SOURCE_URL]
    2. svnsync copy-revprops DEST_URL REV[:REV2]

&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>
        </informalexample>

        <para>That's repository replication
          via <command>svnsync</command> in a nutshell.  You'll likely
          want some automation around such a process.  For example,
          while our example was a pull-and-push setup, you might wish to
          have your primary repository push changes to one or more
          blessed mirrors as part of its post-commit and
          post-revprop-change hook implementations.  This would enable
          the mirror to be up to date in as near to real time as is
          likely possible.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-partial">
        <title>Partial replication with svnsync</title>

        <para><command>svnsync</command> isn't limited to full copies
          of everything which lives in a repository.  It can handle
          various shades of partial replication, too.  For example,
          while it isn't very commonplace to do so,
          <command>svnsync</command> does gracefully mirror repositories
          in which the user as whom it authenticates has only partial
          read access.  It simply copies only the bits of the repository
          that it is permitted to see.  Obviously, such a mirror is not
          useful as a backup solution.</para>

        <para>As of Subversion 1.5, <command>svnsync</command> also
          has the ability to mirror a subset of a repository rather than
          the whole thing.  The process of setting up and maintaining
          such a mirror is exactly the same as when mirroring a whole
          repository, except that instead of specifying the source
          repository's root URL when running <command>svnsync
          init</command>, you specify the URL of some subdirectory
          within that repository.  Synchronization to that mirror will
          now copy only the bits that changed under that source
          repository subdirectory.  There are some limitations to this
          support, though.  First, you can't mirror multiple disjoint
          subdirectories of the source repository into a single mirror
          repository&mdash;you'd need to instead mirror some parent
          directory that is common to both.  Second, the filtering
          logic is entirely path-based, so if the subdirectory you are
          mirroring was renamed at some point in the past, your mirror
          would contain only the revisions since the directory appeared
          at the URL you specified.  And likewise, if the source
          subdirectory is renamed in the future, your synchronization
          processes will stop mirroring data at the point that the
          source URL you specified is no longer valid.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-init-nonempty">
        <title>A quick trick for mirror creation</title>

        <para>We mentioned previously the cost of setting up an
          initial mirror of an existing repository.  For many folks,
          the sheer cost of transmitting thousands&mdash;or
          millions&mdash;of revisions of history to a new mirror
          repository via <command>svnsync</command> is a show-stopper.
          Fortunately, Subversion 1.7 provides a workaround by way of
          a new <option>--allow-non-empty</option> option to
          <command>svnsync initialize</command>.  This option allows
          you to initialize one repository as a mirror of another
          while bypassing the verification that the to-be-initialized
          mirror has no version history present in it.  Per our
          previous warnings about the sensitivity of this whole
          replication process, you should rightly discern that this is
          an option to be used only with great caution.  But it's
          wonderfully handy when you have administrative access to the
          source repository, where you can simply make a physical copy
          of the repository and then initialize that copy as a new
          mirror:</para>

        <informalexample>
          <screen>
$ svnadmin hotcopy /path/to/repos /path/to/mirror-repos
$ ### create /path/to/mirror-repos/hooks/pre-revprop-change
$ svnsync initialize file:///path/to/mirror-repos \
                     file:///path/to/repos
svnsync: E000022: Destination repository already contains revision history; co
nsider using --allow-non-empty if the repository's revisions are known to mirr
or their respective revisions in the source repository
$ svnsync initialize --allow-non-empty file:///path/to/mirror-repos \
                                       file:///path/to/repos
Copied properties for revision 32042.
$
</screen>
        </informalexample>

        <para>Admins who are running a version of Subversion prior to
          1.7 (and thus do not have access to <command>svnsync
          initialize</command>'s <option>--allow-non-empty</option>
          feature) can accomplish effectively the same thing that that
          feature does through <emphasis>careful</emphasis>
          manipulation of the r0 revision properties on the copy of
          the repository which is slated to become a mirror of the
          original.  Use <command>svnadmin setrevprop</command> to
          create the same bookkeeping properties
          that <command>svnsync</command> would have created
          there.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.wrapup">
        <title>Replication wrap-up</title>

        <para>We've discussed a couple of ways to replicate revision
          history from one repository to another.  So let's look now
          at the user end of these operations.  How does replication
          and the various situations which call for it affect
          Subversion clients?</para>

        <para>As far as user interaction with repositories and mirrors
          goes, it <emphasis>is</emphasis> possible to have a single
          working copy that interacts with both, but you'll have to
          jump through some hoops to make it happen.  First, you need
          to ensure that both the primary and mirror repositories have
          the same repository UUID (which is not the case by default).
          See <xref linkend="svn.reposadmin.maint.uuids" /> later in
          this chapter for more about this.</para>
        
        <para>Once the two repositories have the same UUID, you can use
          <command>svn relocate</command> to point your working
          copy to whichever of the repositories you wish to operate
          against, a process that is described in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref.svn"/>.  There is a possible danger here,
          though, in that if the primary and mirror repositories
          aren't in close synchronization, a working copy up to date
          with, and pointing to, the primary repository will, if
          relocated to point to an out-of-date mirror, become confused
          about the apparent sudden loss of revisions it fully expects
          to be present, and it will throw errors to that effect.  If
          this occurs, you can relocate your working copy back to the
          primary repository and then either wait until the mirror
          repository is up to date, or backdate your working copy to a
          revision you know is present in the sync repository, and
          then retry the relocation.</para>

        <para>Finally, be aware that the revision-based replication
          provided by <command>svnsync</command> is only
          that&mdash;replication of revisions.  Only the kinds of
          information carried by the Subversion repository dump file
          format are available for replication.  As such, tools such
          as <command>svnsync</command>
          (and <command>svnrdump</command>, which we discuss in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />)
          are limited in ways similar to that of the repository dump
          stream.  They do not include in their replicated information
          such things as the hook implementations, repository or
          server configuration data, uncommitted transactions, or
          information about user locks on repository paths.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>

      <para>As far as full backups go, the nave approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutiae involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>

      <informalexample>
        <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>
      </informalexample>

      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>

      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with
        the <option>--incremental</option> option to perform an
        incremental backup of a given revision or range of revisions.
        And of course, you can achieve a full backup variation of this
        by omitting the <option>--incremental</option> option to that
        command.  There is some value in these methods, in that the
        format of your backed-up information is flexible&mdash;it's
        not tied to a particular platform, versioned filesystem type,
        or release of Subversion or the libraries it uses.  But that
        flexibility comes at a cost, namely that restoring that data
        can take a long time&mdash;longer with each new revision
        committed to your repository.  Also, as is the case with so
        many of the various backup methods, revision property changes
        that are made to already backed-up revisions won't get picked
        up by a nonoverlapping, incremental dump generation.  For
        these reasons, we recommend against relying solely on
        dump-based backup approaches.</para>

      <para>Beginning with Subversion 1.8, <command>svnadmin hotcopy</command>
        accepts <option>--incremental</option> option and supports incremental
        hotcopy mode for FSFS repositories.  In incremental hotcopy mode,
        revision data which has already been copied from the source to the
        destination repository will not be copied again. When
        <option>--incremental</option> option is used with
        <command>svnadmin hotcopy</command>, Subversion will only copy new
        revisions, and revisions which have changed in size or had their
        modification time stamp changed since the previous hotcopy
        operation.  Moreover, unlike with <command>svnsync</command> or
        <command>svnadmin dump --incremental</command>, performance of
        <command>svnadmin hotcopy --incremental</command> is only limited to
        disk I/O.  Therefore, incremental hotcopy can be a huge
        time saver when making a backup of a large repository.</para>

      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>

      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>

      <para>In any backup scenario, repository administrators need to
        be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change
        hooks.<footnote><para><command>svnadmin setlog</command> can
        be called in a way that bypasses the hook interface
        altogether.</para></footnote>  And since you can change
        revision properties without respect to chronological
        order&mdash;you can change any revision's properties at any
        time&mdash;an incremental backup of the latest few revisions
        might not catch a property modification to a revision that was
        included as part of a previous backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
            
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of
        Fate,<footnote><para>You know&mdash;the collective term for
        all of her <quote>fickle fingers.</quote></para></footnote> it
        should certainly help you recover from those trying
        times.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
      <title>Managing Repository UUIDs</title>

      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>

      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>

      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>

      <informalexample>
        <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load --force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>.</para>

      <informalexample>
        <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
    <title>Moving and Removing Repositories</title>

    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>

    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>

    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including
      their UUIDs.  In some circumstances, this might be desirable.
      But in the instances where it is not, you'll need to generate a
      new UUID for one of these identical repositories.  See
      <xref linkend="svn.reposadmin.maint.uuids" /> for more about
      managing repository UUIDs.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
